#!/usr/bin/env node
//  This file is a standalone bundle encapsulating https://github.com/sboltools/sbolgraph v0.45.0
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@rdfoo/n3/N3.js":
/*!**************************************!*\
  !*** ./node_modules/@rdfoo/n3/N3.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;// Replace local require by a lazy loader
var globalRequire = require;
//require = function () {};

// Expose submodules
var exports = module.exports = {
  Lexer:        __webpack_require__(/*! ./lib/N3Lexer */ "./node_modules/@rdfoo/n3/lib/N3Lexer.js"),
  Parser:       __webpack_require__(/*! ./lib/N3Parser */ "./node_modules/@rdfoo/n3/lib/N3Parser.js"),
  Writer:       __webpack_require__(/*! ./lib/N3Writer */ "./node_modules/@rdfoo/n3/lib/N3Writer.js"),
  Store:        __webpack_require__(/*! ./lib/N3Store */ "./node_modules/@rdfoo/n3/lib/N3Store.js"),
  StreamParser: __webpack_require__(/*! ./lib/N3StreamParser */ "./node_modules/@rdfoo/n3/lib/N3StreamParser.js"),
  StreamWriter: __webpack_require__(/*! ./lib/N3StreamWriter */ "./node_modules/@rdfoo/n3/lib/N3StreamWriter.js"),
  Util:         __webpack_require__(/*! ./lib/N3Util */ "./node_modules/@rdfoo/n3/lib/N3Util.js"),
};

// Load submodules on first access
Object.keys(exports).forEach(function (submodule) {
  Object.defineProperty(exports, submodule, {
    configurable: true,
    enumerable: true,
    get: function () {
      delete exports[submodule];
      return exports[submodule] = __webpack_require__("./node_modules/@rdfoo/n3/lib sync recursive ^\\.\\/N3.*$")("./N3" + submodule);
    },
  });
});


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib sync recursive ^\\.\\/N3.*$":
/*!****************************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib sync ^\.\/N3.*$ ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./N3Lexer": "./node_modules/@rdfoo/n3/lib/N3Lexer.js",
	"./N3Lexer.js": "./node_modules/@rdfoo/n3/lib/N3Lexer.js",
	"./N3Parser": "./node_modules/@rdfoo/n3/lib/N3Parser.js",
	"./N3Parser.js": "./node_modules/@rdfoo/n3/lib/N3Parser.js",
	"./N3Store": "./node_modules/@rdfoo/n3/lib/N3Store.js",
	"./N3Store.js": "./node_modules/@rdfoo/n3/lib/N3Store.js",
	"./N3StreamParser": "./node_modules/@rdfoo/n3/lib/N3StreamParser.js",
	"./N3StreamParser.js": "./node_modules/@rdfoo/n3/lib/N3StreamParser.js",
	"./N3StreamWriter": "./node_modules/@rdfoo/n3/lib/N3StreamWriter.js",
	"./N3StreamWriter.js": "./node_modules/@rdfoo/n3/lib/N3StreamWriter.js",
	"./N3Util": "./node_modules/@rdfoo/n3/lib/N3Util.js",
	"./N3Util.js": "./node_modules/@rdfoo/n3/lib/N3Util.js",
	"./N3Writer": "./node_modules/@rdfoo/n3/lib/N3Writer.js",
	"./N3Writer.js": "./node_modules/@rdfoo/n3/lib/N3Writer.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/@rdfoo/n3/lib sync recursive ^\\.\\/N3.*$";

/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3Lexer.js":
/*!***********************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3Lexer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// **N3Lexer** tokenizes N3 documents.
var fromCharCode = String.fromCharCode;
var immediately = typeof setImmediate === 'function' ? setImmediate :
                  function setImmediate(func) { setTimeout(func, 0); };

// Regular expression and replacement string to escape N3 strings.
// Note how we catch invalid unicode sequences separately (they will trigger an error).
var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\[uU]|\\(.)/g;
var escapeReplacements = { '\\': '\\', "'": "'", '"': '"',
                           'n': '\n', 'r': '\r', 't': '\t', 'f': '\f', 'b': '\b',
                           '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',
                           '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',
                           '/': '/', '?': '?', '#': '#', '@': '@', '%': '%' };
var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;

// ## Constructor
function N3Lexer(options) {
  if (!(this instanceof N3Lexer))
    return new N3Lexer(options);

  // In line mode (N-Triples or N-Quads), only simple features may be parsed
  if (options && options.lineMode) {
    // Don't tokenize special literals
    this._tripleQuotedString = this._number = this._boolean = /$0^/;
    // Swap the tokenize method for a restricted version
    var self = this;
    this._tokenize = this.tokenize;
    this.tokenize = function (input, callback) {
      this._tokenize(input, function (error, token) {
        if (!error && /^(?:IRI|prefixed|literal|langcode|type|\.|eof)$/.test(token.type))
          callback && callback(error, token);
        else
          callback && callback(error || self._syntaxError(token.type, callback = null));
      });
    };
  }
}

N3Lexer.prototype = {
  // ## Regular expressions
  // It's slightly faster to have these as properties than as in-scope variables.

  _iri: /^<((?:[^>\\]|\\[uU])+)>/, // IRI with escape sequences; needs sanity check after unescaping
  _unescapedIri: /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>/, // IRI without escape sequences; no unescaping
  _unescapedString: /^"[^"\\]+"(?=[^"\\])/, // non-empty string without escape sequences
  _singleQuotedString: /^"[^"\\]*(?:\\.[^"\\]*)*"(?=[^"\\])|^'[^'\\]*(?:\\.[^'\\]*)*'(?=[^'\\])/,
  _tripleQuotedString: /^""("[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*")""|^''('[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*')''/,
  _langcode: /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i,
  _prefix: /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/,
  _prefixed: /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?=\.?[,;\s#()\[\]\{\}"'<])/,
  _blank: /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=\.?[,;:\s#()\[\]\{\}"'<])/,
  _number: /^[\-+]?(?:\d+\.?\d*([eE](?:[\-\+])?\d+)|\d*\.?\d+)(?=[.,;:\s#()\[\]\{\}"'<])/,
  _boolean: /^(?:true|false)(?=[.,;:\s#()\[\]\{\}"'<])/,
  _keyword: /^@[a-z]+(?=[\s#<:])/,
  _sparqlKeyword: /^(?:PREFIX|BASE|GRAPH)(?=[\s#<:])/i,
  _shortPredicates: /^a(?=\s+|<)/,
  _newline: /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/,
  _whitespace: /^[ \t]+/,
  _endOfFile: /^(?:#[^\n\r]*)?$/,

  // ## Private methods

  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback.
  _tokenizeToEnd: function (callback, inputFinished) {
    // Continue parsing as far as possible; the loop will return eventually.
    var input = this._input;
    while (true) {
      // Count and skip whitespace lines.
      var whiteSpaceMatch;
      while (whiteSpaceMatch = this._newline.exec(input))
        input = input.substr(whiteSpaceMatch[0].length, input.length), this._line++;
      // Skip whitespace on current line.
      if (whiteSpaceMatch = this._whitespace.exec(input))
        input = input.substr(whiteSpaceMatch[0].length, input.length);

      // Stop for now if we're at the end.
      if (this._endOfFile.test(input)) {
        // If the input is finished, emit EOF.
        if (inputFinished)
          callback(input = null, { line: this._line, type: 'eof', value: '', prefix: '' });
        return this._input = input;
      }

      // Look for specific token types based on the first character.
      var line = this._line, type = '', value = '', prefix = '',
          firstChar = input[0], match = null, matchLength = 0, unescaped, inconclusive = false;
      switch (firstChar) {
      case '^':
        // Try to match a type.
        if (input.length === 1) break;
        else if (input[1] !== '^') return reportSyntaxError(this);
        this._prevTokenType = '^';
        // Move to type IRI or prefixed name.
        input = input.substr(2);
        if (input[0] !== '<') {
          inconclusive = true;
          break;
        }
        // Fall through in case the type is an IRI.

      case '<':
        // Try to find a full IRI without escape sequences.
        if (match = this._unescapedIri.exec(input))
          type = 'IRI', value = match[1];
        // Try to find a full IRI with escape sequences.
        else if (match = this._iri.exec(input)) {
          unescaped = this._unescape(match[1]);
          if (unescaped === null || illegalIriChars.test(unescaped))
            return reportSyntaxError(this);
          type = 'IRI', value = unescaped;
        }
        break;

      case '_':
        // Try to find a blank node. Since it can contain (but not end with) a dot,
        // we always need a non-dot character before deciding it is a prefixed name.
        // Therefore, try inserting a space if we're at the end of the input.
        if ((match = this._blank.exec(input)) ||
            inputFinished && (match = this._blank.exec(input + ' ')))
          type = 'prefixed', prefix = '_', value = match[1];
        break;

      case '"':
      case "'":
        // Try to find a non-empty double-quoted literal without escape sequences.
        if (match = this._unescapedString.exec(input))
          type = 'literal', value = match[0];
        // Try to find any other literal wrapped in a pair of single or double quotes.
        else if (match = this._singleQuotedString.exec(input)) {
          unescaped = this._unescape(match[0]);
          if (unescaped === null)
            return reportSyntaxError(this);
          type = 'literal', value = unescaped.replace(/^'|'$/g, '"');
        }
        // Try to find a literal wrapped in three pairs of single or double quotes.
        else if (match = this._tripleQuotedString.exec(input)) {
          unescaped = match[1] || match[2];
          // Count the newlines and advance line counter.
          this._line += unescaped.split(/\r\n|\r|\n/).length - 1;
          unescaped = this._unescape(unescaped);
          if (unescaped === null)
            return reportSyntaxError(this);
          type = 'literal', value = unescaped.replace(/^'|'$/g, '"');
        }
        break;

      case '@':
        // Try to find a language code.
        if (this._prevTokenType === 'literal' && (match = this._langcode.exec(input)))
          type = 'langcode', value = match[1];
        // Try to find a keyword.
        else if (match = this._keyword.exec(input))
          type = match[0];
        break;

      case '.':
        // Try to find a dot as punctuation.
        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {
          type = '.';
          matchLength = 1;
          break;
        }
        // Fall through to numerical case (could be a decimal dot).

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '+':
      case '-':
        // Try to find a number.
        if (match = this._number.exec(input)) {
          type = 'literal';
          value = '"' + match[0] + '"^^http://www.w3.org/2001/XMLSchema#' +
                  (match[1] ? 'double' : (/^[+\-]?\d+$/.test(match[0]) ? 'integer' : 'decimal'));
        }
        break;

      case 'B':
      case 'b':
      case 'p':
      case 'P':
      case 'G':
      case 'g':
        // Try to find a SPARQL-style keyword.
        if (match = this._sparqlKeyword.exec(input))
          type = match[0].toUpperCase();
        else
          inconclusive = true;
        break;

      case 'f':
      case 't':
        // Try to match a boolean.
        if (match = this._boolean.exec(input))
          type = 'literal', value = '"' + match[0] + '"^^http://www.w3.org/2001/XMLSchema#boolean';
        else
          inconclusive = true;
        break;

      case 'a':
        // Try to find an abbreviated predicate.
        if (match = this._shortPredicates.exec(input))
          type = 'abbreviation', value = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';
        else
          inconclusive = true;
        break;

      case ',':
      case ';':
      case '[':
      case ']':
      case '(':
      case ')':
      case '{':
      case '}':
        // The next token is punctuation
        matchLength = 1;
        type = firstChar;
        break;

      default:
        inconclusive = true;
      }

      // Some first characters do not allow an immediate decision, so inspect more.
      if (inconclusive) {
        // Try to find a prefix.
        if ((this._prevTokenType === '@prefix' || this._prevTokenType === 'PREFIX') &&
            (match = this._prefix.exec(input)))
          type = 'prefix', value = match[1] || '';
        // Try to find a prefixed name. Since it can contain (but not end with) a dot,
        // we always need a non-dot character before deciding it is a prefixed name.
        // Therefore, try inserting a space if we're at the end of the input.
        else if ((match = this._prefixed.exec(input)) ||
                 inputFinished && (match = this._prefixed.exec(input + ' ')))
          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);
      }

      // A type token is special: it can only be emitted after an IRI or prefixed name is read.
      if (this._prevTokenType === '^')
        type = (type === 'IRI' || type === 'prefixed') ? 'type' : '';

      // What if nothing of the above was found?
      if (!type) {
        // We could be in streaming mode, and then we just wait for more input to arrive.
        // Otherwise, a syntax error has occurred in the input.
        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).
        if (inputFinished || (!/^'''|^"""/.test(input) && /\n|\r/.test(input)))
          return reportSyntaxError(this);
        else
          return this._input = input;
      }

      // Emit the parsed token.
      callback(null, { line: line, type: type, value: value, prefix: prefix });
      this._prevTokenType = type;

      // Advance to next part to tokenize.
      input = input.substr(matchLength || match[0].length, input.length);
    }

    // Signals the syntax error through the callback
    function reportSyntaxError(self) { callback(self._syntaxError(/^\S*/.exec(input)[0])); }
  },

  // ### `_unescape` replaces N3 escape codes by their corresponding characters.
  _unescape: function (item) {
    try {
      return item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {
        var charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode <= 0xFFFF) return fromCharCode(charCode);
          return fromCharCode(0xD800 + ((charCode -= 0x10000) / 0x400), 0xDC00 + (charCode & 0x3FF));
        }
        else {
          var replacement = escapeReplacements[escapedChar];
          if (!replacement)
            throw new Error();
          return replacement;
        }
      });
    }
    catch (error) { return null; }
  },

  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError: function (issue) {
    this._input = null;
    return new Error('Syntax error: unexpected "' + issue + '" on line ' + this._line + '.');
  },


  // ## Public methods

  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize: function (input, callback) {
    var self = this;
    this._line = 1;

    // If the input is a string, continuously emit tokens through the callback until the end.
    if (typeof input === 'string') {
      this._input = input;
      immediately(function () { self._tokenizeToEnd(callback, true); });
    }
    // Otherwise, the input will be streamed.
    else {
      this._input = '';

      // If no input was given, it will be streamed through `addChunk` and ended with `end`
      if (!input || typeof input === 'function') {
        this.addChunk = addChunk;
        this.end = end;
        if (!callback)
          callback = input;
      }
      // Otherwise, the input itself must be a stream
      else {
        if (typeof input.setEncoding === 'function')
          input.setEncoding('utf8');
        input.on('data', addChunk);
        input.on('end', end);
      }
    }

    // Adds the data chunk to the buffer and parses as far as possible
    function addChunk(data) {
      if (self._input !== null) {
        self._input += data;
        self._tokenizeToEnd(callback, false);
      }
    }

    // Parses until the end
    function end() {
      if (self._input !== null)
        self._tokenizeToEnd(callback, true);
    }
  },
};

// ## Exports

// Export the `N3Lexer` class as a whole.
module.exports = N3Lexer;


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3Parser.js":
/*!************************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3Parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// **N3Parser** parses N3 documents.
var N3Lexer = __webpack_require__(/*! ./N3Lexer */ "./node_modules/@rdfoo/n3/lib/N3Lexer.js");

var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    RDF_NIL    = RDF_PREFIX + 'nil',
    RDF_FIRST  = RDF_PREFIX + 'first',
    RDF_REST   = RDF_PREFIX + 'rest';

var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,
    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i,
    dotSegments = /(?:^|\/)\.\.?(?:$|[\/#?])/;

// The next ID for new blank nodes
var blankNodePrefix = 0, blankNodeCount = 0;

// ## Constructor
function N3Parser(options) {
  if (!(this instanceof N3Parser))
    return new N3Parser(options);
  this._tripleStack = [];
  this._graph = null;

  // Set the document IRI.
  options = options || {};
  this._setBase(options.documentIRI);

  // Set supported features depending on the format.
  var format = (typeof options.format === 'string') && options.format.match(/\w*$/)[0].toLowerCase(),
      isTurtle = format === 'turtle', isTriG = format === 'trig',
      isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),
      isLineMode = isNTriples || isNQuads;
  if (!(this._supportsNamedGraphs = !isTurtle))
    this._readPredicateOrNamedGraph = this._readPredicate;
  this._supportsQuads = !(isTurtle || isTriG || isNTriples);
  // Disable relative IRIs in N-Triples or N-Quads mode
  if (isLineMode) {
    this._base = '';
    this._resolveIRI = function (token) {
      this._error('Disallowed relative IRI', token);
      return this._callback = noop, this._subject = null;
    };
  }
  this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :
                            '_:' + options.blankNodePrefix.replace(/^_:/, '');
  this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode });
}

// ## Private class methods

// ### `_resetBlankNodeIds` restarts blank node identification.
N3Parser._resetBlankNodeIds = function () {
  blankNodePrefix = blankNodeCount = 0;
};

N3Parser.prototype = {
  // ## Private methods

  // ### `_setBase` sets the base IRI to resolve relative IRIs.
  _setBase: function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;
    else if (baseIRI.indexOf('#') >= 0)
      throw new Error('Invalid base IRI ' + baseIRI);
    // Set base IRI and its components
    if (this._base = baseIRI) {
      this._basePath   = baseIRI.replace(/[^\/?]*(?:\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      this._baseRoot   = baseIRI[0];
      this._baseScheme = baseIRI[1];
    }
  },

  // ### `_readInTopContext` reads a token when in the top context.
  _readInTopContext: function (token) {
    switch (token.type) {
    // If an EOF token arrives in the top context, signal that we're done.
    case 'eof':
      if (this._graph !== null)
        return this._error('Unclosed graph', token);
      delete this._prefixes._;
      return this._callback(null, null, this._prefixes);
    // It could be a prefix declaration.
    case '@prefix':
      this._sparqlStyle = false;
      return this._readPrefix;
    case 'PREFIX':
      this._sparqlStyle = true;
      return this._readPrefix;
    // It could be a base declaration.
    case '@base':
      this._sparqlStyle = false;
      return this._readBaseIRI;
    case 'BASE':
      this._sparqlStyle = true;
      return this._readBaseIRI;
    // It could be a graph.
    case '{':
      if (this._supportsNamedGraphs) {
        this._graph = '';
        this._subject = null;
        return this._readSubject;
      }
    case 'GRAPH':
      if (this._supportsNamedGraphs)
        return this._readNamedGraphLabel;
    // Otherwise, the next token must be a subject.
    default:
      return this._readSubject(token);
    }
  },

  // ### `_readSubject` reads a triple's subject.
  _readSubject: function (token) {
    this._predicate = null;
    switch (token.type) {
    case 'IRI':
      if (this._base === null || absoluteIRI.test(token.value))
        this._subject = token.value;
      else
        this._subject = this._resolveIRI(token);
      break;
    case 'prefixed':
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error('Undefined prefix "' + token.prefix + ':"', token);
      this._subject = prefix + token.value;
      break;
    case '[':
      // Start a new triple with a new blank node as subject.
      this._subject = '_:b' + blankNodeCount++;
      this._tripleStack.push({ subject: this._subject, predicate: null, object: null, type: 'blank' });
      return this._readBlankNodeHead;
    case '(':
      // Start a new list
      this._tripleStack.push({ subject: RDF_NIL, predicate: null, object: null, type: 'list' });
      this._subject = null;
      return this._readListItem;
    case '}':
      return this._readPunctuation(token);
    default:
      return this._error('Expected subject but got ' + token.type, token);
    }
    // The next token must be a predicate,
    // or, if the subject was actually a graph IRI, a named graph.
    return this._readPredicateOrNamedGraph;
  },

  // ### `_readPredicate` reads a triple's predicate.
  _readPredicate: function (token) {
    var type = token.type;
    switch (type) {
    case 'IRI':
    case 'abbreviation':
      if (this._base === null || absoluteIRI.test(token.value))
        this._predicate = token.value;
      else
        this._predicate = this._resolveIRI(token);
      break;
    case 'prefixed':
      if (token.prefix === '_')
        return this._error('Disallowed blank node as predicate', token);
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error('Undefined prefix "' + token.prefix + ':"', token);
      this._predicate = prefix + token.value;
      break;
    case '.':
    case ']':
    case '}':
      // Expected predicate didn't come, must have been trailing semicolon.
      if (this._predicate === null)
        return this._error('Unexpected ' + type, token);
      this._subject = null;
      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);
    case ';':
      // Extra semicolons can be safely ignored
      return this._readPredicate;
    default:
      return this._error('Expected predicate to follow "' + this._subject + '"', token);
    }
    // The next token must be an object.
    return this._readObject;
  },

  // ### `_readObject` reads a triple's object.
  _readObject: function (token) {
    switch (token.type) {
    case 'IRI':
      if (this._base === null || absoluteIRI.test(token.value))
        this._object = token.value;
      else
        this._object = this._resolveIRI(token);
      break;
    case 'prefixed':
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error('Undefined prefix "' + token.prefix + ':"', token);
      this._object = prefix + token.value;
      break;
    case 'literal':
      this._object = token.value;
      return this._readDataTypeOrLang;
    case '[':
      // Start a new triple with a new blank node as subject.
      var blank = '_:b' + blankNodeCount++;
      this._tripleStack.push({ subject: this._subject, predicate: this._predicate, object: blank, type: 'blank' });
      this._subject = blank;
      return this._readBlankNodeHead;
    case '(':
      // Start a new list
      this._tripleStack.push({ subject: this._subject, predicate: this._predicate, object: RDF_NIL, type: 'list' });
      this._subject = null;
      return this._readListItem;
    default:
      return this._error('Expected object to follow "' + this._predicate + '"', token);
    }
    return this._getTripleEndReader();
  },

  // ### `_readPredicateOrNamedGraph` reads a triple's predicate, or a named graph.
  _readPredicateOrNamedGraph: function (token) {
    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);
  },

  // ### `_readGraph` reads a graph.
  _readGraph: function (token) {
    if (token.type !== '{')
      return this._error('Expected graph but got ' + token.type, token);
    // The "subject" we read is actually the GRAPH's label
    this._graph = this._subject, this._subject = null;
    return this._readSubject;
  },

  // ### `_readBlankNodeHead` reads the head of a blank node.
  _readBlankNodeHead: function (token) {
    if (token.type === ']') {
      this._subject = null;
      return this._readBlankNodeTail(token);
    }
    else {
      this._predicate = null;
      return this._readPredicate(token);
    }
  },

  // ### `_readBlankNodeTail` reads the end of a blank node.
  _readBlankNodeTail: function (token) {
    if (token.type !== ']')
      return this._readBlankNodePunctuation(token);

    // Store blank node triple.
    if (this._subject !== null)
      this._callback(null, { subject:   this._subject,
                             predicate: this._predicate,
                             object:    this._object,
                             graph:     this._graph || '' });

    // Restore parent triple that contains the blank node.
    var triple = this._tripleStack.pop();
    this._subject = triple.subject;
    // Was the blank node the object?
    if (triple.object !== null) {
      // Restore predicate and object as well, and continue by reading punctuation.
      this._predicate = triple.predicate;
      this._object = triple.object;
      return this._getTripleEndReader();
    }
    // The blank node was the subject, so continue reading the predicate.
    // If the blank node didn't contain any predicates, it could also be the label of a named graph.
    return this._predicate !== null ? this._readPredicate : this._readPredicateOrNamedGraph;
  },

  // ### `_readDataTypeOrLang` reads an _optional_ data type or language.
  _readDataTypeOrLang: function (token) {
    switch (token.type) {
    case 'type':
      var value;
      if (token.prefix === '') {
        if (this._base === null || absoluteIRI.test(token.value))
          value = token.value;
        else
          value = this._resolveIRI(token);
      }
      else {
        var prefix = this._prefixes[token.prefix];
        if (prefix === undefined)
          return this._error('Undefined prefix "' + token.prefix + ':"', token);
        value = prefix + token.value;
      }
      this._object += '^^' + value;
      return this._getTripleEndReader();
    case 'langcode':
      this._object += '@' + token.value.toLowerCase();
      return this._getTripleEndReader();
    default:
      return this._getTripleEndReader().call(this, token);
    }
  },

  // ### `_readListItem` reads items from a list.
  _readListItem: function (token) {
    var item = null,                  // The actual list item.
        itemHead = null,              // The head of the rdf:first predicate.
        prevItemHead = this._subject, // The head of the previous rdf:first predicate.
        stack = this._tripleStack,    // The stack of triples part of recursion (lists, blanks, etc.).
        parentTriple = stack[stack.length - 1], // The triple containing the current list.
        next = this._readListItem;    // The next function to execute.

    switch (token.type) {
    case 'IRI':
      if (this._base === null || absoluteIRI.test(token.value))
        item = token.value;
      else
        item = this._resolveIRI(token);
      break;
    case 'prefixed':
      var prefix = this._prefixes[token.prefix];
      if (prefix === undefined)
        return this._error('Undefined prefix "' + token.prefix + ':"', token);
      item = prefix + token.value;
      break;
    case 'literal':
      item = token.value;
      next = this._readDataTypeOrLang;
      break;
    case '[':
      // Stack the current list triple and start a new triple with a blank node as subject.
      itemHead = '_:b' + blankNodeCount++;
      item     = '_:b' + blankNodeCount++;
      stack.push({ subject: itemHead, predicate: RDF_FIRST, object: item, type: 'blank' });
      this._subject = item;
      next = this._readBlankNodeHead;
      break;
    case '(':
      // Stack the current list triple and start a new list
      itemHead = '_:b' + blankNodeCount++;
      stack.push({ subject: itemHead, predicate: RDF_FIRST, object: RDF_NIL, type: 'list' });
      this._subject = null;
      next = this._readListItem;
      break;
    case ')':
      // Restore the parent triple.
      stack.pop();
      // If this list is contained within a parent list, return the membership triple here.
      // This will be `<parent list element> rdf:first <this list>.`.
      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')
        this._callback(null, { subject:   parentTriple.subject,
                               predicate: parentTriple.predicate,
                               object:    parentTriple.object,
                               graph:     this._graph || '' });
      // Restore the parent triple's subject.
      this._subject = parentTriple.subject;
      // Was this list in the parent triple's subject?
      if (parentTriple.predicate === null) {
        // The next token is the predicate.
        next = this._readPredicate;
        // Skip writing the list tail if this was an empty list.
        if (parentTriple.subject === RDF_NIL)
          return next;
      }
      // The list was in the parent triple's object.
      else {
        // Restore the parent triple's predicate and object as well.
        this._predicate = parentTriple.predicate;
        this._object = parentTriple.object;
        next = this._getTripleEndReader();
        // Skip writing the list tail if this was an empty list.
        if (parentTriple.object === RDF_NIL)
          return next;
      }
      // Close the list by making the item head nil.
      itemHead = RDF_NIL;
      break;
    default:
      return this._error('Expected list item instead of "' + token.type + '"', token);
    }

     // Create a new blank node if no item head was assigned yet.
    if (itemHead === null)
      this._subject = itemHead = '_:b' + blankNodeCount++;

    // Is this the first element of the list?
    if (prevItemHead === null) {
      // This list is either the object or the subject.
      if (parentTriple.object === RDF_NIL)
        parentTriple.object = itemHead;
      else
        parentTriple.subject = itemHead;
    }
    else {
      // The rest of the list is in the current head.
      this._callback(null, { subject:   prevItemHead,
                             predicate: RDF_REST,
                             object:    itemHead,
                             graph:     this._graph || '' });
    }
    // Add the item's value.
    if (item !== null)
      this._callback(null, { subject:   itemHead,
                             predicate: RDF_FIRST,
                             object:    item,
                             graph:     this._graph || '' });
    return next;
  },

  // ### `_readPunctuation` reads punctuation between triples or triple parts.
  _readPunctuation: function (token) {
    var next, subject = this._subject, graph = this._graph;
    switch (token.type) {
    // A closing brace ends a graph
    case '}':
      if (this._graph === null)
        return this._error('Unexpected graph closing', token);
      this._graph = null;
    // A dot just ends the statement, without sharing anything with the next.
    case '.':
      this._subject = null;
      next = this._readInTopContext;
      break;
    // Semicolon means the subject is shared; predicate and object are different.
    case ';':
      next = this._readPredicate;
      break;
    // Comma means both the subject and predicate are shared; the object is different.
    case ',':
      next = this._readObject;
      break;
    // An IRI means this is a quad (only allowed if not already inside a graph).
    case 'IRI':
      if (this._supportsQuads && this._graph === null) {
        if (this._base === null || absoluteIRI.test(token.value))
          graph = token.value;
        else
          graph = this._resolveIRI(token);
        subject = this._subject;
        next = this._readQuadPunctuation;
        break;
      }
    // An prefixed name means this is a quad (only allowed if not already inside a graph).
    case 'prefixed':
      if (this._supportsQuads && this._graph === null) {
        var prefix = this._prefixes[token.prefix];
        if (prefix === undefined)
          return this._error('Undefined prefix "' + token.prefix + ':"', token);
        graph = prefix + token.value;
        next = this._readQuadPunctuation;
        break;
      }
    default:
      return this._error('Expected punctuation to follow "' + this._object + '"', token);
    }
    // A triple has been completed now, so return it.
    if (subject !== null)
      this._callback(null, { subject:   subject,
                             predicate: this._predicate,
                             object:    this._object,
                             graph:     graph || '' });
    return next;
  },

    // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation: function (token) {
    var next;
    switch (token.type) {
    // Semicolon means the subject is shared; predicate and object are different.
    case ';':
      next = this._readPredicate;
      break;
    // Comma means both the subject and predicate are shared; the object is different.
    case ',':
      next = this._readObject;
      break;
    default:
      return this._error('Expected punctuation to follow "' + this._object + '"', token);
    }
    // A triple has been completed now, so return it.
    this._callback(null, { subject:   this._subject,
                           predicate: this._predicate,
                           object:    this._object,
                           graph:     this._graph || '' });
    return next;
  },

  // ### `_readQuadPunctuation` reads punctuation after a quad.
  _readQuadPunctuation: function (token) {
    if (token.type !== '.')
      return this._error('Expected dot to follow quad', token);
    return this._readInTopContext;
  },

  // ### `_readPrefix` reads the prefix of a prefix declaration.
  _readPrefix: function (token) {
    if (token.type !== 'prefix')
      return this._error('Expected prefix to follow @prefix', token);
    this._prefix = token.value;
    return this._readPrefixIRI;
  },

  // ### `_readPrefixIRI` reads the IRI of a prefix declaration.
  _readPrefixIRI: function (token) {
    if (token.type !== 'IRI')
      return this._error('Expected IRI to follow prefix "' + this._prefix + ':"', token);
    var prefixIRI;
    if (this._base === null || absoluteIRI.test(token.value))
      prefixIRI = token.value;
    else
      prefixIRI = this._resolveIRI(token);
    this._prefixes[this._prefix] = prefixIRI;
    this._prefixCallback(this._prefix, prefixIRI);
    return this._readDeclarationPunctuation;
  },

  // ### `_readBaseIRI` reads the IRI of a base declaration.
  _readBaseIRI: function (token) {
    if (token.type !== 'IRI')
      return this._error('Expected IRI to follow base declaration', token);
    try {
      this._setBase(this._base === null ||
                    absoluteIRI.test(token.value) ? token.value : this._resolveIRI(token));
    }
    catch (error) { this._error(error.message, token); }
    return this._readDeclarationPunctuation;
  },

  // ### `_readNamedGraphLabel` reads the label of a named graph.
  _readNamedGraphLabel: function (token) {
    switch (token.type) {
    case 'IRI':
    case 'prefixed':
      return this._readSubject(token), this._readGraph;
    case '[':
      return this._readNamedGraphBlankLabel;
    default:
      return this._error('Invalid graph label', token);
    }
  },

  // ### `_readNamedGraphLabel` reads a blank node label of a named graph.
  _readNamedGraphBlankLabel: function (token) {
    if (token.type !== ']')
      return this._error('Invalid graph label', token);
    this._subject = '_:b' + blankNodeCount++;
    return this._readGraph;
  },

  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration.
  _readDeclarationPunctuation: function (token) {
    // SPARQL-style declarations don't have punctuation.
    if (this._sparqlStyle)
      return this._readInTopContext(token);

    if (token.type !== '.')
      return this._error('Expected declaration to end with a dot', token);
    return this._readInTopContext;
  },

  // ### `_getTripleEndReader` gets the next reader function at the end of a triple.
  _getTripleEndReader: function () {
    var stack = this._tripleStack;
    if (stack.length === 0)
      return this._readPunctuation;

    switch (stack[stack.length - 1].type) {
    case 'blank':
      return this._readBlankNodeTail;
    case 'list':
      return this._readListItem;
    }
  },

  // ### `_error` emits an error message through the callback.
  _error: function (message, token) {
    this._callback(new Error(message + ' at line ' + token.line + '.'));
  },

  // ### `_resolveIRI` resolves a relative IRI token against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative.
  _resolveIRI: function (token) {
    var iri = token.value;
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return this._base;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return this._base + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return this._base.replace(/(?:\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default:
      return this._removeDotSegments(this._basePath + iri);
    }
  },

  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.
  _removeDotSegments: function (iri) {
    // Don't modify the IRI if it does not contain any dot segments
    if (!dotSegments.test(iri))
      return iri;

    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'
    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';

    while (i < length) {
      switch (next) {
      // The path starts with the first slash after the authority
      case ':':
        if (pathStart < 0) {
          // Skip two slashes before the authority
          if (iri[++i] === '/' && iri[++i] === '/')
            // Skip to slash after the authority
            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')
              i = pathStart;
        }
        break;
      // Don't modify a query string or fragment
      case '?':
      case '#':
        i = length;
        break;
      // Handle '/.' or '/..' path segments
      case '/':
        if (iri[i + 1] === '.') {
          next = iri[++i + 1];
          switch (next) {
          // Remove a '/.' segment
          case '/':
            result += iri.substring(segmentStart, i - 1);
            segmentStart = i + 1;
            break;
          // Remove a trailing '/.' segment
          case undefined:
          case '?':
          case '#':
            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
          // Remove a '/..' segment
          case '.':
            next = iri[++i + 1];
            if (next === undefined || next === '/' || next === '?' || next === '#') {
              result += iri.substring(segmentStart, i - 2);
              // Try to remove the parent path from result
              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)
                result = result.substr(0, segmentStart);
              // Remove a trailing '/..' segment
              if (next !== '/')
                return result + '/' + iri.substr(i + 1);
              segmentStart = i + 1;
            }
          }
        }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  },

  // ## Public methods

  // ### `parse` parses the N3 input and emits each parsed triple through the callback.
  parse: function (input, tripleCallback, prefixCallback) {
    // The read callback is the next function to be executed when a token arrives.
    // We start reading in the top context.
    this._readCallback = this._readInTopContext;
    this._prefixes = Object.create(null);
    this._prefixes._ = this._blankNodePrefix || '_:b' + blankNodePrefix++ + '_';

    // If the input argument is not given, shift parameters
    if (typeof input === 'function')
      prefixCallback = tripleCallback, tripleCallback = input, input = null;

    // Set the triple and prefix callbacks.
    this._callback = tripleCallback || noop;
    this._prefixCallback = prefixCallback || noop;

    // Execute the read callback when a token arrives.
    var self = this;
    this._lexer.tokenize(input, function (error, token) {
      if (error !== null)
        self._callback(error), self._callback = noop;
      else if (self._readCallback !== undefined)
        self._readCallback = self._readCallback(token);
    });

    // If no input was given, it can be added with `addChunk` and ended with `end`
    if (!input) {
      this.addChunk = this._lexer.addChunk;
      this.end = this._lexer.end;
    }
  },
};

// The empty function
function noop() {}

// ## Exports

// Export the `N3Parser` class as a whole.
module.exports = N3Parser;


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3Store.js":
/*!***********************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3Store.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// **N3Store** objects store N3 triples by graph in memory.

var expandPrefixedName = __webpack_require__(/*! ./N3Util */ "./node_modules/@rdfoo/n3/lib/N3Util.js").expandPrefixedName;

// ## Constructor
function N3Store(triples, options) {
  if (!(this instanceof N3Store))
    return new N3Store(triples, options);

  // The number of triples is initially zero.
  this._size = 0;
  // `_graphs` contains subject, predicate, and object indexes per graph.
  this._graphs = Object.create(null);
  // `_entities` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers.
  // This saves memory, since only the numbers have to be stored in `_graphs`.
  this._entities = Object.create(null);
  this._entities['><'] = 0; // Dummy entry, so the first actual key is non-zero
  this._entityCount = 0;
  // `_blankNodeIndex` is the index of the last created blank node that was automatically named
  this._blankNodeIndex = 0;

  // Shift parameters if `triples` is not given
  if (!options && triples && !triples[0])
    options = triples, triples = null;

  // Add triples and prefixes if passed
  this._prefixes = Object.create(null);
  if (options && options.prefixes)
    this.addPrefixes(options.prefixes);
  if (triples)
    this.addTriples(triples);
}

N3Store.prototype = {
  // ## Public properties

  // ### `size` returns the number of triples in the store.
  get size() {
    // Return the triple count if if was cached.
    var size = this._size;
    if (size !== null)
      return size;

    // Calculate the number of triples by counting to the deepest level.
    var graphs = this._graphs, subjects, subject;
    for (var graphKey in graphs)
      for (var subjectKey in (subjects = graphs[graphKey].subjects))
        for (var predicateKey in (subject = subjects[subjectKey]))
          size += Object.keys(subject[predicateKey]).length;
    return this._size = size;
  },

  // ## Private methods

  // ### `_addToIndex` adds a triple to a three-layered index.
  _addToIndex: function (index0, key0, key1, key2) {
    // Create layers as necessary.
    var index1 = index0[key0] || (index0[key0] = {});
    var index2 = index1[key1] || (index1[key1] = {});
    // Setting the key to _any_ value signalizes the presence of the triple.
    index2[key2] = null;
  },

  // ### `_removeFromIndex` removes a triple from a three-layered index.
  _removeFromIndex: function (index0, key0, key1, key2) {
    // Remove the triple from the index.
    var index1 = index0[key0], index2 = index1[key1], key;
    delete index2[key2];

    // Remove intermediary index layers if they are empty.
    for (key in index2) return;
    delete index1[key1];
    for (key in index1) return;
    delete index0[key0];
  },

  // ### `_findInIndex` finds a set of triples in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be `null`, which is interpreted as a wildcard.
  // `name0`, `name1`, and `name2` are the names of the keys at each level,
  // used when reconstructing the resulting triple
  // (for instance: _subject_, _predicate_, and _object_).
  // Finally, `graph` will be the graph of the created triples.
  _findInIndex: function (index0, key0, key1, key2, name0, name1, name2, graph) {
    var results = [], entityKeys = Object.keys(this._entities), tmp, index1, index2;

    // If a key is specified, use only that part of index 0.
    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
    for (var value0 in index0) {
      var entity0 = entityKeys[value0];

      if (index1 = index0[value0]) {
        // If a key is specified, use only that part of index 1.
        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
        for (var value1 in index1) {
          var entity1 = entityKeys[value1];

          if (index2 = index1[value1]) {
            // If a key is specified, use only that part of index 2, if it exists.
            var values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);
            // Create triples for all items found in index 2.
            for (var l = values.length - 1; l >= 0; l--) {
              var result = { subject: '', predicate: '', object: '', graph: graph };
              result[name0] = entity0;
              result[name1] = entity1;
              result[name2] = entityKeys[values[l]];
              results.push(result);
            }
          }
        }
      }
    }
    return results;
  },

  // ### `_countInIndex` counts matching triples in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be `null`, which is interpreted as a wildcard.
  _countInIndex: function (index0, key0, key1, key2) {
    var count = 0, tmp, index1, index2;

    // If a key is specified, count only that part of index 0.
    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];
    for (var value0 in index0) {
      if (index1 = index0[value0]) {
        // If a key is specified, count only that part of index 1.
        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];
        for (var value1 in index1) {
          if (index2 = index1[value1]) {
            // If a key is specified, count the triple if it exists.
            if (key2) (key2 in index2) && count++;
            // Otherwise, count all triples.
            else count += Object.keys(index2).length;
          }
        }
      }
    }
    return count;
  },

  // ## Public methods

  // ### `addTriple` adds a new N3 triple to the store.
  addTriple: function (subject, predicate, object, graph) {
    // Shift arguments if a triple object is given instead of components
    if (!predicate)
      graph = subject.graph, object = subject.object,
        predicate = subject.predicate, subject = subject.subject;

    // Find the graph that will contain the triple.
    graph = graph || '';
    var graphItem = this._graphs[graph];
    // Create the graph if it doesn't exist yet.
    if (!graphItem) {
      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };
      // Freezing a graph helps subsequent `add` performance,
      // and properties will never be modified anyway.
      Object.freeze(graphItem);
    }

    // Since entities can often be long IRIs, we avoid storing them in every index.
    // Instead, we have a separate index that maps entities to numbers,
    // which are then used as keys in the other indexes.
    var entities = this._entities;
    subject   = entities[subject]   || (entities[subject]   = ++this._entityCount);
    predicate = entities[predicate] || (entities[predicate] = ++this._entityCount);
    object    = entities[object]    || (entities[object]    = ++this._entityCount);

    this._addToIndex(graphItem.subjects,   subject,   predicate, object);
    this._addToIndex(graphItem.predicates, predicate, object,    subject);
    this._addToIndex(graphItem.objects,    object,    subject,   predicate);

    // The cached triple count is now invalid.
    this._size = null;
  },

  // ### `addTriples` adds multiple N3 triples to the store.
  addTriples: function (triples) {
    for (var i = triples.length - 1; i >= 0; i--)
      this.addTriple(triples[i]);
  },

  // ### `addPrefix` adds support for querying with the given prefix
  addPrefix: function (prefix, iri) {
    this._prefixes[prefix] = iri;
  },

  // ### `addPrefixes` adds support for querying with the given prefixes
  addPrefixes: function (prefixes) {
    for (var prefix in prefixes)
      this.addPrefix(prefix, prefixes[prefix]);
  },

  // ### `removeTriple` removes an N3 triple from the store if it exists.
  removeTriple: function (subject, predicate, object, graph) {
    // Shift arguments if a triple object is given instead of components.
    if (!predicate)
      graph = subject.graph, object = subject.object,
        predicate = subject.predicate, subject = subject.subject;
    graph = graph || '';

    // Find internal identifiers for all components.
    var graphItem, entities = this._entities, graphs = this._graphs;
    if (!(subject     = entities[subject]))   return;
    if (!(predicate   = entities[predicate])) return;
    if (!(object      = entities[object]))    return;
    if (!(graphItem   = graphs[graph]))       return;

    // Verify that the triple exists.
    var subjects, predicates;
    if (!(subjects   = graphItem.subjects[subject])) return;
    if (!(predicates = subjects[predicate])) return;
    if (!(object in predicates)) return;

    // Remove it from all indexes.
    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);
    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);
    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);
    if (this._size !== null) this._size--;

    // Remove the graph if it is empty.
    for (subject in graphItem.subjects) return;
    delete graphs[graph];
  },

  // ### `removeTriples` removes multiple N3 triples from the store.
  removeTriples: function (triples) {
    for (var i = triples.length - 1; i >= 0; i--)
      this.removeTriple(triples[i]);
  },

  // ### `find` finds a set of triples matching a pattern, expanding prefixes as necessary.
  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.
  // Setting `graph` to `null` means the default graph.
  find: function (subject, predicate, object, graph) {
    var prefixes = this._prefixes;
    return this.findByIRI(
      expandPrefixedName(subject,   prefixes),
      expandPrefixedName(predicate, prefixes),
      expandPrefixedName(object,    prefixes),
      expandPrefixedName(graph,     prefixes)
    );
  },

  // ### `findByIRI` finds a set of triples matching a pattern.
  // Setting `subject`, `predicate`, or `object` to a falsy value means an _anything_ wildcard.
  // Setting `graph` to a falsy value means the default graph.
  findByIRI: function (subject, predicate, object, graph) {
    graph = graph || '';
    var graphItem = this._graphs[graph], entities = this._entities;

    // If the specified graph contain no triples, there are no results.
    if (!graphItem) return [];

    // Translate IRIs to internal index keys.
    // Optimization: if the entity doesn't exist, no triples with it exist.
    if (subject   && !(subject   = entities[subject]))   return [];
    if (predicate && !(predicate = entities[predicate])) return [];
    if (object    && !(object    = entities[object]))    return [];

    // Choose the optimal index, based on what fields are present
    if (subject) {
      if (object)
        // If subject and object are given, the object index will be the fastest.
        return this._findInIndex(graphItem.objects, object, subject, predicate,
                                 'object', 'subject', 'predicate', graph);
      else
        // If only subject and possibly predicate are given, the subject index will be the fastest.
        return this._findInIndex(graphItem.subjects, subject, predicate, null,
                                 'subject', 'predicate', 'object', graph);
    }
    else if (predicate)
      // If only predicate and possibly object are given, the predicate index will be the fastest.
      return this._findInIndex(graphItem.predicates, predicate, object, null,
                               'predicate', 'object', 'subject', graph);
    else if (object)
      // If only object is given, the object index will be the fastest.
      return this._findInIndex(graphItem.objects, object, null, null,
                               'object', 'subject', 'predicate', graph);
    else
      // If nothing is given, iterate subjects and predicates first
      return this._findInIndex(graphItem.subjects, null, null, null,
                               'subject', 'predicate', 'object', graph);
  },

  // ### `count` returns the number of triples matching a pattern, expanding prefixes as necessary.
  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.
  // Setting `graph` to `null` means the default graph.
  count: function (subject, predicate, object, graph) {
    var prefixes = this._prefixes;
    return this.countByIRI(
      expandPrefixedName(subject,   prefixes),
      expandPrefixedName(predicate, prefixes),
      expandPrefixedName(object,    prefixes),
      expandPrefixedName(graph,     prefixes)
    );
  },

  // ### `countByIRI` returns the number of triples matching a pattern.
  // Setting `subject`, `predicate`, or `object` to `null` means an _anything_ wildcard.
  // Setting `graph` to `null` means the default graph.
  countByIRI: function (subject, predicate, object, graph) {
    graph = graph || '';
    var graphItem = this._graphs[graph], entities = this._entities;

    // If the specified graph contain no triples, there are no results.
    if (!graphItem) return 0;

    // Translate IRIs to internal index keys.
    // Optimization: if the entity doesn't exist, no triples with it exist.
    if (subject   && !(subject   = entities[subject]))   return 0;
    if (predicate && !(predicate = entities[predicate])) return 0;
    if (object    && !(object    = entities[object]))    return 0;

    // Choose the optimal index, based on what fields are present
    if (subject) {
      if (object)
        // If subject and object are given, the object index will be the fastest.
        return this._countInIndex(graphItem.objects, object, subject, predicate);
      else
        // If only subject and possibly predicate are given, the subject index will be the fastest.
        return this._countInIndex(graphItem.subjects, subject, predicate, object);
    }
    else if (predicate) {
      // If only predicate and possibly object are given, the predicate index will be the fastest.
      return this._countInIndex(graphItem.predicates, predicate, object, subject);
    }
    else {
      // If only object is possibly given, the object index will be the fastest.
      return this._countInIndex(graphItem.objects, object, subject, predicate);
    }
  },

  // ### `createBlankNode` creates a new blank node, returning its name.
  createBlankNode: function (suggestedName) {
    var name, index;
    // Generate a name based on the suggested name
    if (suggestedName) {
      name = suggestedName = '_:' + suggestedName, index = 1;
      while (this._entities[name])
        name = suggestedName + index++;
    }
    // Generate a generic blank node name
    else {
      do { name = '_:b' + this._blankNodeIndex++; }
      while (this._entities[name]);
    }
    // Add the blank node to the entities, avoiding the generation of duplicates
    this._entities[name] = ++this._entityCount;
    return name;
  },
};

// ## Exports

// Export the `N3Store` class as a whole.
module.exports = N3Store;


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3StreamParser.js":
/*!******************************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3StreamParser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// **N3StreamParser** parses an N3 stream into a triple stream
var Transform = __webpack_require__(/*! stream */ "stream").Transform,
    util = __webpack_require__(/*! util */ "util"),
    N3Parser = __webpack_require__(/*! ./N3Parser.js */ "./node_modules/@rdfoo/n3/lib/N3Parser.js");

// ## Constructor
function N3StreamParser(options) {
  if (!(this instanceof N3StreamParser))
    return new N3StreamParser(options);

  // Initialize Transform base class
  Transform.call(this, { decodeStrings: true });
  this._readableState.objectMode = true;

  // Set up parser
  var self = this, parser = new N3Parser(options);
  parser.parse(
    // Handle triples by pushing them down the pipeline
    function (error, triple) {
      triple && self.push(triple) ||
      error  && self.emit('error', error);
    },
    // Emit prefixes through the `prefix` event
    this.emit.bind(this, 'prefix'));

  // Implement Transform methods on top of parser
  this._transform = function (chunk, encoding, done) { parser.addChunk(chunk); done(); };
  this._flush = function (done) { parser.end(); done(); };
}
util.inherits(N3StreamParser, Transform);

// ## Exports
// Export the `N3StreamParser` class as a whole.
module.exports = N3StreamParser;


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3StreamWriter.js":
/*!******************************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3StreamWriter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// **N3StreamWriter** serializes a triple stream into an N3 stream
var Transform = __webpack_require__(/*! stream */ "stream").Transform,
    util = __webpack_require__(/*! util */ "util"),
    N3Writer = __webpack_require__(/*! ./N3Writer.js */ "./node_modules/@rdfoo/n3/lib/N3Writer.js");

// ## Constructor
function N3StreamWriter(options) {
  if (!(this instanceof N3StreamWriter))
    return new N3StreamWriter(options);

  // Initialize Transform base class
  Transform.call(this, { encoding: 'utf8' });
  this._writableState.objectMode = true;

  // Set up writer with a dummy stream object
  var self = this;
  var writer = new N3Writer({
    write: function (chunk, encoding, callback) { self.push(chunk); callback && callback(); },
    end: function (callback) { self.push(null); callback && callback(); },
  }, options);

  // Implement Transform methods on top of writer
  this._transform = function (triple, encoding, done) { writer.addTriple(triple, done); };
  this._flush = function (done) { writer.end(done); };
}
util.inherits(N3StreamWriter, Transform);

// ## Exports
// Export the `N3StreamWriter` class as a whole.
module.exports = N3StreamWriter;


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3Util.js":
/*!**********************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3Util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// **N3Util** provides N3 utility functions

var Xsd = 'http://www.w3.org/2001/XMLSchema#';
var XsdString  = Xsd + 'string';
var XsdInteger = Xsd + 'integer';
var XsdDecimal = Xsd + 'decimal';
var XsdBoolean = Xsd + 'boolean';
var RdfLangString = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString';

var N3Util = {
  // Tests whether the given entity (triple object) represents an IRI in the N3 library
  isIRI: function (entity) {
    if (!entity)
      return entity;
    var firstChar = entity[0];
    return firstChar !== '"' && firstChar !== '_';
  },

  // Tests whether the given entity (triple object) represents a literal in the N3 library
  isLiteral: function (entity) {
    return entity && entity[0] === '"';
  },

  // Tests whether the given entity (triple object) represents a blank node in the N3 library
  isBlank: function (entity) {
    return entity && entity.substr(0, 2) === '_:';
  },

  // Gets the string value of a literal in the N3 library
  getLiteralValue: function (literal) {
    var match = /^"([^]*)"/.exec(literal);
    if (!match)
      throw new Error(literal + ' is not a literal');
    return match[1];
  },

  // Gets the type of a literal in the N3 library
  getLiteralType: function (literal) {
    var match = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(literal);
    if (!match)
      throw new Error(literal + ' is not a literal');
    return match[1] || (match[2] ? RdfLangString : XsdString);
  },

  // Gets the language of a literal in the N3 library
  getLiteralLanguage: function (literal) {
    var match = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(literal);
    if (!match)
      throw new Error(literal + ' is not a literal');
    return match[1] ? match[1].toLowerCase() : '';
  },

  // Tests whether the given entity (triple object) represents a prefixed name
  isPrefixedName: function (entity) {
    return entity && /^[^:\/"']*:[^:\/"']+$/.test(entity);
  },

  // Expands the prefixed name to a full IRI (also when it occurs as a literal's type)
  expandPrefixedName: function (prefixedName, prefixes) {
    var match = /(?:^|"\^\^)([^:\/#"'\^_]*):[^\/]*$/.exec(prefixedName), prefix, base, index;
    if (match)
      prefix = match[1], base = prefixes[prefix], index = match.index;
    if (base === undefined)
      return prefixedName;

    // The match index is non-zero when expanding a literal's type.
    return index === 0 ? base + prefixedName.substr(prefix.length + 1)
                       : prefixedName.substr(0, index + 3) +
                         base + prefixedName.substr(index + prefix.length + 4);
  },

  // Creates an IRI in N3.js representation
  createIRI: function (iri) {
    return iri && iri[0] === '"' ? N3Util.getLiteralValue(iri) : iri;
  },

  // Creates a literal in N3.js representation
  createLiteral: function (value, modifier) {
    if (!modifier) {
      switch (typeof value) {
      case 'boolean':
        modifier = XsdBoolean;
        break;
      case 'number':
        if (isFinite(value)) {
          modifier = value % 1 === 0 ? XsdInteger : XsdDecimal;
          break;
        }
      default:
        return '"' + value + '"';
      }
    }
    return '"' + value +
           (/^[a-z]+(-[a-z0-9]+)*$/i.test(modifier) ? '"@'  + modifier.toLowerCase()
                                                    : '"^^' + modifier);
  },
};

// Add the N3Util functions to the given object or its prototype
function addN3Util(parent, toPrototype) {
  for (var name in N3Util)
    if (!toPrototype)
      parent[name] = N3Util[name];
    else
      parent.prototype[name] = applyToThis(N3Util[name]);

  return parent;
}

// Returns a function that applies `f` to the `this` object
function applyToThis(f) {
  return function (a) { return f(this, a); };
}

// Expose N3Util, attaching all functions to it
module.exports = addN3Util(addN3Util);


/***/ }),

/***/ "./node_modules/@rdfoo/n3/lib/N3Writer.js":
/*!************************************************!*\
  !*** ./node_modules/@rdfoo/n3/lib/N3Writer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// **N3Writer** writes N3 documents.

// Matches a literal as represented in memory by the N3 library
var N3LiteralMatcher = /^"([^]*)"(?:\^\^(.+)|@([\-a-z]+))?$/i;

// rdf:type predicate (for 'a' abbreviation)
var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    RDF_TYPE   = RDF_PREFIX + 'type';

// Characters in literals that require escaping
var escape    = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,
    escapeAll = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,
    escapeReplacements = { '\\': '\\\\', '"': '\\"', '\t': '\\t',
                           '\n': '\\n', '\r': '\\r', '\b': '\\b', '\f': '\\f' };

// ## Constructor
function N3Writer(outputStream, options) {
  if (!(this instanceof N3Writer))
    return new N3Writer(outputStream, options);

  // Shift arguments if the first argument is not a stream
  if (outputStream && typeof outputStream.write !== 'function')
    options = outputStream, outputStream = null;
  options = options || {};

  // If no output stream given, send the output as string through the end callback
  if (!outputStream) {
    var output = '';
    this._outputStream = {
      write: function (chunk, encoding, done) { output += chunk; done && done(); },
      end:   function (done) { done && done(null, output); },
    };
    this._endStream = true;
  }
  else {
    this._outputStream = outputStream;
    this._endStream = options.end === undefined ? true : !!options.end;
  }

  // Initialize writer, depending on the format
  this._subject = null;
  if (!(/triple|quad/i).test(options.format)) {
    this._graph = '';
    this._prefixIRIs = Object.create(null);
    options.prefixes && this.addPrefixes(options.prefixes);
  }
  else {
    this._writeTriple = this._writeTripleLine;
  }
}

N3Writer.prototype = {
  // ## Private methods

  // ### `_write` writes the argument to the output stream
  _write: function (string, callback) {
    this._outputStream.write(string, 'utf8', callback);
  },

    // ### `_writeTriple` writes the triple to the output stream
  _writeTriple: function (subject, predicate, object, graph, done) {
    try {
      // Write the graph's label if it has changed
      if (this._graph !== graph) {
        // Close the previous graph and start the new one
        this._write((this._subject === null ? '' : (this._graph ? '\n}\n' : '.\n')) +
                    (graph ? this._encodeIriOrBlankNode(graph) + ' {\n' : ''));
        this._subject = null;
        // Don't treat identical blank nodes as repeating graphs
        this._graph = graph[0] !== '[' ? graph : ']';
      }
      // Don't repeat the subject if it's the same
      if (this._subject === subject) {
        // Don't repeat the predicate if it's the same
        if (this._predicate === predicate)
          this._write(', ' + this._encodeObject(object), done);
        // Same subject, different predicate
        else
          this._write(';\n    ' +
                      this._encodePredicate(this._predicate = predicate) + ' ' +
                      this._encodeObject(object), done);
      }
      // Different subject; write the whole triple
      else
        this._write((this._subject === null ? '' : '.\n') +
                    this._encodeSubject(this._subject = subject) + ' ' +
                    this._encodePredicate(this._predicate = predicate) + ' ' +
                    this._encodeObject(object), done);
    }
    catch (error) { done && done(error); }
  },

  // ### `_writeTripleLine` writes the triple or quad to the output stream as a single line
  _writeTripleLine: function (subject, predicate, object, graph, done) {
    // Don't use prefixes
    delete this._prefixMatch;
    // Write the triple
    try {
      this._write(this._encodeIriOrBlankNode(subject) + ' ' +
                  this._encodeIriOrBlankNode(predicate) + ' ' +
                  this._encodeObject(object) +
                  (graph ? ' ' + this._encodeIriOrBlankNode(graph) + '.\n' : '.\n'), done);
    }
    catch (error) { done && done(error); }
  },

  // ### `_encodeIriOrBlankNode` represents an IRI or blank node
  _encodeIriOrBlankNode: function (entity) {
    // A blank node or list is represented as-is
    var firstChar = entity[0];
    if (firstChar === '[' || firstChar === '(' || firstChar === '_' && entity[1] === ':')
      return entity;
    // Escape special characters
    if (escape.test(entity))
      entity = entity.replace(escapeAll, characterReplacer);
    // Try to represent the IRI as prefixed name
    var prefixMatch = this._prefixRegex.exec(entity);
    return !prefixMatch ? '<' + entity + '>' :
           (!prefixMatch[1] ? entity : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);
  },

  // ### `_encodeLiteral` represents a literal
  _encodeLiteral: function (value, type, language) {
    // Escape special characters
    if (escape.test(value))
      value = value.replace(escapeAll, characterReplacer);
    // Write the literal, possibly with type or language
    if (language)
      return '"' + value + '"@' + language;
    else if (type)
      return '"' + value + '"^^' + this._encodeIriOrBlankNode(type);
    else
      return '"' + value + '"';
  },

  // ### `_encodeSubject` represents a subject
  _encodeSubject: function (subject) {
    if (subject[0] === '"')
      throw new Error('A literal as subject is not allowed: ' + subject);
    // Don't treat identical blank nodes as repeating subjects
    if (subject[0] === '[')
      this._subject = ']';
    return this._encodeIriOrBlankNode(subject);
  },

  // ### `_encodePredicate` represents a predicate
  _encodePredicate: function (predicate) {
    if (predicate[0] === '"')
      throw new Error('A literal as predicate is not allowed: ' + predicate);
    return predicate === RDF_TYPE ? 'a' : this._encodeIriOrBlankNode(predicate);
  },

  // ### `_encodeObject` represents an object
  _encodeObject: function (object) {
    // Represent an IRI or blank node
    if (object[0] !== '"')
      return this._encodeIriOrBlankNode(object);
    // Represent a literal
    var match = N3LiteralMatcher.exec(object);
    if (!match) throw new Error('Invalid literal: ' + object);
    return this._encodeLiteral(match[1], match[2], match[3]);
  },

  // ### `_blockedWrite` replaces `_write` after the writer has been closed
  _blockedWrite: function () {
    throw new Error('Cannot write because the writer has been closed.');
  },

  // ### `addTriple` adds the triple to the output stream
  addTriple: function (subject, predicate, object, graph, done) {
    // The triple was given as a triple object, so shift parameters
    if (object === undefined)
      this._writeTriple(subject.subject, subject.predicate, subject.object,
                        subject.graph || '', predicate);
    // The optional `graph` parameter was not provided
    else if (typeof graph !== 'string')
      this._writeTriple(subject, predicate, object, '', graph);
    // The `graph` parameter was provided
    else
      this._writeTriple(subject, predicate, object, graph, done);
  },

  // ### `addTriples` adds the triples to the output stream
  addTriples: function (triples) {
    for (var i = 0; i < triples.length; i++)
      this.addTriple(triples[i]);
  },

  // ### `addPrefix` adds the prefix to the output stream
  addPrefix: function (prefix, iri, done) {
    var prefixes = {};
    prefixes[prefix] = iri;
    this.addPrefixes(prefixes, done);
  },

  // ### `addPrefixes` adds the prefixes to the output stream
  addPrefixes: function (prefixes, done) {
    // Add all useful prefixes
    var prefixIRIs = this._prefixIRIs, hasPrefixes = false;
    for (var prefix in prefixes) {
      // Verify whether the prefix can be used and does not exist yet
      var iri = prefixes[prefix];
      if (/[#\/]$/.test(iri) && prefixIRIs[iri] !== (prefix += ':')) {
        hasPrefixes = true;
        prefixIRIs[iri] = prefix;
        // Finish a possible pending triple
        if (this._subject !== null) {
          this._write(this._graph ? '\n}\n' : '.\n');
          this._subject = null, this._graph = '';
        }
        // Write prefix
        this._write('@prefix ' + prefix + ' <' + iri + '>.\n');
      }
    }
    // Recreate the prefix matcher
    if (hasPrefixes) {
      var IRIlist = '', prefixList = '';
      for (var prefixIRI in prefixIRIs) {
        IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;
        prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];
      }
      IRIlist = IRIlist.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, '\\$&');
      this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\/]*$|' +
                                     '^(' + IRIlist + ')([a-zA-Z][\\-_a-zA-Z0-9]*)$');
    }
    // End a prefix block with a newline
    this._write(hasPrefixes ? '\n' : '', done);
  },

  // ### `blank` creates a blank node with the given content
  blank: function (predicate, object) {
    var children = predicate, child, length;
    // Empty blank node
    if (predicate === undefined)
      children = [];
    // Blank node passed as blank("predicate", "object")
    else if (typeof predicate === 'string')
      children = [{ predicate: predicate, object: object }];
    // Blank node passed as blank({ predicate: predicate, object: object })
    else if (!('length' in predicate))
      children = [predicate];

    switch (length = children.length) {
    // Generate an empty blank node
    case 0:
      return '[]';
    // Generate a non-nested one-triple blank node
    case 1:
      child = children[0];
      if (child.object[0] !== '[')
        return '[ ' + this._encodePredicate(child.predicate) + ' ' +
                      this._encodeObject(child.object) + ' ]';
    // Generate a multi-triple or nested blank node
    default:
      var contents = '[';
      // Write all triples in order
      for (var i = 0; i < length; i++) {
        child = children[i];
        // Write only the object is the predicate is the same as the previous
        if (child.predicate === predicate)
          contents += ', ' + this._encodeObject(child.object);
        // Otherwise, write the predicate and the object
        else {
          contents += (i ? ';\n  ' : '\n  ') +
                      this._encodePredicate(child.predicate) + ' ' +
                      this._encodeObject(child.object);
          predicate = child.predicate;
        }
      }
      return contents + '\n]';
    }
  },

  // ### `list` creates a list node with the given content
  list: function (elements) {
    var length = elements && elements.length || 0, contents = new Array(length);
    for (var i = 0; i < length; i++)
      contents[i] = this._encodeObject(elements[i]);
    return '(' + contents.join(' ') + ')';
  },

  // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes
  _prefixRegex: /$0^/,

  // ### `end` signals the end of the output stream
  end: function (done) {
    // Finish a possible pending triple
    if (this._subject !== null) {
      this._write(this._graph ? '\n}\n' : '.\n');
      this._subject = null;
    }
    // Disallow further writing
    this._write = this._blockedWrite;

    // Try to end the underlying stream, ensuring done is called exactly one time
    var singleDone = done && function (error, result) { singleDone = null, done(error, result); };
    if (this._endStream) {
      try { return this._outputStream.end(singleDone); }
      catch (error) { /* error closing stream */ }
    }
    singleDone && singleDone();
  },
};

// Replaces a character by its escaped version
function characterReplacer(character) {
  // Replace a single character by its escaped version
  var result = escapeReplacements[character];
  if (result === undefined) {
    // Replace a single character with its 4-bit unicode escape sequence
    if (character.length === 1) {
      result = character.charCodeAt(0).toString(16);
      result = '\\u0000'.substr(0, 6 - result.length) + result;
    }
    // Replace a surrogate pair with its 8-bit unicode escape sequence
    else {
      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +
                 character.charCodeAt(1) + 0x2400).toString(16);
      result = '\\U00000000'.substr(0, 10 - result.length) + result;
    }
  }
  return result;
}

// ## Exports

// Export the `N3Writer` class as a whole.
module.exports = N3Writer;


/***/ }),

/***/ "./node_modules/@rdfoo/rdf-parser-n3/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@rdfoo/rdf-parser-n3/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rdf = __webpack_require__(/*! rdf-ext */ "./node_modules/rdf-ext/rdf-ext.js")
var util = __webpack_require__(/*! util */ "util")
var AbstractParser = __webpack_require__(/*! rdf-parser-abstract */ "./node_modules/rdf-parser-abstract/index.js")
var N3 = __webpack_require__(/*! @rdfoo/n3 */ "./node_modules/@rdfoo/n3/N3.js")

function N3Parser (options) {
  AbstractParser.call(this, rdf)

  this.options = options || {}

  if (!('importPrefixMap' in this.options)) {
    this.options.importPrefixMap = true
  }
}

util.inherits(N3Parser, AbstractParser)

N3Parser.prototype.process = function (data, callback, base, filter, done) {
  var self = this

  return new Promise(function (resolve, reject) {
    filter = filter || function () { return true }

    var parser = N3.Parser({documentIRI: base})
    var blankNodes = {}

    parser.parse(data, function (error, n3Triple, n3Prefixes) {
      if (error) {
        if (done) {
          done(error)
        }

        return reject(error)
      }

      if (self.options.importPrefixMap && n3Prefixes) {
        for (var prefix in n3Prefixes) {
          self.rdf.prefixes[prefix] = n3Prefixes[prefix]
        }
      }

      if (!n3Triple) {
        if (done) {
          done()
        }

        return resolve()
      }

      var toRdfNode = function (n3Node) {
        if (N3.Util.isIRI(n3Node)) {
          return self.rdf.createNamedNode(n3Node)
        } else if (N3.Util.isBlank(n3Node)) {
          if (n3Node in blankNodes) {
            return blankNodes[n3Node]
          } else {
            return (blankNodes[n3Node] = self.rdf.createBlankNode())
          }
        } else {
          var lang = N3.Util.getLiteralLanguage(n3Node)
          var type = N3.Util.getLiteralType(n3Node)

          if (lang === '') {
            lang = null
          }

          if (type === 'http://www.w3.org/2001/XMLSchema#string') {
            type = null
          }

          return self.rdf.createLiteral(
            N3.Util.getLiteralValue(n3Node),
            lang,
            type ? self.rdf.createNamedNode(type) : null)
        }
      }

      var pushTriple = function (n3Triple) {
        var triple = self.rdf.createTriple(
          toRdfNode(n3Triple.subject),
          toRdfNode(n3Triple.predicate),
          toRdfNode(n3Triple.object))

        if (filter(triple)) {
          callback(triple)
        }
      }

      pushTriple(n3Triple)
    })
  })
}

// add singleton methods to class
var instance = new N3Parser()

for (var property in instance) {
  N3Parser[property] = instance[property]
}

module.exports = N3Parser


/***/ }),

/***/ "./node_modules/acorn-es7-plugin/acorn-es7-plugin.js":
/*!***********************************************************!*\
  !*** ./node_modules/acorn-es7-plugin/acorn-es7-plugin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function(acorn) {
    switch (parseInt(acorn.version)) {
    case 2:
    case 3:
        acorn.plugins.asyncawait = __webpack_require__(/*! ./acorn-v3 */ "./node_modules/acorn-es7-plugin/acorn-v3.js") ;
        break ;
    case 4:
        acorn.plugins.asyncawait = __webpack_require__(/*! ./acorn-v4 */ "./node_modules/acorn-es7-plugin/acorn-v4.js") ;
        break ;
    case 5:
        acorn.plugins.asyncawait = __webpack_require__(/*! ./acorn-v4 */ "./node_modules/acorn-es7-plugin/acorn-v4.js") ;
        break ;
    default:
        throw new Error("acorn-es7-plugin requires Acorn v2, 3, 4 or 5") ;
    }
    return acorn
}


/***/ }),

/***/ "./node_modules/acorn-es7-plugin/acorn-v3.js":
/*!***************************************************!*\
  !*** ./node_modules/acorn-es7-plugin/acorn-v3.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var NotAsync = {} ;
var asyncExit = /^async[\t ]+(return|throw)/ ;
var asyncFunction = /^async[\t ]+function/ ;
var atomOrPropertyOrLabel = /^\s*[():;]/ ;
var removeComments = /([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g ;
var matchAsyncGet = /\s*(get|set)\s*\(/ ;

function hasLineTerminatorBeforeNext(st, since) {
    return st.lineStart >= since;
}

function test(regex,st,noComment) {
    var src = st.input.slice(st.start) ;
    if (noComment) {
        src = src.replace(removeComments,"$1 $3") ;
  }
    return regex.test(src);
}

/* Create a new parser derived from the specified parser, so that in the
 * event of an error we can back out and try again */
function subParse(parser, pos, extensions,parens) {
    var p = new parser.constructor(parser.options, parser.input, pos);
    if (extensions)
        for (var k in extensions)
            p[k] = extensions[k] ;

    var src = parser ;
    var dest = p ;
    ['inFunction','inAsyncFunction','inAsync','inGenerator','inModule'].forEach(function(k){
        if (k in src)
            dest[k] = src[k] ;
    }) ;
    if (parens)
        p.options.preserveParens = true ;
    p.nextToken();
    return p;
}

//TODO: Implement option noAsyncGetters

function asyncAwaitPlugin (parser,options){
    var es7check = function(){} ;

    parser.extend("initialContext",function(base){
        return function(){
            if (this.options.ecmaVersion < 7) {
                es7check = function(node) {
                    parser.raise(node.start,"async/await keywords only available when ecmaVersion>=7") ;
                } ;
            }
            this.reservedWords = new RegExp(this.reservedWords.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.reservedWordsStrict = new RegExp(this.reservedWordsStrict.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.reservedWordsStrictBind = new RegExp(this.reservedWordsStrictBind.toString().replace(/await|async/g,"").replace("|/","/").replace("/|","/").replace("||","|")) ;
            this.inAsyncFunction = options.inAsyncFunction ;
            if (options.awaitAnywhere && options.inAsyncFunction)
                parser.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive") ;

            return base.apply(this,arguments);
        }
    }) ;

    parser.extend("shouldParseExportStatement",function(base){
        return function(){
            if (this.type.label==='name' && this.value==='async' && test(asyncFunction,this)) {
                return true ;
            }
            return base.apply(this,arguments) ;
        }
    }) ;

    parser.extend("parseStatement",function(base){
        return function (declaration, topLevel) {
            var start = this.start;
            var startLoc = this.startLoc;
            if (this.type.label==='name') {
                if (test(asyncFunction,this,true)) {
                    var wasAsync = this.inAsyncFunction ;
                    try {
                        this.inAsyncFunction = true ;
                        this.next() ;
                        var r = this.parseStatement(declaration, topLevel) ;
                        r.async = true ;
                        r.start = start;
                        r.loc && (r.loc.start = startLoc);
                        r.range && (r.range[0] = start);
                        return r ;
                    } finally {
                        this.inAsyncFunction = wasAsync ;
                    }
                } else if ((typeof options==="object" && options.asyncExits) && test(asyncExit,this)) {
                    // NON-STANDARD EXTENSION iff. options.asyncExits is set, the
                    // extensions 'async return <expr>?' and 'async throw <expr>?'
                    // are enabled. In each case they are the standard ESTree nodes
                    // with the flag 'async:true'
                    this.next() ;
                    var r = this.parseStatement(declaration, topLevel) ;
                    r.async = true ;
                    r.start = start;
                    r.loc && (r.loc.start = startLoc);
                    r.range && (r.range[0] = start);
                   return r ;
                }
            }
            return base.apply(this,arguments);
        }
    }) ;

  parser.extend("parseIdent",function(base){
        return function(liberal){
                var id = base.apply(this,arguments);
                if (this.inAsyncFunction && id.name==='await') {
                    if (arguments.length===0) {
                        this.raise(id.start,"'await' is reserved within async functions") ;
                    }
                }
                return id ;
        }
    }) ;

  parser.extend("parseExprAtom",function(base){
        return function(refShorthandDefaultPos){
            var start = this.start ;
            var startLoc = this.startLoc;
            var rhs,r = base.apply(this,arguments);
            if (r.type==='Identifier') {
                if (r.name==='async' && !hasLineTerminatorBeforeNext(this, r.end)) {
                    // Is this really an async function?
                    var isAsync = this.inAsyncFunction ;
                    try {
                        this.inAsyncFunction = true ;
                        var pp = this ;
                        var inBody = false ;

                        var parseHooks = {
                            parseFunctionBody:function(node,isArrowFunction){
                                try {
                                    var wasInBody = inBody ;
                                    inBody = true ;
                                    return pp.parseFunctionBody.apply(this,arguments) ;
                                } finally {
                                    inBody = wasInBody ;
                                }
                            },
                            raise:function(){
                                try {
                                    return pp.raise.apply(this,arguments) ;
                                } catch(ex) {
                                    throw inBody?ex:NotAsync ;
                                }
                            }
                        } ;

                        rhs = subParse(this,this.start,parseHooks,true).parseExpression() ;
                        if (rhs.type==='SequenceExpression')
                            rhs = rhs.expressions[0] ;
                        if (rhs.type === 'CallExpression')
                            rhs = rhs.callee ;
                        if (rhs.type==='FunctionExpression' || rhs.type==='FunctionDeclaration' || rhs.type==='ArrowFunctionExpression') {
                            // Because we don't know if the top level parser supprts preserveParens, we have to re-parse
                            // without it set
                            rhs = subParse(this,this.start,parseHooks).parseExpression() ;
                            if (rhs.type==='SequenceExpression')
                                rhs = rhs.expressions[0] ;
                            if (rhs.type === 'CallExpression')
                                rhs = rhs.callee ;
                            
                            rhs.async = true ;
                            rhs.start = start;
                            rhs.loc && (rhs.loc.start = startLoc);
                            rhs.range && (rhs.range[0] = start);
                            this.pos = rhs.end;
                            this.end = rhs.end ;
                            this.endLoc = rhs.endLoc ;
                            this.next();
                            es7check(rhs) ;
                            return rhs ;
                        }
                    } catch (ex) {
                        if (ex!==NotAsync)
                            throw ex ;
                    }
                    finally {
                        this.inAsyncFunction = isAsync ;
                    }
                }
                else if (r.name==='await') {
                    var n = this.startNodeAt(r.start, r.loc && r.loc.start);
                    if (this.inAsyncFunction) {
                        rhs = this.parseExprSubscripts() ;
                        n.operator = 'await' ;
                        n.argument = rhs ;
                        n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                        es7check(n) ;
                        return n ;
                    }
                    // NON-STANDARD EXTENSION iff. options.awaitAnywhere is true,
                    // an 'AwaitExpression' is allowed anywhere the token 'await'
                    // could not be an identifier with the name 'await'.

                    // Look-ahead to see if this is really a property or label called async or await
                    if (this.input.slice(r.end).match(atomOrPropertyOrLabel)) {
                        if (!options.awaitAnywhere && this.options.sourceType === 'module')
                            return this.raise(r.start,"'await' is reserved within modules") ;
                        return r ; // This is a valid property name or label
                    }

                    if (typeof options==="object" && options.awaitAnywhere) {
                        start = this.start ;
                        rhs = subParse(this,start-4).parseExprSubscripts() ;
                        if (rhs.end<=start) {
                            rhs = subParse(this,start).parseExprSubscripts() ;
                            n.operator = 'await' ;
                            n.argument = rhs ;
                            n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                            this.pos = rhs.end;
                            this.end = rhs.end ;
                            this.endLoc = rhs.endLoc ;
                            this.next();
                            es7check(n) ;
                            return n ;
                        }
                    }

                    if (!options.awaitAnywhere && this.options.sourceType === 'module')
                        return this.raise(r.start,"'await' is reserved within modules") ;
                }
            }
            return r ;
        }
    }) ;

    parser.extend('finishNodeAt',function(base){
            return function(node,type,pos,loc) {
                if (node.__asyncValue) {
                    delete node.__asyncValue ;
                    node.value.async = true ;
                }
                return base.apply(this,arguments) ;
            }
    }) ;

    parser.extend('finishNode',function(base){
            return function(node,type) {
                if (node.__asyncValue) {
                    delete node.__asyncValue ;
                    node.value.async = true ;
                }
                return base.apply(this,arguments) ;
            }
    }) ;

    var allowedPropSpecifiers = {
        get:true,
        set:true,
        async:true
    };
    
    parser.extend("parsePropertyName",function(base){
        return function (prop) {
            var prevName = prop.key && prop.key.name ;
            var key = base.apply(this,arguments) ;
            if (key.type === "Identifier" && (key.name === "async") && !hasLineTerminatorBeforeNext(this, key.end)) {
                // Look-ahead to see if this is really a property or label called async or await
                if (!this.input.slice(key.end).match(atomOrPropertyOrLabel)){
                    // Cheese - eliminate the cases 'async get(){}' and async set(){}'
                    if (matchAsyncGet.test(this.input.slice(key.end))) {
                        key = base.apply(this,arguments) ;
                        prop.__asyncValue = true ;
                    } else {
                        es7check(prop) ;
                        if (prop.kind === 'set') 
                            this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                        
                        key = base.apply(this,arguments) ;
                        if (key.type==='Identifier') {
                            if (key.name==='set')
                                this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                        }
                        prop.__asyncValue = true ;
                    }
                }
            }
            return key;
        };
    }) ;

    parser.extend("parseClassMethod",function(base){
        return function (classBody, method, isGenerator) {
            var wasAsync ;
            if (method.__asyncValue) {
                if (method.kind==='constructor')
                    this.raise(method.start,"class constructor() cannot be be async") ;
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            }
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            return r ;
        }
    }) ;

    parser.extend("parseMethod",function(base){
        return function (isGenerator) {
            var wasAsync ;
            if (this.__currentProperty && this.__currentProperty.__asyncValue) {
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            }
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            return r ;
        }
    }) ;

    parser.extend("parsePropertyValue",function(base){
        return function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
            var prevProp = this.__currentProperty ; 
            this.__currentProperty = prop ;
            var wasAsync ;
            if (prop.__asyncValue) {
                wasAsync = this.inAsyncFunction ;
                this.inAsyncFunction = true ;
            }
            var r = base.apply(this,arguments) ;
            this.inAsyncFunction = wasAsync ;
            this.__currentProperty = prevProp ;
            return r ;
        }
    }) ;
}

module.exports = asyncAwaitPlugin ;


/***/ }),

/***/ "./node_modules/acorn-es7-plugin/acorn-v4.js":
/*!***************************************************!*\
  !*** ./node_modules/acorn-es7-plugin/acorn-v4.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var asyncExit = /^async[\t ]+(return|throw)/ ;
var atomOrPropertyOrLabel = /^\s*[):;]/ ;
var removeComments = /([^\n])\/\*(\*(?!\/)|[^\n*])*\*\/([^\n])/g ;

function hasLineTerminatorBeforeNext(st, since) {
    return st.lineStart >= since;
}

function test(regex,st,noComment) {
    var src = st.input.slice(st.start) ;
    if (noComment) {
        src = src.replace(removeComments,"$1 $3") ;
    }
    return regex.test(src);
}

/* Create a new parser derived from the specified parser, so that in the
 * event of an error we can back out and try again */
function subParse(parser, pos, extensions) {
    var p = new parser.constructor(parser.options, parser.input, pos);
    if (extensions)
        for (var k in extensions)
            p[k] = extensions[k] ;

    var src = parser ;
    var dest = p ;
    ['inFunction','inAsync','inGenerator','inModule'].forEach(function(k){
        if (k in src)
            dest[k] = src[k] ;
    }) ;
    p.nextToken();
    return p;
}

function asyncAwaitPlugin (parser,options){
    if (!options || typeof options !== "object")
        options = {} ;

    parser.extend("parse",function(base){
        return function(){
            this.inAsync = options.inAsyncFunction ;
            if (options.awaitAnywhere && options.inAsyncFunction)
                parser.raise(node.start,"The options awaitAnywhere and inAsyncFunction are mutually exclusive") ;

            return base.apply(this,arguments);
        }
    }) ;

    parser.extend("parseStatement",function(base){
        return function (declaration, topLevel) {
            var start = this.start;
            var startLoc = this.startLoc;
            if (this.type.label==='name') {
                if ((options.asyncExits) && test(asyncExit,this)) {
                    // TODO: Ensure this function is itself nested in an async function or Method
                    this.next() ;

                    var r = this.parseStatement(declaration, topLevel) ;
                    r.async = true ;
                    r.start = start;
                    r.loc && (r.loc.start = startLoc);
                    r.range && (r.range[0] = start);
                    return r ;
                }
            }
            return base.apply(this,arguments);
        }
    }) ;

    parser.extend("parseIdent",function(base){
        return function(liberal) {
            if (this.options.sourceType==='module' && this.options.ecmaVersion >= 8 && options.awaitAnywhere)
                return base.call(this,true) ; // Force liberal mode if awaitAnywhere is set
            return base.apply(this,arguments) ;
        }
    }) ;

    parser.extend("parseExprAtom",function(base){
        var NotAsync = {};
        return function(refShorthandDefaultPos){
            var start = this.start ;
            var startLoc = this.startLoc;

            var rhs,r = base.apply(this,arguments);

            if (r.type==='Identifier') {
                if (r.name==='await' && !this.inAsync) {
                    if (options.awaitAnywhere) {
                        var n = this.startNodeAt(r.start, r.loc && r.loc.start);

                        start = this.start ;

                        var parseHooks = {
                            raise:function(){
                                try {
                                    return pp.raise.apply(this,arguments) ;
                                } catch(ex) {
                                    throw /*inBody?ex:*/NotAsync ;
                                }
                            }
                        } ;

                        try {
                            rhs = subParse(this,start-4,parseHooks).parseExprSubscripts() ;
                            if (rhs.end<=start) {
                                rhs = subParse(this,start,parseHooks).parseExprSubscripts() ;
                                n.argument = rhs ;
                                n = this.finishNodeAt(n,'AwaitExpression', rhs.end, rhs.loc && rhs.loc.end) ;
                                this.pos = rhs.end;
                                this.end = rhs.end ;
                                this.endLoc = rhs.endLoc ;
                                this.next();
                                return n ;
                            }
                        } catch (ex) {
                            if (ex===NotAsync)
                                return r ;
                            throw ex ;
                        }
                    }
                }
            }
            return r ;
        }
    }) ;

    var allowedPropValues = {
        undefined:true,
        get:true,
        set:true,
        static:true,
        async:true,
        constructor:true
    };
    parser.extend("parsePropertyName",function(base){
        return function (prop) {
            var prevName = prop.key && prop.key.name ;
            var key = base.apply(this,arguments) ;
            if (this.value==='get') {
                prop.__maybeStaticAsyncGetter = true ;
            }
            var next ;
            if (allowedPropValues[this.value])
                return key ;

            if (key.type === "Identifier" && (key.name === "async" || prevName === "async") && !hasLineTerminatorBeforeNext(this, key.end) 
                // Look-ahead to see if this is really a property or label called async or await
                && !this.input.slice(key.end).match(atomOrPropertyOrLabel)) {
                if (prop.kind === 'set' || key.name === 'set') 
                    this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                else {
                    this.__isAsyncProp = true ;
                    key = base.apply(this,arguments) ;
                    if (key.type==='Identifier') {
                        if (key.name==='set')
                            this.raise(key.start,"'set <member>(value)' cannot be be async") ;
                    }
                }
            } else {
                delete prop.__maybeStaticAsyncGetter ;
            }
            return key;
        };
    }) ;

    parser.extend("parseClassMethod",function(base){
        return function (classBody, method, isGenerator) {
            var r = base.apply(this,arguments) ;
            if (method.__maybeStaticAsyncGetter) {
                delete method.__maybeStaticAsyncGetter ;
                if (method.key.name!=='get')
                    method.kind = "get" ;
            }
            return r ;
        }
    }) ;


    parser.extend("parseFunctionBody",function(base){
        return function (node, isArrowFunction) {
            var wasAsync = this.inAsync ;
            if (this.__isAsyncProp) {
                node.async = true ;
                this.inAsync = true ;
                delete this.__isAsyncProp ;
            }
            var r = base.apply(this,arguments) ;
            this.inAsync = wasAsync ;
            return r ;
        }
    }) ;
}

module.exports = asyncAwaitPlugin ;


/***/ }),

/***/ "./node_modules/acorn/dist/acorn.es.js":
/*!*********************************************!*\
  !*** ./node_modules/acorn/dist/acorn.es.js ***!
  \*********************************************/
/*! exports provided: version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, tokTypes, keywordTypes, TokContext, tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse_dammit", function() { return parse_dammit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LooseParser", function() { return LooseParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pluginsLoose", function() { return pluginsLoose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLooseExports", function() { return addLooseExports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Registered plugins
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Load plugins
  this.loadPlugins(options.plugins);

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false;
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterFunctionScope();

  // For RegExp validation
  this.regexpState = null;
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser.prototype.extend = function extend (name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];
    if (!plugin) { throw new Error("Plugin '" + name + "' not found") }
    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"};
var switchLabel = {kind: "switch"};

pp$1.isLet = function() {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false)
  case types._class:
    if (!declaration) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (!declaration && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock()
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (!declaration) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
        !(kind !== "var" && init$1.declarations[0].init)) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict && this.type === types._function);
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;
      if (cur) { this$1.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(types.colon);
    } else {
      if (!cur) { this$1.unexpected(); }
      cur.consequent.push(this$1.parseStatement(true));
    }
  }
  this.exitLexicalScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      this.enterLexicalScope();
      this.checkLVal(clause.param, "let");
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterLexicalScope();
    }
    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(true);
  if (node.body.type === "ClassDeclaration" ||
      node.body.type === "VariableDeclaration" && node.body.kind !== "var" ||
      node.body.type === "FunctionDeclaration" && (this.strict || node.body.generator || node.body.async))
    { this.raiseRecoverable(node.body.start, "Invalid labeled declaration"); }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  if (type === "ForInStatement") {
    if (init.type === "AssignmentPattern" ||
      (init.type === "VariableDeclaration" && init.declarations[0].init != null &&
       (this.strict || init.declarations[0].id.type !== "Identifier")))
      { this.raise(init.start, "Invalid assignment in for-in loop head"); }
  }
  node.left = init;
  node.right = type === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);
    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
      this$1.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
    if (!this$1.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)
    { node.generator = this.eat(types.star); }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (isStatement) {
    node.id = isStatement === "nullableID" && this.type !== types.name ? null : this.parseIdent();
    if (node.id) {
      this.checkLVal(node.id, this.inModule && !this.inFunction ? "let" : "var");
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement)
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var member = this$1.parseClassMember(classBody);
    if (member && member.type === "MethodDefinition" && member.kind === "constructor") {
      if (hadConstructor) { this$1.raise(member.start, "Duplicate constructor in the same class"); }
      hadConstructor = true;
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassMember = function(classBody) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(classBody, method, isGenerator, isAsync);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];

        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this$1.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this$1.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, "let");
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, "let");
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this$1.checkLVal(node$2.local, "let");
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this$1.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this$1.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this$1.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this$1.expect(types.comma); }
    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType && bindingType !== "none") {
      if (
        bindingType === "var" && !this.canDeclareVarName(expr.name) ||
        bindingType !== "var" && !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"));
      }
      if (bindingType === "var") {
        this.declareVarName(expr.name);
      } else {
        this.declareLexicalName(expr.name);
      }
    }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this$1.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) { return this.parseYield() }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  for (var computed = (void 0);;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) { this$1.expect(types.bracketR); }
      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({isTagged: true});
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.inFunction)
      { this.raise(this.start, "'super' outside of function or class"); }
    node = this.startNode();
    this.next();
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(this.type !== types.name);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, false)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
        if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inFunction)
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  var this$1 = this;
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this$1.type === types.eof) { this$1.raise(this$1.pos, "Unterminated template literal"); }
    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict && node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none");
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this$1.type === types.comma)
      { elt = null; }
    else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this$1.start; }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
  if (this.isKeyword(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved === "never") { liberal = false; }
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) { this.checkUnreserved(node); }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function() {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

// Object.assign polyfill
var assign = Object.assign || function(target) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  for (var i = 0, list = sources; i < list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterFunctionScope = function() {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
};

pp$5.exitFunctionScope = function() {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function() {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function() {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};

/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */
pp$5.canDeclareVarName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)
};

/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */
pp$5.canDeclareLexicalName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)
};

pp$5.declareVarName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

var data = {
  "$LONE": [
    "ASCII",
    "ASCII_Hex_Digit",
    "AHex",
    "Alphabetic",
    "Alpha",
    "Any",
    "Assigned",
    "Bidi_Control",
    "Bidi_C",
    "Bidi_Mirrored",
    "Bidi_M",
    "Case_Ignorable",
    "CI",
    "Cased",
    "Changes_When_Casefolded",
    "CWCF",
    "Changes_When_Casemapped",
    "CWCM",
    "Changes_When_Lowercased",
    "CWL",
    "Changes_When_NFKC_Casefolded",
    "CWKCF",
    "Changes_When_Titlecased",
    "CWT",
    "Changes_When_Uppercased",
    "CWU",
    "Dash",
    "Default_Ignorable_Code_Point",
    "DI",
    "Deprecated",
    "Dep",
    "Diacritic",
    "Dia",
    "Emoji",
    "Emoji_Component",
    "Emoji_Modifier",
    "Emoji_Modifier_Base",
    "Emoji_Presentation",
    "Extender",
    "Ext",
    "Grapheme_Base",
    "Gr_Base",
    "Grapheme_Extend",
    "Gr_Ext",
    "Hex_Digit",
    "Hex",
    "IDS_Binary_Operator",
    "IDSB",
    "IDS_Trinary_Operator",
    "IDST",
    "ID_Continue",
    "IDC",
    "ID_Start",
    "IDS",
    "Ideographic",
    "Ideo",
    "Join_Control",
    "Join_C",
    "Logical_Order_Exception",
    "LOE",
    "Lowercase",
    "Lower",
    "Math",
    "Noncharacter_Code_Point",
    "NChar",
    "Pattern_Syntax",
    "Pat_Syn",
    "Pattern_White_Space",
    "Pat_WS",
    "Quotation_Mark",
    "QMark",
    "Radical",
    "Regional_Indicator",
    "RI",
    "Sentence_Terminal",
    "STerm",
    "Soft_Dotted",
    "SD",
    "Terminal_Punctuation",
    "Term",
    "Unified_Ideograph",
    "UIdeo",
    "Uppercase",
    "Upper",
    "Variation_Selector",
    "VS",
    "White_Space",
    "space",
    "XID_Continue",
    "XIDC",
    "XID_Start",
    "XIDS"
  ],
  "General_Category": [
    "Cased_Letter",
    "LC",
    "Close_Punctuation",
    "Pe",
    "Connector_Punctuation",
    "Pc",
    "Control",
    "Cc",
    "cntrl",
    "Currency_Symbol",
    "Sc",
    "Dash_Punctuation",
    "Pd",
    "Decimal_Number",
    "Nd",
    "digit",
    "Enclosing_Mark",
    "Me",
    "Final_Punctuation",
    "Pf",
    "Format",
    "Cf",
    "Initial_Punctuation",
    "Pi",
    "Letter",
    "L",
    "Letter_Number",
    "Nl",
    "Line_Separator",
    "Zl",
    "Lowercase_Letter",
    "Ll",
    "Mark",
    "M",
    "Combining_Mark",
    "Math_Symbol",
    "Sm",
    "Modifier_Letter",
    "Lm",
    "Modifier_Symbol",
    "Sk",
    "Nonspacing_Mark",
    "Mn",
    "Number",
    "N",
    "Open_Punctuation",
    "Ps",
    "Other",
    "C",
    "Other_Letter",
    "Lo",
    "Other_Number",
    "No",
    "Other_Punctuation",
    "Po",
    "Other_Symbol",
    "So",
    "Paragraph_Separator",
    "Zp",
    "Private_Use",
    "Co",
    "Punctuation",
    "P",
    "punct",
    "Separator",
    "Z",
    "Space_Separator",
    "Zs",
    "Spacing_Mark",
    "Mc",
    "Surrogate",
    "Cs",
    "Symbol",
    "S",
    "Titlecase_Letter",
    "Lt",
    "Unassigned",
    "Cn",
    "Uppercase_Letter",
    "Lu"
  ],
  "Script": [
    "Adlam",
    "Adlm",
    "Ahom",
    "Anatolian_Hieroglyphs",
    "Hluw",
    "Arabic",
    "Arab",
    "Armenian",
    "Armn",
    "Avestan",
    "Avst",
    "Balinese",
    "Bali",
    "Bamum",
    "Bamu",
    "Bassa_Vah",
    "Bass",
    "Batak",
    "Batk",
    "Bengali",
    "Beng",
    "Bhaiksuki",
    "Bhks",
    "Bopomofo",
    "Bopo",
    "Brahmi",
    "Brah",
    "Braille",
    "Brai",
    "Buginese",
    "Bugi",
    "Buhid",
    "Buhd",
    "Canadian_Aboriginal",
    "Cans",
    "Carian",
    "Cari",
    "Caucasian_Albanian",
    "Aghb",
    "Chakma",
    "Cakm",
    "Cham",
    "Cherokee",
    "Cher",
    "Common",
    "Zyyy",
    "Coptic",
    "Copt",
    "Qaac",
    "Cuneiform",
    "Xsux",
    "Cypriot",
    "Cprt",
    "Cyrillic",
    "Cyrl",
    "Deseret",
    "Dsrt",
    "Devanagari",
    "Deva",
    "Duployan",
    "Dupl",
    "Egyptian_Hieroglyphs",
    "Egyp",
    "Elbasan",
    "Elba",
    "Ethiopic",
    "Ethi",
    "Georgian",
    "Geor",
    "Glagolitic",
    "Glag",
    "Gothic",
    "Goth",
    "Grantha",
    "Gran",
    "Greek",
    "Grek",
    "Gujarati",
    "Gujr",
    "Gurmukhi",
    "Guru",
    "Han",
    "Hani",
    "Hangul",
    "Hang",
    "Hanunoo",
    "Hano",
    "Hatran",
    "Hatr",
    "Hebrew",
    "Hebr",
    "Hiragana",
    "Hira",
    "Imperial_Aramaic",
    "Armi",
    "Inherited",
    "Zinh",
    "Qaai",
    "Inscriptional_Pahlavi",
    "Phli",
    "Inscriptional_Parthian",
    "Prti",
    "Javanese",
    "Java",
    "Kaithi",
    "Kthi",
    "Kannada",
    "Knda",
    "Katakana",
    "Kana",
    "Kayah_Li",
    "Kali",
    "Kharoshthi",
    "Khar",
    "Khmer",
    "Khmr",
    "Khojki",
    "Khoj",
    "Khudawadi",
    "Sind",
    "Lao",
    "Laoo",
    "Latin",
    "Latn",
    "Lepcha",
    "Lepc",
    "Limbu",
    "Limb",
    "Linear_A",
    "Lina",
    "Linear_B",
    "Linb",
    "Lisu",
    "Lycian",
    "Lyci",
    "Lydian",
    "Lydi",
    "Mahajani",
    "Mahj",
    "Malayalam",
    "Mlym",
    "Mandaic",
    "Mand",
    "Manichaean",
    "Mani",
    "Marchen",
    "Marc",
    "Masaram_Gondi",
    "Gonm",
    "Meetei_Mayek",
    "Mtei",
    "Mende_Kikakui",
    "Mend",
    "Meroitic_Cursive",
    "Merc",
    "Meroitic_Hieroglyphs",
    "Mero",
    "Miao",
    "Plrd",
    "Modi",
    "Mongolian",
    "Mong",
    "Mro",
    "Mroo",
    "Multani",
    "Mult",
    "Myanmar",
    "Mymr",
    "Nabataean",
    "Nbat",
    "New_Tai_Lue",
    "Talu",
    "Newa",
    "Nko",
    "Nkoo",
    "Nushu",
    "Nshu",
    "Ogham",
    "Ogam",
    "Ol_Chiki",
    "Olck",
    "Old_Hungarian",
    "Hung",
    "Old_Italic",
    "Ital",
    "Old_North_Arabian",
    "Narb",
    "Old_Permic",
    "Perm",
    "Old_Persian",
    "Xpeo",
    "Old_South_Arabian",
    "Sarb",
    "Old_Turkic",
    "Orkh",
    "Oriya",
    "Orya",
    "Osage",
    "Osge",
    "Osmanya",
    "Osma",
    "Pahawh_Hmong",
    "Hmng",
    "Palmyrene",
    "Palm",
    "Pau_Cin_Hau",
    "Pauc",
    "Phags_Pa",
    "Phag",
    "Phoenician",
    "Phnx",
    "Psalter_Pahlavi",
    "Phlp",
    "Rejang",
    "Rjng",
    "Runic",
    "Runr",
    "Samaritan",
    "Samr",
    "Saurashtra",
    "Saur",
    "Sharada",
    "Shrd",
    "Shavian",
    "Shaw",
    "Siddham",
    "Sidd",
    "SignWriting",
    "Sgnw",
    "Sinhala",
    "Sinh",
    "Sora_Sompeng",
    "Sora",
    "Soyombo",
    "Soyo",
    "Sundanese",
    "Sund",
    "Syloti_Nagri",
    "Sylo",
    "Syriac",
    "Syrc",
    "Tagalog",
    "Tglg",
    "Tagbanwa",
    "Tagb",
    "Tai_Le",
    "Tale",
    "Tai_Tham",
    "Lana",
    "Tai_Viet",
    "Tavt",
    "Takri",
    "Takr",
    "Tamil",
    "Taml",
    "Tangut",
    "Tang",
    "Telugu",
    "Telu",
    "Thaana",
    "Thaa",
    "Thai",
    "Tibetan",
    "Tibt",
    "Tifinagh",
    "Tfng",
    "Tirhuta",
    "Tirh",
    "Ugaritic",
    "Ugar",
    "Vai",
    "Vaii",
    "Warang_Citi",
    "Wara",
    "Yi",
    "Yiii",
    "Zanabazar_Square",
    "Zanb"
  ]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;

var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString$1(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpFlags = function(state) {
  var this$1 = this;

  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this$1.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$9.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$9.regexp_disjunction = function(state) {
  var this$1 = this;

  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this$1.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$9.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    {  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$9.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$9.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$9.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$9.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$9.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$9.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$9.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$9.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$9.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$9.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$9.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$9.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$9.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$9.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$9.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$9.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$9.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$9.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$9.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$9.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$9.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$9.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$9.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise("Invalid property name");
  }
};
pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise("Invalid property name");
  }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$9.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$9.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$9.regexp_classRanges = function(state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$9.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$9.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$9.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$9.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$9.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$9.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$8 = Parser.prototype;

// Move to the next token

pp$8.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$8[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$8.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$8.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$8.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$8.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$8.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$8.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$8.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this$1.pos;
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos;
      }
    case 10: case 8232: case 8233:
      ++this$1.pos;
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      break
    case 47: // '/'
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // '*'
        this$1.skipBlockComment();
        break
      case 47:
        this$1.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$8.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$8.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$8.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$8.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$8.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$8.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$8.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$8.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$8.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this$1.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$8.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$8.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$8.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$8.readString = function(quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, "Unterminated string constant"); }
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function() {
  var this$1 = this;

  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$8.readInvalidTemplateToken = function() {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
    case "\\":
      ++this$1.pos;
      break

    case "$":
      if (this$1.input[this$1.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$8.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$8.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$8.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // "u"
        { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$8.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

var version = "5.7.3";

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return new Parser(options, input).parse()
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression()
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new Parser(options, input)
}

// This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.
var parse_dammit;
var LooseParser;
var pluginsLoose; // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  parse_dammit = parse; // eslint-disable-line camelcase
  LooseParser = Parser$$1;
  pluginsLoose = plugins$$1;
}




/***/ }),

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/color-convert/index.js");
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/array-filter/index.js":
/*!********************************************!*\
  !*** ./node_modules/array-filter/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ "./node_modules/bioterms/dist/Predicates.js":
/*!**************************************************!*\
  !*** ./node_modules/bioterms/dist/Predicates.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/bioterms/dist/Prefixes.js");
var Predicates;
(function (Predicates) {
    Predicates.a = Prefixes_1.Prefixes.rdf + 'type';
    let SBOL1;
    (function (SBOL1) {
        SBOL1.nucleotides = Prefixes_1.Prefixes.sbol1 + 'nucleotides';
        SBOL1.subComponent = Prefixes_1.Prefixes.sbol1 + 'subComponent';
        SBOL1.dnaSequence = Prefixes_1.Prefixes.sbol1 + 'dnaSequence';
        SBOL1.bioStart = Prefixes_1.Prefixes.sbol1 + 'bioStart';
        SBOL1.bioEnd = Prefixes_1.Prefixes.sbol1 + 'bioEnd';
        SBOL1.displayId = Prefixes_1.Prefixes.sbol1 + 'displayId';
        SBOL1.name = Prefixes_1.Prefixes.sbol1 + 'name';
        SBOL1.description = Prefixes_1.Prefixes.sbol1 + 'description';
        SBOL1.annotation = Prefixes_1.Prefixes.sbol1 + 'annotation';
        SBOL1.strand = Prefixes_1.Prefixes.sbol1 + 'strand';
        SBOL1.component = Prefixes_1.Prefixes.sbol1 + 'component';
        SBOL1.precedes = Prefixes_1.Prefixes.sbol1 + 'precedes';
    })(SBOL1 = Predicates.SBOL1 || (Predicates.SBOL1 = {}));
    let SBOL2;
    (function (SBOL2) {
        SBOL2.component = Prefixes_1.Prefixes.sbol2 + 'component';
        SBOL2.module = Prefixes_1.Prefixes.sbol2 + 'module';
        SBOL2.definition = Prefixes_1.Prefixes.sbol2 + 'definition';
        SBOL2.functionalComponent = Prefixes_1.Prefixes.sbol2 + 'functionalComponent';
        SBOL2.role = Prefixes_1.Prefixes.sbol2 + 'role';
        SBOL2.location = Prefixes_1.Prefixes.sbol2 + 'location';
        SBOL2.start = Prefixes_1.Prefixes.sbol2 + 'start';
        SBOL2.end = Prefixes_1.Prefixes.sbol2 + 'end';
        SBOL2.at = Prefixes_1.Prefixes.sbol2 + 'at';
        SBOL2.sequenceAnnotation = Prefixes_1.Prefixes.sbol2 + 'sequenceAnnotation';
        SBOL2.sequenceConstraint = Prefixes_1.Prefixes.sbol2 + 'sequenceConstraint';
        SBOL2.orientation = Prefixes_1.Prefixes.sbol2 + 'orientation';
        SBOL2.displayId = Prefixes_1.Prefixes.sbol2 + 'displayId';
        SBOL2.version = Prefixes_1.Prefixes.sbol2 + 'version';
        SBOL2.access = Prefixes_1.Prefixes.sbol2 + 'access';
        SBOL2.mapsTo = Prefixes_1.Prefixes.sbol2 + 'mapsTo';
        SBOL2.local = Prefixes_1.Prefixes.sbol2 + 'local';
        SBOL2.remote = Prefixes_1.Prefixes.sbol2 + 'remote';
        SBOL2.refinement = Prefixes_1.Prefixes.sbol2 + 'refinement';
        SBOL2.interaction = Prefixes_1.Prefixes.sbol2 + 'interaction';
        SBOL2.participation = Prefixes_1.Prefixes.sbol2 + 'participation';
        SBOL2.participant = Prefixes_1.Prefixes.sbol2 + 'participant';
        SBOL2.type = Prefixes_1.Prefixes.sbol2 + 'type';
        SBOL2.sequence = Prefixes_1.Prefixes.sbol2 + 'sequence';
        SBOL2.encoding = Prefixes_1.Prefixes.sbol2 + 'encoding';
        SBOL2.elements = Prefixes_1.Prefixes.sbol2 + 'elements';
        SBOL2.persistentIdentity = Prefixes_1.Prefixes.sbol2 + 'persistentIdentity';
        SBOL2.restriction = Prefixes_1.Prefixes.sbol2 + 'restriction';
        SBOL2.subject = Prefixes_1.Prefixes.sbol2 + 'subject';
        SBOL2.object = Prefixes_1.Prefixes.sbol2 + 'object';
        SBOL2.member = Prefixes_1.Prefixes.sbol2 + 'member';
        SBOL2.model = Prefixes_1.Prefixes.sbol2 + 'model';
        SBOL2.framework = Prefixes_1.Prefixes.sbol2 + 'framework';
        SBOL2.language = Prefixes_1.Prefixes.sbol2 + 'language';
        SBOL2.source = Prefixes_1.Prefixes.sbol2 + 'source';
        SBOL2.attachment = Prefixes_1.Prefixes.sbol2 + 'attachment';
        SBOL2.format = Prefixes_1.Prefixes.sbol2 + 'format';
        SBOL2.size = Prefixes_1.Prefixes.sbol2 + 'size';
        SBOL2.hash = Prefixes_1.Prefixes.sbol2 + 'hash';
        SBOL2.built = Prefixes_1.Prefixes.sbol2 + 'built';
        SBOL2.experimentalData = Prefixes_1.Prefixes.sbol2 + 'experimentalData';
        SBOL2.sourceLocation = Prefixes_1.Prefixes.sbol2 + 'sourceLocation';
        SBOL2.measure = Prefixes_1.Prefixes.sbol2 + 'measure';
    })(SBOL2 = Predicates.SBOL2 || (Predicates.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        SBOLX.subComponent = Prefixes_1.Prefixes.sbolx + 'subComponent';
        SBOLX.instanceOf = Prefixes_1.Prefixes.sbolx + 'instanceOf';
        SBOLX.role = Prefixes_1.Prefixes.sbolx + 'role';
        SBOLX.location = Prefixes_1.Prefixes.sbolx + 'location';
        SBOLX.start = Prefixes_1.Prefixes.sbolx + 'start';
        SBOLX.end = Prefixes_1.Prefixes.sbolx + 'end';
        SBOLX.at = Prefixes_1.Prefixes.sbolx + 'at';
        SBOLX.sequenceAnnotation = Prefixes_1.Prefixes.sbolx + 'sequenceAnnotation';
        SBOLX.sequenceConstraint = Prefixes_1.Prefixes.sbolx + 'sequenceConstraint';
        SBOLX.orientation = Prefixes_1.Prefixes.sbolx + 'orientation';
        SBOLX.id = Prefixes_1.Prefixes.sbolx + 'id';
        SBOLX.version = Prefixes_1.Prefixes.sbolx + 'version';
        SBOLX.access = Prefixes_1.Prefixes.sbolx + 'access';
        SBOLX.mapsTo = Prefixes_1.Prefixes.sbolx + 'mapsTo';
        SBOLX.local = Prefixes_1.Prefixes.sbolx + 'local';
        SBOLX.remote = Prefixes_1.Prefixes.sbolx + 'remote';
        SBOLX.refinement = Prefixes_1.Prefixes.sbolx + 'refinement';
        SBOLX.interaction = Prefixes_1.Prefixes.sbolx + 'interaction';
        SBOLX.participation = Prefixes_1.Prefixes.sbolx + 'participation';
        SBOLX.participant = Prefixes_1.Prefixes.sbolx + 'participant';
        SBOLX.type = Prefixes_1.Prefixes.sbolx + 'type';
        SBOLX.sequence = Prefixes_1.Prefixes.sbolx + 'sequence';
        SBOLX.encoding = Prefixes_1.Prefixes.sbolx + 'encoding';
        SBOLX.elements = Prefixes_1.Prefixes.sbolx + 'elements';
        SBOLX.persistentIdentity = Prefixes_1.Prefixes.sbolx + 'persistentIdentity';
        SBOLX.restriction = Prefixes_1.Prefixes.sbolx + 'restriction';
        SBOLX.subject = Prefixes_1.Prefixes.sbolx + 'subject';
        SBOLX.object = Prefixes_1.Prefixes.sbolx + 'object';
        SBOLX.member = Prefixes_1.Prefixes.sbolx + 'member';
        SBOLX.model = Prefixes_1.Prefixes.sbolx + 'model';
        SBOLX.framework = Prefixes_1.Prefixes.sbolx + 'framework';
        SBOLX.language = Prefixes_1.Prefixes.sbolx + 'language';
        SBOLX.source = Prefixes_1.Prefixes.sbolx + 'source';
        SBOLX.attachment = Prefixes_1.Prefixes.sbolx + 'attachment';
        SBOLX.format = Prefixes_1.Prefixes.sbolx + 'format';
        SBOLX.size = Prefixes_1.Prefixes.sbolx + 'size';
        SBOLX.hash = Prefixes_1.Prefixes.sbolx + 'hash';
        SBOLX.built = Prefixes_1.Prefixes.sbolx + 'built';
        SBOLX.experimentalData = Prefixes_1.Prefixes.sbolx + 'experimentalData';
        SBOLX.sourceLocation = Prefixes_1.Prefixes.sbolx + 'sourceLocation';
        SBOLX.measure = Prefixes_1.Prefixes.sbolx + 'measure';
    })(SBOLX = Predicates.SBOLX || (Predicates.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        SBOL3.instanceOf = Prefixes_1.Prefixes.sbol3 + 'instanceOf';
        SBOL3.role = Prefixes_1.Prefixes.sbol3 + 'role';
        SBOL3.hasLocation = Prefixes_1.Prefixes.sbol3 + 'hasLocation';
        SBOL3.start = Prefixes_1.Prefixes.sbol3 + 'start';
        SBOL3.end = Prefixes_1.Prefixes.sbol3 + 'end';
        SBOL3.at = Prefixes_1.Prefixes.sbol3 + 'at';
        SBOL3.hasFeature = Prefixes_1.Prefixes.sbol3 + 'hasFeature';
        SBOL3.hasConstraint = Prefixes_1.Prefixes.sbol3 + 'hasConstraint';
        SBOL3.orientation = Prefixes_1.Prefixes.sbol3 + 'orientation';
        SBOL3.displayId = Prefixes_1.Prefixes.sbol3 + 'displayId';
        SBOL3.name = Prefixes_1.Prefixes.sbol3 + 'name';
        SBOL3.description = Prefixes_1.Prefixes.sbol3 + 'description';
        SBOL3.access = Prefixes_1.Prefixes.sbol3 + 'access';
        SBOL3.mapsTo = Prefixes_1.Prefixes.sbol3 + 'mapsTo';
        SBOL3.local = Prefixes_1.Prefixes.sbol3 + 'local';
        SBOL3.remote = Prefixes_1.Prefixes.sbol3 + 'remote';
        SBOL3.refinement = Prefixes_1.Prefixes.sbol3 + 'refinement';
        SBOL3.hasInteraction = Prefixes_1.Prefixes.sbol3 + 'hasInteraction';
        SBOL3.hasInterface = Prefixes_1.Prefixes.sbol3 + 'hasInterface';
        SBOL3.hasParticipation = Prefixes_1.Prefixes.sbol3 + 'hasParticipation';
        SBOL3.participant = Prefixes_1.Prefixes.sbol3 + 'participant';
        SBOL3.type = Prefixes_1.Prefixes.sbol3 + 'type';
        SBOL3.hasSequence = Prefixes_1.Prefixes.sbol3 + 'hasSequence';
        SBOL3.encoding = Prefixes_1.Prefixes.sbol3 + 'encoding';
        SBOL3.elements = Prefixes_1.Prefixes.sbol3 + 'elements';
        SBOL3.persistentIdentity = Prefixes_1.Prefixes.sbol3 + 'persistentIdentity';
        SBOL3.restriction = Prefixes_1.Prefixes.sbol3 + 'restriction';
        SBOL3.subject = Prefixes_1.Prefixes.sbol3 + 'subject';
        SBOL3.object = Prefixes_1.Prefixes.sbol3 + 'object';
        SBOL3.member = Prefixes_1.Prefixes.sbol3 + 'member';
        SBOL3.hasModel = Prefixes_1.Prefixes.sbol3 + 'hasModel';
        SBOL3.framework = Prefixes_1.Prefixes.sbol3 + 'framework';
        SBOL3.language = Prefixes_1.Prefixes.sbol3 + 'language';
        SBOL3.source = Prefixes_1.Prefixes.sbol3 + 'source';
        SBOL3.hasAttachment = Prefixes_1.Prefixes.sbol3 + 'hasAttachment';
        SBOL3.format = Prefixes_1.Prefixes.sbol3 + 'format';
        SBOL3.size = Prefixes_1.Prefixes.sbol3 + 'size';
        SBOL3.hash = Prefixes_1.Prefixes.sbol3 + 'hash';
        SBOL3.built = Prefixes_1.Prefixes.sbol3 + 'built';
        SBOL3.experimentalData = Prefixes_1.Prefixes.sbol3 + 'experimentalData';
        SBOL3.sourceLocation = Prefixes_1.Prefixes.sbol3 + 'sourceLocation';
        SBOL3.hasMeasure = Prefixes_1.Prefixes.sbol3 + 'hasMeasure';
        SBOL3.hasNamespace = Prefixes_1.Prefixes.sbol3 + 'hasNamespace';
    })(SBOL3 = Predicates.SBOL3 || (Predicates.SBOL3 = {}));
    let Dcterms;
    (function (Dcterms) {
        Dcterms.title = Prefixes_1.Prefixes.dcterms + 'title';
        Dcterms.description = Prefixes_1.Prefixes.dcterms + 'description';
    })(Dcterms = Predicates.Dcterms || (Predicates.Dcterms = {}));
    let SVG;
    (function (SVG) {
        SVG.fontFamily = Prefixes_1.Prefixes.svg + 'font-family';
        SVG.fontSize = Prefixes_1.Prefixes.svg + 'font-size';
        SVG.fontStyle = Prefixes_1.Prefixes.svg + 'font-style';
    })(SVG = Predicates.SVG || (Predicates.SVG = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.encodedBy = Prefixes_1.Prefixes.sybio + 'encodedBy';
        SyBiOnt.EC = Prefixes_1.Prefixes.sybio + 'EC';
        SyBiOnt.isBalanced = Prefixes_1.Prefixes.sybio + 'isBalanced';
        SyBiOnt.isReactionClass = Prefixes_1.Prefixes.sybio + 'isReactionClass';
        SyBiOnt.inPolymerization = Prefixes_1.Prefixes.sybio + 'inPolymerization';
        SyBiOnt.inTransport = Prefixes_1.Prefixes.sybio + 'inTransport';
        SyBiOnt.reactionDirection = Prefixes_1.Prefixes.sybio + 'reactionDirection';
        SyBiOnt.hasReactionParticipant = Prefixes_1.Prefixes.sybio + 'hasReactionParticipant';
        SyBiOnt.referencesCompound = Prefixes_1.Prefixes.sybio + 'referencesCompound';
        SyBiOnt.reactionSide = Prefixes_1.Prefixes.sybio + 'reactionSide';
        SyBiOnt.reactionSummary = Prefixes_1.Prefixes.sybio + 'reactionSummary';
        SyBiOnt.stoicRatio = Prefixes_1.Prefixes.sybio + 'stoichiometricRatio';
        SyBiOnt.compoundCharge = Prefixes_1.Prefixes.sybio + 'compoundCharge';
        SyBiOnt.compoundFormula = Prefixes_1.Prefixes.sybio + 'compoundFormula';
        SyBiOnt.compoundMass = Prefixes_1.Prefixes.sybio + 'compoundMass';
        SyBiOnt.compoundSmilesFormula = Prefixes_1.Prefixes.sybio + 'compoundSmilesFormula';
        SyBiOnt.interactsWith = Prefixes_1.Prefixes.sybio + 'interactsWith';
        SyBiOnt.taxId = Prefixes_1.Prefixes.sybio + 'taxId';
    })(SyBiOnt = Predicates.SyBiOnt || (Predicates.SyBiOnt = {}));
    let Prov;
    (function (Prov) {
        Prov.wasDerivedFrom = Prefixes_1.Prefixes.prov + 'wasDerivedFrom';
        Prov.wasGeneratedBy = Prefixes_1.Prefixes.prov + 'wasGeneratedBy';
        Prov.qualifiedAssociation = Prefixes_1.Prefixes.prov + 'qualifiedAssociation';
        Prov.qualifiedUsage = Prefixes_1.Prefixes.prov + 'qualifiedUsage';
        Prov.startedAtTime = Prefixes_1.Prefixes.prov + 'startedAtTime';
        Prov.endedAtTime = Prefixes_1.Prefixes.prov + 'endedAtTime';
        Prov.wasInformedBy = Prefixes_1.Prefixes.prov + 'wasInformedBy';
        Prov.agent = Prefixes_1.Prefixes.prov + 'agent';
        Prov.entity = Prefixes_1.Prefixes.prov + 'entity';
        Prov.hadRole = Prefixes_1.Prefixes.prov + 'hadRole';
        Prov.hadPlan = Prefixes_1.Prefixes.prov + 'hadPlan';
    })(Prov = Predicates.Prov || (Predicates.Prov = {}));
    let Enrichment;
    (function (Enrichment) {
        Enrichment.hint = Prefixes_1.Prefixes.enrichment + 'hint';
        Enrichment.orfStart = Prefixes_1.Prefixes.enrichment + 'orfStart';
        Enrichment.orfEnd = Prefixes_1.Prefixes.enrichment + 'orfEnd';
    })(Enrichment = Predicates.Enrichment || (Predicates.Enrichment = {}));
    let Measure;
    (function (Measure) {
        Measure.hasNumericalValue = Prefixes_1.Prefixes.measure + 'hasNumericalValue';
        Measure.hasUnit = Prefixes_1.Prefixes.measure + 'hasUnit';
    })(Measure = Predicates.Measure || (Predicates.Measure = {}));
})(Predicates = exports.Predicates || (exports.Predicates = {}));


/***/ }),

/***/ "./node_modules/bioterms/dist/Prefixes.js":
/*!************************************************!*\
  !*** ./node_modules/bioterms/dist/Prefixes.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Prefixes;
(function (Prefixes) {
    Prefixes.sbol1 = 'http://sbols.org/v1#';
    Prefixes.sbol2 = 'http://sbols.org/v2#';
    Prefixes.sbolx = 'http://sboldata.org/sbolx#';
    Prefixes.sbol3 = 'http://sbols.org/v3#';
    Prefixes.rdf = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
    Prefixes.visual = 'http://wiki.synbiohub.org/wiki/Terms/visual#';
    Prefixes.sequenceOntologyPurl = 'http://purl.org/obo/owl/SO#';
    Prefixes.sequenceOntologyIdentifiersOrg = 'http://identifiers.org/so/';
    Prefixes.go = 'http://identifiers.org/go/';
    Prefixes.dcterms = 'http://purl.org/dc/terms/';
    Prefixes.rdfs = 'http://www.w3.org/2000/01/rdf-schema#';
    Prefixes.svg = 'http://www.w3.org/2000/svg#';
    Prefixes.sbo = 'http://identifiers.org/biomodels.sbo/';
    Prefixes.sybio = 'http://www.sybio.ncl.ac.uk#';
    Prefixes.prov = 'http://www.w3.org/ns/prov#';
    Prefixes.enrichment = 'http://wiki.synbiohub.org/wiki/Terms/enrichment#';
    Prefixes.measure = 'http://www.ontology-of-units-of-measure.org/resource/om-2/';
})(Prefixes = exports.Prefixes || (exports.Prefixes = {}));
function prefixify(uri) {
    uri = '' + uri;
    for (var i = 0; i < keys.length; ++i) {
        const prefix = keys[i];
        const uriPrefix = Prefixes[prefix];
        if (uri.indexOf(uriPrefix) === 0) {
            return prefix + ':' + uri.slice(uriPrefix.length);
        }
    }
    return uri;
}
exports.prefixify = prefixify;
const keys = Object.keys(Prefixes);


/***/ }),

/***/ "./node_modules/bioterms/dist/Specifiers.js":
/*!**************************************************!*\
  !*** ./node_modules/bioterms/dist/Specifiers.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/bioterms/dist/Prefixes.js");
var Specifiers;
(function (Specifiers) {
    let SBOL2;
    (function (SBOL2) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbol2 + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbol2 + 'reverseComplement';
        })(Orientation = SBOL2.Orientation || (SBOL2.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbol2 + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbol2 + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbol2 + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbol2 + 'none';
        })(Direction = SBOL2.Direction || (SBOL2.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbol2 + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbol2 + 'private';
        })(Access = SBOL2.Access || (SBOL2.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOL2.Type || (SBOL2.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOL2.SequenceEncoding || (SBOL2.SequenceEncoding = {}));
        let SequenceConstraint;
        (function (SequenceConstraint) {
            SequenceConstraint.Precedes = Prefixes_1.Prefixes.sbol2 + 'precedes';
            SequenceConstraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbol2 + 'oppositeOrientationAs';
        })(SequenceConstraint = SBOL2.SequenceConstraint || (SBOL2.SequenceConstraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbol2 + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbol2 + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbol2 + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbol2 + 'learn';
        })(ProvRole = SBOL2.ProvRole || (SBOL2.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbol2 + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbol2 + 'useRemote';
        })(MapsToRefinement = SBOL2.MapsToRefinement || (SBOL2.MapsToRefinement = {}));
    })(SBOL2 = Specifiers.SBOL2 || (Specifiers.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbolx + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbolx + 'reverseComplement';
        })(Orientation = SBOLX.Orientation || (SBOLX.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbolx + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbolx + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbolx + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbolx + 'none';
        })(Direction = SBOLX.Direction || (SBOLX.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbolx + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbolx + 'private';
        })(Access = SBOLX.Access || (SBOLX.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOLX.Type || (SBOLX.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOLX.SequenceEncoding || (SBOLX.SequenceEncoding = {}));
        let SequenceConstraint;
        (function (SequenceConstraint) {
            SequenceConstraint.Precedes = Prefixes_1.Prefixes.sbolx + 'precedes';
            SequenceConstraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbolx + 'oppositeOrientationAs';
        })(SequenceConstraint = SBOLX.SequenceConstraint || (SBOLX.SequenceConstraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbolx + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbolx + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbolx + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbolx + 'learn';
        })(ProvRole = SBOLX.ProvRole || (SBOLX.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbolx + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbolx + 'useRemote';
        })(MapsToRefinement = SBOLX.MapsToRefinement || (SBOLX.MapsToRefinement = {}));
    })(SBOLX = Specifiers.SBOLX || (Specifiers.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbol3 + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbol3 + 'reverseComplement';
        })(Orientation = SBOL3.Orientation || (SBOL3.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbol3 + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbol3 + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbol3 + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbol3 + 'none';
        })(Direction = SBOL3.Direction || (SBOL3.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbol3 + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbol3 + 'private';
        })(Access = SBOL3.Access || (SBOL3.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOL3.Type || (SBOL3.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOL3.SequenceEncoding || (SBOL3.SequenceEncoding = {}));
        let Constraint;
        (function (Constraint) {
            Constraint.Precedes = Prefixes_1.Prefixes.sbol3 + 'precedes';
            Constraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbol3 + 'oppositeOrientationAs';
        })(Constraint = SBOL3.Constraint || (SBOL3.Constraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbol3 + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbol3 + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbol3 + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbol3 + 'learn';
        })(ProvRole = SBOL3.ProvRole || (SBOL3.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbol3 + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbol3 + 'useRemote';
        })(MapsToRefinement = SBOL3.MapsToRefinement || (SBOL3.MapsToRefinement = {}));
    })(SBOL3 = Specifiers.SBOL3 || (Specifiers.SBOL3 = {}));
    let Visual;
    (function (Visual) {
        /* opacity
         */
        Visual.Blackbox = Prefixes_1.Prefixes.visual + 'blackbox';
        Visual.Whitebox = Prefixes_1.Prefixes.visual + 'whitebox';
        /* display modes
         */
        Visual.Float = Prefixes_1.Prefixes.visual + 'float';
        Visual.Backbone = Prefixes_1.Prefixes.visual + 'backbone';
        /* orientation
         */
        Visual.Forward = Prefixes_1.Prefixes.visual + 'forward';
        Visual.Reverse = Prefixes_1.Prefixes.visual + 'reverse';
        /* expandability
         */
        Visual.Expandable = Prefixes_1.Prefixes.visual + 'expandable';
        Visual.NotExpandable = Prefixes_1.Prefixes.visual + 'notExpandable';
        Visual.AnchorTop = Prefixes_1.Prefixes.visual + 'anchorTop';
        Visual.AnchorMid = Prefixes_1.Prefixes.visual + 'anchorMid';
        Visual.AnchorBottom = Prefixes_1.Prefixes.visual + 'anchorBottom';
    })(Visual = Specifiers.Visual || (Specifiers.Visual = {}));
    let SO;
    (function (SO) {
        SO.CDS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000316';
        SO.Promoter = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000167';
        SO.RBS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000139';
        SO.RestrictionSite = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0001687';
        SO.Terminator = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000141';
        SO.OriginOfReplication = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000296';
        SO.OriginOfTransfer = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000724';
        SO.PlasmidBackbone = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000755';
        SO.EngineeredRegion = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000804';
    })(SO = Specifiers.SO || (Specifiers.SO = {}));
    let SBO;
    (function (SBO) {
        SBO.Inhibition = Prefixes_1.Prefixes.sbo + 'SBO:0000169';
        SBO.Inhibitor = Prefixes_1.Prefixes.sbo + 'SBO:0000020';
        SBO.Inhibited = Prefixes_1.Prefixes.sbo + 'SBO:0000642';
        SBO.Stimulation = Prefixes_1.Prefixes.sbo + 'SBO:0000170';
        SBO.Stimulator = Prefixes_1.Prefixes.sbo + 'SBO:0000459';
        SBO.Stimulated = Prefixes_1.Prefixes.sbo + 'SBO:0000643';
        SBO.GeneticProduction = Prefixes_1.Prefixes.sbo + 'SBO:0000589';
        SBO.Product = Prefixes_1.Prefixes.sbo + 'SBO:0000011';
        SBO.Modifier = Prefixes_1.Prefixes.sbo + 'SBO:0000019';
        SBO.Promoter = Prefixes_1.Prefixes.sbo + 'SBO:0000598';
        SBO.Control = Prefixes_1.Prefixes.sbo + 'SBO:0000168';
    })(SBO = Specifiers.SBO || (Specifiers.SBO = {}));
    let GO;
    (function (GO) {
        GO.ProteinDepolymerization = Prefixes_1.Prefixes.go + 'GO:0051261';
        GO.CovalentChromatinModification = Prefixes_1.Prefixes.go + 'GO:0016569';
        GO.ProteinProcessing = Prefixes_1.Prefixes.go + 'GO:0016485';
        GO.ProteinBinding = Prefixes_1.Prefixes.go + 'GO:0005515';
        GO.CatalyticActivity = Prefixes_1.Prefixes.go + 'GO:0003824';
    })(GO = Specifiers.GO || (Specifiers.GO = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.Bidirectional = Prefixes_1.Prefixes.sybio + 'Bidirectional';
        SyBiOnt.LeftToRight = Prefixes_1.Prefixes.sybio + 'LeftToRight';
        SyBiOnt.RightToLeft = Prefixes_1.Prefixes.sybio + 'RightToLeft';
        SyBiOnt.UndefinedDirection = Prefixes_1.Prefixes.sybio + 'UndefinedDirection';
        SyBiOnt.LeftSide = Prefixes_1.Prefixes.sybio + 'LeftSide';
        SyBiOnt.RightSide = Prefixes_1.Prefixes.sybio + 'RightSide';
    })(SyBiOnt = Specifiers.SyBiOnt || (Specifiers.SyBiOnt = {}));
})(Specifiers = exports.Specifiers || (exports.Specifiers = {}));


/***/ }),

/***/ "./node_modules/bioterms/dist/Types.js":
/*!*********************************************!*\
  !*** ./node_modules/bioterms/dist/Types.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/bioterms/dist/Prefixes.js");
var Types;
(function (Types) {
    let SBOL1;
    (function (SBOL1) {
        SBOL1.DnaComponent = Prefixes_1.Prefixes.sbol1 + 'DnaComponent';
        SBOL1.DnaSequence = Prefixes_1.Prefixes.sbol1 + 'DnaSequence';
        SBOL1.Collection = Prefixes_1.Prefixes.sbol1 + 'Collection';
        SBOL1.SequenceAnnotation = Prefixes_1.Prefixes.sbol1 + 'SequenceAnnotation';
    })(SBOL1 = Types.SBOL1 || (Types.SBOL1 = {}));
    let SBOL2;
    (function (SBOL2) {
        SBOL2.ModuleDefinition = Prefixes_1.Prefixes.sbol2 + 'ModuleDefinition';
        SBOL2.ComponentDefinition = Prefixes_1.Prefixes.sbol2 + 'ComponentDefinition';
        SBOL2.Module = Prefixes_1.Prefixes.sbol2 + 'Module';
        SBOL2.Component = Prefixes_1.Prefixes.sbol2 + 'Component';
        SBOL2.Range = Prefixes_1.Prefixes.sbol2 + 'Range';
        SBOL2.Cut = Prefixes_1.Prefixes.sbol2 + 'Cut';
        SBOL2.GenericLocation = Prefixes_1.Prefixes.sbol2 + 'GenericLocation';
        SBOL2.SequenceAnnotation = Prefixes_1.Prefixes.sbol2 + 'SequenceAnnotation';
        SBOL2.SequenceConstraint = Prefixes_1.Prefixes.sbol2 + 'SequenceConstraint';
        SBOL2.Interaction = Prefixes_1.Prefixes.sbol2 + 'Interaction';
        SBOL2.Participation = Prefixes_1.Prefixes.sbol2 + 'Participation';
        SBOL2.Collection = Prefixes_1.Prefixes.sbol2 + 'Collection';
        SBOL2.FunctionalComponent = Prefixes_1.Prefixes.sbol2 + 'FunctionalComponent';
        SBOL2.Sequence = Prefixes_1.Prefixes.sbol2 + 'Sequence';
        SBOL2.MapsTo = Prefixes_1.Prefixes.sbol2 + 'MapsTo';
        SBOL2.Attachment = Prefixes_1.Prefixes.sbol2 + 'Attachment';
        SBOL2.Model = Prefixes_1.Prefixes.sbol2 + 'Model';
        SBOL2.Implementation = Prefixes_1.Prefixes.sbol2 + 'Implementation';
        SBOL2.Experiment = Prefixes_1.Prefixes.sbol2 + 'Experiment';
        SBOL2.ExperimentalData = Prefixes_1.Prefixes.sbol2 + 'ExperimentalData';
    })(SBOL2 = Types.SBOL2 || (Types.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        SBOLX.Component = Prefixes_1.Prefixes.sbolx + 'Component';
        SBOLX.SubComponent = Prefixes_1.Prefixes.sbolx + 'SubComponent';
        SBOLX.Range = Prefixes_1.Prefixes.sbolx + 'Range';
        SBOLX.Cut = Prefixes_1.Prefixes.sbolx + 'Cut';
        SBOLX.SequenceConstraint = Prefixes_1.Prefixes.sbolx + 'SequenceConstraint';
        SBOLX.Interaction = Prefixes_1.Prefixes.sbolx + 'Interaction';
        SBOLX.Participation = Prefixes_1.Prefixes.sbolx + 'Participation';
        SBOLX.Collection = Prefixes_1.Prefixes.sbolx + 'Collection';
        SBOLX.Sequence = Prefixes_1.Prefixes.sbolx + 'Sequence';
        SBOLX.OrientedLocation = Prefixes_1.Prefixes.sbolx + 'OrientedLocation';
        SBOLX.SequenceAnnotation = Prefixes_1.Prefixes.sbolx + 'SequenceAnnotation';
        SBOLX.Attachment = Prefixes_1.Prefixes.sbolx + 'Attachment';
        SBOLX.Model = Prefixes_1.Prefixes.sbolx + 'Model';
        SBOLX.Implementation = Prefixes_1.Prefixes.sbolx + 'Implementation';
        SBOLX.MapsTo = Prefixes_1.Prefixes.sbolx + 'MapsTo';
        SBOLX.Experiment = Prefixes_1.Prefixes.sbolx + 'Experiment';
        SBOLX.ExperimentalData = Prefixes_1.Prefixes.sbolx + 'ExperimentalData';
    })(SBOLX = Types.SBOLX || (Types.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        SBOL3.Component = Prefixes_1.Prefixes.sbol3 + 'Component';
        SBOL3.SubComponent = Prefixes_1.Prefixes.sbol3 + 'SubComponent';
        SBOL3.Range = Prefixes_1.Prefixes.sbol3 + 'Range';
        SBOL3.Cut = Prefixes_1.Prefixes.sbol3 + 'Cut';
        SBOL3.EntireSequence = Prefixes_1.Prefixes.sbol3 + 'EntireSequence';
        SBOL3.Constraint = Prefixes_1.Prefixes.sbol3 + 'Constraint';
        SBOL3.Interaction = Prefixes_1.Prefixes.sbol3 + 'Interaction';
        SBOL3.Participation = Prefixes_1.Prefixes.sbol3 + 'Participation';
        SBOL3.Collection = Prefixes_1.Prefixes.sbol3 + 'Collection';
        SBOL3.Sequence = Prefixes_1.Prefixes.sbol3 + 'Sequence';
        SBOL3.OrientedLocation = Prefixes_1.Prefixes.sbol3 + 'OrientedLocation';
        SBOL3.SequenceFeature = Prefixes_1.Prefixes.sbol3 + 'SequenceFeature';
        SBOL3.Attachment = Prefixes_1.Prefixes.sbol3 + 'Attachment';
        SBOL3.Model = Prefixes_1.Prefixes.sbol3 + 'Model';
        SBOL3.Implementation = Prefixes_1.Prefixes.sbol3 + 'Implementation';
        SBOL3.MapsTo = Prefixes_1.Prefixes.sbol3 + 'MapsTo';
        SBOL3.Experiment = Prefixes_1.Prefixes.sbol3 + 'Experiment';
        SBOL3.ExperimentalData = Prefixes_1.Prefixes.sbol3 + 'ExperimentalData';
        SBOL3.Namespace = Prefixes_1.Prefixes.sbol3 + 'Namespace';
    })(SBOL3 = Types.SBOL3 || (Types.SBOL3 = {}));
    let Visual;
    (function (Visual) {
        Visual.ModuleDepiction = Prefixes_1.Prefixes.visual + 'ModuleDepiction';
        Visual.ComponentDepiction = Prefixes_1.Prefixes.visual + 'ComponentDepiction';
        Visual.Glyph = Prefixes_1.Prefixes.visual + 'Glyph';
        Visual.Label = Prefixes_1.Prefixes.visual + 'Label';
    })(Visual = Types.Visual || (Types.Visual = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.Protein = Prefixes_1.Prefixes.sybio + 'Protein';
        SyBiOnt.InduciblePromoter = Prefixes_1.Prefixes.sybio + 'InduciblePromoter';
        SyBiOnt.Reaction = Prefixes_1.Prefixes.sybio + 'Reaction';
        SyBiOnt.ReactionParticipant = Prefixes_1.Prefixes.sybio + 'ReactionParticipant';
        SyBiOnt.Compound = Prefixes_1.Prefixes.sybio + 'Compound';
    })(SyBiOnt = Types.SyBiOnt || (Types.SyBiOnt = {}));
    let Prov;
    (function (Prov) {
        Prov.Agent = Prefixes_1.Prefixes.prov + 'Agent';
        Prov.Association = Prefixes_1.Prefixes.prov + 'Association';
        Prov.Activity = Prefixes_1.Prefixes.prov + 'Activity';
        Prov.Usage = Prefixes_1.Prefixes.prov + 'Usage';
        Prov.Plan = Prefixes_1.Prefixes.prov + 'Plan';
    })(Prov = Types.Prov || (Types.Prov = {}));
    let Enrichment;
    (function (Enrichment) {
        Enrichment.GeneProduct = Prefixes_1.Prefixes.enrichment + 'GeneProduct';
    })(Enrichment = Types.Enrichment || (Types.Enrichment = {}));
    let Measure;
    (function (Measure_1) {
        Measure_1.Measure = Prefixes_1.Prefixes.measure + 'Measure';
    })(Measure = Types.Measure || (Types.Measure = {}));
})(Types = exports.Types || (exports.Types = {}));


/***/ }),

/***/ "./node_modules/bioterms/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/bioterms/dist/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/bioterms/dist/Prefixes.js");
exports.Prefixes = Prefixes_1.Prefixes;
exports.prefixify = Prefixes_1.prefixify;
const Types_1 = __webpack_require__(/*! ./Types */ "./node_modules/bioterms/dist/Types.js");
exports.Types = Types_1.Types;
const Predicates_1 = __webpack_require__(/*! ./Predicates */ "./node_modules/bioterms/dist/Predicates.js");
exports.Predicates = Predicates_1.Predicates;
const Specifiers_1 = __webpack_require__(/*! ./Specifiers */ "./node_modules/bioterms/dist/Specifiers.js");
exports.Specifiers = Specifiers_1.Specifiers;
const sequenceOntology_1 = __webpack_require__(/*! ./sequenceOntology */ "./node_modules/bioterms/dist/sequenceOntology.js");
exports.sequenceOntology = sequenceOntology_1.sequenceOntology;
exports.uriToName = sequenceOntology_1.uriToName;


/***/ }),

/***/ "./node_modules/bioterms/dist/sequenceOntology.js":
/*!********************************************************!*\
  !*** ./node_modules/bioterms/dist/sequenceOntology.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function uriToName(uri) {
    let temp = uri.split('/');
    let id = temp.pop();
    let entry = sequenceOntology.so[id];
    if (!entry)
        return undefined;
    let name = entry['name'];
    return name;
}
exports.uriToName = uriToName;
var sequenceOntology;
(function (sequenceOntology) {
    sequenceOntology.so = {
        "SO:0000000": {
            "name": "Sequence_Ontology"
        },
        "SO:0000001": {
            "name": "region",
            "def": "A sequence_feature with an extent greater than zero. A nucleotide region is composed of bases and a polypeptide region is composed of amino acids. [SO:ke]"
        },
        "SO:0000002": {
            "name": "sequence_secondary_structure",
            "def": "A folded sequence. [SO:ke]"
        },
        "SO:0000003": {
            "name": "G_quartet",
            "def": "G-quartets are unusual nucleic acid structures consisting of a planar arrangement where each guanine is hydrogen bonded by hoogsteen pairing to another guanine in the quartet. [http://www.ncbi.nlm.nih.gov/pubmed/7919797?dopt=Abstract]"
        },
        "SO:0000004": {
            "name": "interior_coding_exon"
        },
        "SO:0000005": {
            "name": "satellite_DNA",
            "def": "The many tandem repeats (identical or related) of a short basic repeating unit; many have a base composition or other property different from the genome average that allows them to be separated from the bulk (main band) genomic DNA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000006": {
            "name": "PCR_product",
            "def": "A region amplified by a PCR reaction. [SO:ke]"
        },
        "SO:0000007": {
            "name": "read_pair",
            "def": "One of a pair of sequencing reads in which the two members of the pair are related by originating at either end of a clone insert. [SO:ls]"
        },
        "SO:0000008": {
            "name": "gene_sensu_your_favorite_organism"
        },
        "SO:0000009": {
            "name": "gene_class"
        },
        "SO:0000010": {
            "name": "protein_coding"
        },
        "SO:0000011": {
            "name": "non_protein_coding"
        },
        "SO:0000012": {
            "name": "scRNA_primary_transcript",
            "def": "The primary transcript of any one of several small cytoplasmic RNA molecules present in the cytoplasm and sometimes nucleus of a Eukaryote. [http://www.ebi.ac.uk/embl/WebFeat/align/scRNA_s.html]"
        },
        "SO:0000013": {
            "name": "scRNA",
            "def": "A small non coding RNA sequence, present in the cytoplasm. [SO:ke]"
        },
        "SO:0000014": {
            "name": "INR_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters required for the correct positioning of the polymerase for the start of transcription. Overlaps the TSS. The mammalian consensus sequence is YYAN(T|A)YY; the Drosophila consensus sequence is TCA(G|T)t(T|C). In each the A is at position +1 with respect to the TSS. Functionally similar to the TATA box element. [PMID:12651739, PMID:16858867]"
        },
        "SO:0000015": {
            "name": "DPE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters; Positioned from +28 to +32 with respect to the TSS (+1). Experimental results suggest that the DPE acts in conjunction with the INR_motif to provide a binding site for TFIID in the absence of a TATA box to mediate transcription of TATA-less promoters. Consensus sequence (A|G)G(A|T)(C|T)(G|A|C). [PMID:12651739:12537576, PMID:16858867]"
        },
        "SO:0000016": {
            "name": "BREu_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements at -37 to -32 with respect to the TSS (+1). Consensus sequence is (G|C)(G|C)(G|A)CGCC. Binds TFIIB. [PMID:12651739, PMID:16858867]"
        },
        "SO:0000017": {
            "name": "PSE_motif",
            "def": "A sequence element characteristic of the promoters of snRNA genes transcribed by RNA polymerase II or by RNA polymerase III. Located between -45 and -60 relative to the TSS. The human PSE_motif consensus sequence is TCACCNTNA(C|G)TNAAAAG(T|G). [PMID:12651739]"
        },
        "SO:0000018": {
            "name": "linkage_group",
            "def": "A group of loci that can be grouped in a linear order representing the different degrees of linkage among the genes concerned. [ISBN:038752046]"
        },
        "SO:0000020": {
            "name": "RNA_internal_loop",
            "def": "A region of double stranded RNA where the bases do not conform to WC base pairing. The loop is closed on both sides by canonical base pairing. If the interruption to base pairing occurs on one strand only, it is known as a bulge. [SO:ke]"
        },
        "SO:0000021": {
            "name": "asymmetric_RNA_internal_loop",
            "def": "An internal RNA loop where one of the strands includes more bases than the corresponding region on the other strand. [SO:ke]"
        },
        "SO:0000022": {
            "name": "A_minor_RNA_motif",
            "def": "A region forming a motif, composed of adenines, where the minor groove edges are inserted into the minor groove of another helix. [SO:ke]"
        },
        "SO:0000023": {
            "name": "K_turn_RNA_motif",
            "def": "The kink turn (K-turn) is an RNA structural motif that creates a sharp (~120 degree) bend between two continuous helices. [SO:ke]"
        },
        "SO:0000024": {
            "name": "sarcin_like_RNA_motif",
            "def": "A loop in ribosomal RNA containing the sites of attack for ricin and sarcin. [http://www.ncbi.nlm.nih.gov/pubmed/7897662]"
        },
        "SO:0000025": {
            "name": "symmetric_RNA_internal_loop",
            "def": "An internal RNA loop where the extent of the loop on both stands is the same size. [SO:ke]"
        },
        "SO:0000026": {
            "name": "RNA_junction_loop"
        },
        "SO:0000027": {
            "name": "RNA_hook_turn"
        },
        "SO:0000028": {
            "name": "base_pair"
        },
        "SO:0000029": {
            "name": "WC_base_pair",
            "def": "The canonical base pair, where two bases interact via WC edges, with glycosidic bonds oriented cis relative to the axis of orientation. [PMID:12177293]"
        },
        "SO:0000030": {
            "name": "sugar_edge_base_pair",
            "def": "A type of non-canonical base-pairing. [PMID:12177293]"
        },
        "SO:0000031": {
            "name": "aptamer",
            "def": "DNA or RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
        },
        "SO:0000032": {
            "name": "DNA_aptamer",
            "def": "DNA molecules that have been selected from random pools based on their ability to bind other molecules. [http:aptamer.icmb.utexas.edu]"
        },
        "SO:0000033": {
            "name": "RNA_aptamer",
            "def": "RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
        },
        "SO:0000034": {
            "name": "morpholino_oligo",
            "def": "Morpholino oligos are synthesized from four different Morpholino subunits, each of which contains one of the four genetic bases (A, C, G, T) linked to a 6-membered morpholine ring. Eighteen to 25 subunits of these four subunit types are joined in a specific order by non-ionic phosphorodiamidate intersubunit linkages to give a Morpholino. [http://www.gene-tools.com/]"
        },
        "SO:0000035": {
            "name": "riboswitch",
            "def": "A riboswitch is a part of an mRNA that can act as a direct sensor of small molecules to control their own expression. A riboswitch is a cis element in the 5' end of an mRNA, that acts as a direct sensor of metabolites. [PMID:2820954]"
        },
        "SO:0000036": {
            "name": "matrix_attachment_site",
            "def": "A DNA region that is required for the binding of chromatin to the nuclear matrix. [SO:ma]"
        },
        "SO:0000037": {
            "name": "locus_control_region",
            "def": "A DNA region that includes DNAse hypersensitive sites located 5' to a gene that confers the high-level, position-independent, and copy number-dependent expression to that gene. [SO:ma]"
        },
        "SO:0000038": {
            "name": "match_set",
            "def": "A collection of match parts. [SO:ke]"
        },
        "SO:0000039": {
            "name": "match_part",
            "def": "A part of a match, for example an hsp from blast is a match_part. [SO:ke]"
        },
        "SO:0000040": {
            "name": "genomic_clone",
            "def": "A clone of a DNA region of a genome. [SO:ma]"
        },
        "SO:0000041": {
            "name": "sequence_operation",
            "def": "An operation that can be applied to a sequence, that results in a change. [SO:ke]"
        },
        "SO:0000042": {
            "name": "pseudogene_attribute",
            "def": "An attribute of a pseudogene (SO:0000336). [SO:ma]"
        },
        "SO:0000043": {
            "name": "processed_pseudogene",
            "def": "A pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promoters, but often including a polyA tail. [SO:xp]"
        },
        "SO:0000044": {
            "name": "pseudogene_by_unequal_crossing_over",
            "def": "A pseudogene caused by unequal crossing over at recombination. [SO:ke]"
        },
        "SO:0000045": {
            "name": "delete",
            "def": "To remove a subsection of sequence. [SO:ke]"
        },
        "SO:0000046": {
            "name": "insert",
            "def": "To insert a subsection of sequence. [SO:ke]"
        },
        "SO:0000047": {
            "name": "invert",
            "def": "To invert a subsection of sequence. [SO:ke]"
        },
        "SO:0000048": {
            "name": "substitute",
            "def": "To substitute a subsection of sequence for another. [SO:ke]"
        },
        "SO:0000049": {
            "name": "translocate",
            "def": "To translocate a subsection of sequence. [SO:ke]"
        },
        "SO:0000050": {
            "name": "gene_part",
            "def": "A part of a gene, that has no other route in the ontology back to region. This concept is necessary for logical inference as these parts must have the properties of region. It also allows us to associate all the parts of genes with a gene. [SO:ke]"
        },
        "SO:0000051": {
            "name": "probe",
            "def": "A DNA sequence used experimentally to detect the presence or absence of a complementary nucleic acid. [SO:ma]"
        },
        "SO:0000052": {
            "name": "assortment_derived_deficiency"
        },
        "SO:0000053": {
            "name": "sequence_variant_affecting_regulatory_region",
            "def": "A sequence_variant_effect which changes the regulatory region of a gene. [SO:ke]"
        },
        "SO:0000054": {
            "name": "aneuploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
        },
        "SO:0000055": {
            "name": "hyperploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as extra chromosomes are present. [SO:ke]"
        },
        "SO:0000056": {
            "name": "hypoploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as some chromosomes are missing. [SO:ke]"
        },
        "SO:0000057": {
            "name": "operator",
            "def": "A regulatory element of an operon to which activators or repressors bind thereby effecting translation of genes in that operon. [SO:ma]"
        },
        "SO:0000058": {
            "name": "assortment_derived_aneuploid"
        },
        "SO:0000059": {
            "name": "nuclease_binding_site",
            "def": "A binding site that, of a nucleotide molecule, that interacts selectively and non-covalently with polypeptide residues of a nuclease. [SO:cb]"
        },
        "SO:0000060": {
            "name": "compound_chromosome_arm"
        },
        "SO:0000061": {
            "name": "restriction_enzyme_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a restriction enzyme. [SO:cb]"
        },
        "SO:0000062": {
            "name": "deficient_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
        },
        "SO:0000063": {
            "name": "deficient_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [SO:ke]"
        },
        "SO:0000064": {
            "name": "gene_by_transcript_attribute"
        },
        "SO:0000065": {
            "name": "free_chromosome_arm",
            "def": "A chromosome structure variation whereby an arm exists as an individual chromosome element. [SO:ke]"
        },
        "SO:0000066": {
            "name": "gene_by_polyadenylation_attribute"
        },
        "SO:0000067": {
            "name": "gene_to_gene_feature"
        },
        "SO:0000068": {
            "name": "overlapping",
            "def": "An attribute describing a gene that has a sequence that overlaps the sequence of another gene. [SO:ke]"
        },
        "SO:0000069": {
            "name": "inside_intron",
            "def": "An attribute to describe a gene when it is located within the intron of another gene. [SO:ke]"
        },
        "SO:0000070": {
            "name": "inside_intron_antiparallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the opposite strand. [SO:ke]"
        },
        "SO:0000071": {
            "name": "inside_intron_parallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the same strand. [SO:ke]"
        },
        "SO:0000072": {
            "name": "end_overlapping_gene"
        },
        "SO:0000073": {
            "name": "five_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's 3' region. [SO:ke]"
        },
        "SO:0000074": {
            "name": "five_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's five prime region. [SO:ke]"
        },
        "SO:0000075": {
            "name": "three_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 3' region. [SO:ke]"
        },
        "SO:0000076": {
            "name": "three_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 5' region. [SO:ke]"
        },
        "SO:0000077": {
            "name": "antisense",
            "def": "A region sequence that is complementary to a sequence of messenger RNA. [SO:ke]"
        },
        "SO:0000078": {
            "name": "polycistronic_transcript",
            "def": "A transcript that is polycistronic. [SO:xp]"
        },
        "SO:0000079": {
            "name": "dicistronic_transcript",
            "def": "A transcript that is dicistronic. [SO:ke]"
        },
        "SO:0000080": {
            "name": "operon_member"
        },
        "SO:0000081": {
            "name": "gene_array_member"
        },
        "SO:0000082": {
            "name": "processed_transcript_attribute"
        },
        "SO:0000083": {
            "name": "macronuclear_sequence"
        },
        "SO:0000084": {
            "name": "micronuclear_sequence"
        },
        "SO:0000085": {
            "name": "gene_by_genome_location"
        },
        "SO:0000086": {
            "name": "gene_by_organelle_of_genome"
        },
        "SO:0000087": {
            "name": "nuclear_gene",
            "def": "A gene from nuclear sequence. [SO:xp]"
        },
        "SO:0000088": {
            "name": "mt_gene",
            "def": "A gene located in mitochondrial sequence. [SO:xp]"
        },
        "SO:0000089": {
            "name": "kinetoplast_gene",
            "def": "A gene located in kinetoplast sequence. [SO:xp]"
        },
        "SO:0000090": {
            "name": "plastid_gene",
            "def": "A gene from plastid sequence. [SO:xp]"
        },
        "SO:0000091": {
            "name": "apicoplast_gene",
            "def": "A gene from apicoplast sequence. [SO:xp]"
        },
        "SO:0000092": {
            "name": "ct_gene",
            "def": "A gene from chloroplast sequence. [SO:xp]"
        },
        "SO:0000093": {
            "name": "chromoplast_gene",
            "def": "A gene from chromoplast_sequence. [SO:xp]"
        },
        "SO:0000094": {
            "name": "cyanelle_gene",
            "def": "A gene from cyanelle sequence. [SO:xp]"
        },
        "SO:0000095": {
            "name": "leucoplast_gene",
            "def": "A plastid gene from leucoplast sequence. [SO:xp]"
        },
        "SO:0000096": {
            "name": "proplastid_gene",
            "def": "A gene from proplastid sequence. [SO:ke]"
        },
        "SO:0000097": {
            "name": "nucleomorph_gene",
            "def": "A gene from nucleomorph sequence. [SO:xp]"
        },
        "SO:0000098": {
            "name": "plasmid_gene",
            "def": "A gene from plasmid sequence. [SO:xp]"
        },
        "SO:0000099": {
            "name": "proviral_gene",
            "def": "A gene from proviral sequence. [SO:xp]"
        },
        "SO:0000100": {
            "name": "endogenous_retroviral_gene",
            "def": "A proviral gene with origin endogenous retrovirus. [SO:xp]"
        },
        "SO:0000101": {
            "name": "transposable_element",
            "def": "A transposon or insertion sequence. An element that can insert in a variety of DNA sequences. [http://www.sci.sdsu.edu/~smaloy/Glossary/T.html]"
        },
        "SO:0000102": {
            "name": "expressed_sequence_match",
            "def": "A match to an EST or cDNA sequence. [SO:ke]"
        },
        "SO:0000103": {
            "name": "clone_insert_end",
            "def": "The end of the clone insert. [SO:ke]"
        },
        "SO:0000104": {
            "name": "polypeptide",
            "def": "A sequence of amino acids linked by peptide bonds which may lack appreciable tertiary structure and may not be liable to irreversible denaturation. [SO:ma]"
        },
        "SO:0000105": {
            "name": "chromosome_arm",
            "def": "A region of the chromosome between the centromere and the telomere. Human chromosomes have two arms, the p arm (short) and the q arm (long) which are separated from each other by the centromere. [http://www.medterms.com/script/main/art.asp?articlekey=5152]"
        },
        "SO:0000106": {
            "name": "non_capped_primary_transcript"
        },
        "SO:0000107": {
            "name": "sequencing_primer"
        },
        "SO:0000108": {
            "name": "mRNA_with_frameshift",
            "def": "An mRNA with a frameshift. [SO:xp]"
        },
        "SO:0000109": {
            "name": "sequence_variant_obs",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
        },
        "SO:0000110": {
            "name": "sequence_feature",
            "def": "Any extent of continuous biological sequence. [LAMHDI:mb, SO:ke]"
        },
        "SO:0000111": {
            "name": "transposable_element_gene",
            "def": "A gene encoded within a transposable element. For example gag, int, env and pol are the transposable element genes of the TY element in yeast. [SO:ke]"
        },
        "SO:0000112": {
            "name": "primer",
            "def": "An oligo to which new deoxyribonucleotides can be added by DNA polymerase. [SO:ke]"
        },
        "SO:0000113": {
            "name": "proviral_region",
            "def": "A viral sequence which has integrated into a host genome. [SO:ke]"
        },
        "SO:0000114": {
            "name": "methylated_cytosine",
            "def": "A methylated deoxy-cytosine. [SO:ke]"
        },
        "SO:0000115": {
            "name": "transcript_feature"
        },
        "SO:0000116": {
            "name": "edited",
            "def": "An attribute describing a sequence that is modified by editing. [SO:ke]"
        },
        "SO:0000117": {
            "name": "transcript_with_readthrough_stop_codon"
        },
        "SO:0000118": {
            "name": "transcript_with_translational_frameshift",
            "def": "A transcript with a translational frameshift. [SO:xp]"
        },
        "SO:0000119": {
            "name": "regulated",
            "def": "An attribute to describe a sequence that is regulated. [SO:ke]"
        },
        "SO:0000120": {
            "name": "protein_coding_primary_transcript",
            "def": "A primary transcript that, at least in part, encodes one or more proteins. [SO:ke]"
        },
        "SO:0000121": {
            "name": "forward_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000122": {
            "name": "RNA_sequence_secondary_structure",
            "def": "A folded RNA sequence. [SO:ke]"
        },
        "SO:0000123": {
            "name": "transcriptionally_regulated",
            "def": "An attribute describing a gene that is regulated at transcription. [SO:ma]"
        },
        "SO:0000124": {
            "name": "transcriptionally_constitutive",
            "def": "Expressed in relatively constant amounts without regard to cellular environmental conditions such as the concentration of a particular substrate. [SO:ke]"
        },
        "SO:0000125": {
            "name": "transcriptionally_induced",
            "def": "An inducer molecule is required for transcription to occur. [SO:ke]"
        },
        "SO:0000126": {
            "name": "transcriptionally_repressed",
            "def": "A repressor molecule is required for transcription to stop. [SO:ke]"
        },
        "SO:0000127": {
            "name": "silenced_gene",
            "def": "A gene that is silenced. [SO:xp]"
        },
        "SO:0000128": {
            "name": "gene_silenced_by_DNA_modification",
            "def": "A gene that is silenced by DNA modification. [SO:xp]"
        },
        "SO:0000129": {
            "name": "gene_silenced_by_DNA_methylation",
            "def": "A gene that is silenced by DNA methylation. [SO:xp]"
        },
        "SO:0000130": {
            "name": "post_translationally_regulated",
            "def": "An attribute describing a gene that is regulated after it has been translated. [SO:ke]"
        },
        "SO:0000131": {
            "name": "translationally_regulated",
            "def": "An attribute describing a gene that is regulated as it is translated. [SO:ke]"
        },
        "SO:0000132": {
            "name": "reverse_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000133": {
            "name": "epigenetically_modified",
            "def": "This attribute describes a gene where heritable changes other than those in the DNA sequence occur. These changes include: modification to the DNA (such as DNA methylation, the covalent modification of cytosine), and post-translational modification of histones. [SO:ke]"
        },
        "SO:0000134": {
            "name": "genomically_imprinted",
            "def": "Imprinted genes are epigenetically modified genes that are expressed monoallelically according to their parent of origin. [SO:ke]"
        },
        "SO:0000135": {
            "name": "maternally_imprinted",
            "def": "The maternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
        },
        "SO:0000136": {
            "name": "paternally_imprinted",
            "def": "The paternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
        },
        "SO:0000137": {
            "name": "allelically_excluded",
            "def": "Allelic exclusion is a process occurring in diploid organisms, where a gene is inactivated and not expressed in that cell. [SO:ke]"
        },
        "SO:0000138": {
            "name": "gene_rearranged_at_DNA_level",
            "def": "An epigenetically modified gene, rearranged at the DNA level. [SO:xp]"
        },
        "SO:0000139": {
            "name": "ribosome_entry_site",
            "def": "Region in mRNA where ribosome assembles. [SO:ke]"
        },
        "SO:0000140": {
            "name": "attenuator",
            "def": "A sequence segment located within the five prime end of an mRNA that causes premature termination of translation. [SO:as]"
        },
        "SO:0000141": {
            "name": "terminator",
            "def": "The sequence of DNA located either at the end of the transcript that causes RNA polymerase to terminate transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000142": {
            "name": "DNA_sequence_secondary_structure",
            "def": "A folded DNA sequence. [SO:ke]"
        },
        "SO:0000143": {
            "name": "assembly_component",
            "def": "A region of known length which may be used to manufacture a longer region. [SO:ke]"
        },
        "SO:0000144": {
            "name": "primary_transcript_attribute"
        },
        "SO:0000145": {
            "name": "recoded_codon",
            "def": "A codon that has been redefined at translation. The redefinition may be as a result of translational bypass, translational frameshifting or stop codon readthrough. [SO:xp]"
        },
        "SO:0000146": {
            "name": "capped",
            "def": "An attribute describing when a sequence, usually an mRNA is capped by the addition of a modified guanine nucleotide at the 5' end. [SO:ke]"
        },
        "SO:0000147": {
            "name": "exon",
            "def": "A region of the transcript sequence within a gene which is not removed from the primary RNA transcript by RNA splicing. [SO:ke]"
        },
        "SO:0000148": {
            "name": "supercontig",
            "def": "One or more contigs that have been ordered and oriented using end-read information. Contains gaps that are filled with N's. [SO:ls]"
        },
        "SO:0000149": {
            "name": "contig",
            "def": "A contiguous sequence derived from sequence assembly. Has no gaps, but may contain N's from unavailable bases. [SO:ls]"
        },
        "SO:0000150": {
            "name": "read",
            "def": "A sequence obtained from a single sequencing experiment. Typically a read is produced when a base calling program interprets information from a chromatogram trace file produced from a sequencing machine. [SO:rd]"
        },
        "SO:0000151": {
            "name": "clone",
            "def": "A piece of DNA that has been inserted in a vector so that it can be propagated in a host bacterium or some other organism. [SO:ke]"
        },
        "SO:0000152": {
            "name": "YAC",
            "def": "Yeast Artificial Chromosome, a vector constructed from the telomeric, centromeric, and replication origin sequences needed for replication in yeast cells. [SO:ma]"
        },
        "SO:0000153": {
            "name": "BAC",
            "def": "Bacterial Artificial Chromosome, a cloning vector that can be propagated as mini-chromosomes in a bacterial host. [SO:ma]"
        },
        "SO:0000154": {
            "name": "PAC",
            "def": "The P1-derived artificial chromosome are DNA constructs that are derived from the DNA of P1 bacteriophage. They can carry large amounts (about 100-300 kilobases) of other sequences for a variety of bioengineering purposes. It is one type of vector used to clone DNA fragments (100- to 300-kb insert size; average, 150 kb) in Escherichia coli cells. [http://en.wikipedia.org/wiki/P1-derived_artificial_chromosome]"
        },
        "SO:0000155": {
            "name": "plasmid",
            "def": "A self replicating, using the hosts cellular machinery, often circular nucleic acid molecule that is distinct from a chromosome in the organism. [SO:ma]"
        },
        "SO:0000156": {
            "name": "cosmid",
            "def": "A cloning vector that is a hybrid of lambda phages and a plasmid that can be propagated as a plasmid or packaged as a phage,since they retain the lambda cos sites. [SO:ma]"
        },
        "SO:0000157": {
            "name": "phagemid",
            "def": "A plasmid which carries within its sequence a bacteriophage replication origin. When the host bacterium is infected with \\helper\\ phage, a phagemid is replicated along with the phage DNA and packaged into phage capsids. [SO:ma]"
        },
        "SO:0000158": {
            "name": "fosmid",
            "def": "A cloning vector that utilizes the E. coli F factor. [SO:ma]"
        },
        "SO:0000159": {
            "name": "deletion",
            "def": "The point at which one or more contiguous nucleotides were excised. [SO:ke]"
        },
        "SO:0000160": {
            "name": "lambda_clone",
            "def": "A linear clone derived from lambda bacteriophage. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
        },
        "SO:0000161": {
            "name": "methylated_adenine",
            "def": "A modified  base in which adenine has been methylated. [SO:ke]"
        },
        "SO:0000162": {
            "name": "splice_site",
            "def": "Consensus region of primary transcript bordering junction of splicing. A region that overlaps exactly 2 base and adjacent_to splice_junction. [SO:cjm, SO:ke]"
        },
        "SO:0000163": {
            "name": "five_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 5' edge of the intron. A splice_site that is downstream_adjacent_to exon and starts intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
        },
        "SO:0000164": {
            "name": "three_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 3' edge of the intron. A splice_site that is upstream_adjacent_to exon and finishes intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
        },
        "SO:0000165": {
            "name": "enhancer",
            "def": "A cis-acting sequence that increases the utilization of (some) eukaryotic promoters, and can function in either orientation and in any location (upstream or downstream) relative to the promoter. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000166": {
            "name": "enhancer_bound_by_factor",
            "def": "An enhancer bound by a factor. [SO:xp]"
        },
        "SO:0000167": {
            "name": "promoter",
            "def": "A regulatory_region composed of the TSS(s) and binding sites for TF_complexes of the basal transcription machinery. [SO:regcreative]"
        },
        "SO:0000168": {
            "name": "restriction_enzyme_cut_site",
            "def": "A specific nucleotide sequence of DNA at or near which a particular restriction enzyme cuts the DNA. [SO:ma]"
        },
        "SO:0000169": {
            "name": "RNApol_I_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase I binds, to begin transcription. [SO:ke]"
        },
        "SO:0000170": {
            "name": "RNApol_II_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase II binds, to begin transcription. [SO:ke]"
        },
        "SO:0000171": {
            "name": "RNApol_III_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase III binds, to begin transcription. [SO:ke]"
        },
        "SO:0000172": {
            "name": "CAAT_signal",
            "def": "Part of a conserved sequence located about 75-bp upstream of the start point of eukaryotic transcription units which may be involved in RNA polymerase binding; consensus=GG(C|T)CAATCT. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000173": {
            "name": "GC_rich_promoter_region",
            "def": "A conserved GC-rich region located upstream of the start point of eukaryotic transcription units which may occur in multiple copies or in either orientation; consensus=GGGCGG. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000174": {
            "name": "TATA_box",
            "def": "A conserved AT-rich septamer found about 25-bp before the start point of many eukaryotic RNA polymerase II transcript units; may be involved in positioning the enzyme for correct initiation; consensus=TATA(A|T)A(A|T). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:16858867]"
        },
        "SO:0000175": {
            "name": "minus_10_signal",
            "def": "A conserved region about 10-bp upstream of the start point of bacterial transcription units which may be involved in binding RNA polymerase; consensus=TAtAaT. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000176": {
            "name": "minus_35_signal",
            "def": "A conserved hexamer about 35-bp upstream of the start point of bacterial transcription units; consensus=TTGACa or TGTTGACA. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000177": {
            "name": "cross_genome_match",
            "def": "A nucleotide match against a sequence from another organism. [SO:ma]"
        },
        "SO:0000178": {
            "name": "operon",
            "def": "A group of contiguous genes transcribed as a single (polycistronic) mRNA from a single regulatory region. [SO:ma]"
        },
        "SO:0000179": {
            "name": "clone_insert_start",
            "def": "The start of the clone insert. [SO:ke]"
        },
        "SO:0000180": {
            "name": "retrotransposon",
            "def": "A transposable element that is incorporated into a chromosome by a mechanism that requires reverse transcriptase. [http://www.dddmag.com/Glossary.aspx#r]"
        },
        "SO:0000181": {
            "name": "translated_nucleotide_match",
            "def": "A match against a translated sequence. [SO:ke]"
        },
        "SO:0000182": {
            "name": "DNA_transposon",
            "def": "A transposon where the mechanism of transposition is via a DNA intermediate. [SO:ke]"
        },
        "SO:0000183": {
            "name": "non_transcribed_region",
            "def": "A region of the gene which is not transcribed. [SO:ke]"
        },
        "SO:0000184": {
            "name": "U2_intron",
            "def": "A major type of spliceosomal intron spliced by the U2 spliceosome, that includes U1, U2, U4/U6 and U5 snRNAs. [PMID:9428511]"
        },
        "SO:0000185": {
            "name": "primary_transcript",
            "def": "A transcript that in its initial state requires modification to be functional. [SO:ma]"
        },
        "SO:0000186": {
            "name": "LTR_retrotransposon",
            "def": "A retrotransposon flanked by long terminal repeat sequences. [SO:ke]"
        },
        "SO:0000187": {
            "name": "repeat_family",
            "def": "A group of characterized repeat sequences. [SO:ke]"
        },
        "SO:0000188": {
            "name": "intron",
            "def": "A region of a primary transcript that is transcribed, but removed from within the transcript by splicing together the sequences (exons) on either side of it. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000189": {
            "name": "non_LTR_retrotransposon",
            "def": "A retrotransposon without long terminal repeat sequences. [SO:ke]"
        },
        "SO:0000190": {
            "name": "five_prime_intron"
        },
        "SO:0000191": {
            "name": "interior_intron"
        },
        "SO:0000192": {
            "name": "three_prime_intron"
        },
        "SO:0000193": {
            "name": "RFLP_fragment",
            "def": "A DNA fragment used as a reagent to detect the polymorphic genomic loci by hybridizing against the genomic DNA digested with a given restriction enzyme. [GOC:pj]"
        },
        "SO:0000194": {
            "name": "LINE_element",
            "def": "A dispersed repeat family with many copies, each from 1 to 6 kb long. New elements are generated by retroposition of a transcribed copy. Typically the LINE contains 2 ORF's one of which is reverse transcriptase, and 3'and 5' direct repeats. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
        },
        "SO:0000195": {
            "name": "coding_exon",
            "def": "An exon whereby at least one base is part of a codon (here, 'codon' is inclusive of the stop_codon). [SO:ke]"
        },
        "SO:0000196": {
            "name": "five_prime_coding_exon_coding_region",
            "def": "The sequence of the five_prime_coding_exon that codes for protein. [SO:cjm]"
        },
        "SO:0000197": {
            "name": "three_prime_coding_exon_coding_region",
            "def": "The sequence of the three_prime_coding_exon that codes for protein. [SO:cjm]"
        },
        "SO:0000198": {
            "name": "noncoding_exon",
            "def": "An exon that does not contain any codons. [SO:ke]"
        },
        "SO:0000199": {
            "name": "translocation",
            "def": "A region of nucleotide sequence that has translocated to a new position. The observed adjacency of two previously separated regions. [NCBI:th, SO:ke]"
        },
        "SO:0000200": {
            "name": "five_prime_coding_exon",
            "def": "The 5' most coding exon. [SO:ke]"
        },
        "SO:0000201": {
            "name": "interior_exon",
            "def": "An exon that is bounded by 5' and 3' splice sites. [PMID:10373547]"
        },
        "SO:0000202": {
            "name": "three_prime_coding_exon",
            "def": "The coding exon that is most 3-prime on a given transcript. [SO:ma]"
        },
        "SO:0000203": {
            "name": "UTR",
            "def": "Messenger RNA sequences that are untranslated and lie five prime or three prime to sequences which are translated. [SO:ke]"
        },
        "SO:0000204": {
            "name": "five_prime_UTR",
            "def": "A region at the 5' end of a mature transcript (preceding the initiation codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000205": {
            "name": "three_prime_UTR",
            "def": "A region at the 3' end of a mature transcript (following the stop codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000206": {
            "name": "SINE_element",
            "def": "A repetitive element, a few hundred base pairs long, that is dispersed throughout the genome. A common human SINE is the Alu element. [SO:ke]"
        },
        "SO:0000207": {
            "name": "simple_sequence_length_variation"
        },
        "SO:0000208": {
            "name": "terminal_inverted_repeat_element",
            "def": "A DNA transposable element defined as having termini with perfect, or nearly perfect short inverted repeats, generally 10 - 40 nucleotides long. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
        },
        "SO:0000209": {
            "name": "rRNA_primary_transcript",
            "def": "A primary transcript encoding a ribosomal RNA. [SO:ke]"
        },
        "SO:0000210": {
            "name": "tRNA_primary_transcript",
            "def": "A primary transcript encoding a transfer RNA (SO:0000253). [SO:ke]"
        },
        "SO:0000211": {
            "name": "alanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding alanyl tRNA. [SO:ke]"
        },
        "SO:0000212": {
            "name": "arginine_tRNA_primary_transcript",
            "def": "A primary transcript encoding arginyl tRNA (SO:0000255). [SO:ke]"
        },
        "SO:0000213": {
            "name": "asparagine_tRNA_primary_transcript",
            "def": "A primary transcript encoding asparaginyl tRNA (SO:0000256). [SO:ke]"
        },
        "SO:0000214": {
            "name": "aspartic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding aspartyl tRNA (SO:0000257). [SO:ke]"
        },
        "SO:0000215": {
            "name": "cysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding cysteinyl tRNA (SO:0000258). [SO:ke]"
        },
        "SO:0000216": {
            "name": "glutamic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutaminyl tRNA (SO:0000260). [SO:ke]"
        },
        "SO:0000217": {
            "name": "glutamine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutamyl tRNA (SO:0000260). [SO:ke]"
        },
        "SO:0000218": {
            "name": "glycine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glycyl tRNA (SO:0000263). [SO:ke]"
        },
        "SO:0000219": {
            "name": "histidine_tRNA_primary_transcript",
            "def": "A primary transcript encoding histidyl tRNA (SO:0000262). [SO:ke]"
        },
        "SO:0000220": {
            "name": "isoleucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding isoleucyl tRNA (SO:0000263). [SO:ke]"
        },
        "SO:0000221": {
            "name": "leucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding leucyl tRNA (SO:0000264). [SO:ke]"
        },
        "SO:0000222": {
            "name": "lysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding lysyl tRNA (SO:0000265). [SO:ke]"
        },
        "SO:0000223": {
            "name": "methionine_tRNA_primary_transcript",
            "def": "A primary transcript encoding methionyl tRNA (SO:0000266). [SO:ke]"
        },
        "SO:0000224": {
            "name": "phenylalanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding phenylalanyl tRNA (SO:0000267). [SO:ke]"
        },
        "SO:0000225": {
            "name": "proline_tRNA_primary_transcript",
            "def": "A primary transcript encoding prolyl tRNA (SO:0000268). [SO:ke]"
        },
        "SO:0000226": {
            "name": "serine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
        },
        "SO:0000227": {
            "name": "threonine_tRNA_primary_transcript",
            "def": "A primary transcript encoding threonyl tRNA (SO:000270). [SO:ke]"
        },
        "SO:0000228": {
            "name": "tryptophan_tRNA_primary_transcript",
            "def": "A primary transcript encoding tryptophanyl tRNA (SO:000271). [SO:ke]"
        },
        "SO:0000229": {
            "name": "tyrosine_tRNA_primary_transcript",
            "def": "A primary transcript encoding tyrosyl tRNA (SO:000272). [SO:ke]"
        },
        "SO:0000230": {
            "name": "valine_tRNA_primary_transcript",
            "def": "A primary transcript encoding valyl tRNA (SO:000273). [SO:ke]"
        },
        "SO:0000231": {
            "name": "snRNA_primary_transcript",
            "def": "A primary transcript encoding a small nuclear RNA (SO:0000274). [SO:ke]"
        },
        "SO:0000232": {
            "name": "snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar mRNA (SO:0000275). [SO:ke]"
        },
        "SO:0000233": {
            "name": "mature_transcript",
            "def": "A transcript which has undergone the necessary modifications, if any, for its function. In eukaryotes this includes, for example, processing of introns, cleavage, base modification, and modifications to the 5' and/or the 3' ends, other than addition of bases. In bacteria functional mRNAs are usually not modified. [SO:ke]"
        },
        "SO:0000234": {
            "name": "mRNA",
            "def": "Messenger RNA is the intermediate molecule between DNA and protein. It includes UTR and coding sequences. It does not contain introns. [SO:ma]"
        },
        "SO:0000235": {
            "name": "TF_binding_site",
            "def": "A region of a nucleotide molecule that binds a Transcription Factor or Transcription Factor complex [GO:0005667]. [SO:ke]"
        },
        "SO:0000236": {
            "name": "ORF",
            "def": "The in-frame interval between the stop codons of a reading frame which when read as sequential triplets, has the potential of encoding a sequential string of amino acids. TER(NNN)nTER. [SGD:rb, SO:ma]"
        },
        "SO:0000237": {
            "name": "transcript_attribute"
        },
        "SO:0000238": {
            "name": "foldback_element",
            "def": "A transposable element with extensive secondary structure, characterized by large modular imperfect long inverted repeats. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
        },
        "SO:0000239": {
            "name": "flanking_region",
            "def": "The sequences extending on either side of a specific region. [SO:ke]"
        },
        "SO:0000240": {
            "name": "chromosome_variation"
        },
        "SO:0000241": {
            "name": "internal_UTR",
            "def": "A UTR bordered by the terminal and initial codons of two CDSs in a polycistronic transcript. Every UTR is either 5', 3' or internal. [SO:cjm]"
        },
        "SO:0000242": {
            "name": "untranslated_region_polycistronic_mRNA",
            "def": "The untranslated sequence separating the 'cistrons' of multicistronic mRNA. [SO:ke]"
        },
        "SO:0000243": {
            "name": "internal_ribosome_entry_site",
            "def": "Sequence element that recruits a ribosomal subunit to internal mRNA for translation initiation. [SO:ke]"
        },
        "SO:0000244": {
            "name": "four_cutter_restriction_site"
        },
        "SO:0000245": {
            "name": "mRNA_by_polyadenylation_status"
        },
        "SO:0000246": {
            "name": "polyadenylated",
            "def": "A attribute describing the addition of a poly A tail to the 3' end of a mRNA molecule. [SO:ke]"
        },
        "SO:0000247": {
            "name": "mRNA_not_polyadenylated"
        },
        "SO:0000248": {
            "name": "sequence_length_variation"
        },
        "SO:0000249": {
            "name": "six_cutter_restriction_site"
        },
        "SO:0000250": {
            "name": "modified_RNA_base_feature",
            "def": "A post_transcriptionally modified base. [SO:ke]"
        },
        "SO:0000251": {
            "name": "eight_cutter_restriction_site"
        },
        "SO:0000252": {
            "name": "rRNA",
            "def": "RNA that comprises part of a ribosome, and that can provide both structural scaffolding and catalytic activity. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, ISBN:0198506732]"
        },
        "SO:0000253": {
            "name": "tRNA",
            "def": "Transfer RNA (tRNA) molecules are approximately 80 nucleotides in length. Their secondary structure includes four short double-helical elements and three loops (D, anti-codon, and T loops). Further hydrogen bonds mediate the characteristic L-shaped molecular structure. Transfer RNAs have two regions of fundamental functional importance: the anti-codon, which is responsible for specific mRNA codon recognition, and the 3' end, to which the tRNA's corresponding amino acid is attached (by aminoacyl-tRNA synthetases). Transfer RNAs cope with the degeneracy of the genetic code in two manners: having more than one tRNA (with a specific anti-codon) for a particular amino acid; and 'wobble' base-pairing, i.e. permitting non-standard base-pairing at the 3rd anti-codon position. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00005, ISBN:0198506732]"
        },
        "SO:0000254": {
            "name": "alanyl_tRNA",
            "def": "A tRNA sequence that has an alanine anticodon, and a 3' alanine binding region. [SO:ke]"
        },
        "SO:0000255": {
            "name": "rRNA_small_subunit_primary_transcript",
            "def": "A primary transcript encoding a small ribosomal subunit RNA. [SO:ke]"
        },
        "SO:0000256": {
            "name": "asparaginyl_tRNA",
            "def": "A tRNA sequence that has an asparagine anticodon, and a 3' asparagine binding region. [SO:ke]"
        },
        "SO:0000257": {
            "name": "aspartyl_tRNA",
            "def": "A tRNA sequence that has an aspartic acid anticodon, and a 3' aspartic acid binding region. [SO:ke]"
        },
        "SO:0000258": {
            "name": "cysteinyl_tRNA",
            "def": "A tRNA sequence that has a cysteine anticodon, and a 3' cysteine binding region. [SO:ke]"
        },
        "SO:0000259": {
            "name": "glutaminyl_tRNA",
            "def": "A tRNA sequence that has a glutamine anticodon, and a 3' glutamine binding region. [SO:ke]"
        },
        "SO:0000260": {
            "name": "glutamyl_tRNA",
            "def": "A tRNA sequence that has a glutamic acid anticodon, and a 3' glutamic acid binding region. [SO:ke]"
        },
        "SO:0000261": {
            "name": "glycyl_tRNA",
            "def": "A tRNA sequence that has a glycine anticodon, and a 3' glycine binding region. [SO:ke]"
        },
        "SO:0000262": {
            "name": "histidyl_tRNA",
            "def": "A tRNA sequence that has a histidine anticodon, and a 3' histidine binding region. [SO:ke]"
        },
        "SO:0000263": {
            "name": "isoleucyl_tRNA",
            "def": "A tRNA sequence that has an isoleucine anticodon, and a 3' isoleucine binding region. [SO:ke]"
        },
        "SO:0000264": {
            "name": "leucyl_tRNA",
            "def": "A tRNA sequence that has a leucine anticodon, and a 3' leucine binding region. [SO:ke]"
        },
        "SO:0000265": {
            "name": "lysyl_tRNA",
            "def": "A tRNA sequence that has a lysine anticodon, and a 3' lysine binding region. [SO:ke]"
        },
        "SO:0000266": {
            "name": "methionyl_tRNA",
            "def": "A tRNA sequence that has a methionine anticodon, and a 3' methionine binding region. [SO:ke]"
        },
        "SO:0000267": {
            "name": "phenylalanyl_tRNA",
            "def": "A tRNA sequence that has a phenylalanine anticodon, and a 3' phenylalanine binding region. [SO:ke]"
        },
        "SO:0000268": {
            "name": "prolyl_tRNA",
            "def": "A tRNA sequence that has a proline anticodon, and a 3' proline binding region. [SO:ke]"
        },
        "SO:0000269": {
            "name": "seryl_tRNA",
            "def": "A tRNA sequence that has a serine anticodon, and a 3' serine binding region. [SO:ke]"
        },
        "SO:0000270": {
            "name": "threonyl_tRNA",
            "def": "A tRNA sequence that has a threonine anticodon, and a 3' threonine binding region. [SO:ke]"
        },
        "SO:0000271": {
            "name": "tryptophanyl_tRNA",
            "def": "A tRNA sequence that has a tryptophan anticodon, and a 3' tryptophan binding region. [SO:ke]"
        },
        "SO:0000272": {
            "name": "tyrosyl_tRNA",
            "def": "A tRNA sequence that has a tyrosine anticodon, and a 3' tyrosine binding region. [SO:ke]"
        },
        "SO:0000273": {
            "name": "valyl_tRNA",
            "def": "A tRNA sequence that has a valine anticodon, and a 3' valine binding region. [SO:ke]"
        },
        "SO:0000274": {
            "name": "snRNA",
            "def": "A small nuclear RNA molecule involved in pre-mRNA splicing and processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:11733745, WB:ems]"
        },
        "SO:0000275": {
            "name": "snoRNA",
            "def": "A snoRNA (small nucleolar RNA) is any one of a class of small RNAs that are associated with the eukaryotic nucleus as components of small nucleolar ribonucleoproteins. They participate in the processing or modifications of many RNAs, mostly ribosomal RNAs (rRNAs) though snoRNAs are also known to target other classes of RNA, including spliceosomal RNAs, tRNAs, and mRNAs via a stretch of sequence that is complementary to a sequence in the targeted RNA. [GOC:kgc]"
        },
        "SO:0000276": {
            "name": "miRNA",
            "def": "Small, ~22-nt, RNA molecule that is the endogenous transcript of a miRNA gene (or the product of other non coding RNA genes. Micro RNAs are produced from precursor molecules (SO:0000647) that can form local hairpin structures, which ordinarily are processed (usually via the Dicer pathway) such that a single miRNA molecule accumulates from one arm of a hairpin precursor molecule. Micro RNAs may trigger the cleavage of their target molecules or act as translational repressors. [PMID:11081512, PMID:12592000]"
        },
        "SO:0000277": {
            "name": "bound_by_factor",
            "def": "An attribute describing a sequence that is bound by another molecule. [SO:ke]"
        },
        "SO:0000278": {
            "name": "transcript_bound_by_nucleic_acid",
            "def": "A transcript that is bound by a nucleic acid. [SO:xp]"
        },
        "SO:0000279": {
            "name": "transcript_bound_by_protein",
            "def": "A transcript that is bound by a protein. [SO:xp]"
        },
        "SO:0000280": {
            "name": "engineered_gene",
            "def": "A gene that is engineered. [SO:xp]"
        },
        "SO:0000281": {
            "name": "engineered_foreign_gene",
            "def": "A gene that is engineered and foreign. [SO:xp]"
        },
        "SO:0000282": {
            "name": "mRNA_with_minus_1_frameshift",
            "def": "An mRNA with a minus 1 frameshift. [SO:xp]"
        },
        "SO:0000283": {
            "name": "engineered_foreign_transposable_element_gene",
            "def": "A transposable_element that is engineered and foreign. [SO:xp]"
        },
        "SO:0000284": {
            "name": "type_I_enzyme_restriction_site",
            "def": "The recognition site is bipartite and interrupted. [http://www.promega.com]"
        },
        "SO:0000285": {
            "name": "foreign_gene",
            "def": "A gene that is foreign. [SO:xp]"
        },
        "SO:0000286": {
            "name": "long_terminal_repeat",
            "def": "A sequence directly repeated at both ends of a defined sequence, of the sort typically found in retroviruses. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000287": {
            "name": "fusion_gene",
            "def": "A gene that is a fusion. [SO:xp]"
        },
        "SO:0000288": {
            "name": "engineered_fusion_gene",
            "def": "A fusion gene that is engineered. [SO:xp]"
        },
        "SO:0000289": {
            "name": "microsatellite",
            "def": "A repeat_region containing repeat_units of 2 to 10 bp repeated in tandem. [http://www.informatics.jax.org/silver/glossary.shtml, NCBI:th]"
        },
        "SO:0000290": {
            "name": "dinucleotide_repeat_microsatellite_feature"
        },
        "SO:0000291": {
            "name": "trinucleotide_repeat_microsatellite_feature"
        },
        "SO:0000292": {
            "name": "repetitive_element"
        },
        "SO:0000293": {
            "name": "engineered_foreign_repetitive_element",
            "def": "A repetitive element that is engineered and foreign. [SO:xp]"
        },
        "SO:0000294": {
            "name": "inverted_repeat",
            "def": "The sequence is complementarily repeated on the opposite strand. It is a palindrome, and it may, or may not be hyphenated. Examples: GCTGATCAGC, or GCTGA-----TCAGC. [SO:ke]"
        },
        "SO:0000295": {
            "name": "U12_intron",
            "def": "A type of spliceosomal intron spliced by the U12 spliceosome, that includes U11, U12, U4atac/U6atac and U5 snRNAs. [PMID:9428511]"
        },
        "SO:0000296": {
            "name": "origin_of_replication",
            "def": "The origin of replication; starting site for duplication of a nucleic acid molecule to give two identical copies. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000297": {
            "name": "D_loop",
            "def": "Displacement loop; a region within mitochondrial DNA in which a short stretch of RNA is paired with one strand of DNA, displacing the original partner DNA strand in this region; also used to describe the displacement of a region of one strand of duplex DNA by a single stranded invader in the reaction catalyzed by RecA protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000298": {
            "name": "recombination_feature"
        },
        "SO:0000299": {
            "name": "specific_recombination_site"
        },
        "SO:0000300": {
            "name": "recombination_feature_of_rearranged_gene"
        },
        "SO:0000301": {
            "name": "vertebrate_immune_system_gene_recombination_feature"
        },
        "SO:0000302": {
            "name": "J_gene_recombination_feature",
            "def": "Recombination signal including J-heptamer, J-spacer and J-nonamer in 5' of J-region of a J-gene or J-sequence. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000303": {
            "name": "clip",
            "def": "Part of the primary transcript that is clipped off during processing. [SO:ke]"
        },
        "SO:0000304": {
            "name": "type_II_enzyme_restriction_site",
            "def": "The recognition site is either palindromic, partially palindromic or an interrupted palindrome. Cleavage occurs within the recognition site. [http://www.promega.com]"
        },
        "SO:0000305": {
            "name": "modified_DNA_base",
            "def": "A modified nucleotide, i.e. a nucleotide other than A, T, C. G. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000306": {
            "name": "methylated_DNA_base_feature",
            "def": "A nucleotide modified by methylation. [SO:ke]"
        },
        "SO:0000307": {
            "name": "CpG_island",
            "def": "Regions of a few hundred to a few thousand bases in vertebrate genomes that are relatively GC and CpG rich; they are typically unmethylated and often found near the 5' ends of genes. [SO:rd]"
        },
        "SO:0000308": {
            "name": "sequence_feature_locating_method"
        },
        "SO:0000309": {
            "name": "computed_feature"
        },
        "SO:0000310": {
            "name": "predicted_ab_initio_computation"
        },
        "SO:0000311": {
            "name": "computed_feature_by_similarity",
            "def": ". [SO:ma]"
        },
        "SO:0000312": {
            "name": "experimentally_determined",
            "def": "Attribute to describe a feature that has been experimentally verified. [SO:ke]"
        },
        "SO:0000313": {
            "name": "stem_loop",
            "def": "A double-helical region of nucleic acid formed by base-pairing between adjacent (inverted) complementary sequences. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000314": {
            "name": "direct_repeat",
            "def": "A repeat where the same sequence is repeated in the same direction. Example: GCTGA-followed by-GCTGA. [SO:ke]"
        },
        "SO:0000315": {
            "name": "TSS",
            "def": "The first base where RNA polymerase begins to synthesize the RNA transcript. [SO:ke]"
        },
        "SO:0000316": {
            "name": "CDS",
            "def": "A contiguous sequence which begins with, and includes, a start codon and ends with, and includes, a stop codon. [SO:ma]"
        },
        "SO:0000317": {
            "name": "cDNA_clone",
            "def": "Complementary DNA; A piece of DNA copied from an mRNA and spliced into a vector for propagation in a suitable host. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
        },
        "SO:0000318": {
            "name": "start_codon",
            "def": "First codon to be translated by a ribosome. [SO:ke]"
        },
        "SO:0000319": {
            "name": "stop_codon",
            "def": "In mRNA, a set of three nucleotides that indicates the end of information for protein synthesis. [SO:ke]"
        },
        "SO:0000320": {
            "name": "intronic_splice_enhancer",
            "def": "Sequences within the intron that modulate splice site selection for some introns. [SO:ke]"
        },
        "SO:0000321": {
            "name": "mRNA_with_plus_1_frameshift",
            "def": "An mRNA with a plus 1 frameshift. [SO:ke]"
        },
        "SO:0000322": {
            "name": "nuclease_hypersensitive_site"
        },
        "SO:0000323": {
            "name": "coding_start",
            "def": "The first base to be translated into protein. [SO:ke]"
        },
        "SO:0000324": {
            "name": "tag",
            "def": "A nucleotide sequence that may be used to identify a larger sequence. [SO:ke]"
        },
        "SO:0000325": {
            "name": "rRNA_large_subunit_primary_transcript",
            "def": "A primary transcript encoding a large ribosomal subunit RNA. [SO:ke]"
        },
        "SO:0000326": {
            "name": "SAGE_tag",
            "def": "A short diagnostic sequence tag, serial analysis of gene expression (SAGE), that allows the quantitative and simultaneous analysis of a large number of transcripts. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=7570003&dopt=Abstract]"
        },
        "SO:0000327": {
            "name": "coding_end",
            "def": "The last base to be translated into protein. It does not include the stop codon. [SO:ke]"
        },
        "SO:0000328": {
            "name": "microarray_oligo"
        },
        "SO:0000329": {
            "name": "mRNA_with_plus_2_frameshift",
            "def": "An mRNA with a plus 2 frameshift. [SO:xp]"
        },
        "SO:0000330": {
            "name": "conserved_region",
            "def": "Region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000331": {
            "name": "STS",
            "def": "Short (typically a few hundred base pairs) DNA sequence that has a single occurrence in a genome and whose location and base sequence are known. [http://www.biospace.com]"
        },
        "SO:0000332": {
            "name": "coding_conserved_region",
            "def": "Coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000333": {
            "name": "exon_junction",
            "def": "The boundary between two exons in a processed transcript. [SO:ke]"
        },
        "SO:0000334": {
            "name": "nc_conserved_region",
            "def": "Non-coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000335": {
            "name": "mRNA_with_minus_2_frameshift",
            "def": "A mRNA with a minus 2 frameshift. [SO:ke]"
        },
        "SO:0000336": {
            "name": "pseudogene",
            "def": "A sequence that closely resembles a known functional gene, at another locus within a genome, that is non-functional as a consequence of (usually several) mutations that prevent either its transcription or translation (or both). In general, pseudogenes result from either reverse transcription of a transcript of their \\normal\\ paralog (SO:0000043) (in which case the pseudogene typically lacks introns and includes a poly(A) tail) or from recombination (SO:0000044) (in which case the pseudogene is typically a tandem duplication of its \\normal\\ paralog). [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
        },
        "SO:0000337": {
            "name": "RNAi_reagent",
            "def": "A double stranded RNA duplex, at least 20bp long, used experimentally to inhibit gene function by RNA interference. [SO:rd]"
        },
        "SO:0000338": {
            "name": "MITE",
            "def": "A highly repetitive and short (100-500 base pair) transposable element with terminal inverted repeats (TIR) and target site duplication (TSD). MITEs do not encode proteins. [http://www.pnas.org/cgi/content/full/97/18/10083]"
        },
        "SO:0000339": {
            "name": "recombination_hotspot",
            "def": "A region in a genome which promotes recombination. [SO:rd]"
        },
        "SO:0000340": {
            "name": "chromosome",
            "def": "Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication. [SO:ma]"
        },
        "SO:0000341": {
            "name": "chromosome_band",
            "def": "A cytologically distinguishable feature of a chromosome, often made visible by staining, and usually alternating light and dark. [SO:ma]"
        },
        "SO:0000342": {
            "name": "site_specific_recombination_target_region"
        },
        "SO:0000343": {
            "name": "match",
            "def": "A region of sequence, aligned to another sequence with some statistical significance, using an algorithm such as BLAST or SIM4. [SO:ke]"
        },
        "SO:0000344": {
            "name": "splice_enhancer",
            "def": "Region of a transcript that regulates splicing. [SO:ke]"
        },
        "SO:0000345": {
            "name": "EST",
            "def": "A tag produced from a single sequencing read from a cDNA clone or PCR product; typically a few hundred base pairs long. [SO:ke]"
        },
        "SO:0000346": {
            "name": "loxP_site"
        },
        "SO:0000347": {
            "name": "nucleotide_match",
            "def": "A match against a nucleotide sequence. [SO:ke]"
        },
        "SO:0000348": {
            "name": "nucleic_acid",
            "def": "An attribute describing a sequence consisting of nucleobases bound to repeating units. The forms found in nature are deoxyribonucleic acid (DNA), where the repeating units are 2-deoxy-D-ribose rings connected to a phosphate backbone, and ribonucleic acid (RNA), where the repeating units are D-ribose rings connected to a phosphate backbone. [CHEBI:33696, RSC:cb]"
        },
        "SO:0000349": {
            "name": "protein_match",
            "def": "A match against a protein sequence. [SO:ke]"
        },
        "SO:0000350": {
            "name": "FRT_site",
            "def": "An inversion site found on the Saccharomyces cerevisiae 2 micron plasmid. [SO:ma]"
        },
        "SO:0000351": {
            "name": "synthetic_sequence",
            "def": "An attribute to decide a sequence of nucleotides, nucleotide analogs, or amino acids that has been designed by an experimenter and which may, or may not, correspond with any natural sequence. [SO:ma]"
        },
        "SO:0000352": {
            "name": "DNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a 2-deoxy-D-ribose ring connected to a phosphate backbone. [RSC:cb]"
        },
        "SO:0000353": {
            "name": "sequence_assembly",
            "def": "A sequence of nucleotides that has been algorithmically derived from an alignment of two or more different sequences. [SO:ma]"
        },
        "SO:0000354": {
            "name": "group_1_intron_homing_endonuclease_target_region",
            "def": "A region of intronic nucleotide sequence targeted by a nuclease enzyme. [SO:ke]"
        },
        "SO:0000355": {
            "name": "haplotype_block",
            "def": "A region of the genome which is co-inherited as the result of the lack of historic recombination within it. [SO:ma]"
        },
        "SO:0000356": {
            "name": "RNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a D-ribose ring connected to a phosphate backbone. [RSC:cb]"
        },
        "SO:0000357": {
            "name": "flanked",
            "def": "An attribute describing a region that is bounded either side by a particular kind of region. [SO:ke]"
        },
        "SO:0000359": {
            "name": "floxed",
            "def": "An attribute describing sequence that is flanked by Lox-P sites. [SO:ke]"
        },
        "SO:0000360": {
            "name": "codon",
            "def": "A set of (usually) three nucleotide bases in a DNA or RNA sequence, which together code for a unique amino acid or the termination of translation and are contained within the CDS. [http://www.everythingbio.com/glos/definition.php?word=codon, SO:ke]"
        },
        "SO:0000361": {
            "name": "FRT_flanked",
            "def": "An attribute to describe sequence that is flanked by the FLP recombinase recognition site, FRT. [SO:ke]"
        },
        "SO:0000362": {
            "name": "invalidated_by_chimeric_cDNA",
            "def": "A cDNA clone constructed from more than one mRNA. Usually an experimental artifact. [SO:ma]"
        },
        "SO:0000363": {
            "name": "floxed_gene",
            "def": "A transgene that is floxed. [SO:xp]"
        },
        "SO:0000364": {
            "name": "transposable_element_flanking_region",
            "def": "The region of sequence surrounding a transposable element. [SO:ke]"
        },
        "SO:0000365": {
            "name": "integron",
            "def": "A region encoding an integrase which acts at a site adjacent to it (attI_site) to insert DNA which must include but is not limited to an attC_site. [SO:as]"
        },
        "SO:0000366": {
            "name": "insertion_site",
            "def": "The junction where an insertion occurred. [SO:ke]"
        },
        "SO:0000367": {
            "name": "attI_site",
            "def": "A region within an integron, adjacent to an integrase, at which site specific recombination involving an attC_site takes place. [SO:as]"
        },
        "SO:0000368": {
            "name": "transposable_element_insertion_site",
            "def": "The junction in a genome where a transposable_element has inserted. [SO:ke]"
        },
        "SO:0000369": {
            "name": "integrase_coding_region"
        },
        "SO:0000370": {
            "name": "small_regulatory_ncRNA",
            "def": "A non-coding RNA, usually with a specific secondary structure, that acts to regulate gene expression. [SO:ma]"
        },
        "SO:0000371": {
            "name": "conjugative_transposon",
            "def": "A transposon that encodes function required for conjugation. [http://www.sci.sdsu.edu/~smaloy/Glossary/C.html]"
        },
        "SO:0000372": {
            "name": "enzymatic_RNA",
            "def": "An RNA sequence that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0000373": {
            "name": "recombinationally_inverted_gene",
            "def": "A recombinationally rearranged gene by inversion. [SO:xp]"
        },
        "SO:0000374": {
            "name": "ribozyme",
            "def": "An RNA with catalytic activity. [SO:ma]"
        },
        "SO:0000375": {
            "name": "rRNA_5_8S",
            "def": "5_8S ribosomal RNA (5. 8S rRNA) is a component of the large subunit of the eukaryotic ribosome. It is transcribed by RNA polymerase I as part of the 45S precursor that also contains 18S and 28S rRNA. Functionally, it is thought that 5.8S rRNA may be involved in ribosome translocation. It is also known to form covalent linkage to the p53 tumour suppressor protein. 5_8S rRNA is also found in archaea. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00002]"
        },
        "SO:0000376": {
            "name": "RNA_6S",
            "def": "A small (184-nt in E. coli) RNA that forms a hairpin type structure. 6S RNA associates with RNA polymerase in a highly specific manner. 6S RNA represses expression from a sigma70-dependent promoter during stationary phase. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00013]"
        },
        "SO:0000377": {
            "name": "CsrB_RsmB_RNA",
            "def": "An enterobacterial RNA that binds the CsrA protein. The CsrB RNAs contain a conserved motif CAGGXXG that is found in up to 18 copies and has been suggested to bind CsrA. The Csr regulatory system has a strong negative regulatory effect on glycogen biosynthesis, glyconeogenesis and glycogen catabolism and a positive regulatory effect on glycolysis. In other bacteria such as Erwinia caratovara the RsmA protein has been shown to regulate the production of virulence determinants, such extracellular enzymes. RsmA binds to RsmB regulatory RNA which is also a member of this family. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00018]"
        },
        "SO:0000378": {
            "name": "DsrA_RNA",
            "def": "DsrA RNA regulates both transcription, by overcoming transcriptional silencing by the nucleoid-associated H-NS protein, and translation, by promoting efficient translation of the stress sigma factor, RpoS. These two activities of DsrA can be separated by mutation: the first of three stem-loops of the 85 nucleotide RNA is necessary for RpoS translation but not for anti-H-NS action, while the second stem-loop is essential for antisilencing and less critical for RpoS translation. The third stem-loop, which behaves as a transcription terminator, can be substituted by the trp transcription terminator without loss of either DsrA function. The sequence of the first stem-loop of DsrA is complementary with the upstream leader portion of RpoS messenger RNA, suggesting that pairing of DsrA with the RpoS message might be important for translational regulation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00014]"
        },
        "SO:0000379": {
            "name": "GcvB_RNA",
            "def": "A small untranslated RNA involved in expression of the dipeptide and oligopeptide transport systems in Escherichia coli. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00022]"
        },
        "SO:0000380": {
            "name": "hammerhead_ribozyme",
            "def": "A small catalytic RNA motif that catalyzes self-cleavage reaction. Its name comes from its secondary structure which resembles a carpenter's hammer. The hammerhead ribozyme is involved in the replication of some viroid and some satellite RNAs. [PMID:2436805]"
        },
        "SO:0000381": {
            "name": "group_IIA_intron"
        },
        "SO:0000382": {
            "name": "group_IIB_intron"
        },
        "SO:0000383": {
            "name": "MicF_RNA",
            "def": "A non-translated 93 nt antisense RNA that binds its target ompF mRNA and regulates ompF expression by inhibiting translation and inducing degradation of the message. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00033]"
        },
        "SO:0000384": {
            "name": "OxyS_RNA",
            "def": "A small untranslated RNA which is induced in response to oxidative stress in Escherichia coli. Acts as a global regulator to activate or repress the expression of as many as 40 genes, including the fhlA-encoded transcriptional activator and the rpoS-encoded sigma(s) subunit of RNA polymerase. OxyS is bound by the Hfq protein, that increases the OxyS RNA interaction with its target messages. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00035]"
        },
        "SO:0000385": {
            "name": "RNase_MRP_RNA",
            "def": "The RNA molecule essential for the catalytic activity of RNase MRP, an enzymatically active ribonucleoprotein with two distinct roles in eukaryotes. In mitochondria it plays a direct role in the initiation of mitochondrial DNA replication. In the nucleus it is involved in precursor rRNA processing, where it cleaves the internal transcribed spacer 1 between 18S and 5.8S rRNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00030]"
        },
        "SO:0000386": {
            "name": "RNase_P_RNA",
            "def": "The RNA component of Ribonuclease P (RNase P), a ubiquitous endoribonuclease, found in archaea, bacteria and eukarya as well as chloroplasts and mitochondria. Its best characterized activity is the generation of mature 5 prime ends of tRNAs by cleaving the 5 prime leader elements of precursor-tRNAs. Cellular RNase Ps are ribonucleoproteins. RNA from bacterial RNase Ps retains its catalytic activity in the absence of the protein subunit, i.e. it is a ribozyme. Isolated eukaryotic and archaeal RNase P RNA has not been shown to retain its catalytic function, but is still essential for the catalytic activity of the holoenzyme. Although the archaeal and eukaryotic holoenzymes have a much greater protein content than the bacterial ones, the RNA cores from all the three lineages are homologous. Helices corresponding to P1, P2, P3, P4, and P10/11 are common to all cellular RNase P RNAs. Yet, there is considerable sequence variation, particularly among the eukaryotic RNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00010]"
        },
        "SO:0000387": {
            "name": "RprA_RNA",
            "def": "Translational regulation of the stationary phase sigma factor RpoS is mediated by the formation of a double-stranded RNA stem-loop structure in the upstream region of the rpoS messenger RNA, occluding the translation initiation site. Clones carrying rprA (RpoS regulator RNA) increased the translation of RpoS. The rprA gene encodes a 106 nucleotide regulatory RNA. As with DsrA Rfam:RF00014, RprA is predicted to form three stem-loops. Thus, at least two small RNAs, DsrA and RprA, participate in the positive regulation of RpoS translation. Unlike DsrA, RprA does not have an extensive region of complementarity to the RpoS leader, leaving its mechanism of action unclear. RprA is non-essential. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00034]"
        },
        "SO:0000388": {
            "name": "RRE_RNA",
            "def": "The Rev response element (RRE) is encoded within the HIV-env gene. Rev is an essential regulatory protein of HIV that binds an internal loop of the RRE leading, encouraging further Rev-RRE binding. This RNP complex is critical for mRNA export and hence for expression of the HIV structural proteins. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00036]"
        },
        "SO:0000389": {
            "name": "spot_42_RNA",
            "def": "A 109-nucleotide RNA of E. coli that seems to have a regulatory role on the galactose operon. Changes in Spot 42 levels are implicated in affecting DNA polymerase I levels. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00021]"
        },
        "SO:0000390": {
            "name": "telomerase_RNA",
            "def": "The RNA component of telomerase, a reverse transcriptase that synthesizes telomeric DNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00025]"
        },
        "SO:0000391": {
            "name": "U1_snRNA",
            "def": "U1 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Its 5' end forms complementary base pairs with the 5' splice junction, thus defining the 5' donor site of an intron. There are significant differences in sequence and secondary structure between metazoan and yeast U1 snRNAs, the latter being much longer (568 nucleotides as compared to 164 nucleotides in human). Nevertheless, secondary structure predictions suggest that all U1 snRNAs share a 'common core' consisting of helices I, II, the proximal region of III, and IV. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00003]"
        },
        "SO:0000392": {
            "name": "U2_snRNA",
            "def": "U2 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Complementary binding between U2 snRNA (in an area lying towards the 5' end but 3' to hairpin I) and the branchpoint sequence (BPS) of the intron results in the bulging out of an unpaired adenine, on the BPS, which initiates a nucleophilic attack at the intronic 5' splice site, thus starting the first of two transesterification reactions that mediate splicing. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00004]"
        },
        "SO:0000393": {
            "name": "U4_snRNA",
            "def": "U4 small nuclear RNA (U4 snRNA) is a component of the major U2-dependent spliceosome. It forms a duplex with U6, and with each splicing round, it is displaced from U6 (and the spliceosome) in an ATP-dependent manner, allowing U6 to refold and create the active site for splicing catalysis. A recycling process involving protein Prp24 re-anneals U4 and U6. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
        },
        "SO:0000394": {
            "name": "U4atac_snRNA",
            "def": "An snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U6atac_snRNA (SO:0000397). [PMID:=12409455]"
        },
        "SO:0000395": {
            "name": "U5_snRNA",
            "def": "U5 RNA is a component of both types of known spliceosome. The precise function of this molecule is unknown, though it is known that the 5' loop is required for splice site selection and p220 binding, and that both the 3' stem-loop and the Sm site are important for Sm protein binding and cap methylation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00020]"
        },
        "SO:0000396": {
            "name": "U6_snRNA",
            "def": "U6 snRNA is a component of the spliceosome which is involved in splicing pre-mRNA. The putative secondary structure consensus base pairing is confined to a short 5' stem loop, but U6 snRNA is thought to form extensive base-pair interactions with U4 snRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
        },
        "SO:0000397": {
            "name": "U6atac_snRNA",
            "def": "U6atac_snRNA is an snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U4atac_snRNA (SO:0000394). [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=retrieve&db=pubmed&list_uids=12409455&dopt=Abstract]"
        },
        "SO:0000398": {
            "name": "U11_snRNA",
            "def": "U11 snRNA plays a role in splicing of the minor U12-dependent class of eukaryotic nuclear introns, similar to U1 snRNA in the major class spliceosome it base pairs to the conserved 5' splice site sequence. [PMID:9622129]"
        },
        "SO:0000399": {
            "name": "U12_snRNA",
            "def": "The U12 small nuclear (snRNA), together with U4atac/U6atac, U5, and U11 snRNAs and associated proteins, forms a spliceosome that cleaves a divergent class of low-abundance pre-mRNA introns. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00007]"
        },
        "SO:0000400": {
            "name": "sequence_attribute",
            "def": "An attribute describes a quality of sequence. [SO:ke]"
        },
        "SO:0000401": {
            "name": "gene_attribute"
        },
        "SO:0000402": {
            "name": "enhancer_attribute"
        },
        "SO:0000403": {
            "name": "U14_snoRNA",
            "def": "U14 small nucleolar RNA (U14 snoRNA) is required for early cleavages of eukaryotic precursor rRNAs. In yeasts, this molecule possess a stem-loop region (known as the Y-domain) which is essential for function. A similar structure, but with a different consensus sequence, is found in plants, but is absent in vertebrates. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00016, PMID:2551119]"
        },
        "SO:0000404": {
            "name": "vault_RNA",
            "def": "A family of RNAs are found as part of the enigmatic vault ribonucleoprotein complex. The complex consists of a major vault protein (MVP), two minor vault proteins (VPARP and TEP1), and several small untranslated RNA molecules. It has been suggested that the vault complex is involved in drug resistance. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00006]"
        },
        "SO:0000405": {
            "name": "Y_RNA",
            "def": "Y RNAs are components of the Ro ribonucleoprotein particle (Ro RNP), in association with Ro60 and La proteins. The Y RNAs and Ro60 and La proteins are well conserved, but the function of the Ro RNP is not known. In humans the RNA component can be one of four small RNAs: hY1, hY3, hY4 and hY5. These small RNAs are predicted to fold into a conserved secondary structure containing three stem structures. The largest of the four, hY1, contains an additional hairpin. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00019]"
        },
        "SO:0000406": {
            "name": "twintron",
            "def": "An intron within an intron. Twintrons are group II or III introns, into which another group II or III intron has been transposed. [PMID:1899376, PMID:7823908]"
        },
        "SO:0000407": {
            "name": "rRNA_18S",
            "def": "A large polynucleotide in eukaryotes, which functions as the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0000408": {
            "name": "site",
            "def": "The interbase position where something (eg an aberration) occurred. [SO:ke]"
        },
        "SO:0000409": {
            "name": "binding_site",
            "def": "A biological_region of sequence that, in the molecule, interacts selectively and non-covalently with other molecules. A region on the surface of a molecule that may interact with another molecule. When applied to polypeptides: Amino acids involved in binding or interactions. It can also apply to an amino acid bond which is represented by the positions of the two flanking amino acids. [EBIBS:GAR, SO:ke]"
        },
        "SO:0000410": {
            "name": "protein_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with polypeptide molecules. [SO:ke]"
        },
        "SO:0000411": {
            "name": "rescue_region",
            "def": "A region that rescues. [SO:xp]"
        },
        "SO:0000412": {
            "name": "restriction_fragment",
            "def": "A region of polynucleotide sequence produced by digestion with a restriction endonuclease. [SO:ke]"
        },
        "SO:0000413": {
            "name": "sequence_difference",
            "def": "A region where the sequence differs from that of a specified sequence. [SO:ke]"
        },
        "SO:0000414": {
            "name": "invalidated_by_genomic_contamination",
            "def": "An attribute to describe a feature that is invalidated due to genomic contamination. [SO:ke]"
        },
        "SO:0000415": {
            "name": "invalidated_by_genomic_polyA_primed_cDNA",
            "def": "An attribute to describe a feature that is invalidated due to polyA priming. [SO:ke]"
        },
        "SO:0000416": {
            "name": "invalidated_by_partial_processing",
            "def": "An attribute to describe a feature that is invalidated due to partial processing. [SO:ke]"
        },
        "SO:0000417": {
            "name": "polypeptide_domain",
            "def": "A structurally or functionally defined protein region. In proteins with multiple domains, the combination of the domains determines the function of the protein. A region which has been shown to recur throughout evolution. [EBIBS:GAR]"
        },
        "SO:0000418": {
            "name": "signal_peptide",
            "def": "The signal_peptide is a short region of the peptide located at the N-terminus that directs the protein to be secreted or part of membrane components. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000419": {
            "name": "mature_protein_region",
            "def": "The polypeptide sequence that remains when the cleaved peptide regions have been cleaved from the immature peptide. [EBIBS:GAR, http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, SO:cb]"
        },
        "SO:0000420": {
            "name": "five_prime_terminal_inverted_repeat"
        },
        "SO:0000421": {
            "name": "three_prime_terminal_inverted_repeat"
        },
        "SO:0000422": {
            "name": "U5_LTR_region"
        },
        "SO:0000423": {
            "name": "R_LTR_region"
        },
        "SO:0000424": {
            "name": "U3_LTR_region"
        },
        "SO:0000425": {
            "name": "five_prime_LTR"
        },
        "SO:0000426": {
            "name": "three_prime_LTR"
        },
        "SO:0000427": {
            "name": "R_five_prime_LTR_region"
        },
        "SO:0000428": {
            "name": "U5_five_prime_LTR_region"
        },
        "SO:0000429": {
            "name": "U3_five_prime_LTR_region"
        },
        "SO:0000430": {
            "name": "R_three_prime_LTR_region"
        },
        "SO:0000431": {
            "name": "U3_three_prime_LTR_region"
        },
        "SO:0000432": {
            "name": "U5_three_prime_LTR_region"
        },
        "SO:0000433": {
            "name": "non_LTR_retrotransposon_polymeric_tract",
            "def": "A polymeric tract, such as poly(dA), within a non_LTR_retrotransposon. [SO:ke]"
        },
        "SO:0000434": {
            "name": "target_site_duplication",
            "def": "A sequence of the target DNA that is duplicated when a transposable element or phage inserts; usually found at each end the insertion. [http://www.koko.gov.my/CocoaBioTech/Glossaryt.html]"
        },
        "SO:0000435": {
            "name": "RR_tract",
            "def": "A polypurine tract within an LTR_retrotransposon. [SO:ke]"
        },
        "SO:0000436": {
            "name": "ARS",
            "def": "A sequence that can autonomously replicate, as a plasmid, when transformed into a bacterial host. [SO:ma]"
        },
        "SO:0000437": {
            "name": "assortment_derived_duplication"
        },
        "SO:0000438": {
            "name": "gene_not_polyadenylated"
        },
        "SO:0000439": {
            "name": "inverted_ring_chromosome"
        },
        "SO:0000440": {
            "name": "vector_replicon",
            "def": "A replicon that has been modified to act as a vector for foreign sequence. [SO:ma]"
        },
        "SO:0000441": {
            "name": "ss_oligo",
            "def": "A single stranded oligonucleotide. [SO:ke]"
        },
        "SO:0000442": {
            "name": "ds_oligo",
            "def": "A double stranded oligonucleotide. [SO:ke]"
        },
        "SO:0000443": {
            "name": "polymer_attribute",
            "def": "An attribute to describe the kind of biological sequence. [SO:ke]"
        },
        "SO:0000444": {
            "name": "three_prime_noncoding_exon",
            "def": "Non-coding exon in the 3' UTR. [SO:ke]"
        },
        "SO:0000445": {
            "name": "five_prime_noncoding_exon",
            "def": "Non-coding exon in the 5' UTR. [SO:ke]"
        },
        "SO:0000446": {
            "name": "UTR_intron",
            "def": "Intron located in the untranslated region. [SO:ke]"
        },
        "SO:0000447": {
            "name": "five_prime_UTR_intron",
            "def": "An intron located in the 5' UTR. [SO:ke]"
        },
        "SO:0000448": {
            "name": "three_prime_UTR_intron",
            "def": "An intron located in the 3' UTR. [SO:ke]"
        },
        "SO:0000449": {
            "name": "random_sequence",
            "def": "A sequence of nucleotides or amino acids which, by design, has a \\random\\ order of components, given a predetermined input frequency of these components. [SO:ma]"
        },
        "SO:0000450": {
            "name": "interband",
            "def": "A light region between two darkly staining bands in a polytene chromosome. [SO:ma]"
        },
        "SO:0000451": {
            "name": "gene_with_polyadenylated_mRNA",
            "def": "A gene that encodes a polyadenylated mRNA. [SO:xp]"
        },
        "SO:0000452": {
            "name": "transgene_attribute"
        },
        "SO:0000453": {
            "name": "chromosomal_transposition",
            "def": "A chromosome structure variant whereby a region of a chromosome has been transferred to another position. Among interchromosomal rearrangements, the term transposition is reserved for that class in which the telomeres of the chromosomes involved are coupled (that is to say, form the two ends of a single DNA molecule) as in wild-type. [FB:reference_manual, SO:ke]"
        },
        "SO:0000454": {
            "name": "rasiRNA",
            "def": "A 17-28-nt, small interfering RNA derived from transcripts of repetitive elements. [http://www.developmentalcell.com/content/article/abstract?uid=PIIS1534580703002284]"
        },
        "SO:0000455": {
            "name": "gene_with_mRNA_with_frameshift",
            "def": "A gene that encodes an mRNA with a frameshift. [SO:xp]"
        },
        "SO:0000456": {
            "name": "recombinationally_rearranged_gene",
            "def": "A gene that is recombinationally rearranged. [SO:ke]"
        },
        "SO:0000457": {
            "name": "interchromosomal_duplication",
            "def": "A chromosome duplication involving an insertion from another chromosome. [SO:ke]"
        },
        "SO:0000458": {
            "name": "D_gene_segment",
            "def": "Germline genomic DNA including D-region with 5' UTR and 3' UTR, also designated as D-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000459": {
            "name": "gene_with_trans_spliced_transcript",
            "def": "A gene with a transcript that is trans-spliced. [SO:xp]"
        },
        "SO:0000460": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_segment"
        },
        "SO:0000461": {
            "name": "inversion_derived_bipartite_deficiency",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at each end of the inversion. [FB:km]"
        },
        "SO:0000462": {
            "name": "pseudogenic_region",
            "def": "A non-functional descendant of a functional entity. [SO:cjm]"
        },
        "SO:0000463": {
            "name": "encodes_alternately_spliced_transcripts",
            "def": "A gene that encodes more than one transcript. [SO:ke]"
        },
        "SO:0000464": {
            "name": "decayed_exon",
            "def": "A non-functional descendant of an exon. [SO:ke]"
        },
        "SO:0000465": {
            "name": "inversion_derived_deficiency_plus_duplication",
            "def": "A chromosome deletion whereby a chromosome is generated by recombination between two inversions; there is a deficiency at one end of the inversion and a duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000466": {
            "name": "V_gene_segment",
            "def": "Germline genomic DNA including L-part1, V-intron and V-exon, with the 5' UTR and 3' UTR. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000467": {
            "name": "post_translationally_regulated_by_protein_stability",
            "def": "An attribute describing a gene sequence where the resulting protein is regulated by the stability of the resulting protein. [SO:ke]"
        },
        "SO:0000468": {
            "name": "golden_path_fragment",
            "def": "One of the pieces of sequence that make up a golden path. [SO:rd]"
        },
        "SO:0000469": {
            "name": "post_translationally_regulated_by_protein_modification",
            "def": "An attribute describing a gene sequence where the resulting protein is modified to regulate it. [SO:ke]"
        },
        "SO:0000470": {
            "name": "J_gene_segment",
            "def": "Germline genomic DNA of an immunoglobulin/T-cell receptor gene including J-region with 5' UTR (SO:0000204) and 3' UTR (SO:0000205), also designated as J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000471": {
            "name": "autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation. [SO:ke]"
        },
        "SO:0000472": {
            "name": "tiling_path",
            "def": "A set of regions which overlap with minimal polymorphism to form a linear sequence. [SO:cjm]"
        },
        "SO:0000473": {
            "name": "negatively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation where it decreases transcription. [SO:ke]"
        },
        "SO:0000474": {
            "name": "tiling_path_fragment",
            "def": "A piece of sequence that makes up a tiling_path (SO:0000472). [SO:ke]"
        },
        "SO:0000475": {
            "name": "positively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation, where it increases transcription. [SO:ke]"
        },
        "SO:0000476": {
            "name": "contig_read",
            "def": "A DNA sequencer read which is part of a contig. [SO:ke]"
        },
        "SO:0000477": {
            "name": "polycistronic_gene",
            "def": "A gene that is polycistronic. [SO:ke]"
        },
        "SO:0000478": {
            "name": "C_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including C-region (and introns if present) with 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000479": {
            "name": "trans_spliced_transcript",
            "def": "A transcript that is trans-spliced. [SO:xp]"
        },
        "SO:0000480": {
            "name": "tiling_path_clone",
            "def": "A clone which is part of a tiling path. A tiling path is a set of sequencing substrates, typically clones, which have been selected in order to efficiently cover a region of the genome in preparation for sequencing and assembly. [SO:ke]"
        },
        "SO:0000481": {
            "name": "terminal_inverted_repeat",
            "def": "An inverted repeat (SO:0000294) occurring at the termini of a DNA transposon. [SO:ke]"
        },
        "SO:0000482": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_gene_cluster"
        },
        "SO:0000483": {
            "name": "nc_primary_transcript",
            "def": "A primary transcript that is never translated into a protein. [SO:ke]"
        },
        "SO:0000484": {
            "name": "three_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 3' exon that is not coding. [SO:ke]"
        },
        "SO:0000485": {
            "name": "DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000486": {
            "name": "five_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 5' exon preceding the start codon. [SO:ke]"
        },
        "SO:0000487": {
            "name": "VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000488": {
            "name": "VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000489": {
            "name": "VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000490": {
            "name": "VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000491": {
            "name": "VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000492": {
            "name": "D_gene_recombination_feature"
        },
        "SO:0000493": {
            "name": "three_prime_D_heptamer",
            "def": "7 nucleotide recombination site like CACAGTG, part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000494": {
            "name": "three_prime_D_nonamer",
            "def": "A 9 nucleotide recombination site (e.g. ACAAAAACC), part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000495": {
            "name": "three_prime_D_spacer",
            "def": "A 12 or 23 nucleotide spacer between the 3'D-HEPTAMER and 3'D-NONAMER of a 3'D-RS. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000496": {
            "name": "five_prime_D_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACTGTG), part of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000497": {
            "name": "five_prime_D_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a five_prime_D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000498": {
            "name": "five_prime_D_spacer",
            "def": "12 or 23 nucleotide spacer between the 5' D-heptamer (SO:0000496) and 5' D-nonamer (SO:0000497) of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000499": {
            "name": "virtual_sequence",
            "def": "A continuous piece of sequence similar to the 'virtual contig' concept of the Ensembl database. [SO:ke]"
        },
        "SO:0000500": {
            "name": "Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. This is less energetically favourable than watson crick base pairing. Hoogsteen GC base pairs only have two hydrogen bonds. [PMID:12177293]"
        },
        "SO:0000501": {
            "name": "reverse_Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. [SO:ke]"
        },
        "SO:0000502": {
            "name": "transcribed_region",
            "def": "A region of sequence that is transcribed. This region may cover the transcript of a gene, it may emcompas the sequence covered by all of the transcripts of a alternately spliced gene, or it may cover the region transcribed by a polycistronic transcript. A gene may have 1 or more transcribed regions and a transcribed_region may belong to one or more genes. [SO:ke]"
        },
        "SO:0000503": {
            "name": "alternately_spliced_gene_encodeing_one_transcript"
        },
        "SO:0000504": {
            "name": "D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000505": {
            "name": "D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000506": {
            "name": "D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000507": {
            "name": "pseudogenic_exon",
            "def": "A non functional descendant of an exon, part of a pseudogene. [SO:ke]"
        },
        "SO:0000508": {
            "name": "D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000509": {
            "name": "D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000510": {
            "name": "VD_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including L-part1, V-intron and V-D-exon, with the 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000511": {
            "name": "J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000512": {
            "name": "inversion_derived_deficiency_plus_aneuploid",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000513": {
            "name": "J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000514": {
            "name": "J_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000515": {
            "name": "J_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000516": {
            "name": "pseudogenic_transcript",
            "def": "A non functional descendant of a transcript, part of a pseudogene. [SO:ke]"
        },
        "SO:0000517": {
            "name": "J_spacer",
            "def": "12 or 23 nucleotide spacer between the J-nonamer and the J-heptamer of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000518": {
            "name": "V_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000519": {
            "name": "V_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000520": {
            "name": "V_VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000521": {
            "name": "V_VDJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VDJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000522": {
            "name": "V_VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000523": {
            "name": "V_VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000524": {
            "name": "V_VJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000525": {
            "name": "V_VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000526": {
            "name": "V_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one V-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000527": {
            "name": "V_D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000528": {
            "name": "V_D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000529": {
            "name": "V_D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000530": {
            "name": "V_D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000531": {
            "name": "V_D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000532": {
            "name": "V_D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000533": {
            "name": "V_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000534": {
            "name": "V_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000535": {
            "name": "V_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000536": {
            "name": "V_nonamer",
            "def": "9 nucleotide recombination site (e.g. ACAAAAACC), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000537": {
            "name": "V_spacer",
            "def": "12 or 23 nucleotide spacer between the V-heptamer and the V-nonamer of a V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000538": {
            "name": "V_gene_recombination_feature",
            "def": "Recombination signal including V-heptamer, V-spacer and V-nonamer in 3' of V-region of a V-gene or V-sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000539": {
            "name": "DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000540": {
            "name": "DJ_J_C_cluster",
            "def": "Genomic DNA in rearranged configuration including at least one D-J-GENE, one J-GENE and one C-GENE. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000541": {
            "name": "VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000542": {
            "name": "V_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000543": {
            "name": "alternately_spliced_gene_encoding_greater_than_one_transcript"
        },
        "SO:0000544": {
            "name": "helitron",
            "def": "A rolling circle transposon. Autonomous helitrons encode a 5'-to-3' DNA helicase and nuclease/ligase similar to those encoded by known rolling-circle replicons. [http://www.pnas.org/cgi/content/full/100/11/6569]"
        },
        "SO:0000545": {
            "name": "recoding_pseudoknot",
            "def": "The pseudoknots involved in recoding are unique in that, as they play their role as a structure, they are immediately unfolded and their now linear sequence serves as a template for decoding. [http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=33937]"
        },
        "SO:0000546": {
            "name": "designed_sequence"
        },
        "SO:0000547": {
            "name": "inversion_derived_bipartite_duplication",
            "def": "A chromosome generated by recombination between two inversions; there is a duplication at each end of the inversion. [FB:km]"
        },
        "SO:0000548": {
            "name": "gene_with_edited_transcript",
            "def": "A gene that encodes a transcript that is edited. [SO:xp]"
        },
        "SO:0000549": {
            "name": "inversion_derived_duplication_plus_aneuploid",
            "def": "A chromosome generated by recombination between two inversions; has a duplication at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000550": {
            "name": "aneuploid_chromosome",
            "def": "A chromosome structural variation whereby either a chromosome exists in addition to the normal chromosome complement or is lacking. [SO:ke]"
        },
        "SO:0000551": {
            "name": "polyA_signal_sequence",
            "def": "The recognition sequence necessary for endonuclease cleavage of an RNA transcript that is followed by polyadenylation; consensus=AATAAA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000552": {
            "name": "Shine_Dalgarno_sequence",
            "def": "A region in the 5' UTR that pairs with the 16S rRNA during formation of the preinitiation complex. [SO:jh]"
        },
        "SO:0000553": {
            "name": "polyA_site",
            "def": "The site on an RNA transcript to which will be added adenine residues by post-transcriptional polyadenylation. The boundary between the UTR and the polyA sequence. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000554": {
            "name": "assortment_derived_deficiency_plus_duplication"
        },
        "SO:0000555": {
            "name": "five_prime_clip",
            "def": "5' most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000556": {
            "name": "five_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 5' D-nonamer (SO:0000497), 5' D-spacer (SO:0000498), and 5' D-heptamer (SO:0000396) in 5' of the D-region of a D-gene, or in 5' of the D-region of DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000557": {
            "name": "three_prime_clip",
            "def": "3'-most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000558": {
            "name": "C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including more than one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000559": {
            "name": "D_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000560": {
            "name": "D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000561": {
            "name": "heptamer_of_recombination_feature_of_vertebrate_immune_system_gene",
            "def": "Seven nucleotide recombination site (e.g. CACAGTG), part of V-gene, D-gene or J-gene recombination feature of an immunoglobulin or T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000562": {
            "name": "nonamer_of_recombination_feature_of_vertebrate_immune_system_gene"
        },
        "SO:0000563": {
            "name": "vertebrate_immune_system_gene_recombination_spacer"
        },
        "SO:0000564": {
            "name": "V_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000565": {
            "name": "V_VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000566": {
            "name": "V_VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000567": {
            "name": "inversion_derived_aneuploid_chromosome",
            "def": "A chromosome may be generated by recombination between two inversions; presumed to have a deficiency or duplication at each end of the inversion. [FB:km]"
        },
        "SO:0000568": {
            "name": "bidirectional_promoter",
            "def": "An unregulated promoter that allows continuous expression. [SO:ke]"
        },
        "SO:0000569": {
            "name": "retrotransposed",
            "def": "An attribute of a feature that occurred as the product of a reverse transcriptase mediated event. [SO:ke]"
        },
        "SO:0000570": {
            "name": "three_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 3' D-heptamer (SO:0000493), 3' D-spacer, and 3' D-nonamer (SO:0000494) in 3' of the D-region of a D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000571": {
            "name": "miRNA_encoding"
        },
        "SO:0000572": {
            "name": "DJ_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including D-J-region with 5' UTR and 3' UTR, also designated as D-J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000573": {
            "name": "rRNA_encoding"
        },
        "SO:0000574": {
            "name": "VDJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-D-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000575": {
            "name": "scRNA_encoding"
        },
        "SO:0000576": {
            "name": "VJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000577": {
            "name": "centromere",
            "def": "A region of chromosome where the spindle fibers attach during mitosis and meiosis. [SO:ke]"
        },
        "SO:0000578": {
            "name": "snoRNA_encoding"
        },
        "SO:0000579": {
            "name": "edited_transcript_feature",
            "def": "A locatable feature on a transcript that is edited. [SO:ma]"
        },
        "SO:0000580": {
            "name": "methylation_guide_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a methylation guide small nucleolar RNA. [SO:ke]"
        },
        "SO:0000581": {
            "name": "cap",
            "def": "A structure consisting of a 7-methylguanosine in 5'-5' triphosphate linkage with the first nucleotide of an mRNA. It is added post-transcriptionally, and is not encoded in the DNA. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
        },
        "SO:0000582": {
            "name": "rRNA_cleavage_snoRNA_primary_transcript",
            "def": "A primary transcript encoding an rRNA cleavage snoRNA. [SO:ke]"
        },
        "SO:0000583": {
            "name": "pre_edited_region",
            "def": "The region of a transcript that will be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000584": {
            "name": "tmRNA",
            "def": "A tmRNA liberates a mRNA from a stalled ribosome. To accomplish this part of the tmRNA is used as a reading frame that ends in a translation stop signal. The broken mRNA is replaced in the ribosome by the tmRNA and translation of the tmRNA leads to addition of a proteolysis tag to the incomplete protein enabling recognition by a protease. Recently a number of permuted tmRNAs genes have been found encoded in two parts. TmRNAs have been identified in eubacteria and some chloroplasts but are absent from archeal and Eukaryote nuclear genomes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00023]"
        },
        "SO:0000585": {
            "name": "C_D_box_snoRNA_encoding"
        },
        "SO:0000586": {
            "name": "tmRNA_primary_transcript",
            "def": "A primary transcript encoding a tmRNA (SO:0000584). [SO:ke]"
        },
        "SO:0000587": {
            "name": "group_I_intron",
            "def": "Group I catalytic introns are large self-splicing ribozymes. They catalyze their own excision from mRNA, tRNA and rRNA precursors in a wide range of organisms. The core secondary structure consists of 9 paired regions (P1-P9). These fold to essentially two domains, the P4-P6 domain (formed from the stacking of P5, P4, P6 and P6a helices) and the P3-P9 domain (formed from the P8, P3, P7 and P9 helices). Group I catalytic introns often have long ORFs inserted in loop regions. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00028]"
        },
        "SO:0000588": {
            "name": "autocatalytically_spliced_intron",
            "def": "A self spliced intron. [SO:ke]"
        },
        "SO:0000589": {
            "name": "SRP_RNA_primary_transcript",
            "def": "A primary transcript encoding a signal recognition particle RNA. [SO:ke]"
        },
        "SO:0000590": {
            "name": "SRP_RNA",
            "def": "The signal recognition particle (SRP) is a universally conserved ribonucleoprotein. It is involved in the co-translational targeting of proteins to membranes. The eukaryotic SRP consists of a 300-nucleotide 7S RNA and six proteins: SRPs 72, 68, 54, 19, 14, and 9. Archaeal SRP consists of a 7S RNA and homologues of the eukaryotic SRP19 and SRP54 proteins. In most eubacteria, the SRP consists of a 4.5S RNA and the Ffh protein (a homologue of the eukaryotic SRP54 protein). Eukaryotic and archaeal 7S RNAs have very similar secondary structures, with eight helical elements. These fold into the Alu and S domains, separated by a long linker region. Eubacterial SRP is generally a simpler structure, with the M domain of Ffh bound to a region of the 4.5S RNA that corresponds to helix 8 of the eukaryotic and archaeal SRP S domain. Some Gram-positive bacteria (e.g. Bacillus subtilis), however, have a larger SRP RNA that also has an Alu domain. The Alu domain is thought to mediate the peptide chain elongation retardation function of the SRP. The universally conserved helix which interacts with the SRP54/Ffh M domain mediates signal sequence recognition. In eukaryotes and archaea, the SRP19-helix 6 complex is thought to be involved in SRP assembly and stabilizes helix 8 for SRP54 binding. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00017]"
        },
        "SO:0000591": {
            "name": "pseudoknot",
            "def": "A tertiary structure in RNA where nucleotides in a loop form base pairs with a region of RNA downstream of the loop. [RSC:cb]"
        },
        "SO:0000592": {
            "name": "H_pseudoknot",
            "def": "A pseudoknot which contains two stems and at least two loops. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=10334330&dopt=Abstract]"
        },
        "SO:0000593": {
            "name": "C_D_box_snoRNA",
            "def": "Most box C/D snoRNAs also contain long (>10 nt) sequences complementary to rRNA. Boxes C and D, as well as boxes C' and D', are usually located in close proximity, and form a structure known as the box C/D motif. This motif is important for snoRNA stability, processing, nucleolar targeting and function. A small number of box C/D snoRNAs are involved in rRNA processing; most, however, are known or predicted to serve as guide RNAs in ribose methylation of rRNA. Targeting involves direct base pairing of the snoRNA at the rRNA site to be modified and selection of a rRNA nucleotide a fixed distance from box D or D'. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
        },
        "SO:0000594": {
            "name": "H_ACA_box_snoRNA",
            "def": "Members of the box H/ACA family contain an ACA triplet, exactly 3 nt upstream from the 3' end and an H-box in a hinge region that links two structurally similar functional domains of the molecule. Both boxes are important for snoRNA biosynthesis and function. A few box H/ACA snoRNAs are involved in rRNA processing; most others are known or predicted to participate in selection of uridine nucleosides in rRNA to be converted to pseudouridines. Site selection is mediated by direct base pairing of the snoRNA with rRNA through one or both targeting domains. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
        },
        "SO:0000595": {
            "name": "C_D_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box C/D family. [SO:ke]"
        },
        "SO:0000596": {
            "name": "H_ACA_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box H/ACA family. [SO:ke]"
        },
        "SO:0000597": {
            "name": "transcript_edited_by_U_insertion/deletion",
            "def": "The insertion and deletion of uridine (U) residues, usually within coding regions of mRNA transcripts of cryptogenes in the mitochondrial genome of kinetoplastid protozoa. [http://www.rna.ucla.edu/index.html]"
        },
        "SO:0000598": {
            "name": "edited_by_C_insertion_and_dinucleotide_insertion"
        },
        "SO:0000599": {
            "name": "edited_by_C_to_U_substitution"
        },
        "SO:0000600": {
            "name": "edited_by_A_to_I_substitution"
        },
        "SO:0000601": {
            "name": "edited_by_G_addition"
        },
        "SO:0000602": {
            "name": "guide_RNA",
            "def": "A short 3'-uridylated RNA that can form a duplex (except for its post-transcriptionally added oligo_U tail (SO:0000609)) with a stretch of mature edited mRNA. [http://www.rna.ucla.edu/index.html]"
        },
        "SO:0000603": {
            "name": "group_II_intron",
            "def": "Group II introns are found in rRNA, tRNA and mRNA of organelles in fungi, plants and protists, and also in mRNA in bacteria. They are large self-splicing ribozymes and have 6 structural domains (usually designated dI to dVI). A subset of group II introns also encode essential splicing proteins in intronic ORFs. The length of these introns can therefore be up to 3kb. Splicing occurs in almost identical fashion to nuclear pre-mRNA splicing with two transesterification steps. The 2' hydroxyl of a bulged adenosine in domain VI attacks the 5' splice site, followed by nucleophilic attack on the 3' splice site by the 3' OH of the upstream exon. Protein machinery is required for splicing in vivo, and long range intron to intron and intron-exon interactions are important for splice site positioning. Group II introns are further sub-classified into groups IIA and IIB which differ in splice site consensus, distance of bulged A from 3' splice site, some tertiary interactions, and intronic ORF phylogeny. [http://www.sanger.ac.uk/Software/Rfam/browse/index.shtml]"
        },
        "SO:0000604": {
            "name": "editing_block",
            "def": "Edited mRNA sequence mediated by a single guide RNA (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000605": {
            "name": "intergenic_region",
            "def": "A region containing or overlapping no genes that is bounded on either side by a gene, or bounded by a gene and the end of the chromosome. [SO:cjm]"
        },
        "SO:0000606": {
            "name": "editing_domain",
            "def": "Edited mRNA sequence mediated by two or more overlapping guide RNAs (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000607": {
            "name": "unedited_region",
            "def": "The region of an edited transcript that will not be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000608": {
            "name": "H_ACA_box_snoRNA_encoding"
        },
        "SO:0000609": {
            "name": "oligo_U_tail",
            "def": "The string of non-encoded U's at the 3' end of a guide RNA (SO:0000602). [http://www.rna.ucla.edu/]"
        },
        "SO:0000610": {
            "name": "polyA_sequence",
            "def": "Sequence of about 100 nucleotides of A added to the 3' end of most eukaryotic mRNAs. [SO:ke]"
        },
        "SO:0000611": {
            "name": "branch_site",
            "def": "A pyrimidine rich sequence near the 3' end of an intron to which the 5'end becomes covalently bound during nuclear splicing. The resulting structure resembles a lariat. [SO:ke]"
        },
        "SO:0000612": {
            "name": "polypyrimidine_tract",
            "def": "The polypyrimidine tract is one of the cis-acting sequence elements directing intron removal in pre-mRNA splicing. [http://nar.oupjournals.org/cgi/content/full/25/4/888]"
        },
        "SO:0000613": {
            "name": "bacterial_RNApol_promoter",
            "def": "A DNA sequence to which bacterial RNA polymerase binds, to begin transcription. [SO:ke]"
        },
        "SO:0000614": {
            "name": "bacterial_terminator",
            "def": "A terminator signal for bacterial transcription. [SO:ke]"
        },
        "SO:0000615": {
            "name": "terminator_of_type_2_RNApol_III_promoter",
            "def": "A terminator signal for RNA polymerase III transcription. [SO:ke]"
        },
        "SO:0000616": {
            "name": "transcription_end_site",
            "def": "The base where transcription ends. [SO:ke]"
        },
        "SO:0000617": {
            "name": "RNApol_III_promoter_type_1"
        },
        "SO:0000618": {
            "name": "RNApol_III_promoter_type_2"
        },
        "SO:0000619": {
            "name": "A_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence TGGCnnAGTGG. [SO:ke]"
        },
        "SO:0000620": {
            "name": "B_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence AGGTTCCAnnCC. [SO:ke]"
        },
        "SO:0000621": {
            "name": "RNApol_III_promoter_type_3"
        },
        "SO:0000622": {
            "name": "C_box",
            "def": "An RNA polymerase III type 1 promoter with consensus sequence CAnnCCn. [SO:ke]"
        },
        "SO:0000623": {
            "name": "snRNA_encoding"
        },
        "SO:0000624": {
            "name": "telomere",
            "def": "A specific structure at the end of a linear chromosome, required for the integrity and maintenance of the end. [SO:ma]"
        },
        "SO:0000625": {
            "name": "silencer",
            "def": "A regulatory region which upon binding of transcription factors, suppress the transcription of the gene or genes they control. [SO:ke]"
        },
        "SO:0000626": {
            "name": "chromosomal_regulatory_element"
        },
        "SO:0000627": {
            "name": "insulator",
            "def": "A transcriptional cis regulatory region that when located between a CM and a gene's promoter prevents the CRM from modulating that genes expression. [SO:regcreative]"
        },
        "SO:0000628": {
            "name": "chromosomal_structural_element"
        },
        "SO:0000629": {
            "name": "five_prime_open_reading_frame"
        },
        "SO:0000630": {
            "name": "upstream_AUG_codon",
            "def": "A start codon upstream of the ORF. [SO:ke]"
        },
        "SO:0000631": {
            "name": "polycistronic_primary_transcript",
            "def": "A primary transcript encoding for more than one gene product. [SO:ke]"
        },
        "SO:0000632": {
            "name": "monocistronic_primary_transcript",
            "def": "A primary transcript encoding for one gene product. [SO:ke]"
        },
        "SO:0000633": {
            "name": "monocistronic_mRNA",
            "def": "An mRNA with either a single protein product, or for which the regions encoding all its protein products overlap. [SO:rd]"
        },
        "SO:0000634": {
            "name": "polycistronic_mRNA",
            "def": "An mRNA that encodes multiple proteins from at least two non-overlapping regions. [SO:rd]"
        },
        "SO:0000635": {
            "name": "mini_exon_donor_RNA",
            "def": "A primary transcript that donates the spliced leader to other mRNA. [SO:ke]"
        },
        "SO:0000636": {
            "name": "spliced_leader_RNA"
        },
        "SO:0000637": {
            "name": "engineered_plasmid",
            "def": "A plasmid that is engineered. [SO:xp]"
        },
        "SO:0000638": {
            "name": "transcribed_spacer_region",
            "def": "Part of an rRNA transcription unit that is transcribed but discarded during maturation, not giving rise to any part of rRNA. [http://oregonstate.edu/instruction/bb492/general/glossary.html]"
        },
        "SO:0000639": {
            "name": "internal_transcribed_spacer_region",
            "def": "Non-coding regions of DNA sequence that separate genes coding for the 28S, 5.8S, and 18S ribosomal RNAs. [SO:ke]"
        },
        "SO:0000640": {
            "name": "external_transcribed_spacer_region",
            "def": "Non-coding regions of DNA that precede the sequence that codes for the ribosomal RNA. [SO:ke]"
        },
        "SO:0000641": {
            "name": "tetranucleotide_repeat_microsatellite_feature"
        },
        "SO:0000642": {
            "name": "SRP_RNA_encoding"
        },
        "SO:0000643": {
            "name": "minisatellite",
            "def": "A repeat region containing tandemly repeated sequences having a unit length of 10 to 40 bp. [http://www.informatics.jax.org/silver/glossary.shtml]"
        },
        "SO:0000644": {
            "name": "antisense_RNA",
            "def": "Antisense RNA is RNA that is transcribed from the coding, rather than the template, strand of DNA. It is therefore complementary to mRNA. [SO:ke]"
        },
        "SO:0000645": {
            "name": "antisense_primary_transcript",
            "def": "The reverse complement of the primary transcript. [SO:ke]"
        },
        "SO:0000646": {
            "name": "siRNA",
            "def": "A small RNA molecule that is the product of a longer exogenous or endogenous dsRNA, which is either a bimolecular duplex or very long hairpin, processed (via the Dicer pathway) such that numerous siRNAs accumulate from both strands of the dsRNA. SRNAs trigger the cleavage of their target molecules. [PMID:12592000]"
        },
        "SO:0000647": {
            "name": "miRNA_primary_transcript",
            "def": "A primary transcript encoding a micro RNA. [SO:ke]"
        },
        "SO:0000650": {
            "name": "small_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0000651": {
            "name": "large_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the large subunit of the ribosome. [SO:ke]"
        },
        "SO:0000652": {
            "name": "rRNA_5S",
            "def": "5S ribosomal RNA (5S rRNA) is a component of the large ribosomal subunit in both prokaryotes and eukaryotes. In eukaryotes, it is synthesised by RNA polymerase III (the other eukaryotic rRNAs are cleaved from a 45S precursor synthesised by RNA polymerase I). In Xenopus oocytes, it has been shown that fingers 4-7 of the nine-zinc finger transcription factor TFIIIA can bind to the central region of 5S RNA. Thus, in addition to positively regulating 5S rRNA transcription, TFIIIA also stabilizes 5S rRNA until it is required for transcription. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00001]"
        },
        "SO:0000653": {
            "name": "rRNA_28S",
            "def": "A component of the large ribosomal subunit. [SO:ke]"
        },
        "SO:0000654": {
            "name": "maxicircle_gene",
            "def": "A mitochondrial gene located in a maxicircle. [SO:xp]"
        },
        "SO:0000655": {
            "name": "ncRNA",
            "def": "An RNA transcript that does not encode for a protein rather the RNA molecule is the gene product. [SO:ke]"
        },
        "SO:0000656": {
            "name": "stRNA_encoding"
        },
        "SO:0000657": {
            "name": "repeat_region",
            "def": "A region of sequence containing one or more repeat units. [SO:ke]"
        },
        "SO:0000658": {
            "name": "dispersed_repeat",
            "def": "A repeat that is located at dispersed sites in the genome. [SO:ke]"
        },
        "SO:0000659": {
            "name": "tmRNA_encoding"
        },
        "SO:0000660": {
            "name": "DNA_invertase_target_sequence"
        },
        "SO:0000661": {
            "name": "intron_attribute"
        },
        "SO:0000662": {
            "name": "spliceosomal_intron",
            "def": "An intron which is spliced by the spliceosome. [SO:ke]"
        },
        "SO:0000663": {
            "name": "tRNA_encoding"
        },
        "SO:0000664": {
            "name": "introgressed_chromosome_region"
        },
        "SO:0000665": {
            "name": "monocistronic_transcript",
            "def": "A transcript that is monocistronic. [SO:xp]"
        },
        "SO:0000666": {
            "name": "mobile_intron",
            "def": "An intron (mitochondrial, chloroplast, nuclear or prokaryotic) that encodes a double strand sequence specific endonuclease allowing for mobility. [SO:ke]"
        },
        "SO:0000667": {
            "name": "insertion",
            "def": "The sequence of one or more nucleotides added between two adjacent nucleotides in the sequence. [SO:ke]"
        },
        "SO:0000668": {
            "name": "EST_match",
            "def": "A match against an EST sequence. [SO:ke]"
        },
        "SO:0000669": {
            "name": "sequence_rearrangement_feature"
        },
        "SO:0000670": {
            "name": "chromosome_breakage_sequence",
            "def": "A sequence within the micronuclear DNA of ciliates at which chromosome breakage and telomere addition occurs during nuclear differentiation. [SO:ma]"
        },
        "SO:0000671": {
            "name": "internal_eliminated_sequence",
            "def": "A sequence eliminated from the genome of ciliates during nuclear differentiation. [SO:ma]"
        },
        "SO:0000672": {
            "name": "macronucleus_destined_segment",
            "def": "A sequence that is conserved, although rearranged relative to the micronucleus, in the macronucleus of a ciliate genome. [SO:ma]"
        },
        "SO:0000673": {
            "name": "transcript",
            "def": "An RNA synthesized on a DNA or RNA template by an RNA polymerase. [SO:ma]"
        },
        "SO:0000674": {
            "name": "non_canonical_splice_site",
            "def": "A splice site where the donor and acceptor sites differ from the canonical form. [SO:ke]"
        },
        "SO:0000675": {
            "name": "canonical_splice_site",
            "def": "The major class of splice site with dinucleotides GT and AG for donor and acceptor sites, respectively. [SO:ke]"
        },
        "SO:0000676": {
            "name": "canonical_three_prime_splice_site",
            "def": "The canonical 3' splice site has the sequence \\AG\\. [SO:ke]"
        },
        "SO:0000677": {
            "name": "canonical_five_prime_splice_site",
            "def": "The canonical 5' splice site has the sequence \\GT\\. [SO:ke]"
        },
        "SO:0000678": {
            "name": "non_canonical_three_prime_splice_site",
            "def": "A 3' splice site that does not have the sequence \\AG\\. [SO:ke]"
        },
        "SO:0000679": {
            "name": "non_canonical_five_prime_splice_site",
            "def": "A 5' splice site which does not have the sequence \\GT\\. [SO:ke]"
        },
        "SO:0000680": {
            "name": "non_canonical_start_codon",
            "def": "A start codon that is not the usual AUG sequence. [SO:ke]"
        },
        "SO:0000681": {
            "name": "aberrant_processed_transcript",
            "def": "A transcript that has been processed \\incorrectly\\, for example by the failure of splicing of one or more exons. [SO:ke]"
        },
        "SO:0000682": {
            "name": "splicing_feature"
        },
        "SO:0000683": {
            "name": "exonic_splice_enhancer",
            "def": "Exonic splicing enhancers (ESEs) facilitate exon definition by assisting in the recruitment of splicing factors to the adjacent intron. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12403462&dopt=Abstract]"
        },
        "SO:0000684": {
            "name": "nuclease_sensitive_site",
            "def": "A region of nucleotide sequence targeted by a nuclease enzyme. [SO:ma]"
        },
        "SO:0000685": {
            "name": "DNAseI_hypersensitive_site"
        },
        "SO:0000686": {
            "name": "translocation_element",
            "def": "A chromosomal translocation whereby the chromosomes carrying non-homologous centromeres may be recovered independently. These chromosomes are described as translocation elements. This occurs for some translocations, particularly but not exclusively, reciprocal translocations. [SO:ma]"
        },
        "SO:0000687": {
            "name": "deletion_junction",
            "def": "The space between two bases in a sequence which marks the position where a deletion has occurred. [SO:ke]"
        },
        "SO:0000688": {
            "name": "golden_path",
            "def": "A set of subregions selected from sequence contigs which when concatenated form a nonredundant linear sequence. [SO:ls]"
        },
        "SO:0000689": {
            "name": "cDNA_match",
            "def": "A match against cDNA sequence. [SO:ke]"
        },
        "SO:0000690": {
            "name": "gene_with_polycistronic_transcript",
            "def": "A gene that encodes a polycistronic transcript. [SO:xp]"
        },
        "SO:0000691": {
            "name": "cleaved_initiator_methionine",
            "def": "The initiator methionine that has been cleaved from a mature polypeptide sequence. [EBIBS:GAR]"
        },
        "SO:0000692": {
            "name": "gene_with_dicistronic_transcript",
            "def": "A gene that encodes a dicistronic transcript. [SO:xp]"
        },
        "SO:0000693": {
            "name": "gene_with_recoded_mRNA",
            "def": "A gene that encodes an mRNA that is recoded. [SO:xp]"
        },
        "SO:0000694": {
            "name": "SNP",
            "def": "SNPs are single base pair positions in genomic DNA at which different sequence alternatives exist in normal individuals in some population(s), wherein the least frequent variant has an abundance of 1% or greater. [SO:cb]"
        },
        "SO:0000695": {
            "name": "reagent",
            "def": "A sequence used in experiment. [SO:ke]"
        },
        "SO:0000696": {
            "name": "oligo",
            "def": "A short oligonucleotide sequence, of length on the order of 10's of bases; either single or double stranded. [SO:ma]"
        },
        "SO:0000697": {
            "name": "gene_with_stop_codon_read_through",
            "def": "A gene that encodes a transcript with stop codon readthrough. [SO:xp]"
        },
        "SO:0000698": {
            "name": "gene_with_stop_codon_redefined_as_pyrrolysine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as pyrrolysine. [SO:xp]"
        },
        "SO:0000699": {
            "name": "junction",
            "def": "A sequence_feature with an extent of zero. [SO:ke]"
        },
        "SO:0000700": {
            "name": "remark",
            "def": "A comment about the sequence. [SO:ke]"
        },
        "SO:0000701": {
            "name": "possible_base_call_error",
            "def": "A region of sequence where the validity of the base calling is questionable. [SO:ke]"
        },
        "SO:0000702": {
            "name": "possible_assembly_error",
            "def": "A region of sequence where there may have been an error in the assembly. [SO:ke]"
        },
        "SO:0000703": {
            "name": "experimental_result_region",
            "def": "A region of sequence implicated in an experimental result. [SO:ke]"
        },
        "SO:0000704": {
            "name": "gene",
            "def": "A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. [SO:immuno_workshop]"
        },
        "SO:0000705": {
            "name": "tandem_repeat",
            "def": "Two or more adjacent copies of a region (of length greater than 1). [SO:ke]"
        },
        "SO:0000706": {
            "name": "trans_splice_acceptor_site",
            "def": "The 3' splice site of the acceptor primary transcript. [SO:ke]"
        },
        "SO:0000707": {
            "name": "trans_splice_donor_site",
            "def": "The 5' five prime splice site region of the donor RNA. [SO:ke]"
        },
        "SO:0000708": {
            "name": "SL1_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL1 RNA leader sequence to the 5' end of most mRNAs. [SO:nlw]"
        },
        "SO:0000709": {
            "name": "SL2_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL2 RNA leader sequence to the 5' end of mRNAs. SL2 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0000710": {
            "name": "gene_with_stop_codon_redefined_as_selenocysteine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as selenocysteine. [SO:xp]"
        },
        "SO:0000711": {
            "name": "gene_with_mRNA_recoded_by_translational_bypass",
            "def": "A gene with mRNA recoded by translational bypass. [SO:xp]"
        },
        "SO:0000712": {
            "name": "gene_with_transcript_with_translational_frameshift",
            "def": "A gene encoding a transcript that has a translational frameshift. [SO:xp]"
        },
        "SO:0000713": {
            "name": "DNA_motif",
            "def": "A motif that is active in the DNA form of the sequence. [SO:ke]"
        },
        "SO:0000714": {
            "name": "nucleotide_motif",
            "def": "A region of nucleotide sequence corresponding to a known motif. [SO:ke]"
        },
        "SO:0000715": {
            "name": "RNA_motif",
            "def": "A motif that is active in RNA sequence. [SO:ke]"
        },
        "SO:0000716": {
            "name": "dicistronic_mRNA",
            "def": "An mRNA that has the quality dicistronic. [SO:ke]"
        },
        "SO:0000717": {
            "name": "reading_frame",
            "def": "A nucleic acid sequence that when read as sequential triplets, has the potential of encoding a sequential string of amino acids. It need not contain the start or stop codon. [SGD:rb]"
        },
        "SO:0000718": {
            "name": "blocked_reading_frame",
            "def": "A reading_frame that is interrupted by one or more stop codons; usually identified through inter-genomic sequence comparisons. [SGD:rb]"
        },
        "SO:0000719": {
            "name": "ultracontig",
            "def": "An ordered and oriented set of scaffolds based on somewhat weaker sets of inferential evidence such as one set of mate pair reads together with supporting evidence from ESTs or location of markers from SNP or microsatellite maps, or cytogenetic localization of contained markers. [FB:WG]"
        },
        "SO:0000720": {
            "name": "foreign_transposable_element",
            "def": "A transposable element that is foreign. [SO:ke]"
        },
        "SO:0000721": {
            "name": "gene_with_dicistronic_primary_transcript",
            "def": "A gene that encodes a dicistronic primary transcript. [SO:xp]"
        },
        "SO:0000722": {
            "name": "gene_with_dicistronic_mRNA",
            "def": "A gene that encodes a polycistronic mRNA. [SO:xp]"
        },
        "SO:0000723": {
            "name": "iDNA",
            "def": "Genomic sequence removed from the genome, as a normal event, by a process of recombination. [SO:ma]"
        },
        "SO:0000724": {
            "name": "oriT",
            "def": "A region of a DNA molecule where transfer is initiated during the process of conjugation or mobilization. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000725": {
            "name": "transit_peptide",
            "def": "The transit_peptide is a short region at the N-terminus of the peptide that directs the protein to an organelle (chloroplast, mitochondrion, microbody or cyanelle). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000726": {
            "name": "repeat_unit",
            "def": "The simplest repeated component of a repeat region. A single repeat. [SO:ke]"
        },
        "SO:0000727": {
            "name": "CRM",
            "def": "A regulatory region where transcription factor binding sites clustered to regulate various aspects of transcription activities. (CRMs can be located a few kb to hundred kb upstream of the basal promoter, in the coding sequence, within introns, or in the downstream 3'UTR sequences, as well as on different chromosome). A single gene can be regulated by multiple CRMs to give precise control of its spatial and temporal expression. CRMs function as nodes in large, intertwined regulatory network. [PMID:19660565, SO:SG]"
        },
        "SO:0000728": {
            "name": "intein",
            "def": "A region of a peptide that is able to excise itself and rejoin the remaining portions with a peptide bond. [SO:ke]"
        },
        "SO:0000729": {
            "name": "intein_containing",
            "def": "An attribute of protein-coding genes where the initial protein product contains an intein. [SO:ke]"
        },
        "SO:0000730": {
            "name": "gap",
            "def": "A gap in the sequence of known length. The unknown bases are filled in with N's. [SO:ke]"
        },
        "SO:0000731": {
            "name": "fragmentary",
            "def": "An attribute to describe a feature that is incomplete. [SO:ke]"
        },
        "SO:0000732": {
            "name": "predicted",
            "def": "An attribute describing an unverified region. [SO:ke]"
        },
        "SO:0000733": {
            "name": "feature_attribute",
            "def": "An attribute describing a located_sequence_feature. [SO:ke]"
        },
        "SO:0000734": {
            "name": "exemplar_mRNA",
            "def": "An exemplar is a representative cDNA sequence for each gene. The exemplar approach is a method that usually involves some initial clustering into gene groups and the subsequent selection of a representative from each gene group. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000735": {
            "name": "sequence_location"
        },
        "SO:0000736": {
            "name": "organelle_sequence"
        },
        "SO:0000737": {
            "name": "mitochondrial_sequence"
        },
        "SO:0000738": {
            "name": "nuclear_sequence"
        },
        "SO:0000739": {
            "name": "nucleomorphic_sequence"
        },
        "SO:0000740": {
            "name": "plastid_sequence"
        },
        "SO:0000741": {
            "name": "kinetoplast",
            "def": "A kinetoplast is an interlocked network of thousands of minicircles and tens of maxicircles, located near the base of the flagellum of some protozoan species. [PMID:8395055]"
        },
        "SO:0000742": {
            "name": "maxicircle",
            "def": "A maxicircle is a replicon, part of a kinetoplast, that contains open reading frames and replicates via a rolling circle method. [PMID:8395055]"
        },
        "SO:0000743": {
            "name": "apicoplast_sequence"
        },
        "SO:0000744": {
            "name": "chromoplast_sequence"
        },
        "SO:0000745": {
            "name": "chloroplast_sequence"
        },
        "SO:0000746": {
            "name": "cyanelle_sequence"
        },
        "SO:0000747": {
            "name": "leucoplast_sequence"
        },
        "SO:0000748": {
            "name": "proplastid_sequence"
        },
        "SO:0000749": {
            "name": "plasmid_location"
        },
        "SO:0000750": {
            "name": "amplification_origin",
            "def": "An origin_of_replication that is used for the amplification of a chromosomal nucleic acid sequence. [SO:ma]"
        },
        "SO:0000751": {
            "name": "proviral_location"
        },
        "SO:0000752": {
            "name": "gene_group_regulatory_region"
        },
        "SO:0000753": {
            "name": "clone_insert",
            "def": "The region of sequence that has been inserted and is being propagated by the clone. [SO:ke]"
        },
        "SO:0000754": {
            "name": "lambda_vector",
            "def": "The lambda bacteriophage is the vector for the linear lambda clone. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
        },
        "SO:0000755": {
            "name": "plasmid_vector"
        },
        "SO:0000756": {
            "name": "cDNA",
            "def": "DNA synthesized by reverse transcriptase using RNA as a template. [SO:ma]"
        },
        "SO:0000757": {
            "name": "single_stranded_cDNA"
        },
        "SO:0000758": {
            "name": "double_stranded_cDNA"
        },
        "SO:0000759": {
            "name": "plasmid_clone"
        },
        "SO:0000760": {
            "name": "YAC_clone"
        },
        "SO:0000761": {
            "name": "phagemid_clone"
        },
        "SO:0000762": {
            "name": "PAC_clone"
        },
        "SO:0000763": {
            "name": "fosmid_clone"
        },
        "SO:0000764": {
            "name": "BAC_clone"
        },
        "SO:0000765": {
            "name": "cosmid_clone"
        },
        "SO:0000766": {
            "name": "pyrrolysyl_tRNA",
            "def": "A tRNA sequence that has a pyrrolysine anticodon, and a 3' pyrrolysine binding region. [SO:ke]"
        },
        "SO:0000767": {
            "name": "clone_insert_start"
        },
        "SO:0000768": {
            "name": "episome",
            "def": "A plasmid that may integrate with a chromosome. [SO:ma]"
        },
        "SO:0000769": {
            "name": "tmRNA_coding_piece",
            "def": "The region of a two-piece tmRNA that bears the reading frame encoding the proteolysis tag. The tmRNA gene undergoes circular permutation in some groups of bacteria. Processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw, issn:1362-4962]"
        },
        "SO:0000770": {
            "name": "tmRNA_acceptor_piece",
            "def": "The acceptor region of a two-piece tmRNA that when mature is charged at its 3' end with alanine. The tmRNA gene undergoes circular permutation in some groups of bacteria; processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw]"
        },
        "SO:0000771": {
            "name": "QTL",
            "def": "A quantitative trait locus (QTL) is a polymorphic locus which contains alleles that differentially affect the expression of a continuously distributed phenotypic trait. Usually it is a marker described by statistical association to quantitative variation in the particular phenotypic trait that is thought to be controlled by the cumulative action of alleles at multiple loci. [http://rgd.mcw.edu/tu/qtls/]"
        },
        "SO:0000772": {
            "name": "genomic_island",
            "def": "A genomic island is an integrated mobile genetic element, characterized by size (over 10 Kb). It that has features that suggest a foreign origin. These can include nucleotide distribution (oligonucleotides signature, CG content etc.) that differs from the bulk of the chromosome and/or genes suggesting DNA mobility. [Phigo:at, SO:ke]"
        },
        "SO:0000773": {
            "name": "pathogenic_island",
            "def": "Mobile genetic elements that contribute to rapid changes in virulence potential. They are present on the genomes of pathogenic strains but absent from the genomes of non pathogenic members of the same or related species. [SO:ke]"
        },
        "SO:0000774": {
            "name": "metabolic_island",
            "def": "A transmissible element containing genes involved in metabolism, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
        },
        "SO:0000775": {
            "name": "adaptive_island",
            "def": "An adaptive island is a genomic island that provides an adaptive advantage to the host. [SO:ke]"
        },
        "SO:0000776": {
            "name": "symbiosis_island",
            "def": "A transmissible element containing genes involved in symbiosis, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
        },
        "SO:0000777": {
            "name": "pseudogenic_rRNA",
            "def": "A non functional descendant of an rRNA. [SO:ke]"
        },
        "SO:0000778": {
            "name": "pseudogenic_tRNA",
            "def": "A non functional descendent of a tRNA. [SO:ke]"
        },
        "SO:0000779": {
            "name": "engineered_episome",
            "def": "An episome that is engineered. [SO:xp]"
        },
        "SO:0000780": {
            "name": "transposable_element_attribute"
        },
        "SO:0000781": {
            "name": "transgenic",
            "def": "Attribute describing sequence that has been integrated with foreign sequence. [SO:ke]"
        },
        "SO:0000782": {
            "name": "natural",
            "def": "An attribute describing a feature that occurs in nature. [SO:ke]"
        },
        "SO:0000783": {
            "name": "engineered",
            "def": "An attribute to describe a region that was modified in vitro. [SO:ke]"
        },
        "SO:0000784": {
            "name": "foreign",
            "def": "An attribute to describe a region from another species. [SO:ke]"
        },
        "SO:0000785": {
            "name": "cloned_region"
        },
        "SO:0000786": {
            "name": "reagent_attribute"
        },
        "SO:0000787": {
            "name": "clone_attribute"
        },
        "SO:0000788": {
            "name": "cloned"
        },
        "SO:0000789": {
            "name": "validated",
            "def": "An attribute to describe a feature that has been proven. [SO:ke]"
        },
        "SO:0000790": {
            "name": "invalidated",
            "def": "An attribute describing a feature that is invalidated. [SO:ke]"
        },
        "SO:0000791": {
            "name": "cloned_genomic"
        },
        "SO:0000792": {
            "name": "cloned_cDNA"
        },
        "SO:0000793": {
            "name": "engineered_DNA"
        },
        "SO:0000794": {
            "name": "engineered_rescue_region",
            "def": "A rescue region that is engineered. [SO:xp]"
        },
        "SO:0000795": {
            "name": "rescue_mini_gene",
            "def": "A mini_gene that rescues. [SO:xp]"
        },
        "SO:0000796": {
            "name": "transgenic_transposable_element",
            "def": "TE that has been modified in vitro, including insertion of DNA derived from a source other than the originating TE. [FB:mc]"
        },
        "SO:0000797": {
            "name": "natural_transposable_element",
            "def": "TE that exists (or existed) in nature. [FB:mc]"
        },
        "SO:0000798": {
            "name": "engineered_transposable_element",
            "def": "TE that has been modified by manipulations in vitro. [FB:mc]"
        },
        "SO:0000799": {
            "name": "engineered_foreign_transposable_element",
            "def": "A transposable_element that is engineered and foreign. [FB:mc]"
        },
        "SO:0000800": {
            "name": "assortment_derived_duplication",
            "def": "A multi-chromosome duplication aberration generated by reassortment of other aberration components. [FB:gm]"
        },
        "SO:0000801": {
            "name": "assortment_derived_deficiency_plus_duplication",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency and a duplication. [FB:gm]"
        },
        "SO:0000802": {
            "name": "assortment_derived_deficiency",
            "def": "A multi-chromosome deficiency aberration generated by reassortment of other aberration components. [FB:gm]"
        },
        "SO:0000803": {
            "name": "assortment_derived_aneuploid",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency or a duplication. [FB:gm]"
        },
        "SO:0000804": {
            "name": "engineered_region",
            "def": "A region that is engineered. [SO:xp]"
        },
        "SO:0000805": {
            "name": "engineered_foreign_region",
            "def": "A region that is engineered and foreign. [SO:xp]"
        },
        "SO:0000806": {
            "name": "fusion"
        },
        "SO:0000807": {
            "name": "engineered_tag",
            "def": "A tag that is engineered. [SO:xp]"
        },
        "SO:0000808": {
            "name": "validated_cDNA_clone",
            "def": "A cDNA clone that has been validated. [SO:xp]"
        },
        "SO:0000809": {
            "name": "invalidated_cDNA_clone",
            "def": "A cDNA clone that is invalid. [SO:xp]"
        },
        "SO:0000810": {
            "name": "chimeric_cDNA_clone",
            "def": "A cDNA clone invalidated because it is chimeric. [SO:xp]"
        },
        "SO:0000811": {
            "name": "genomically_contaminated_cDNA_clone",
            "def": "A cDNA clone invalidated by genomic contamination. [SO:xp]"
        },
        "SO:0000812": {
            "name": "polyA_primed_cDNA_clone",
            "def": "A cDNA clone invalidated by polyA priming. [SO:xp]"
        },
        "SO:0000813": {
            "name": "partially_processed_cDNA_clone",
            "def": "A cDNA invalidated clone by partial processing. [SO:xp]"
        },
        "SO:0000814": {
            "name": "rescue",
            "def": "An attribute describing a region's ability, when introduced to a mutant organism, to re-establish (rescue) a phenotype. [SO:ke]"
        },
        "SO:0000815": {
            "name": "mini_gene",
            "def": "By definition, minigenes are short open-reading frames (ORF), usually encoding approximately 9 to 20 amino acids, which are expressed in vivo (as distinct from being synthesized as peptide or protein ex vivo and subsequently injected). The in vivo synthesis confers a distinct advantage: the expressed sequences can enter both antigen presentation pathways, MHC I (inducing CD8+ T- cells, which are usually cytotoxic T-lymphocytes (CTL)) and MHC II (inducing CD4+ T-cells, usually 'T-helpers' (Th)); and can encounter B-cells, inducing antibody responses. Three main vector approaches have been used to deliver minigenes: viral vectors, bacterial vectors and plasmid DNA. [PMID:15992143]"
        },
        "SO:0000816": {
            "name": "rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
        },
        "SO:0000817": {
            "name": "wild_type",
            "def": "An attribute describing sequence with the genotype found in nature and/or standard laboratory stock. [SO:ke]"
        },
        "SO:0000818": {
            "name": "wild_type_rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
        },
        "SO:0000819": {
            "name": "mitochondrial_chromosome",
            "def": "A chromosome originating in a mitochondria. [SO:xp]"
        },
        "SO:0000820": {
            "name": "chloroplast_chromosome",
            "def": "A chromosome originating in a chloroplast. [SO:xp]"
        },
        "SO:0000821": {
            "name": "chromoplast_chromosome",
            "def": "A chromosome originating in a chromoplast. [SO:xp]"
        },
        "SO:0000822": {
            "name": "cyanelle_chromosome",
            "def": "A chromosome originating in a cyanelle. [SO:xp]"
        },
        "SO:0000823": {
            "name": "leucoplast_chromosome",
            "def": "A chromosome with origin in a leucoplast. [SO:xp]"
        },
        "SO:0000824": {
            "name": "macronuclear_chromosome",
            "def": "A chromosome originating in a macronucleus. [SO:xp]"
        },
        "SO:0000825": {
            "name": "micronuclear_chromosome",
            "def": "A chromosome originating in a micronucleus. [SO:xp]"
        },
        "SO:0000828": {
            "name": "nuclear_chromosome",
            "def": "A chromosome originating in a nucleus. [SO:xp]"
        },
        "SO:0000829": {
            "name": "nucleomorphic_chromosome",
            "def": "A chromosome originating in a nucleomorph. [SO:xp]"
        },
        "SO:0000830": {
            "name": "chromosome_part",
            "def": "A region of a chromosome. [SO:ke]"
        },
        "SO:0000831": {
            "name": "gene_member_region",
            "def": "A region of a gene. [SO:ke]"
        },
        "SO:0000832": {
            "name": "promoter_region",
            "def": "A region of sequence which is part of a promoter. [SO:ke]"
        },
        "SO:0000833": {
            "name": "transcript_region",
            "def": "A region of a transcript. [SO:ke]"
        },
        "SO:0000834": {
            "name": "mature_transcript_region",
            "def": "A region of a mature transcript. [SO:ke]"
        },
        "SO:0000835": {
            "name": "primary_transcript_region",
            "def": "A part of a primary transcript. [SO:ke]"
        },
        "SO:0000836": {
            "name": "mRNA_region",
            "def": "A region of an mRNA. [SO:cb]"
        },
        "SO:0000837": {
            "name": "UTR_region",
            "def": "A region of UTR. [SO:ke]"
        },
        "SO:0000838": {
            "name": "rRNA_primary_transcript_region",
            "def": "A region of an rRNA primary transcript. [SO:ke]"
        },
        "SO:0000839": {
            "name": "polypeptide_region",
            "def": "Biological sequence region that can be assigned to a specific subsequence of a polypeptide. [SO:GAR, SO:ke]"
        },
        "SO:0000840": {
            "name": "repeat_component",
            "def": "A region of a repeated sequence. [SO:ke]"
        },
        "SO:0000841": {
            "name": "spliceosomal_intron_region",
            "def": "A region within an intron. [SO:ke]"
        },
        "SO:0000842": {
            "name": "gene_component_region"
        },
        "SO:0000843": {
            "name": "bacterial_RNApol_promoter_region",
            "def": "A region which is part of a bacterial RNA polymerase promoter. [SO:ke]"
        },
        "SO:0000844": {
            "name": "RNApol_II_promoter_region",
            "def": "A region of sequence which is a promoter for RNA polymerase II. [SO:ke]"
        },
        "SO:0000845": {
            "name": "RNApol_III_promoter_type_1_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 1. [SO:ke]"
        },
        "SO:0000846": {
            "name": "RNApol_III_promoter_type_2_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 2. [SO:ke]"
        },
        "SO:0000847": {
            "name": "tmRNA_region",
            "def": "A region of a tmRNA. [SO:cb]"
        },
        "SO:0000848": {
            "name": "LTR_component"
        },
        "SO:0000849": {
            "name": "three_prime_LTR_component"
        },
        "SO:0000850": {
            "name": "five_prime_LTR_component"
        },
        "SO:0000851": {
            "name": "CDS_region",
            "def": "A region of a CDS. [SO:cb]"
        },
        "SO:0000852": {
            "name": "exon_region",
            "def": "A region of an exon. [RSC:cb]"
        },
        "SO:0000853": {
            "name": "homologous_region",
            "def": "A region that is homologous to another region. [SO:ke]"
        },
        "SO:0000854": {
            "name": "paralogous_region",
            "def": "A homologous_region that is paralogous to another region. [SO:ke]"
        },
        "SO:0000855": {
            "name": "orthologous_region",
            "def": "A homologous_region that is orthologous to another region. [SO:ke]"
        },
        "SO:0000856": {
            "name": "conserved"
        },
        "SO:0000857": {
            "name": "homologous",
            "def": "Similarity due to common ancestry. [SO:ke]"
        },
        "SO:0000858": {
            "name": "orthologous",
            "def": "An attribute describing a kind of homology where divergence occurred after a speciation event. [SO:ke]"
        },
        "SO:0000859": {
            "name": "paralogous",
            "def": "An attribute describing a kind of homology where divergence occurred after a duplication event. [SO:ke]"
        },
        "SO:0000860": {
            "name": "syntenic",
            "def": "Attribute describing sequence regions occurring in same order on chromosome of different species. [SO:ke]"
        },
        "SO:0000861": {
            "name": "capped_primary_transcript",
            "def": "A primary transcript that is capped. [SO:xp]"
        },
        "SO:0000862": {
            "name": "capped_mRNA",
            "def": "An mRNA that is capped. [SO:xp]"
        },
        "SO:0000863": {
            "name": "mRNA_attribute",
            "def": "An attribute describing an mRNA feature. [SO:ke]"
        },
        "SO:0000864": {
            "name": "exemplar",
            "def": "An attribute describing a sequence is representative of a class of similar sequences. [SO:ke]"
        },
        "SO:0000865": {
            "name": "frameshift",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is not divisible by 3. [SO:ke]"
        },
        "SO:0000866": {
            "name": "minus_1_frameshift",
            "def": "A frameshift caused by deleting one base. [SO:ke]"
        },
        "SO:0000867": {
            "name": "minus_2_frameshift",
            "def": "A frameshift caused by deleting two bases. [SO:ke]"
        },
        "SO:0000868": {
            "name": "plus_1_frameshift",
            "def": "A frameshift caused by inserting one base. [SO:ke]"
        },
        "SO:0000869": {
            "name": "plus_2_framshift",
            "def": "A frameshift caused by inserting two bases. [SO:ke]"
        },
        "SO:0000870": {
            "name": "trans_spliced",
            "def": "An attribute describing transcript sequence that is created by splicing exons from diferent genes. [SO:ke]"
        },
        "SO:0000871": {
            "name": "polyadenylated_mRNA",
            "def": "An mRNA that is polyadenylated. [SO:xp]"
        },
        "SO:0000872": {
            "name": "trans_spliced_mRNA",
            "def": "An mRNA that is trans-spliced. [SO:xp]"
        },
        "SO:0000873": {
            "name": "edited_transcript",
            "def": "A transcript that is edited. [SO:ke]"
        },
        "SO:0000874": {
            "name": "edited_transcript_by_A_to_I_substitution",
            "def": "A transcript that has been edited by A to I substitution. [SO:ke]"
        },
        "SO:0000875": {
            "name": "bound_by_protein",
            "def": "An attribute describing a sequence that is bound by a protein. [SO:ke]"
        },
        "SO:0000876": {
            "name": "bound_by_nucleic_acid",
            "def": "An attribute describing a sequence that is bound by a nucleic acid. [SO:ke]"
        },
        "SO:0000877": {
            "name": "alternatively_spliced",
            "def": "An attribute describing a situation where a gene may encode for more than 1 transcript. [SO:ke]"
        },
        "SO:0000878": {
            "name": "monocistronic",
            "def": "An attribute describing a sequence that contains the code for one gene product. [SO:ke]"
        },
        "SO:0000879": {
            "name": "dicistronic",
            "def": "An attribute describing a sequence that contains the code for two gene products. [SO:ke]"
        },
        "SO:0000880": {
            "name": "polycistronic",
            "def": "An attribute describing a sequence that contains the code for more than one gene product. [SO:ke]"
        },
        "SO:0000881": {
            "name": "recoded",
            "def": "An attribute describing an mRNA sequence that has been reprogrammed at translation, causing localized alterations. [SO:ke]"
        },
        "SO:0000882": {
            "name": "codon_redefined",
            "def": "An attribute describing the alteration of codon meaning. [SO:ke]"
        },
        "SO:0000883": {
            "name": "stop_codon_read_through",
            "def": "A stop codon redefined to be a new amino acid. [SO:ke]"
        },
        "SO:0000884": {
            "name": "stop_codon_redefined_as_pyrrolysine",
            "def": "A stop codon redefined to be the new amino acid, pyrrolysine. [SO:ke]"
        },
        "SO:0000885": {
            "name": "stop_codon_redefined_as_selenocysteine",
            "def": "A stop codon redefined to be the new amino acid, selenocysteine. [SO:ke]"
        },
        "SO:0000886": {
            "name": "recoded_by_translational_bypass",
            "def": "Recoded mRNA where a block of nucleotides is not translated. [SO:ke]"
        },
        "SO:0000887": {
            "name": "translationally_frameshifted",
            "def": "Recoding by frameshifting a particular site. [SO:ke]"
        },
        "SO:0000888": {
            "name": "maternally_imprinted_gene",
            "def": "A gene that is maternally_imprinted. [SO:xp]"
        },
        "SO:0000889": {
            "name": "paternally_imprinted_gene",
            "def": "A gene that is paternally imprinted. [SO:xp]"
        },
        "SO:0000890": {
            "name": "post_translationally_regulated_gene",
            "def": "A gene that is post translationally regulated. [SO:xp]"
        },
        "SO:0000891": {
            "name": "negatively_autoregulated_gene",
            "def": "A gene that is negatively autoreguated. [SO:xp]"
        },
        "SO:0000892": {
            "name": "positively_autoregulated_gene",
            "def": "A gene that is positively autoregulated. [SO:xp]"
        },
        "SO:0000893": {
            "name": "silenced",
            "def": "An attribute describing an epigenetic process where a gene is inactivated at transcriptional or translational level. [SO:ke]"
        },
        "SO:0000894": {
            "name": "silenced_by_DNA_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA modifications, resulting in repression of transcription. [SO:ke]"
        },
        "SO:0000895": {
            "name": "silenced_by_DNA_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA methylation, resulting in repression of transcription. [SO:ke]"
        },
        "SO:0000896": {
            "name": "translationally_regulated_gene",
            "def": "A gene that is translationally regulated. [SO:xp]"
        },
        "SO:0000897": {
            "name": "allelically_excluded_gene",
            "def": "A gene that is allelically_excluded. [SO:xp]"
        },
        "SO:0000898": {
            "name": "epigenetically_modified_gene",
            "def": "A gene that is epigenetically modified. [SO:ke]"
        },
        "SO:0000899": {
            "name": "nuclear_mitochondrial",
            "def": "An attribute describing a nuclear pseudogene of a mitochndrial gene. [SO:ke]"
        },
        "SO:0000900": {
            "name": "processed",
            "def": "An attribute describing a pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promotors, but often including a polyA tail. [SO:ke]"
        },
        "SO:0000901": {
            "name": "unequally_crossed_over",
            "def": "An attribute describing a pseudogene that was created by tandem duplication and unequal crossing over during recombination. [SO:ke]"
        },
        "SO:0000902": {
            "name": "transgene",
            "def": "A transgene is a gene that has been transferred naturally or by any of a number of genetic engineering techniques from one organism to another. [SO:xp]"
        },
        "SO:0000903": {
            "name": "endogenous_retroviral_sequence"
        },
        "SO:0000904": {
            "name": "rearranged_at_DNA_level",
            "def": "An attribute to describe the sequence of a feature, where the DNA is rearranged. [SO:ke]"
        },
        "SO:0000905": {
            "name": "status",
            "def": "An attribute describing the status of a feature, based on the available evidence. [SO:ke]"
        },
        "SO:0000906": {
            "name": "independently_known",
            "def": "Attribute to describe a feature that is independently known - not predicted. [SO:ke]"
        },
        "SO:0000907": {
            "name": "supported_by_sequence_similarity",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity techniques. [SO:ke]"
        },
        "SO:0000908": {
            "name": "supported_by_domain_match",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity of a known domain. [SO:ke]"
        },
        "SO:0000909": {
            "name": "supported_by_EST_or_cDNA",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity to EST or cDNA data. [SO:ke]"
        },
        "SO:0000910": {
            "name": "orphan"
        },
        "SO:0000911": {
            "name": "predicted_by_ab_initio_computation",
            "def": "An attribute describing a feature that is predicted by a computer program that did not rely on sequence similarity. [SO:ke]"
        },
        "SO:0000912": {
            "name": "asx_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Aspartate or Asparagine (Asx), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0000913": {
            "name": "cloned_cDNA_insert",
            "def": "A clone insert made from cDNA. [SO:xp]"
        },
        "SO:0000914": {
            "name": "cloned_genomic_insert",
            "def": "A clone insert made from genomic DNA. [SO:xp]"
        },
        "SO:0000915": {
            "name": "engineered_insert",
            "def": "A clone insert that is engineered. [SO:xp]"
        },
        "SO:0000916": {
            "name": "edit_operation"
        },
        "SO:0000917": {
            "name": "insert_U",
            "def": "An edit to insert a U. [SO:ke]"
        },
        "SO:0000918": {
            "name": "delete_U",
            "def": "An edit to delete a uridine. [SO:ke]"
        },
        "SO:0000919": {
            "name": "substitute_A_to_I",
            "def": "An edit to substitute an I for an A. [SO:ke]"
        },
        "SO:0000920": {
            "name": "insert_C",
            "def": "An edit to insert a cytidine. [SO:ke]"
        },
        "SO:0000921": {
            "name": "insert_dinucleotide",
            "def": "An edit to insert a dinucleotide. [SO:ke]"
        },
        "SO:0000922": {
            "name": "substitute_C_to_U",
            "def": "An edit to substitute an U for a C. [SO:ke]"
        },
        "SO:0000923": {
            "name": "insert_G",
            "def": "An edit to insert a G. [SO:ke]"
        },
        "SO:0000924": {
            "name": "insert_GC",
            "def": "An edit to insert a GC dinucleotide. [SO:ke]"
        },
        "SO:0000925": {
            "name": "insert_GU",
            "def": "An edit to insert a GU dinucleotide. [SO:ke]"
        },
        "SO:0000926": {
            "name": "insert_CU",
            "def": "An edit to insert a CU dinucleotide. [SO:ke]"
        },
        "SO:0000927": {
            "name": "insert_AU",
            "def": "An edit to insert a AU dinucleotide. [SO:ke]"
        },
        "SO:0000928": {
            "name": "insert_AA",
            "def": "An edit to insert a AA dinucleotide. [SO:ke]"
        },
        "SO:0000929": {
            "name": "edited_mRNA",
            "def": "An mRNA that is edited. [SO:xp]"
        },
        "SO:0000930": {
            "name": "guide_RNA_region",
            "def": "A region of guide RNA. [SO:ma]"
        },
        "SO:0000931": {
            "name": "anchor_region",
            "def": "A region of a guide_RNA that base-pairs to a target mRNA. [SO:jk]"
        },
        "SO:0000932": {
            "name": "pre_edited_mRNA"
        },
        "SO:0000933": {
            "name": "intermediate",
            "def": "An attribute to describe a feature between stages of processing. [SO:ke]"
        },
        "SO:0000934": {
            "name": "miRNA_target_site",
            "def": "A miRNA target site is a binding site where the molecule is a micro RNA. [FB:cds]"
        },
        "SO:0000935": {
            "name": "edited_CDS",
            "def": "A CDS that is edited. [SO:xp]"
        },
        "SO:0000936": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment"
        },
        "SO:0000937": {
            "name": "vertebrate_immune_system_feature"
        },
        "SO:0000938": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster"
        },
        "SO:0000939": {
            "name": "vertebrate_immune_system_gene_recombination_signal_feature"
        },
        "SO:0000940": {
            "name": "recombinationally_rearranged"
        },
        "SO:0000941": {
            "name": "recombinationally_rearranged_vertebrate_immune_system_gene",
            "def": "A recombinationally rearranged gene of the vertebrate immune system. [SO:xp]"
        },
        "SO:0000942": {
            "name": "attP_site",
            "def": "An integration/excision site of a phage chromosome at which a recombinase acts to insert the phage DNA at a cognate integration/excision site on a bacterial chromosome. [SO:as]"
        },
        "SO:0000943": {
            "name": "attB_site",
            "def": "An integration/excision site of a bacterial chromosome at which a recombinase acts to insert foreign DNA containing a cognate integration/excision site. [SO:as]"
        },
        "SO:0000944": {
            "name": "attL_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attB_site and the 3' portion of attP_site. [SO:as]"
        },
        "SO:0000945": {
            "name": "attR_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attP_site and the 3' portion of attB_site. [SO:as]"
        },
        "SO:0000946": {
            "name": "integration_excision_site",
            "def": "A region specifically recognised by a recombinase, which inserts or removes another region marked by a distinct cognate integration/excision site. [SO:as]"
        },
        "SO:0000947": {
            "name": "resolution_site",
            "def": "A region specifically recognized by a recombinase, which separates a physically contiguous circle of DNA into two physically separate circles. [SO:as]"
        },
        "SO:0000948": {
            "name": "inversion_site",
            "def": "A region specifically recognised by a recombinase, which inverts the region flanked by a pair of sites. [SO:ma]"
        },
        "SO:0000949": {
            "name": "dif_site",
            "def": "A site at which replicated bacterial circular chromosomes are decatenated by site specific resolvase. [SO:as]"
        },
        "SO:0000950": {
            "name": "attC_site",
            "def": "An attC site is a sequence required for the integration of a DNA of an integron. [SO:as]"
        },
        "SO:0000951": {
            "name": "eukaryotic_terminator"
        },
        "SO:0000952": {
            "name": "oriV",
            "def": "An origin of vegetative replication in plasmids and phages. [SO:as]"
        },
        "SO:0000953": {
            "name": "oriC",
            "def": "An origin of bacterial chromosome replication. [SO:as]"
        },
        "SO:0000954": {
            "name": "DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, DNA molecule. [SO:ma]"
        },
        "SO:0000955": {
            "name": "double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded DNA molecule. [SO:ma]"
        },
        "SO:0000956": {
            "name": "single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded DNA molecule. [SO:ma]"
        },
        "SO:0000957": {
            "name": "linear_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear DNA molecule. [SO:ma]"
        },
        "SO:0000958": {
            "name": "circular_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000959": {
            "name": "linear_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear DNA molecule. [SO:ma]"
        },
        "SO:0000960": {
            "name": "circular_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000961": {
            "name": "RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, RNA molecule. [SO:ma]"
        },
        "SO:0000962": {
            "name": "single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded RNA molecule. [SO:ma]"
        },
        "SO:0000963": {
            "name": "linear_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear RNA molecule. [SO:ma]"
        },
        "SO:0000964": {
            "name": "linear_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear RNA molecule. [SO:ma]"
        },
        "SO:0000965": {
            "name": "double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded RNA molecule. [SO:ma]"
        },
        "SO:0000966": {
            "name": "circular_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000967": {
            "name": "circular_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular RNA molecule. [SO:ma]"
        },
        "SO:0000968": {
            "name": "sequence_replication_mode"
        },
        "SO:0000969": {
            "name": "rolling_circle"
        },
        "SO:0000970": {
            "name": "theta_replication"
        },
        "SO:0000971": {
            "name": "DNA_replication_mode"
        },
        "SO:0000972": {
            "name": "RNA_replication_mode"
        },
        "SO:0000973": {
            "name": "insertion_sequence",
            "def": "A terminal_inverted_repeat_element that is bacterial and only encodes the functions required for its transposition between these inverted repeats. [SO:as]"
        },
        "SO:0000975": {
            "name": "minicircle_gene"
        },
        "SO:0000976": {
            "name": "cryptic",
            "def": "A feature_attribute describing a feature that is not manifest under normal conditions. [SO:ke]"
        },
        "SO:0000977": {
            "name": "anchor_binding_site"
        },
        "SO:0000978": {
            "name": "template_region",
            "def": "A region of a guide_RNA that specifies the insertions and deletions of bases in the editing of a target mRNA. [SO:jk]"
        },
        "SO:0000979": {
            "name": "gRNA_encoding",
            "def": "A non-protein_coding gene that encodes a guide_RNA. [SO:ma]"
        },
        "SO:0000980": {
            "name": "minicircle",
            "def": "A minicircle is a replicon, part of a kinetoplast, that encodes for guide RNAs. [PMID:8395055]"
        },
        "SO:0000981": {
            "name": "rho_dependent_bacterial_terminator"
        },
        "SO:0000982": {
            "name": "rho_independent_bacterial_terminator"
        },
        "SO:0000983": {
            "name": "strand_attribute"
        },
        "SO:0000984": {
            "name": "single"
        },
        "SO:0000985": {
            "name": "double"
        },
        "SO:0000986": {
            "name": "topology_attribute"
        },
        "SO:0000987": {
            "name": "linear",
            "def": "A quality of a nucleotide polymer that has a 3'-terminal residue and a 5'-terminal residue. [SO:cb]"
        },
        "SO:0000988": {
            "name": "circular",
            "def": "A quality of a nucleotide polymer that has no terminal nucleotide residues. [SO:cb]"
        },
        "SO:0000989": {
            "name": "class_II_RNA",
            "def": "Small non-coding RNA (59-60 nt long) containing 5' and 3' ends that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
        },
        "SO:0000990": {
            "name": "class_I_RNA",
            "def": "Small non-coding RNA (55-65 nt long) containing highly conserved 5' and 3' ends (16 and 8 nt, respectively) that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
        },
        "SO:0000991": {
            "name": "genomic_DNA"
        },
        "SO:0000992": {
            "name": "BAC_cloned_genomic_insert"
        },
        "SO:0000993": {
            "name": "consensus"
        },
        "SO:0000994": {
            "name": "consensus_region"
        },
        "SO:0000995": {
            "name": "consensus_mRNA"
        },
        "SO:0000996": {
            "name": "predicted_gene"
        },
        "SO:0000997": {
            "name": "gene_fragment"
        },
        "SO:0000998": {
            "name": "recursive_splice_site",
            "def": "A recursive splice site is a splice site which subdivides a large intron. Recursive splicing is a mechanism that splices large introns by sub dividing the intron at non exonic elements and alternate exons. [http://www.genetics.org/cgi/content/full/170/2/661]"
        },
        "SO:0000999": {
            "name": "BAC_end",
            "def": "A region of sequence from the end of a BAC clone that may provide a highly specific marker. [SO:ke]"
        },
        "SO:0001000": {
            "name": "rRNA_16S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0001001": {
            "name": "rRNA_23S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the large subunit of the ribosome. [SO:ke]"
        },
        "SO:0001002": {
            "name": "rRNA_25S",
            "def": "A large polynucleotide which functions as part of the large subunit of the ribosome in some eukaryotes. [RSC:cb]"
        },
        "SO:0001003": {
            "name": "solo_LTR",
            "def": "A recombination product between the 2 LTR of the same element. [SO:ke]"
        },
        "SO:0001004": {
            "name": "low_complexity"
        },
        "SO:0001005": {
            "name": "low_complexity_region"
        },
        "SO:0001006": {
            "name": "prophage",
            "def": "A phage genome after it has established in the host genome in a latent/immune state either as a plasmid or as an integrated \\island\\. [GOC:jl]"
        },
        "SO:0001007": {
            "name": "cryptic_prophage",
            "def": "A remnant of an integrated prophage in the host genome or an \\island\\ in the host genome that includes phage like-genes. [GOC:jl]"
        },
        "SO:0001008": {
            "name": "tetraloop",
            "def": "A base-paired stem with loop of 4 non-hydrogen bonded nucleotides. [SO:ke]"
        },
        "SO:0001009": {
            "name": "DNA_constraint_sequence",
            "def": "A double-stranded DNA used to control macromolecular structure and function. [http:/www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&db=pubmed&term=SILVERMAN+SK[au\\]&dispmax=50]"
        },
        "SO:0001010": {
            "name": "i_motif",
            "def": "A cytosine rich domain whereby strands associate both inter- and intramolecularly at moderately acidic pH. [PMID:9753739]"
        },
        "SO:0001011": {
            "name": "PNA_oligo",
            "def": "Peptide nucleic acid, is a chemical not known to occur naturally but is artificially synthesized and used in some biological research and medical treatments. The PNA backbone is composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [SO:ke]"
        },
        "SO:0001012": {
            "name": "DNAzyme",
            "def": "A DNA sequence with catalytic activity. [SO:cb]"
        },
        "SO:0001013": {
            "name": "MNP",
            "def": "A multiple nucleotide polymorphism with alleles of common length > 1, for example AAA/TTT. [http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs=rs2067431]"
        },
        "SO:0001014": {
            "name": "intron_domain"
        },
        "SO:0001015": {
            "name": "wobble_base_pair",
            "def": "A type of non-canonical base pairing, most commonly between G and U, which is important for the secondary structure of RNAs. It has similar thermodynamic stability to the Watson-Crick pairing. Wobble base pairs only have two hydrogen bonds. Other wobble base pair possibilities are I-A, I-U and I-C. [PMID:11256617]"
        },
        "SO:0001016": {
            "name": "internal_guide_sequence",
            "def": "A purine-rich sequence in the group I introns which determines the locations of the splice sites in group I intron splicing and has catalytic activity. [SO:cb]"
        },
        "SO:0001017": {
            "name": "silent_mutation",
            "def": "A sequence variant that does not affect protein function. Silent mutations may occur in genic ( CDS, UTR, intron etc) and intergenic regions. Silent mutations may have affects on processes such as splicing and regulation. [SO:ke]"
        },
        "SO:0001018": {
            "name": "epitope",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with antibodies, B cells or T cells. [http://en.wikipedia.org/wiki/Epitope, SO:cb]"
        },
        "SO:0001019": {
            "name": "copy_number_variation",
            "def": "A variation that increases or decreases the copy number of a given region. [SO:ke]"
        },
        "SO:0001020": {
            "name": "sequence_variant_affecting_copy_number"
        },
        "SO:0001021": {
            "name": "chromosome_breakpoint"
        },
        "SO:0001022": {
            "name": "inversion_breakpoint",
            "def": "The point within a chromosome where an inversion begins or ends. [SO:cb]"
        },
        "SO:0001023": {
            "name": "allele",
            "def": "An allele is one of a set of coexisting sequence variants of a gene. [SO:immuno_workshop]"
        },
        "SO:0001024": {
            "name": "haplotype",
            "def": "A haplotype is one of a set of coexisting sequence variants of a haplotype block. [SO:immuno_workshop]"
        },
        "SO:0001025": {
            "name": "polymorphic_sequence_variant",
            "def": "A sequence variant that is segregating in one or more natural populations of a species. [SO:immuno_workshop]"
        },
        "SO:0001026": {
            "name": "genome",
            "def": "A genome is the sum of genetic material within a cell or virion. [SO:immuno_workshop]"
        },
        "SO:0001027": {
            "name": "genotype",
            "def": "A genotype is a variant genome, complete or incomplete. [SO:immuno_workshop]"
        },
        "SO:0001028": {
            "name": "diplotype",
            "def": "A diplotype is a pair of haplotypes from a given individual. It is a genotype where the phase is known. [SO:immuno_workshop]"
        },
        "SO:0001029": {
            "name": "direction_attribute"
        },
        "SO:0001030": {
            "name": "forward",
            "def": "Forward is an attribute of the feature, where the feature is in the 5' to 3' direction. [SO:ke]"
        },
        "SO:0001031": {
            "name": "reverse",
            "def": "Reverse is an attribute of the feature, where the feature is in the 3' to 5' direction. Again could be applied to primer. [SO:ke]"
        },
        "SO:0001032": {
            "name": "mitochondrial_DNA"
        },
        "SO:0001033": {
            "name": "chloroplast_DNA"
        },
        "SO:0001034": {
            "name": "miRtron",
            "def": "A de-branched intron which mimics the structure of pre-miRNA and enters the miRNA processing pathway without Drosha mediated cleavage. [PMID:17589500, SO:ma]"
        },
        "SO:0001035": {
            "name": "piRNA",
            "def": "A small non coding RNA, part of a silencing system that prevents the spreading of selfish genetic elements. [SO:ke]"
        },
        "SO:0001036": {
            "name": "arginyl_tRNA",
            "def": "A tRNA sequence that has an arginine anticodon, and a 3' arginine binding region. [SO:ke]"
        },
        "SO:0001037": {
            "name": "mobile_genetic_element",
            "def": "A nucleotide region with either intra-genome or intracellular mobility, of varying length, which often carry the information necessary for transfer and recombination with the host genome. [PMID:14681355]"
        },
        "SO:0001038": {
            "name": "extrachromosomal_mobile_genetic_element",
            "def": "An MGE that is not integrated into the host chromosome. [SO:ke]"
        },
        "SO:0001039": {
            "name": "integrated_mobile_genetic_element",
            "def": "An MGE that is integrated into the host chromosome. [SO:ke]"
        },
        "SO:0001040": {
            "name": "integrated_plasmid",
            "def": "A plasmid sequence that is integrated within the host chromosome. [SO:ke]"
        },
        "SO:0001041": {
            "name": "viral_sequence",
            "def": "The region of nucleotide sequence of a virus, a submicroscopic particle that replicates by infecting a host cell. [SO:ke]"
        },
        "SO:0001042": {
            "name": "phage_sequence",
            "def": "The nucleotide sequence of a virus that infects bacteria. [SO:ke]"
        },
        "SO:0001043": {
            "name": "attCtn_site",
            "def": "An attachment site located on a conjugative transposon and used for site-specific integration of a conjugative transposon. [Phigo:at]"
        },
        "SO:0001044": {
            "name": "nuclear_mt_pseudogene",
            "def": "A nuclear pseudogene of either coding or non-coding mitochondria derived sequence. [SO:xp]"
        },
        "SO:0001045": {
            "name": "cointegrated_plasmid",
            "def": "A MGE region consisting of two fused plasmids resulting from a replicative transposition event. [phigo:at]"
        },
        "SO:0001046": {
            "name": "IRLinv_site",
            "def": "Component of the inversion site located at the left of a region susceptible to site-specific inversion. [Phigo:at]"
        },
        "SO:0001047": {
            "name": "IRRinv_site",
            "def": "Component of the inversion site located at the right of a region susceptible to site-specific inversion. [Phigo:at]"
        },
        "SO:0001048": {
            "name": "inversion_site_part",
            "def": "A region located within an inversion site. [SO:ke]"
        },
        "SO:0001049": {
            "name": "defective_conjugative_transposon",
            "def": "An island that contains genes for integration/excision and the gene and site for the initiation of intercellular transfer by conjugation. It can be complemented for transfer by a conjugative transposon. [Phigo:ariane]"
        },
        "SO:0001050": {
            "name": "repeat_fragment",
            "def": "A portion of a repeat, interrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001051": {
            "name": "nested_region"
        },
        "SO:0001052": {
            "name": "nested_repeat"
        },
        "SO:0001053": {
            "name": "nested_transposon"
        },
        "SO:0001054": {
            "name": "transposon_fragment",
            "def": "A portion of a transposon, interrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001055": {
            "name": "transcriptional_cis_regulatory_region",
            "def": "A regulatory_region that modulates the transcription of a gene or genes. [PMID:9679020, SO:regcreative]"
        },
        "SO:0001056": {
            "name": "splicing_regulatory_region",
            "def": "A regulatory_region that modulates splicing. [SO:ke]"
        },
        "SO:0001057": {
            "name": "enhanceosome"
        },
        "SO:0001058": {
            "name": "promoter_targeting_sequence",
            "def": "A transcriptional_cis_regulatory_region that restricts the activity of a CRM to a single promoter and which functions only when both itself and an insulator are located between the CRM and the promoter. [SO:regcreative]"
        },
        "SO:0001059": {
            "name": "sequence_alteration",
            "def": "A sequence_alteration is a sequence_feature whose extent is the deviation from another sequence. [SO:ke]"
        },
        "SO:0001060": {
            "name": "sequence_variant",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
        },
        "SO:0001061": {
            "name": "propeptide_cleavage_site",
            "def": "The propeptide_cleavage_site is the arginine/lysine boundary on a propeptide where cleavage occurs. [EBIBS:GAR]"
        },
        "SO:0001062": {
            "name": "propeptide",
            "def": "Part of a peptide chain which is cleaved off during the formation of the mature protein. [EBIBS:GAR]"
        },
        "SO:0001063": {
            "name": "immature_peptide_region",
            "def": "An immature_peptide_region is the extent of the peptide after it has been translated and before any processing occurs. [EBIBS:GAR]"
        },
        "SO:0001064": {
            "name": "active_peptide",
            "def": "Active peptides are proteins which are biologically active, released from a precursor molecule. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001066": {
            "name": "compositionally_biased_region_of_peptide",
            "def": "Polypeptide region that is rich in a particular amino acid or homopolymeric and greater than three residues in length. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001067": {
            "name": "polypeptide_motif",
            "def": "A sequence motif is a short (up to 20 amino acids) region of biological interest. Such motifs, although they are too short to constitute functional domains, share sequence similarities and are conserved in different proteins. They display a common function (protein-binding, subcellular location etc.). [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001068": {
            "name": "polypeptide_repeat",
            "def": "A polypeptide_repeat is a single copy of an internal sequence repetition. [EBIBS:GAR]"
        },
        "SO:0001070": {
            "name": "polypeptide_structural_region",
            "def": "Region of polypeptide with a given structural property. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001071": {
            "name": "membrane_structure",
            "def": "Arrangement of the polypeptide with respect to the lipid bilayer. [EBIBS:GAR]"
        },
        "SO:0001072": {
            "name": "extramembrane_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001073": {
            "name": "cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized inside the cytoplasm. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001074": {
            "name": "non_cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer and outside of the cytoplasm. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001075": {
            "name": "intramembrane_polypeptide_region",
            "def": "Polypeptide region present in the lipid bilayer. [EBIBS:GAR]"
        },
        "SO:0001076": {
            "name": "membrane_peptide_loop",
            "def": "Polypeptide region localized within the lipid bilayer where both ends traverse the same membrane. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001077": {
            "name": "transmembrane_polypeptide_region",
            "def": "Polypeptide region traversing the lipid bilayer. [EBIBS:GAR, UniProt:curator_manual]"
        },
        "SO:0001078": {
            "name": "polypeptide_secondary_structure",
            "def": "A region of peptide with secondary structure has hydrogen bonding along the peptide chain that causes a defined conformation of the chain. [EBIBS:GAR]"
        },
        "SO:0001079": {
            "name": "polypeptide_structural_motif",
            "def": "Motif is a three-dimensional structural element within the chain, which appears also in a variety of other molecules. Unlike a domain, a motif does not need to form a stable globular unit. [EBIBS:GAR]"
        },
        "SO:0001080": {
            "name": "coiled_coil",
            "def": "A coiled coil is a structural motif in proteins, in which alpha-helices are coiled together like the strands of a rope. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001081": {
            "name": "helix_turn_helix",
            "def": "A motif comprising two helices separated by a turn. [EBIBS:GAR]"
        },
        "SO:0001082": {
            "name": "polypeptide_sequencing_information",
            "def": "Incompatibility in the sequence due to some experimental problem. [EBIBS:GAR]"
        },
        "SO:0001083": {
            "name": "non_adjacent_residues",
            "def": "Indicates that two consecutive residues in a fragment sequence are not consecutive in the full-length protein and that there are a number of unsequenced residues between them. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001084": {
            "name": "non_terminal_residue",
            "def": "The residue at an extremity of the sequence is not the terminal residue. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001085": {
            "name": "sequence_conflict",
            "def": "Different sources report differing sequences. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001086": {
            "name": "sequence_uncertainty",
            "def": "Describes the positions in a sequence where the authors are unsure about the sequence assignment. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001087": {
            "name": "cross_link",
            "def": "Posttranslationally formed amino acid bonds. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001088": {
            "name": "disulfide_bond",
            "def": "The covalent bond between sulfur atoms that binds two peptide chains or different parts of one peptide chain and is a structural determinant in many protein molecules. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001089": {
            "name": "post_translationally_modified_region",
            "def": "A region where a transformation occurs in a protein after it has been synthesized. This which may regulate, stabilize, crosslink or introduce new chemical functionalities in the protein. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001090": {
            "name": "covalent_binding_site",
            "def": "Binding involving a covalent bond. [EBIBS:GAR]"
        },
        "SO:0001091": {
            "name": "non_covalent_binding_site",
            "def": "Binding site for any chemical group (co-enzyme, prosthetic group, etc.). [EBIBS:GAR]"
        },
        "SO:0001092": {
            "name": "polypeptide_metal_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with metal ions. [EBIBS:GAR, SO:cb, UniProt:curation_manual]"
        },
        "SO:0001093": {
            "name": "protein_protein_contact",
            "def": "A binding site that, in the protein molecule, interacts selectively and non-covalently with polypeptide residues. [EBIBS:GAR, UniProt:Curation_manual]"
        },
        "SO:0001094": {
            "name": "polypeptide_calcium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with calcium ions. [EBIBS:GAR]"
        },
        "SO:0001095": {
            "name": "polypeptide_cobalt_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with cobalt ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001096": {
            "name": "polypeptide_copper_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with copper ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001097": {
            "name": "polypeptide_iron_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with iron ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001098": {
            "name": "polypeptide_magnesium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with magnesium ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001099": {
            "name": "polypeptide_manganese_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with manganese ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001100": {
            "name": "polypeptide_molybdenum_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with molybdenum ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001101": {
            "name": "polypeptide_nickel_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with nickel ions. [EBIBS:GAR]"
        },
        "SO:0001102": {
            "name": "polypeptide_tungsten_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with tungsten ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001103": {
            "name": "polypeptide_zinc_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with zinc ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001104": {
            "name": "catalytic_residue",
            "def": "Amino acid involved in the activity of an enzyme. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001105": {
            "name": "polypeptide_ligand_contact",
            "def": "Residues which interact with a ligand. [EBIBS:GAR]"
        },
        "SO:0001106": {
            "name": "asx_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: Residue(i) is Aspartate or Asparagine (Asx), side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3), main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001107": {
            "name": "beta_bulge",
            "def": "A motif of three residues within a beta-sheet in which the main chains of two consecutive residues are H-bonded to that of the third, and in which the dihedral angles are as follows: Residue(i): -140 degrees < phi(l) -20 degrees , -90 degrees < psi(l) < 40 degrees. Residue (i+1): -180 degrees < phi < -25 degrees or +120 degrees < phi < +180 degrees, +40 degrees < psi < +180 degrees or -180 degrees < psi < -120 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001108": {
            "name": "beta_bulge_loop",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds. Beta bulge loops often occur at the loop ends of beta-hairpins. [EBIBS:GAR, Http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001109": {
            "name": "beta_bulge_loop_five",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+4), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+3), these loops have an RL nest at residues i+2 and i+3. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001110": {
            "name": "beta_bulge_loop_six",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+5), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+4), these loops have an RL nest at residues i+3 and i+4. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001111": {
            "name": "beta_strand",
            "def": "A beta strand describes a single length of polypeptide chain that forms part of a beta sheet. A single continuous stretch of amino acids adopting an extended conformation of hydrogen bonds between the N-O and the C=O of another part of the peptide. This forms a secondary protein structure in which two or more extended polypeptide regions are hydrogen-bonded to one another in a planar array. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001112": {
            "name": "antiparallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (one running N-terminal to C-terminal and one running C-terminal to N-terminal). Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i) and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they form two mutual backbone hydrogen bonds to each other's flanking peptide groups; this is known as a close pair of hydrogen bonds. The peptide backbone dihedral angles (phi, psi) are about (-140 degrees, 135 degrees) in antiparallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001113": {
            "name": "parallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (both running N-terminal to C-terminal). This orientation is slightly less stable because it introduces nonplanarity in the inter-strand hydrogen bonding pattern. Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i)and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they do not hydrogen bond to each other; rather, one residue forms hydrogen bonds to the residues that flank the other (but not vice versa). For example, residue i may form hydrogen bonds to residues j - 1 and j + 1; this is known as a wide pair of hydrogen bonds. By contrast, residue j may hydrogen-bond to different residues altogether, or to none at all. The dihedral angles (phi, psi) are about (-120 degrees, 115 degrees) in parallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001114": {
            "name": "peptide_helix",
            "def": "A helix is a secondary_structure conformation where the peptide backbone forms a coil. [EBIBS:GAR]"
        },
        "SO:0001115": {
            "name": "left_handed_peptide_helix",
            "def": "A left handed helix is a region of peptide where the coiled conformation turns in an anticlockwise, left handed screw. [EBIBS:GAR]"
        },
        "SO:0001116": {
            "name": "right_handed_peptide_helix",
            "def": "A right handed helix is a region of peptide where the coiled conformation turns in a clockwise, right handed screw. [EBIBS:GAR]"
        },
        "SO:0001117": {
            "name": "alpha_helix",
            "def": "The helix has 3.6 residues per turn which corresponds to a translation of 1.5 angstroms (= 0.15 nm) along the helical axis. Every backbone N-H group donates a hydrogen bond to the backbone C=O group of the amino acid four residues earlier. [EBIBS:GAR]"
        },
        "SO:0001118": {
            "name": "pi_helix",
            "def": "The pi helix has 4.1 residues per turn and a translation of 1.15  (=0.115 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid five residues earlier. [EBIBS:GAR]"
        },
        "SO:0001119": {
            "name": "three_ten_helix",
            "def": "The 3-10 helix has 3 residues per turn with a translation of 2.0 angstroms (=0.2 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid three residues earlier. [EBIBS:GAR]"
        },
        "SO:0001120": {
            "name": "polypeptide_nest_motif",
            "def": "A motif of two consecutive residues with dihedral angles. Nest should not have Proline as any residue. Nests frequently occur as parts of other motifs such as Schellman loops. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001121": {
            "name": "polypeptide_nest_left_right_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001122": {
            "name": "polypeptide_nest_right_left_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001123": {
            "name": "schellmann_loop",
            "def": "A motif of six or seven consecutive residues that contains two H-bonds. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001124": {
            "name": "schellmann_loop_seven",
            "def": "Wild type: A motif of seven consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+6), the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+5). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001125": {
            "name": "schellmann_loop_six",
            "def": "Common Type: A motif of six consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+5) the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001126": {
            "name": "serine_threonine_motif",
            "def": "A motif of five consecutive residues and two hydrogen bonds in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3) , the main-chain CO group of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001127": {
            "name": "serine_threonine_staple_motif",
            "def": "A motif of four or five consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain OH of residue(i) is H-bonded to the main-chain CO of residue(i3) or (i4), Phi angles of residues(i1), (i2) and (i3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001128": {
            "name": "polypeptide_turn_motif",
            "def": "A reversal in the direction of the backbone of a protein that is stabilized by hydrogen bond between backbone NH and CO groups, involving no more than 4 amino acid residues. [EBIBS:GAR, uniprot:feature_type]"
        },
        "SO:0001129": {
            "name": "asx_turn_left_handed_type_one",
            "def": "Left handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001130": {
            "name": "asx_turn_left_handed_type_two",
            "def": "Left handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001131": {
            "name": "asx_turn_right_handed_type_two",
            "def": "Right handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001132": {
            "name": "asx_turn_right_handed_type_one",
            "def": "Right handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001133": {
            "name": "beta_turn",
            "def": "A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles of the second and third residues, which are the basis for sub-categorization. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001134": {
            "name": "beta_turn_left_handed_type_one",
            "def": "Left handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles:- Residue(i+1): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. Residue(i+2): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001135": {
            "name": "beta_turn_left_handed_type_two",
            "def": "Left handed type II: A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees > phi > -20 degrees, +80 degrees > psi > +180 degrees. Residue(i+2): +20 degrees > phi > +140 degrees, -40 degrees > psi > +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001136": {
            "name": "beta_turn_right_handed_type_one",
            "def": "Right handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+2): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001137": {
            "name": "beta_turn_right_handed_type_two",
            "def": "Right handed type II:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, +80 degrees < psi < +180 degrees. Residue(i+2): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001138": {
            "name": "gamma_turn",
            "def": "Gamma turns, defined for 3 residues i,( i+1),( i+2) if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001139": {
            "name": "gamma_turn_classic",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=75.0 - psi(i+1)=-64.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001140": {
            "name": "gamma_turn_inverse",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=-79.0 - psi(i+1)=69.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001141": {
            "name": "serine_threonine_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001142": {
            "name": "st_turn_left_handed_type_one",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001143": {
            "name": "st_turn_left_handed_type_two",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001144": {
            "name": "st_turn_right_handed_type_one",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001145": {
            "name": "st_turn_right_handed_type_two",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001146": {
            "name": "polypeptide_variation_site",
            "def": "A site of sequence variation (alteration). Alternative sequence due to naturally occurring events such as polymorphisms and alternative splicing or experimental methods such as site directed mutagenesis. [EBIBS:GAR, SO:ke]"
        },
        "SO:0001147": {
            "name": "natural_variant_site",
            "def": "Describes the natural sequence variants due to polymorphisms, disease-associated mutations, RNA editing and variations between strains, isolates or cultivars. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001148": {
            "name": "mutated_variant_site",
            "def": "Site which has been experimentally altered. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001149": {
            "name": "alternate_sequence_site",
            "def": "Description of sequence variants produced by alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001150": {
            "name": "beta_turn_type_six",
            "def": "A motif of four consecutive peptide resides of type VIa or type VIb and where the i+2 residue is cis-proline. [SO:cb]"
        },
        "SO:0001151": {
            "name": "beta_turn_type_six_a",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -90 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001152": {
            "name": "beta_turn_type_six_a_one"
        },
        "SO:0001153": {
            "name": "beta_turn_type_six_a_two"
        },
        "SO:0001154": {
            "name": "beta_turn_type_six_b",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -120 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -60 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001155": {
            "name": "beta_turn_type_eight",
            "def": "A motif of four consecutive peptide residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ -30 degrees. Residue(i+2): phi ~ -120 degrees, psi ~ 120 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001156": {
            "name": "DRE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -10 and -60 relative to the TSS. Consensus sequence is WATCGATW. [PMID:12537576]"
        },
        "SO:0001157": {
            "name": "DMv4_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements with respect to the TSS (+1). Consensus sequence is YGGTCACACTR. Marked spatial preference within core promoter; tend to occur near the TSS, although not as tightly as INR (SO:0000014). [PMID:16827941:12537576]"
        },
        "SO:0001158": {
            "name": "E_box_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and +1 relative to the TSS. Consensus sequence is AWCAGCTGWT. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015). [PMID:12537576:16827941]"
        },
        "SO:0001159": {
            "name": "DMv5_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -50 and -10 relative to the TSS. Consensus sequence is KTYRGTATWTTT. Tends to co-occur with DMv4 (SO:0001157) . Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
        },
        "SO:0001160": {
            "name": "DMv3_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -30 and +15 relative to the TSS. Consensus sequence is KNNCAKCNCTRNY. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015) or MTE (0001162). [PMID:12537576:16827941]"
        },
        "SO:0001161": {
            "name": "DMv2_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and -45 relative to the TSS. Consensus sequence is MKSYGGCARCGSYSS. Tends to co-occur with DMv3 (SO:0001160). Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
        },
        "SO:0001162": {
            "name": "MTE",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between +20 and +30 relative to the TSS. Consensus sequence is CSARCSSAACGS. Tends to co-occur with INR motif (SO:0000014). Tends to not occur with DPE motif (SO:0000015) or DMv5 (SO:0001159). [PMID:12537576:15231738, PMID:16858867]"
        },
        "SO:0001163": {
            "name": "INR1_motif",
            "def": "A promoter motif with consensus sequence TCATTCG. [PMID:16827941]"
        },
        "SO:0001164": {
            "name": "DPE1_motif",
            "def": "A promoter motif with consensus sequence CGGACGT. [PMID:16827941]"
        },
        "SO:0001165": {
            "name": "DMv1_motif",
            "def": "A promoter motif with consensus sequence CARCCCT. [PMID:16827941]"
        },
        "SO:0001166": {
            "name": "GAGA_motif",
            "def": "A non directional promoter motif with consensus sequence GAGAGCG. [PMID:16827941]"
        },
        "SO:0001167": {
            "name": "NDM2_motif",
            "def": "A non directional promoter motif with consensus CGMYGYCR. [PMID:16827941]"
        },
        "SO:0001168": {
            "name": "NDM3_motif",
            "def": "A non directional promoter motif with consensus sequence GAAAGCT. [PMID:16827941]"
        },
        "SO:0001169": {
            "name": "ds_RNA_viral_sequence",
            "def": "A ds_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded RNA. [SO:ke]"
        },
        "SO:0001170": {
            "name": "polinton",
            "def": "A kind of DNA transposon that populates the genomes of protists, fungi, and animals, characterized by a unique set of proteins necessary for their transposition, including a protein-primed DNA polymerase B, retroviral integrase, cysteine protease, and ATPase. Polintons are characterized by 6-bp target site duplications, terminal-inverted repeats that are several hundred nucleotides long, and 5'-AG and TC-3' termini. Polintons exist as autonomous and nonautonomous elements. [PMID:16537396]"
        },
        "SO:0001171": {
            "name": "rRNA_21S",
            "def": "A component of the large ribosomal subunit in mitochondrial rRNA. [RSC:cb]"
        },
        "SO:0001172": {
            "name": "tRNA_region",
            "def": "A region of a tRNA. [RSC:cb]"
        },
        "SO:0001173": {
            "name": "anticodon_loop",
            "def": "A sequence of seven nucleotide bases in tRNA which contains the anticodon. It has the sequence 5'-pyrimidine-purine-anticodon-modified purine-any base-3. [ISBN:0716719207]"
        },
        "SO:0001174": {
            "name": "anticodon",
            "def": "A sequence of three nucleotide bases in tRNA which recognizes a codon in mRNA. [RSC:cb]"
        },
        "SO:0001175": {
            "name": "CCA_tail",
            "def": "Base sequence at the 3' end of a tRNA. The 3'-hydroxyl group on the terminal adenosine is the attachment point for the amino acid. [ISBN:0716719207]"
        },
        "SO:0001176": {
            "name": "DHU_loop",
            "def": "Non-base-paired sequence of nucleotide bases in tRNA. It contains several dihydrouracil residues. [ISBN:071671920]"
        },
        "SO:0001177": {
            "name": "T_loop",
            "def": "Non-base-paired sequence of three nucleotide bases in tRNA. It has sequence T-Psi-C. [ISBN:0716719207]"
        },
        "SO:0001178": {
            "name": "pyrrolysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding pyrrolysyl tRNA (SO:0000766). [RSC:cb]"
        },
        "SO:0001179": {
            "name": "U3_snoRNA",
            "def": "U3 snoRNA is a member of the box C/D class of small nucleolar RNAs. The U3 snoRNA secondary structure is characterised by a small 5' domain (with boxes A and A'), and a larger 3' domain (with boxes B, C, C', and D), the two domains being linked by a single-stranded hinge. Boxes B and C form the B/C motif, which appears to be exclusive to U3 snoRNAs, and boxes C' and D form the C'/D motif. The latter is functionally similar to the C/D motifs found in other snoRNAs. The 5' domain and the hinge region act as a pre-rRNA-binding domain. The 3' domain has conserved protein-binding sites. Both the box B/C and box C'/D motifs are sufficient for nuclear retention of U3 snoRNA. The box C'/D motif is also necessary for nucleolar localization, stability and hypermethylation of U3 snoRNA. Both box B/C and C'/D motifs are involved in specific protein interactions and are necessary for the rRNA processing functions of U3 snoRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00012]"
        },
        "SO:0001180": {
            "name": "AU_rich_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is rich in AUUUA pentamers. Messenger RNAs bearing multiple AU-rich elements are often unstable. [PMID:7892223]"
        },
        "SO:0001181": {
            "name": "Bruno_response_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is bound by the Drosophila Bruno protein and its homologs. [PMID:10893231]"
        },
        "SO:0001182": {
            "name": "iron_responsive_element",
            "def": "A regulatory sequence found in the 5' and 3' UTRs of many mRNAs which encode iron-binding proteins. It has a hairpin structure and is recognized by trans-acting proteins known as iron-regulatory proteins. [PMID:3198610, PMID:8710843]"
        },
        "SO:0001183": {
            "name": "morpholino_backbone",
            "def": "An attribute describing a sequence composed of nucleobases bound to a morpholino backbone. A morpholino backbone consists of morpholine (CHEBI:34856) rings connected by phosphorodiamidate linkages. [RSC:cb]"
        },
        "SO:0001184": {
            "name": "PNA",
            "def": "An attribute describing a sequence composed of peptide nucleic acid (CHEBI:48021), a chemical consisting of nucleobases bound to a backbone composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [RSC:cb]"
        },
        "SO:0001185": {
            "name": "enzymatic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0001186": {
            "name": "ribozymic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity even without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0001187": {
            "name": "pseudouridylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of pseudouridylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
        },
        "SO:0001188": {
            "name": "LNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of 'locked' deoxyribose rings connected to a phosphate backbone. The deoxyribose unit's conformation is 'locked' by a 2'-C,4'-C-oxymethylene link. [CHEBI:48010]"
        },
        "SO:0001189": {
            "name": "LNA_oligo",
            "def": "An oligo composed of LNA residues. [RSC:cb]"
        },
        "SO:0001190": {
            "name": "TNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of threose rings connected to a phosphate backbone. [CHEBI:48019]"
        },
        "SO:0001191": {
            "name": "TNA_oligo",
            "def": "An oligo composed of TNA residues. [RSC:cb]"
        },
        "SO:0001192": {
            "name": "GNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of an acyclic three-carbon propylene glycol connected to a phosphate backbone. It has two enantiomeric forms, (R)-GNA and (S)-GNA. [CHEBI:48015]"
        },
        "SO:0001193": {
            "name": "GNA_oligo",
            "def": "An oligo composed of GNA residues. [RSC:cb]"
        },
        "SO:0001194": {
            "name": "R_GNA",
            "def": "An attribute describing a GNA sequence in the (R)-GNA enantiomer. [CHEBI:48016]"
        },
        "SO:0001195": {
            "name": "R_GNA_oligo",
            "def": "An oligo composed of (R)-GNA residues. [RSC:cb]"
        },
        "SO:0001196": {
            "name": "S_GNA",
            "def": "An attribute describing a GNA sequence in the (S)-GNA enantiomer. [CHEBI:48017]"
        },
        "SO:0001197": {
            "name": "S_GNA_oligo",
            "def": "An oligo composed of (S)-GNA residues. [RSC:cb]"
        },
        "SO:0001198": {
            "name": "ds_DNA_viral_sequence",
            "def": "A ds_DNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded DNA. [SO:ke]"
        },
        "SO:0001199": {
            "name": "ss_RNA_viral_sequence",
            "def": "A ss_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as single stranded RNA. [SO:ke]"
        },
        "SO:0001200": {
            "name": "negative_sense_ssRNA_viral_sequence",
            "def": "A negative_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that is complementary to mRNA and must be converted to positive sense RNA by RNA polymerase before translation. [SO:ke]"
        },
        "SO:0001201": {
            "name": "positive_sense_ssRNA_viral_sequence",
            "def": "A positive_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that can be immediately translated by the host. [SO:ke]"
        },
        "SO:0001202": {
            "name": "ambisense_ssRNA_viral_sequence",
            "def": "A ambisense_RNA_virus is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus with both messenger and anti messenger polarity. [SO:ke]"
        },
        "SO:0001203": {
            "name": "RNA_polymerase_promoter",
            "def": "A region (DNA) to which RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001204": {
            "name": "Phage_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which Bacteriophage RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001205": {
            "name": "SP6_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the SP6 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001206": {
            "name": "T3_RNA_Polymerase_Promoter",
            "def": "A DNA sequence to which the T3 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001207": {
            "name": "T7_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the T7 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001208": {
            "name": "five_prime_EST",
            "def": "An EST read from the 5' end of a transcript that usually codes for a protein. These regions tend to be conserved across species and do not change much within a gene family. [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
        },
        "SO:0001209": {
            "name": "three_prime_EST",
            "def": "An EST read from the 3' end of a transcript. They are more likely to fall within non-coding, or untranslated regions(UTRs). [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
        },
        "SO:0001210": {
            "name": "translational_frameshift",
            "def": "The region of mRNA (not divisible by 3 bases) that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001211": {
            "name": "plus_1_translational_frameshift",
            "def": "The region of mRNA 1 base long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001212": {
            "name": "plus_2_translational_frameshift",
            "def": "The region of mRNA 2 bases long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001213": {
            "name": "group_III_intron",
            "def": "Group III introns are introns found in the mRNA of the plastids of euglenoid protists. They are spliced by a two step transesterification with bulged adenosine as initiating nucleophile. [PMID:11377794]"
        },
        "SO:0001214": {
            "name": "noncoding_region_of_exon",
            "def": "The maximal intersection of exon and UTR. [SO:ke]"
        },
        "SO:0001215": {
            "name": "coding_region_of_exon",
            "def": "The region of an exon that encodes for protein sequence. [SO:ke]"
        },
        "SO:0001216": {
            "name": "endonuclease_spliced_intron",
            "def": "An intron that spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
        },
        "SO:0001217": {
            "name": "protein_coding_gene"
        },
        "SO:0001218": {
            "name": "transgenic_insertion",
            "def": "An insertion that derives from another organism, via the use of recombinant DNA technology. [SO:bm]"
        },
        "SO:0001219": {
            "name": "retrogene"
        },
        "SO:0001220": {
            "name": "silenced_by_RNA_interference",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by RNA interference. [RSC:cb]"
        },
        "SO:0001221": {
            "name": "silenced_by_histone_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone modification. [RSC:cb]"
        },
        "SO:0001222": {
            "name": "silenced_by_histone_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone methylation. [RSC:cb]"
        },
        "SO:0001223": {
            "name": "silenced_by_histone_deacetylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone deacetylation. [RSC:cb]"
        },
        "SO:0001224": {
            "name": "gene_silenced_by_RNA_interference",
            "def": "A gene that is silenced by RNA interference. [SO:xp]"
        },
        "SO:0001225": {
            "name": "gene_silenced_by_histone_modification",
            "def": "A gene that is silenced by histone modification. [SO:xp]"
        },
        "SO:0001226": {
            "name": "gene_silenced_by_histone_methylation",
            "def": "A gene that is silenced by histone methylation. [SO:xp]"
        },
        "SO:0001227": {
            "name": "gene_silenced_by_histone_deacetylation",
            "def": "A gene that is silenced by histone deacetylation. [SO:xp]"
        },
        "SO:0001228": {
            "name": "dihydrouridine",
            "def": "A modified RNA base in which the 5,6-dihydrouracil is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001229": {
            "name": "pseudouridine",
            "def": "A modified RNA base in which the 5- position of the uracil is bound to the ribose ring instead of the 4- position. [RSC:cb]"
        },
        "SO:0001230": {
            "name": "inosine",
            "def": "A modified RNA base in which hypoxanthine is bound to the ribose ring. [http://library.med.utah.edu/RNAmods/, RSC:cb]"
        },
        "SO:0001231": {
            "name": "seven_methylguanine",
            "def": "A modified RNA base in which guanine is methylated at the 7- position. [RSC:cb]"
        },
        "SO:0001232": {
            "name": "ribothymidine",
            "def": "A modified RNA base in which thymine is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001233": {
            "name": "methylinosine",
            "def": "A modified RNA base in which methylhypoxanthine is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001234": {
            "name": "mobile",
            "def": "An attribute describing a feature that has either intra-genome or intracellular mobility. [RSC:cb]"
        },
        "SO:0001235": {
            "name": "replicon",
            "def": "A region containing at least one unique origin of replication and a unique termination site. [ISBN:0716719207]"
        },
        "SO:0001236": {
            "name": "base",
            "def": "A base is a sequence feature that corresponds to a single unit of a nucleotide polymer. [SO:ke]"
        },
        "SO:0001237": {
            "name": "amino_acid",
            "def": "A sequence feature that corresponds to a single amino acid residue in a polypeptide. [RSC:cb]"
        },
        "SO:0001238": {
            "name": "major_TSS"
        },
        "SO:0001239": {
            "name": "minor_TSS"
        },
        "SO:0001240": {
            "name": "TSS_region",
            "def": "The region of a gene from the 5' most TSS to the 3' TSS. [BBOP:nw]"
        },
        "SO:0001241": {
            "name": "encodes_alternate_transcription_start_sites"
        },
        "SO:0001243": {
            "name": "miRNA_primary_transcript_region",
            "def": "A part of an miRNA primary_transcript. [SO:ke]"
        },
        "SO:0001244": {
            "name": "pre_miRNA",
            "def": "The 60-70 nucleotide region remain after Drosha processing of the primary transcript, that folds back upon itself to form a hairpin structure. [SO:ke]"
        },
        "SO:0001245": {
            "name": "miRNA_stem",
            "def": "The stem of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
        },
        "SO:0001246": {
            "name": "miRNA_loop",
            "def": "The loop of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
        },
        "SO:0001247": {
            "name": "synthetic_oligo",
            "def": "An oligo composed of synthetic nucleotides. [SO:ke]"
        },
        "SO:0001248": {
            "name": "assembly",
            "def": "A region of the genome of known length that is composed by ordering and aligning two or more different regions. [SO:ke]"
        },
        "SO:0001249": {
            "name": "fragment_assembly",
            "def": "A fragment assembly is a genome assembly that orders overlapping fragments of the genome based on landmark sequences. The base pair distance between the landmarks is known allowing additivity of lengths. [SO:ke]"
        },
        "SO:0001250": {
            "name": "fingerprint_map",
            "def": "A fingerprint_map is a physical map composed of restriction fragments. [SO:ke]"
        },
        "SO:0001251": {
            "name": "STS_map",
            "def": "An STS map is a physical map organized by the unique STS landmarks. [SO:ke]"
        },
        "SO:0001252": {
            "name": "RH_map",
            "def": "A radiation hybrid map is a physical map. [SO:ke]"
        },
        "SO:0001253": {
            "name": "sonicate_fragment",
            "def": "A DNA fragment generated by sonication. Sonication is a technique used to sheer DNA into smaller fragments. [SO:ke]"
        },
        "SO:0001254": {
            "name": "polyploid",
            "def": "A kind of chromosome variation where the chromosome complement is an exact multiple of the haploid number and is greater than the diploid number. [SO:ke]"
        },
        "SO:0001255": {
            "name": "autopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from the same organism. [SO:ke]"
        },
        "SO:0001256": {
            "name": "allopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from a different organism. [SO:ke]"
        },
        "SO:0001257": {
            "name": "homing_endonuclease_binding_site",
            "def": "The binding site (recognition site) of a homing endonuclease. The binding site is typically large. [SO:ke]"
        },
        "SO:0001258": {
            "name": "octamer_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters with sequence ATTGCAT that binds Pou-domain transcription factors. [GOC:dh, PMID:3095662]"
        },
        "SO:0001259": {
            "name": "apicoplast_chromosome",
            "def": "A chromosome originating in an apicoplast. [SO:xp]"
        },
        "SO:0001260": {
            "name": "sequence_collection",
            "def": "A collection of discontinuous sequences. [SO:ke]"
        },
        "SO:0001261": {
            "name": "overlapping_feature_set",
            "def": "A continuous region of sequence composed of the overlapping of multiple sequence_features, which ultimately provides evidence for another sequence_feature. [SO:ke]"
        },
        "SO:0001262": {
            "name": "overlapping_EST_set",
            "def": "A continous experimental result region extending the length of multiple overlapping EST's. [SO:ke]"
        },
        "SO:0001263": {
            "name": "ncRNA_gene"
        },
        "SO:0001264": {
            "name": "gRNA_gene"
        },
        "SO:0001265": {
            "name": "miRNA_gene"
        },
        "SO:0001266": {
            "name": "scRNA_gene"
        },
        "SO:0001267": {
            "name": "snoRNA_gene"
        },
        "SO:0001268": {
            "name": "snRNA_gene"
        },
        "SO:0001269": {
            "name": "SRP_RNA_gene"
        },
        "SO:0001271": {
            "name": "tmRNA_gene"
        },
        "SO:0001272": {
            "name": "tRNA_gene"
        },
        "SO:0001273": {
            "name": "modified_adenosine",
            "def": "A modified adenine is an adenine base feature that has been altered. [SO:ke]"
        },
        "SO:0001274": {
            "name": "modified_inosine",
            "def": "A modified inosine is an inosine base feature that has been altered. [SO:ke]"
        },
        "SO:0001275": {
            "name": "modified_cytidine",
            "def": "A modified cytidine is a cytidine base feature which has been altered. [SO:ke]"
        },
        "SO:0001276": {
            "name": "modified_guanosine"
        },
        "SO:0001277": {
            "name": "modified_uridine"
        },
        "SO:0001278": {
            "name": "one_methylinosine",
            "def": "1-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001279": {
            "name": "one_two_prime_O_dimethylinosine",
            "def": "1,2'-O-dimethylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001280": {
            "name": "two_prime_O_methylinosine",
            "def": "2'-O-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001281": {
            "name": "three_methylcytidine",
            "def": "3-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001282": {
            "name": "five_methylcytidine",
            "def": "5-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001283": {
            "name": "two_prime_O_methylcytidine",
            "def": "2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001284": {
            "name": "two_thiocytidine",
            "def": "2-thiocytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001285": {
            "name": "N4_acetylcytidine",
            "def": "N4-acetylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001286": {
            "name": "five_formylcytidine",
            "def": "5-formylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001287": {
            "name": "five_two_prime_O_dimethylcytidine",
            "def": "5,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001288": {
            "name": "N4_acetyl_2_prime_O_methylcytidine",
            "def": "N4-acetyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001289": {
            "name": "lysidine",
            "def": "Lysidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001290": {
            "name": "N4_methylcytidine",
            "def": "N4-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001291": {
            "name": "N4_2_prime_O_dimethylcytidine",
            "def": "N4,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001292": {
            "name": "five_hydroxymethylcytidine",
            "def": "5-hydroxymethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001293": {
            "name": "five_formyl_two_prime_O_methylcytidine",
            "def": "5-formyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001294": {
            "name": "N4_N4_2_prime_O_trimethylcytidine",
            "def": "N4_N4_2_prime_O_trimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001295": {
            "name": "one_methyladenosine",
            "def": "1_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001296": {
            "name": "two_methyladenosine",
            "def": "2_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001297": {
            "name": "N6_methyladenosine",
            "def": "N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001298": {
            "name": "two_prime_O_methyladenosine",
            "def": "2prime_O_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001299": {
            "name": "two_methylthio_N6_methyladenosine",
            "def": "2_methylthio_N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001300": {
            "name": "N6_isopentenyladenosine",
            "def": "N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001301": {
            "name": "two_methylthio_N6_isopentenyladenosine",
            "def": "2_methylthio_N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001302": {
            "name": "N6_cis_hydroxyisopentenyl_adenosine",
            "def": "N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001303": {
            "name": "two_methylthio_N6_cis_hydroxyisopentenyl_adenosine",
            "def": "2_methylthio_N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001304": {
            "name": "N6_glycinylcarbamoyladenosine",
            "def": "N6_glycinylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001305": {
            "name": "N6_threonylcarbamoyladenosine",
            "def": "N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001306": {
            "name": "two_methylthio_N6_threonyl_carbamoyladenosine",
            "def": "2_methylthio_N6_threonyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001307": {
            "name": "N6_methyl_N6_threonylcarbamoyladenosine",
            "def": "N6_methyl_N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001308": {
            "name": "N6_hydroxynorvalylcarbamoyladenosine",
            "def": "N6_hydroxynorvalylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001309": {
            "name": "two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine",
            "def": "2_methylthio_N6_hydroxynorvalyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001310": {
            "name": "two_prime_O_ribosyladenosine_phosphate",
            "def": "2prime_O_ribosyladenosine_phosphate is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001311": {
            "name": "N6_N6_dimethyladenosine",
            "def": "N6_N6_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001312": {
            "name": "N6_2_prime_O_dimethyladenosine",
            "def": "N6_2prime_O_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001313": {
            "name": "N6_N6_2_prime_O_trimethyladenosine",
            "def": "N6_N6_2prime_O_trimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001314": {
            "name": "one_two_prime_O_dimethyladenosine",
            "def": "1,2'-O-dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001315": {
            "name": "N6_acetyladenosine",
            "def": "N6_acetyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001316": {
            "name": "seven_deazaguanosine",
            "def": "7-deazaguanosine is a modified guanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001317": {
            "name": "queuosine",
            "def": "Queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001318": {
            "name": "epoxyqueuosine",
            "def": "Epoxyqueuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001319": {
            "name": "galactosyl_queuosine",
            "def": "Galactosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001320": {
            "name": "mannosyl_queuosine",
            "def": "Mannosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001321": {
            "name": "seven_cyano_seven_deazaguanosine",
            "def": "7_cyano_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001322": {
            "name": "seven_aminomethyl_seven_deazaguanosine",
            "def": "7_aminomethyl_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001323": {
            "name": "archaeosine",
            "def": "Archaeosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001324": {
            "name": "one_methylguanosine",
            "def": "1_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001325": {
            "name": "N2_methylguanosine",
            "def": "N2_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001326": {
            "name": "seven_methylguanosine",
            "def": "7_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001327": {
            "name": "two_prime_O_methylguanosine",
            "def": "2prime_O_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001328": {
            "name": "N2_N2_dimethylguanosine",
            "def": "N2_N2_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001329": {
            "name": "N2_2_prime_O_dimethylguanosine",
            "def": "N2_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001330": {
            "name": "N2_N2_2_prime_O_trimethylguanosine",
            "def": "N2_N2_2prime_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001331": {
            "name": "two_prime_O_ribosylguanosine_phosphate",
            "def": "2prime_O_ribosylguanosine_phosphate is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001332": {
            "name": "wybutosine",
            "def": "Wybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001333": {
            "name": "peroxywybutosine",
            "def": "Peroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001334": {
            "name": "hydroxywybutosine",
            "def": "Hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001335": {
            "name": "undermodified_hydroxywybutosine",
            "def": "Undermodified_hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001336": {
            "name": "wyosine",
            "def": "Wyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001337": {
            "name": "methylwyosine",
            "def": "Methylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001338": {
            "name": "N2_7_dimethylguanosine",
            "def": "N2_7_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001339": {
            "name": "N2_N2_7_trimethylguanosine",
            "def": "N2_N2_7_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001340": {
            "name": "one_two_prime_O_dimethylguanosine",
            "def": "1_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001341": {
            "name": "four_demethylwyosine",
            "def": "4_demethylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001342": {
            "name": "isowyosine",
            "def": "Isowyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001343": {
            "name": "N2_7_2prirme_O_trimethylguanosine",
            "def": "N2_7_2prirme_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001344": {
            "name": "five_methyluridine",
            "def": "5_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001345": {
            "name": "two_prime_O_methyluridine",
            "def": "2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001346": {
            "name": "five_two_prime_O_dimethyluridine",
            "def": "5_2_prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001347": {
            "name": "one_methylpseudouridine",
            "def": "1_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001348": {
            "name": "two_prime_O_methylpseudouridine",
            "def": "2prime_O_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001349": {
            "name": "two_thiouridine",
            "def": "2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001350": {
            "name": "four_thiouridine",
            "def": "4_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001351": {
            "name": "five_methyl_2_thiouridine",
            "def": "5_methyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001352": {
            "name": "two_thio_two_prime_O_methyluridine",
            "def": "2_thio_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001353": {
            "name": "three_three_amino_three_carboxypropyl_uridine",
            "def": "3_3_amino_3_carboxypropyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001354": {
            "name": "five_hydroxyuridine",
            "def": "5_hydroxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001355": {
            "name": "five_methoxyuridine",
            "def": "5_methoxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001356": {
            "name": "uridine_five_oxyacetic_acid",
            "def": "Uridine_5_oxyacetic_acid is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001357": {
            "name": "uridine_five_oxyacetic_acid_methyl_ester",
            "def": "Uridine_5_oxyacetic_acid_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001358": {
            "name": "five_carboxyhydroxymethyl_uridine",
            "def": "5_carboxyhydroxymethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001359": {
            "name": "five_carboxyhydroxymethyl_uridine_methyl_ester",
            "def": "5_carboxyhydroxymethyl_uridine_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001360": {
            "name": "five_methoxycarbonylmethyluridine",
            "def": "Five_methoxycarbonylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001361": {
            "name": "five_methoxycarbonylmethyl_two_prime_O_methyluridine",
            "def": "Five_methoxycarbonylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001362": {
            "name": "five_methoxycarbonylmethyl_two_thiouridine",
            "def": "5_methoxycarbonylmethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001363": {
            "name": "five_aminomethyl_two_thiouridine",
            "def": "5_aminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001364": {
            "name": "five_methylaminomethyluridine",
            "def": "5_methylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001365": {
            "name": "five_methylaminomethyl_two_thiouridine",
            "def": "5_methylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001366": {
            "name": "five_methylaminomethyl_two_selenouridine",
            "def": "5_methylaminomethyl_2_selenouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001367": {
            "name": "five_carbamoylmethyluridine",
            "def": "5_carbamoylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001368": {
            "name": "five_carbamoylmethyl_two_prime_O_methyluridine",
            "def": "5_carbamoylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001369": {
            "name": "five_carboxymethylaminomethyluridine",
            "def": "5_carboxymethylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001370": {
            "name": "five_carboxymethylaminomethyl_two_prime_O_methyluridine",
            "def": "5_carboxymethylaminomethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001371": {
            "name": "five_carboxymethylaminomethyl_two_thiouridine",
            "def": "5_carboxymethylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001372": {
            "name": "three_methyluridine",
            "def": "3_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001373": {
            "name": "one_methyl_three_three_amino_three_carboxypropyl_pseudouridine",
            "def": "1_methyl_3_3_amino_3_carboxypropyl_pseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001374": {
            "name": "five_carboxymethyluridine",
            "def": "5_carboxymethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001375": {
            "name": "three_two_prime_O_dimethyluridine",
            "def": "3_2prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001376": {
            "name": "five_methyldihydrouridine",
            "def": "5_methyldihydrouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001377": {
            "name": "three_methylpseudouridine",
            "def": "3_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001378": {
            "name": "five_taurinomethyluridine",
            "def": "5_taurinomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001379": {
            "name": "five_taurinomethyl_two_thiouridine",
            "def": "5_taurinomethyl_2_thiouridineis a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001380": {
            "name": "five_isopentenylaminomethyl_uridine",
            "def": "5_isopentenylaminomethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001381": {
            "name": "five_isopentenylaminomethyl_two_thiouridine",
            "def": "5_isopentenylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001382": {
            "name": "five_isopentenylaminomethyl_two_prime_O_methyluridine",
            "def": "5_isopentenylaminomethyl_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001383": {
            "name": "histone_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a histone. [SO:ke]"
        },
        "SO:0001384": {
            "name": "CDS_fragment"
        },
        "SO:0001385": {
            "name": "modified_amino_acid_feature",
            "def": "A post translationally modified amino acid feature. [SO:ke]"
        },
        "SO:0001386": {
            "name": "modified_glycine",
            "def": "A post translationally modified glycine amino acid feature. [SO:ke]"
        },
        "SO:0001387": {
            "name": "modified_L_alanine",
            "def": "A post translationally modified alanine amino acid feature. [SO:ke]"
        },
        "SO:0001388": {
            "name": "modified_L_asparagine",
            "def": "A post translationally modified asparagine amino acid feature. [SO:ke]"
        },
        "SO:0001389": {
            "name": "modified_L_aspartic_acid",
            "def": "A post translationally modified aspartic acid amino acid feature. [SO:ke]"
        },
        "SO:0001390": {
            "name": "modified_L_cysteine",
            "def": "A post translationally modified cysteine amino acid feature. [SO:ke]"
        },
        "SO:0001391": {
            "name": "modified_L_glutamic_acid"
        },
        "SO:0001392": {
            "name": "modified_L_threonine",
            "def": "A post translationally modified threonine amino acid feature. [SO:ke]"
        },
        "SO:0001393": {
            "name": "modified_L_tryptophan",
            "def": "A post translationally modified tryptophan amino acid feature. [SO:ke]"
        },
        "SO:0001394": {
            "name": "modified_L_glutamine",
            "def": "A post translationally modified glutamine amino acid feature. [SO:ke]"
        },
        "SO:0001395": {
            "name": "modified_L_methionine",
            "def": "A post translationally modified methionine amino acid feature. [SO:ke]"
        },
        "SO:0001396": {
            "name": "modified_L_isoleucine",
            "def": "A post translationally modified isoleucine amino acid feature. [SO:ke]"
        },
        "SO:0001397": {
            "name": "modified_L_phenylalanine",
            "def": "A post translationally modified phenylalanine amino acid feature. [SO:ke]"
        },
        "SO:0001398": {
            "name": "modified_L_histidine",
            "def": "A post translationally modified histidine amino acid feature. [SO:ke]"
        },
        "SO:0001399": {
            "name": "modified_L_serine",
            "def": "A post translationally modified serine amino acid feature. [SO:ke]"
        },
        "SO:0001400": {
            "name": "modified_L_lysine",
            "def": "A post translationally modified lysine amino acid feature. [SO:ke]"
        },
        "SO:0001401": {
            "name": "modified_L_leucine",
            "def": "A post translationally modified leucine amino acid feature. [SO:ke]"
        },
        "SO:0001402": {
            "name": "modified_L_selenocysteine",
            "def": "A post translationally modified selenocysteine amino acid feature. [SO:ke]"
        },
        "SO:0001403": {
            "name": "modified_L_valine",
            "def": "A post translationally modified valine amino acid feature. [SO:ke]"
        },
        "SO:0001404": {
            "name": "modified_L_proline",
            "def": "A post translationally modified proline amino acid feature. [SO:ke]"
        },
        "SO:0001405": {
            "name": "modified_L_tyrosine",
            "def": "A post translationally modified tyrosine amino acid feature. [SO:ke]"
        },
        "SO:0001406": {
            "name": "modified_L_arginine",
            "def": "A post translationally modified arginine amino acid feature. [SO:ke]"
        },
        "SO:0001407": {
            "name": "peptidyl",
            "def": "An attribute describing the nature of a proteinaceous polymer, where by the amino acid units are joined by peptide bonds. [SO:ke]"
        },
        "SO:0001408": {
            "name": "cleaved_for_gpi_anchor_region",
            "def": "The C-terminal residues of a polypeptide which are exchanged for a GPI-anchor. [EBI:rh]"
        },
        "SO:0001409": {
            "name": "biomaterial_region",
            "def": "A region which is intended for use in an experiment. [SO:cb]"
        },
        "SO:0001410": {
            "name": "experimental_feature",
            "def": "A region which is the result of some arbitrary experimental procedure. The procedure may be carried out with biological material or inside a computer. [SO:cb]"
        },
        "SO:0001411": {
            "name": "biological_region",
            "def": "A region defined by its disposition to be involved in a biological process. [SO:cb]"
        },
        "SO:0001412": {
            "name": "topologically_defined_region",
            "def": "A region that is defined according to its relations with other regions within the same sequence. [SO:cb]"
        },
        "SO:0001413": {
            "name": "translocation_breakpoint",
            "def": "The point within a chromosome where a translocation begins or ends. [SO:cb]"
        },
        "SO:0001414": {
            "name": "insertion_breakpoint",
            "def": "The point within a chromosome where a insertion begins or ends. [SO:cb]"
        },
        "SO:0001415": {
            "name": "deletion_breakpoint",
            "def": "The point within a chromosome where a deletion begins or ends. [SO:cb]"
        },
        "SO:0001416": {
            "name": "five_prime_flanking_region",
            "def": "A flanking region located five prime of a specific region. [SO:chado]"
        },
        "SO:0001417": {
            "name": "three_prime_flanking_region",
            "def": "A flanking region located three prime of a specific region. [SO:chado]"
        },
        "SO:0001418": {
            "name": "transcribed_fragment",
            "def": "An experimental region, defined by a tiling array experiment to be transcribed at some level. [SO:ke]"
        },
        "SO:0001419": {
            "name": "cis_splice_site",
            "def": "Intronic 2 bp region bordering exon. A splice_site that adjacent_to exon and overlaps intron. [SO:cjm, SO:ke]"
        },
        "SO:0001420": {
            "name": "trans_splice_site",
            "def": "Primary transcript region bordering trans-splice junction. [SO:ke]"
        },
        "SO:0001421": {
            "name": "splice_junction",
            "def": "The boundary between an intron and an exon. [SO:ke]"
        },
        "SO:0001422": {
            "name": "conformational_switch",
            "def": "A region of a polypeptide, involved in the transition from one conformational state to another. [SO:ke]"
        },
        "SO:0001423": {
            "name": "dye_terminator_read",
            "def": "A read produced by the dye terminator method of sequencing. [SO:ke]"
        },
        "SO:0001424": {
            "name": "pyrosequenced_read",
            "def": "A read produced by pyrosequencing technology. [SO:ke]"
        },
        "SO:0001425": {
            "name": "ligation_based_read",
            "def": "A read produced by ligation based sequencing technologies. [SO:ke]"
        },
        "SO:0001426": {
            "name": "polymerase_synthesis_read",
            "def": "A read produced by the polymerase based sequence by synthesis method. [SO:ke]"
        },
        "SO:0001427": {
            "name": "cis_regulatory_frameshift_element",
            "def": "A structural region in an RNA molecule which promotes ribosomal frameshifting of cis coding sequence. [RFAM:jd]"
        },
        "SO:0001428": {
            "name": "expressed_sequence_assembly",
            "def": "A sequence assembly derived from expressed sequences. [SO:ke]"
        },
        "SO:0001429": {
            "name": "DNA_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with DNA. [SO:ke]"
        },
        "SO:0001431": {
            "name": "cryptic_gene",
            "def": "A gene that is not transcribed under normal conditions and is not critical to normal cellular functioning. [SO:ke]"
        },
        "SO:0001432": {
            "name": "sequence_variant_affecting_polyadenylation"
        },
        "SO:0001433": {
            "name": "three_prime_RACE_clone",
            "def": "A three prime RACE (Rapid Amplification of cDNA Ends) clone is a cDNA clone copied from the 3' end of an mRNA (using a poly-dT primer to capture the polyA tail and a gene-specific or randomly primed 5' primer), and spliced into a vector for propagation in a suitable host. [modENCODE:nlw]"
        },
        "SO:0001434": {
            "name": "cassette_pseudogene",
            "def": "A cassette pseudogene is a kind of gene in an inactive form which may recombine at a telomeric locus to form a functional copy. [SO:ke]"
        },
        "SO:0001435": {
            "name": "alanine"
        },
        "SO:0001436": {
            "name": "valine"
        },
        "SO:0001437": {
            "name": "leucine"
        },
        "SO:0001438": {
            "name": "isoleucine"
        },
        "SO:0001439": {
            "name": "proline"
        },
        "SO:0001440": {
            "name": "tryptophan"
        },
        "SO:0001441": {
            "name": "phenylalanine"
        },
        "SO:0001442": {
            "name": "methionine"
        },
        "SO:0001443": {
            "name": "glycine"
        },
        "SO:0001444": {
            "name": "serine"
        },
        "SO:0001445": {
            "name": "threonine"
        },
        "SO:0001446": {
            "name": "tyrosine"
        },
        "SO:0001447": {
            "name": "cysteine"
        },
        "SO:0001448": {
            "name": "glutamine"
        },
        "SO:0001449": {
            "name": "asparagine"
        },
        "SO:0001450": {
            "name": "lysine"
        },
        "SO:0001451": {
            "name": "arginine"
        },
        "SO:0001452": {
            "name": "histidine"
        },
        "SO:0001453": {
            "name": "aspartic_acid"
        },
        "SO:0001454": {
            "name": "glutamic_acid"
        },
        "SO:0001455": {
            "name": "selenocysteine"
        },
        "SO:0001456": {
            "name": "pyrrolysine"
        },
        "SO:0001457": {
            "name": "transcribed_cluster",
            "def": "A region defined by a set of transcribed sequences from the same gene or expressed pseudogene. [SO:ke]"
        },
        "SO:0001458": {
            "name": "unigene_cluster",
            "def": "A kind of transcribed_cluster defined by a set of transcribed sequences from the a unique gene. [SO:ke]"
        },
        "SO:0001459": {
            "name": "CRISPR",
            "def": "Clustered Palindromic Repeats interspersed with bacteriophage derived spacer sequences. [RFAM:jd]"
        },
        "SO:0001460": {
            "name": "insulator_binding_site",
            "def": "A binding site that, in an insulator region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001461": {
            "name": "enhancer_binding_site",
            "def": "A binding site that, in the enhancer region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001462": {
            "name": "contig_collection",
            "def": "A collection of contigs. [SO:ke]"
        },
        "SO:0001463": {
            "name": "lincRNA",
            "def": "A multiexonic non-coding RNA transcribed by RNA polymerase II. [PMID:19182780, SO:ke]"
        },
        "SO:0001464": {
            "name": "UST",
            "def": "An EST spanning part or all of the untranslated regions of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001465": {
            "name": "three_prime_UST",
            "def": "A UST located in the 3'UTR of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001466": {
            "name": "five_prime_UST",
            "def": "An UST located in the 5'UTR of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001467": {
            "name": "RST",
            "def": "A tag produced from a single sequencing read from a RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001468": {
            "name": "three_prime_RST",
            "def": "A tag produced from a single sequencing read from a 3'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001469": {
            "name": "five_prime_RST",
            "def": "A tag produced from a single sequencing read from a 5'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001470": {
            "name": "UST_match",
            "def": "A match against an UST sequence. [SO:nlw]"
        },
        "SO:0001471": {
            "name": "RST_match",
            "def": "A match against an RST sequence. [SO:nlw]"
        },
        "SO:0001472": {
            "name": "primer_match",
            "def": "A nucleotide match to a primer sequence. [SO:nlw]"
        },
        "SO:0001473": {
            "name": "miRNA_antiguide",
            "def": "A region of the pri miRNA that base pairs with the guide to form the hairpin. [SO:ke]"
        },
        "SO:0001474": {
            "name": "trans_splice_junction",
            "def": "The boundary between the spliced leader and the first exon of the mRNA. [SO:ke]"
        },
        "SO:0001475": {
            "name": "outron",
            "def": "A region of a primary transcript, that is removed via trans splicing. [PMID:16401417, SO:ke]"
        },
        "SO:0001476": {
            "name": "natural_plasmid",
            "def": "A plasmid that occurs naturally. [SO:xp]"
        },
        "SO:0001477": {
            "name": "gene_trap_construct",
            "def": "A gene trap construct is a type of engineered plasmid which is designed to integrate into a genome and produce a fusion transcript between exons of the gene into which it inserts and a reporter element in the construct. Gene traps contain a splice acceptor, do not contain promoter elements for the reporter, and are mutagenic. Gene traps may be bicistronic with the second cassette containing a promoter driving an a selectable marker. [ZFIN:dh]"
        },
        "SO:0001478": {
            "name": "promoter_trap_construct",
            "def": "A promoter trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when inserted in close proximity to a promoter element. Promoter traps typically do not contain promoter elements and are mutagenic. [ZFIN:dh]"
        },
        "SO:0001479": {
            "name": "enhancer_trap_construct",
            "def": "An enhancer trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when the expression from a basic minimal promoter is enhanced by genomic enhancer elements. Enhancer traps contain promoter elements and are not usually mutagenic. [ZFIN:dh]"
        },
        "SO:0001480": {
            "name": "PAC_end",
            "def": "A region of sequence from the end of a PAC clone that may provide a highly specific marker. [ZFIN:mh]"
        },
        "SO:0001481": {
            "name": "RAPD",
            "def": "RAPD is a 'PCR product' where a sequence variant is identified through the use of PCR with random primers. [ZFIN:mh]"
        },
        "SO:0001482": {
            "name": "shadow_enhancer"
        },
        "SO:0001483": {
            "name": "SNV",
            "def": "SNVs are single nucleotide positions in genomic DNA at which different sequence alternatives exist. [SO:bm]"
        },
        "SO:0001484": {
            "name": "X_element_combinatorial_repeat",
            "def": "An X element combinatorial repeat is a repeat region located between the X element and the telomere or adjacent Y' element. [http://www.yeastgenome.org/help/glossary.html]"
        },
        "SO:0001485": {
            "name": "Y_prime_element",
            "def": "A Y' element is a repeat region (SO:0000657) located adjacent to telomeric repeats or X element combinatorial repeats, either as a single copy or tandem repeat of two to four copies. [http:http://www.yeastgenome.org/help/glossary.html]"
        },
        "SO:0001486": {
            "name": "standard_draft",
            "def": "The status of a whole genome sequence, where the data is minimally filtered or un-filtered, from any number of sequencing platforms, and is assembled into contigs. Genome sequence of this quality may harbour regions of poor quality and can be relatively incomplete. [DOI:10.1126]"
        },
        "SO:0001487": {
            "name": "high_quality_draft",
            "def": "The status of a whole genome sequence, where overall coverage represents at least 90 percent of the genome. [DOI:10.1126]"
        },
        "SO:0001488": {
            "name": "improved_high_quality_draft",
            "def": "The status of a whole genome sequence, where additional work has been performed, using either manual or automated methods, such as gap resolution. [DOI:10.1126]"
        },
        "SO:0001489": {
            "name": "annotation_directed_improved_draft",
            "def": "The status of a whole genome sequence,where annotation, and verification of coding regions has occurred. [DOI:10.1126]"
        },
        "SO:0001490": {
            "name": "noncontiguous_finished",
            "def": "The status of a whole genome sequence, where the assembly is high quality, closure approaches have been successful for most gaps, misassemblies and low quality regions. [DOI:10.1126]"
        },
        "SO:0001491": {
            "name": "finished_genome",
            "def": "The status of a whole genome sequence, with less than 1 error per 100,000 base pairs. [DOI:10.1126]"
        },
        "SO:0001492": {
            "name": "intronic_regulatory_region",
            "def": "A regulatory region that is part of an intron. [SO:ke]"
        },
        "SO:0001493": {
            "name": "centromere_DNA_Element_I",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region composed of 8-11bp which enables binding by the centromere binding factor 1(Cbf1p). [PMID:11222754]"
        },
        "SO:0001494": {
            "name": "centromere_DNA_Element_II",
            "def": "A centromere DNA Element II (CDEII) is part a conserved region of the centromere, consisting of a consensus region that is AT-rich and ~ 75-100 bp in length. [PMID:11222754]"
        },
        "SO:0001495": {
            "name": "centromere_DNA_Element_III",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region that consists of a 25-bp which enables binding by the centromere DNA binding factor 3 (CBF3) complex. [PMID:11222754]"
        },
        "SO:0001496": {
            "name": "telomeric_repeat",
            "def": "The telomeric repeat is a repeat region, part of the chromosome, which in yeast, is a G-rich terminal sequence of the form (TG(1-3))n or more precisely ((TG)(1-6)TG(2-3))n. [PMID:8720065]"
        },
        "SO:0001497": {
            "name": "X_element",
            "def": "The X element is a conserved region, of the telomere, of ~475 bp that contains an ARS sequence and in most cases an Abf1p binding site. [http://www.yeastgenome.org/help/glossary.html#xelemcoresequence, PMID:7785338, PMID:8005434]"
        },
        "SO:0001498": {
            "name": "YAC_end",
            "def": "A region of sequence from the end of a YAC clone that may provide a highly specific marker. [SO:ke]"
        },
        "SO:0001499": {
            "name": "whole_genome_sequence_status",
            "def": "The status of whole genome sequence. [DOI:10.1126]"
        },
        "SO:0001500": {
            "name": "heritable_phenotypic_marker",
            "def": "A biological_region characterized as a single heritable trait in a phenotype screen. The heritable phenotype may be mapped to a chromosome but generally has not been characterized to a specific gene locus. [JAX:hdene]"
        },
        "SO:0001501": {
            "name": "peptide_collection",
            "def": "A collection of peptide sequences. [BBOP:nlw]"
        },
        "SO:0001502": {
            "name": "high_identity_region",
            "def": "An experimental feature with high sequence identity to another sequence. [SO:ke]"
        },
        "SO:0001503": {
            "name": "processed_transcript",
            "def": "A transcript for which no open reading frame has been identified and for which no other function has been determined. [MGI:hdeen]"
        },
        "SO:0001504": {
            "name": "assortment_derived_variation",
            "def": "A chromosome variation derived from an event during meiosis. [SO:ke]"
        },
        "SO:0001505": {
            "name": "reference_genome",
            "def": "A collection of sequences (often chromosomes) taken as the standard for a given organism and genome assembly. [SO:ke]"
        },
        "SO:0001506": {
            "name": "variant_genome",
            "def": "A collection of sequences (often chromosomes) of an individual. [SO:ke]"
        },
        "SO:0001507": {
            "name": "variant_collection",
            "def": "A collection of one or more sequences of an individual. [SO:ke]"
        },
        "SO:0001508": {
            "name": "alteration_attribute"
        },
        "SO:0001509": {
            "name": "chromosomal_variation_attribute"
        },
        "SO:0001510": {
            "name": "intrachromosomal"
        },
        "SO:0001511": {
            "name": "interchromosomal"
        },
        "SO:0001512": {
            "name": "insertion_attribute",
            "def": "A quality of a chromosomal insertion,. [SO:ke]"
        },
        "SO:0001513": {
            "name": "tandem"
        },
        "SO:0001514": {
            "name": "direct",
            "def": "A quality of an insertion where the insert is not in a cytologically inverted orientation. [SO:ke]"
        },
        "SO:0001515": {
            "name": "inverted",
            "def": "A quality of an insertion where the insert is in a cytologically inverted orientation. [SO:ke]"
        },
        "SO:0001516": {
            "name": "free",
            "def": "The quality of a duplication where the new region exists independently of the original. [SO:ke]"
        },
        "SO:0001517": {
            "name": "inversion_attribute"
        },
        "SO:0001518": {
            "name": "pericentric"
        },
        "SO:0001519": {
            "name": "paracentric"
        },
        "SO:0001520": {
            "name": "translocaton_attribute"
        },
        "SO:0001521": {
            "name": "reciprocal"
        },
        "SO:0001522": {
            "name": "insertional"
        },
        "SO:0001523": {
            "name": "duplication_attribute"
        },
        "SO:0001524": {
            "name": "chromosomally_aberrant_genome"
        },
        "SO:0001525": {
            "name": "assembly_error_correction",
            "def": "A region of sequence where the final nucleotide assignment differs from the original assembly due to an improvement that replaces a mistake. [SO:ke]"
        },
        "SO:0001526": {
            "name": "base_call_error_correction",
            "def": "A region of sequence where the final nucleotide assignment is different from that given by the base caller due to an improvement that replaces a mistake. [SO:ke]"
        },
        "SO:0001527": {
            "name": "peptide_localization_signal",
            "def": "A region of peptide sequence used to target the polypeptide molecule to a specific organelle. [SO:ke]"
        },
        "SO:0001528": {
            "name": "nuclear_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nucleus. [SO:ke]"
        },
        "SO:0001529": {
            "name": "endosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the endosome. [SO:ke]"
        },
        "SO:0001530": {
            "name": "lysosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the lysosome. [SO:ke]"
        },
        "SO:0001531": {
            "name": "nuclear_export_signal",
            "def": "A polypeptide region that targets a polypeptide to he cytoplasm. [SO:ke]"
        },
        "SO:0001532": {
            "name": "recombination_signal_sequence",
            "def": "A region recognized by a recombinase. [SO:ke]"
        },
        "SO:0001533": {
            "name": "cryptic_splice_site",
            "def": "A splice site that is in part of the transcript not normally spliced. They occur via mutation or transcriptional error. [SO:ke]"
        },
        "SO:0001534": {
            "name": "nuclear_rim_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nuclear rim. [SO:ke]"
        },
        "SO:0001535": {
            "name": "p_element",
            "def": "A P_element is a DNA transposon responsible for hybrid dysgenesis. [SO:ke]"
        },
        "SO:0001536": {
            "name": "functional_variant",
            "def": "A sequence variant in which the function of a gene product is altered with respect to a reference. [SO:ke]"
        },
        "SO:0001537": {
            "name": "structural_variant",
            "def": "A sequence variant that changes one or more sequence features. [SO:ke]"
        },
        "SO:0001538": {
            "name": "transcript_function_variant",
            "def": "A sequence variant which alters the functioning of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001539": {
            "name": "translational_product_function_variant",
            "def": "A sequence variant that affects the functioning of a translational product with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001540": {
            "name": "level_of_transcript_variant",
            "def": "A sequence variant which alters the level of a transcript. [SO:ke]"
        },
        "SO:0001541": {
            "name": "decreased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001542": {
            "name": "increased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001543": {
            "name": "transcript_processing_variant",
            "def": "A sequence variant that affects the post transcriptional processing of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001544": {
            "name": "editing_variant",
            "def": "A transcript processing variant whereby the process of editing is disrupted with respect to the reference. [SO:ke]"
        },
        "SO:0001545": {
            "name": "polyadenylation_variant",
            "def": "A sequence variant that changes polyadenylation with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001546": {
            "name": "transcript_stability_variant",
            "def": "A variant that changes the stability of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001547": {
            "name": "decreased_transcript_stability_variant",
            "def": "A sequence variant that decreases transcript stability with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001548": {
            "name": "increased_transcript_stability_variant",
            "def": "A sequence variant that increases transcript stability with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001549": {
            "name": "transcription_variant",
            "def": "A variant that changes alters the transcription of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001550": {
            "name": "rate_of_transcription_variant",
            "def": "A sequence variant that changes the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001551": {
            "name": "increased_transcription_rate_variant",
            "def": "A sequence variant that increases the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001552": {
            "name": "decreased_transcription_rate_variant",
            "def": "A sequence variant that decreases the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001553": {
            "name": "translational_product_level_variant",
            "def": "A functional variant that changes the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001554": {
            "name": "polypeptide_function_variant",
            "def": "A sequence variant which changes polypeptide functioning with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001555": {
            "name": "decreased_translational_product_level",
            "def": "A sequence variant which decreases the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001556": {
            "name": "increased_translational_product_level",
            "def": "A sequence variant which increases the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001557": {
            "name": "polypeptide_gain_of_function_variant",
            "def": "A sequence variant which causes gain of polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001558": {
            "name": "polypeptide_localization_variant",
            "def": "A sequence variant which changes the localization of a polypeptide with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001559": {
            "name": "polypeptide_loss_of_function_variant",
            "def": "A sequence variant that causes the loss of a polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001560": {
            "name": "inactive_ligand_binding_site",
            "def": "A sequence variant that causes the inactivation of a ligand binding site with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001561": {
            "name": "polypeptide_partial_loss_of_function",
            "def": "A sequence variant that causes some but not all loss of polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001562": {
            "name": "polypeptide_post_translational_processing_variant",
            "def": "A sequence variant that causes a change in post translational processing of the peptide with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001563": {
            "name": "copy_number_change",
            "def": "A sequence variant where copies of a feature (CNV) are either increased or decreased. [SO:ke]"
        },
        "SO:0001564": {
            "name": "gene_variant",
            "def": "A sequence variant where the structure of the gene is changed. [SO:ke]"
        },
        "SO:0001565": {
            "name": "gene_fusion",
            "def": "A sequence variant whereby a two genes have become joined. [SO:ke]"
        },
        "SO:0001566": {
            "name": "regulatory_region_variant",
            "def": "A sequence variant located within a regulatory region. [SO:ke]"
        },
        "SO:0001567": {
            "name": "stop_retained_variant",
            "def": "A sequence variant where at least one base in the terminator codon is changed, but the terminator remains. [SO:ke]"
        },
        "SO:0001568": {
            "name": "splicing_variant",
            "def": "A sequence variant that changes the process of splicing. [SO:ke]"
        },
        "SO:0001569": {
            "name": "cryptic_splice_site_variant",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:0001570": {
            "name": "cryptic_splice_acceptor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new acceptor. [SO:ke]"
        },
        "SO:0001571": {
            "name": "cryptic_splice_donor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new donor. [SO:ke]"
        },
        "SO:0001572": {
            "name": "exon_loss_variant",
            "def": "A sequence variant whereby an exon is lost from the transcript. [SO:ke]"
        },
        "SO:0001573": {
            "name": "intron_gain_variant",
            "def": "A sequence variant whereby an intron is gained by the processed transcript; usually a result of an alteration of the donor or acceptor. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:0001574": {
            "name": "splice_acceptor_variant",
            "def": "A splice variant that changes the 2 base region at the 3' end of an intron. [SO:ke]"
        },
        "SO:0001575": {
            "name": "splice_donor_variant",
            "def": "A splice variant that changes the 2 base pair region at the 5' end of an intron. [SO:ke]"
        },
        "SO:0001576": {
            "name": "transcript_variant",
            "def": "A sequence variant that changes the structure of the transcript. [SO:ke]"
        },
        "SO:0001577": {
            "name": "complex_transcript_variant",
            "def": "A transcript variant with a complex INDEL- Insertion or deletion that spans an exon/intron border or a coding sequence/UTR border. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001578": {
            "name": "stop_lost",
            "def": "A sequence variant where at least one base of the terminator codon (stop) is changed, resulting in an elongated transcript. [SO:ke]"
        },
        "SO:0001579": {
            "name": "transcript_sequence_variant"
        },
        "SO:0001580": {
            "name": "coding_sequence_variant",
            "def": "A sequence variant that changes the coding sequence. [SO:ke]"
        },
        "SO:0001582": {
            "name": "initiator_codon_variant",
            "def": "A codon variant that changes at least one base of the first codon of a transcript. [SO:ke]"
        },
        "SO:0001583": {
            "name": "missense_variant",
            "def": "A sequence variant, that changes one or more bases, resulting in a different amino acid sequence but where the length is preserved. [EBI:fc, EBI:gr, SO:ke]"
        },
        "SO:0001585": {
            "name": "conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for a different but similar amino acid. These variants may or may not be deleterious. [SO:ke]"
        },
        "SO:0001586": {
            "name": "non_conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for an amino acid with different biochemical properties. [SO:ke]"
        },
        "SO:0001587": {
            "name": "stop_gained",
            "def": "A sequence variant whereby at least one base of a codon is changed, resulting in a premature stop codon, leading to a shortened transcript. [SO:ke]"
        },
        "SO:0001589": {
            "name": "frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
        },
        "SO:0001590": {
            "name": "terminator_codon_variant",
            "def": "A sequence variant whereby at least one of the bases in the terminator codon is changed. [SO:ke]"
        },
        "SO:0001591": {
            "name": "frame_restoring_variant",
            "def": "A sequence variant that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
        },
        "SO:0001592": {
            "name": "minus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base ahead. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
        },
        "SO:0001593": {
            "name": "minus_2_frameshift_variant"
        },
        "SO:0001594": {
            "name": "plus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base backward. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
        },
        "SO:0001595": {
            "name": "plus_2_frameshift_variant"
        },
        "SO:0001596": {
            "name": "transcript_secondary_structure_variant",
            "def": "A sequence variant within a transcript that changes the secondary structure of the RNA product. [SO:ke]"
        },
        "SO:0001597": {
            "name": "compensatory_transcript_secondary_structure_variant",
            "def": "A secondary structure variant that compensate for the change made by a previous variant. [SO:ke]"
        },
        "SO:0001598": {
            "name": "translational_product_structure_variant",
            "def": "A sequence variant within the transcript that changes the structure of the translational product. [SO:ke]"
        },
        "SO:0001599": {
            "name": "3D_polypeptide_structure_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
        },
        "SO:0001600": {
            "name": "complex_3D_structural_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
        },
        "SO:0001601": {
            "name": "conformational_change_variant",
            "def": "A sequence variant in the CDS region that causes a conformational change in the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001602": {
            "name": "complex_change_of_translational_product_variant"
        },
        "SO:0001603": {
            "name": "polypeptide_sequence_variant",
            "def": "A sequence variant with in the CDS that causes a change in the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001604": {
            "name": "amino_acid_deletion",
            "def": "A sequence variant within a CDS resulting in the loss of an amino acid from the resulting polypeptide. [SO:ke]"
        },
        "SO:0001605": {
            "name": "amino_acid_insertion",
            "def": "A sequence variant within a CDS resulting in the gain of an amino acid to the resulting polypeptide. [SO:ke]"
        },
        "SO:0001606": {
            "name": "amino_acid_substitution",
            "def": "A sequence variant of a codon resulting in the substitution of one amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001607": {
            "name": "conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a similar amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001608": {
            "name": "non_conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a non conservative amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001609": {
            "name": "elongated_polypeptide",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001610": {
            "name": "elongated_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001611": {
            "name": "elongated_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001612": {
            "name": "elongated_in_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001613": {
            "name": "elongated_out_of_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001614": {
            "name": "elongated_in_frame_polypeptide_N_terminal_elongation",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001615": {
            "name": "elongated_out_of_frame_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001616": {
            "name": "polypeptide_fusion",
            "def": "A sequence variant that causes a fusion of two polypeptide sequences. [SO:ke]"
        },
        "SO:0001617": {
            "name": "polypeptide_truncation",
            "def": "A sequence variant of the CD that causes a truncation of the resulting polypeptide. [SO:ke]"
        },
        "SO:0001618": {
            "name": "inactive_catalytic_site",
            "def": "A sequence variant that causes the inactivation of a catalytic site with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001619": {
            "name": "non_coding_transcript_variant",
            "def": "A transcript variant of a non coding RNA gene. [SO:ke]"
        },
        "SO:0001620": {
            "name": "mature_miRNA_variant",
            "def": "A transcript variant located with the sequence of the mature miRNA. [SO:ke]"
        },
        "SO:0001621": {
            "name": "NMD_transcript_variant",
            "def": "A variant in a transcript that is the target of NMD. [SO:ke]"
        },
        "SO:0001622": {
            "name": "UTR_variant",
            "def": "A transcript variant that is located within the UTR. [SO:ke]"
        },
        "SO:0001623": {
            "name": "5_prime_UTR_variant",
            "def": "A UTR variant of the 5' UTR. [SO:ke]"
        },
        "SO:0001624": {
            "name": "3_prime_UTR_variant",
            "def": "A UTR variant of the 3' UTR. [SO:ke]"
        },
        "SO:0001626": {
            "name": "incomplete_terminal_codon_variant",
            "def": "A sequence variant where at least one base of the final codon of an incompletely annotated transcript is changed. [SO:ke]"
        },
        "SO:0001627": {
            "name": "intron_variant",
            "def": "A transcript variant occurring within an intron. [SO:ke]"
        },
        "SO:0001628": {
            "name": "intergenic_variant",
            "def": "A sequence variant located in the intergenic region, between genes. [SO:ke]"
        },
        "SO:0001629": {
            "name": "splice_site_variant",
            "def": "A sequence variant that changes the first two or last two bases of an intron, or the 5th base from the start of the intron in the orientation of the transcript. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001630": {
            "name": "splice_region_variant",
            "def": "A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001631": {
            "name": "upstream_gene_variant",
            "def": "A sequence variant located 5' of a gene. [SO:ke]"
        },
        "SO:0001632": {
            "name": "downstream_gene_variant",
            "def": "A sequence variant located 3' of a gene. [SO:ke]"
        },
        "SO:0001633": {
            "name": "5KB_downstream_variant",
            "def": "A sequence variant located within 5 KB of the end of a gene. [SO:ke]"
        },
        "SO:0001634": {
            "name": "500B_downstream_variant",
            "def": "A sequence variant located within a half KB of the end of a gene. [SO:ke]"
        },
        "SO:0001635": {
            "name": "5KB_upstream_variant",
            "def": "A sequence variant located within 5KB 5' of a gene. [SO:ke]"
        },
        "SO:0001636": {
            "name": "2KB_upstream_variant",
            "def": "A sequence variant located within 2KB 5' of a gene. [SO:ke]"
        },
        "SO:0001637": {
            "name": "rRNA_gene",
            "def": "A gene that encodes for ribosomal RNA. [SO:ke]"
        },
        "SO:0001638": {
            "name": "piRNA_gene",
            "def": "A gene that encodes for an piwi associated RNA. [SO:ke]"
        },
        "SO:0001639": {
            "name": "RNase_P_RNA_gene",
            "def": "A gene that encodes an RNase P RNA. [SO:ke]"
        },
        "SO:0001640": {
            "name": "RNase_MRP_RNA_gene",
            "def": "A gene that encodes a RNase_MRP_RNA. [SO:ke]"
        },
        "SO:0001641": {
            "name": "lincRNA_gene",
            "def": "A gene that encodes large intervening non-coding RNA. [SO:ke]"
        },
        "SO:0001642": {
            "name": "mathematically_defined_repeat",
            "def": "A mathematically defined repeat (MDR) is a experimental feature that is determined by querying overlapping oligomers of length k against a database of shotgun sequence data and identifying regions in the query sequence that exceed a statistically determined threshold of repetitiveness. [SO:jestill]"
        },
        "SO:0001643": {
            "name": "telomerase_RNA_gene",
            "def": "A telomerase RNA gene is a non coding RNA gene the RNA product of which is a component of telomerase. [SO:ke]"
        },
        "SO:0001644": {
            "name": "targeting_vector",
            "def": "An engineered vector that is able to take part in homologous recombination in a host with the intent of introducing site specific genomic modifications. [MGD:tm, PMID:10354467]"
        },
        "SO:0001645": {
            "name": "genetic_marker",
            "def": "A measurable sequence feature that varies within a population. [SO:db]"
        },
        "SO:0001646": {
            "name": "DArT_marker",
            "def": "A genetic marker, discovered using Diversity Arrays Technology (DArT) technology. [SO:ke]"
        },
        "SO:0001647": {
            "name": "kozak_sequence",
            "def": "A kind of ribosome entry site, specific to Eukaryotic organisms that overlaps part of both 5' UTR and CDS sequence. [SO:ke]"
        },
        "SO:0001648": {
            "name": "nested_transposon",
            "def": "A transposon that is disrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001649": {
            "name": "nested_repeat",
            "def": "A repeat that is disrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001650": {
            "name": "inframe_variant",
            "def": "A sequence variant which does not cause a disruption of the translational reading frame. [SO:ke]"
        },
        "SO:0001653": {
            "name": "retinoic_acid_responsive_element",
            "def": "A transcription factor binding site of variable direct repeats of the sequence PuGGTCA spaced by five nucleotides (DR5) found in the promoters of retinoic acid-responsive genes, to which retinoic acid receptors bind. [PMID:11327309, PMID:19917671]"
        },
        "SO:0001654": {
            "name": "nucleotide_to_protein_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001655": {
            "name": "nucleotide_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with nucleotide residues. [SO:cb]"
        },
        "SO:0001656": {
            "name": "metal_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with metal ions. [SO:cb]"
        },
        "SO:0001657": {
            "name": "ligand_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with a small molecule such as a drug, or hormone. [SO:ke]"
        },
        "SO:0001658": {
            "name": "nested_tandem_repeat",
            "def": "An NTR is a nested repeat of two distinct tandem motifs interspersed with each other. [SO:AF]"
        },
        "SO:0001659": {
            "name": "promoter_element"
        },
        "SO:0001660": {
            "name": "core_promoter_element"
        },
        "SO:0001661": {
            "name": "RNA_polymerase_II_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase II. [PMID:16858867]"
        },
        "SO:0001662": {
            "name": "RNA_polymerase_III_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase III. [SO:ke]"
        },
        "SO:0001663": {
            "name": "BREd_motif",
            "def": "A core TRNA polymerase II promoter element with consensus (G/A)T(T/G/A)(T/A)(G/T)(T/G)(T/G). [PMID:16858867]"
        },
        "SO:0001664": {
            "name": "DCE",
            "def": "A discontinuous core element of RNA polymerase II transcribed genes, situated downstream of the TSS. It is composed of three sub elements: SI, SII and SIII. [PMID:16858867]"
        },
        "SO:0001665": {
            "name": "DCE_SI",
            "def": "A sub element of the DCE core promoter element, with consensus sequence CTTC. [PMID:16858867, SO:ke]"
        },
        "SO:0001666": {
            "name": "DCE_SII",
            "def": "A sub element of the DCE core promoter element with consensus sequence CTGT. [PMID:16858867, SO:ke]"
        },
        "SO:0001667": {
            "name": "DCE_SIII",
            "def": "A sub element of the DCE core promoter element with consensus sequence AGC. [PMID:16858867, SO:ke]"
        },
        "SO:0001668": {
            "name": "proximal_promoter_element",
            "def": "DNA segment that ranges from about -250 to -40 relative to +1 of RNA transcription start site, where sequence specific DNA-binding transcription factors binds, such as Sp1, CTF (CCAAT-binding transcription factor), and CBF (CCAAT-box binding factor). [PMID:12515390, PMID:9679020, SO:ml]"
        },
        "SO:0001669": {
            "name": "RNApol_II_core_promoter",
            "def": "The minimal portion of the promoter required to properly initiate transcription in RNA polymerase II transcribed genes. [PMID:16858867]"
        },
        "SO:0001670": {
            "name": "distal_promoter_element"
        },
        "SO:0001671": {
            "name": "bacterial_RNApol_promoter_sigma_70"
        },
        "SO:0001672": {
            "name": "bacterial_RNApol_promoter_sigma54"
        },
        "SO:0001673": {
            "name": "minus_12_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
        },
        "SO:0001674": {
            "name": "minus_24_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
        },
        "SO:0001675": {
            "name": "A_box_type_1",
            "def": "An A box within an RNA polymerase III type 1 promoter. [SO:ke]"
        },
        "SO:0001676": {
            "name": "A_box_type_2",
            "def": "An A box within an RNA polymerase III type 2 promoter. [SO:ke]"
        },
        "SO:0001677": {
            "name": "intermediate_element",
            "def": "A core promoter region of RNA polymerase III type 1 promoters. [PMID:12381659]"
        },
        "SO:0001678": {
            "name": "regulatory_promoter_element",
            "def": "A promoter element that is not part of the core promoter, but provides the promoter with a specific regulatory region. [PMID:12381659]"
        },
        "SO:0001679": {
            "name": "transcription_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of transcription. [SO:ke]"
        },
        "SO:0001680": {
            "name": "translation_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of translation. [SO:ke]"
        },
        "SO:0001681": {
            "name": "recombination_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of recombination. [SO:ke]"
        },
        "SO:0001682": {
            "name": "replication_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of nucleotide replication. [SO:ke]"
        },
        "SO:0001683": {
            "name": "sequence_motif",
            "def": "A sequence motif is a nucleotide or amino-acid sequence pattern that may have biological significance. [http://en.wikipedia.org/wiki/Sequence_motif]"
        },
        "SO:0001684": {
            "name": "experimental_feature_attribute",
            "def": "An attribute of an experimentally derived feature. [SO:ke]"
        },
        "SO:0001685": {
            "name": "score",
            "def": "The score of an experimentally derived feature such as a p-value. [SO:ke]"
        },
        "SO:0001686": {
            "name": "quality_value",
            "def": "An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score. [SO:ke]"
        },
        "SO:0001687": {
            "name": "restriction_enzyme_recognition_site",
            "def": "The nucleotide region (usually a palindrome) that is recognized by a restriction enzyme. This may or may not be equal to the restriction enzyme binding site. [SO:ke]"
        },
        "SO:0001688": {
            "name": "restriction_enzyme_cleavage_junction",
            "def": "The boundary at which a restriction enzyme breaks the nucleotide sequence. [SO:ke]"
        },
        "SO:0001689": {
            "name": "five_prime_restriction_enzyme_junction",
            "def": "The restriction enzyme cleavage junction on the 5' strand of the nucleotide sequence. [SO:ke]"
        },
        "SO:0001690": {
            "name": "three_prime_restriction_enzyme_junction"
        },
        "SO:0001691": {
            "name": "blunt_end_restriction_enzyme_cleavage_site"
        },
        "SO:0001692": {
            "name": "sticky_end_restriction_enzyme_cleavage_site"
        },
        "SO:0001693": {
            "name": "blunt_end_restriction_enzyme_cleavage_junction",
            "def": "A restriction enzyme cleavage site where both strands are cut at the same position. [SO:ke]"
        },
        "SO:0001694": {
            "name": "single_strand_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme cleavage site whereby only one strand is cut. [SO:ke]"
        },
        "SO:0001695": {
            "name": "restriction_enzyme_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended. [SO:ke]"
        },
        "SO:0001696": {
            "name": "experimentally_defined_binding_region",
            "def": "A region that has been implicated in binding although the exact coordinates of binding may be unknown. [SO:ke]"
        },
        "SO:0001697": {
            "name": "ChIP_seq_region",
            "def": "A region of sequence identified by CHiP seq technology to contain a protein binding site. [SO:ke]"
        },
        "SO:0001698": {
            "name": "ASPE_primer",
            "def": "\\A primer containing an SNV at the 3' end for accurate genotyping. [http://www.ncbi.nlm.nih.gov/pubmed/11252801]"
        },
        "SO:0001699": {
            "name": "dCAPS_primer",
            "def": "A primer with one or more mismatches to the DNA template corresponding to a position within a restriction enzyme recognition site. [http://www.ncbi.nlm.nih.gov/pubmed/9628033]"
        },
        "SO:0001700": {
            "name": "histone_modification",
            "def": "Histone modification is a post translationally modified region whereby residues of the histone protein are modified by methylation, acetylation, phosphorylation, ubiquitination, sumoylation, citrullination, or ADP-ribosylation. [http:en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001701": {
            "name": "histone_methylation_site",
            "def": "A histone modification site where the modification is the methylation of the residue. [SO:ke]"
        },
        "SO:0001702": {
            "name": "histone_acetylation_site",
            "def": "A histone modification where the modification is the acylation of the residue. [SO:ke]"
        },
        "SO:0001703": {
            "name": "H3K9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001704": {
            "name": "H3K14_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001705": {
            "name": "H3K4_monomethylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001706": {
            "name": "H3K4_trimethylation",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001707": {
            "name": "H3K9_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001708": {
            "name": "H3K27_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001709": {
            "name": "H3K27_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001710": {
            "name": "H3K79_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is mono- methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001711": {
            "name": "H3K79_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is di-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001712": {
            "name": "H3K79_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001713": {
            "name": "H4K20_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H4histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001714": {
            "name": "H2BK5_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2B protein is methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001715": {
            "name": "ISRE",
            "def": "An ISRE is a transcriptional cis regulatory region, containing the consensus region: YAGTTTC(A/T)YTTTYCC, responsible for increased transcription via interferon binding. [http://genesdev.cshlp.org/content/2/4/383.abstrac]"
        },
        "SO:0001716": {
            "name": "histone_ubiqitination_site",
            "def": "A histone modification site where ubiquitin may be added. [SO:ke]"
        },
        "SO:0001717": {
            "name": "H2B_ubiquitination_site",
            "def": "A histone modification site on H2B where ubiquitin may be added. [SO:ke]"
        },
        "SO:0001718": {
            "name": "H3K18_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001719": {
            "name": "H3K23_acylation_site",
            "def": "A kind of histone modification, whereby the 23rd residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001720": {
            "name": "epigenetically_modified_region",
            "def": "A biological region implicated in inherited changes caused by mechanisms other than changes in the underlying DNA sequence. [http://en.wikipedia.org/wiki/Epigenetics, SO:ke]"
        },
        "SO:0001721": {
            "name": "H3K27_acylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001722": {
            "name": "H3K36_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
        },
        "SO:0001723": {
            "name": "H3K36_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is dimethylated. [SO:ke]"
        },
        "SO:0001724": {
            "name": "H3K36_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [SO:ke]"
        },
        "SO:0001725": {
            "name": "H3K4_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
        },
        "SO:0001726": {
            "name": "H3K27_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
        },
        "SO:0001727": {
            "name": "H3K9_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
        },
        "SO:0001728": {
            "name": "H3K9_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein may be dimethylated. [SO:ke]"
        },
        "SO:0001729": {
            "name": "H4K16_acylation_site",
            "def": "A kind of histone modification site, whereby the 16th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
        },
        "SO:0001730": {
            "name": "H4K5_acylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
        },
        "SO:0001731": {
            "name": "H4K8_acylation_site",
            "def": "A kind of histone modification site, whereby the 8th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:KE]"
        },
        "SO:0001732": {
            "name": "H3K27_methylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001733": {
            "name": "H3K36_methylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001734": {
            "name": "H3K4_methylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is methylated. [SO:ke]"
        },
        "SO:0001735": {
            "name": "H3K79_methylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001736": {
            "name": "H3K9_methylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001737": {
            "name": "histone_acylation_region",
            "def": "A histone modification, whereby the histone protein is acylated at multiple sites in a region. [SO:ke]"
        },
        "SO:0001738": {
            "name": "H4K_acylation_region",
            "def": "A region of the H4 histone whereby multiple lysines are acylated. [SO:ke]"
        },
        "SO:0001739": {
            "name": "gene_with_non_canonical_start_codon",
            "def": "A gene with a start codon other than AUG. [SO:xp]"
        },
        "SO:0001740": {
            "name": "gene_with_start_codon_CUG",
            "def": "A gene with a translational start codon of CUG. [SO:mc]"
        },
        "SO:0001741": {
            "name": "pseudogenic_gene_segment",
            "def": "A gene segment which when incorporated by somatic recombination in the final gene transcript results in a nonfunctional product. [SO:hd]"
        },
        "SO:0001742": {
            "name": "copy_number_gain",
            "def": "A sequence alteration whereby the copy number of a given regions is greater than the reference sequence. [SO:ke]"
        },
        "SO:0001743": {
            "name": "copy_number_loss",
            "def": "A sequence alteration whereby the copy number of a given region is less than the reference sequence. [SO:ke]"
        },
        "SO:0001744": {
            "name": "UPD",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from one parent and no copies of the same chromosome or region from the other parent. [SO:BM]"
        },
        "SO:0001745": {
            "name": "maternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the mother and no copies of the same chromosome or region from the father. [SO:bm]"
        },
        "SO:0001746": {
            "name": "paternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the father and no copies of the same chromosome or region from the mother. [SO:bm]"
        },
        "SO:0001747": {
            "name": "open_chromatin_region",
            "def": "A DNA sequence that in the normal state of the chromosome corresponds to an unfolded, un-complexed stretch of double-stranded DNA. [SO:cb]"
        },
        "SO:0001748": {
            "name": "SL3_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL3 RNA leader sequence to the 5' end of an mRNA. SL3 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001749": {
            "name": "SL4_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL4 RNA leader sequence to the 5' end of an mRNA. SL4 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001750": {
            "name": "SL5_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL5 RNA leader sequence to the 5' end of an mRNA. SL5 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001751": {
            "name": "SL6_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL6 RNA leader sequence to the 5' end of an mRNA. SL6 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001752": {
            "name": "SL7_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL7 RNA leader sequence to the 5' end of an mRNA. SL7 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001753": {
            "name": "SL8_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL8 RNA leader sequence to the 5' end of an mRNA. SL8 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001754": {
            "name": "SL9_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL9 RNA leader sequence to the 5' end of an mRNA. SL9 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001755": {
            "name": "SL10_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL10 RNA leader sequence to the 5' end of an mRNA. SL10 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001756": {
            "name": "SL11_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL11 RNA leader sequence to the 5' end of an mRNA. SL11 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001757": {
            "name": "SL12_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL12 RNA leader sequence to the 5' end of an mRNA. SL12 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001758": {
            "name": "duplicated_pseudogene",
            "def": "A pseudogene that arose via gene duplication. Generally duplicated pseudogenes have the same structure as the original gene, including intron-exon structure and some regulatory sequence. [http://en.wikipedia.org/wiki/Pseudogene]"
        },
        "SO:0001759": {
            "name": "unitary_pseudogene",
            "def": "A pseudogene, deactivated from original state by mutation, fixed in a population. [http://en.wikipedia.org/wiki/Pseudogene, SO:ke]"
        },
        "SO:0001760": {
            "name": "non_processed_pseudogene",
            "def": "A pseudogene that arose from a means other than retrotransposition. [SO:ke]"
        },
        "SO:0001761": {
            "name": "variant_quality",
            "def": "A dependent entity that inheres in a bearer, a sequence variant. [PMID:17597783, SO:ke]"
        },
        "SO:0001762": {
            "name": "variant_origin",
            "def": "A quality inhering in a variant by virtue of its origin. [PMID:17597783, SO:ke]"
        },
        "SO:0001763": {
            "name": "variant_frequency",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [PMID:17597783, SO:ke]"
        },
        "SO:0001764": {
            "name": "unique_variant",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [SO:ke]"
        },
        "SO:0001765": {
            "name": "rare_variant"
        },
        "SO:0001766": {
            "name": "polymorphic_variant"
        },
        "SO:0001767": {
            "name": "common_variant"
        },
        "SO:0001768": {
            "name": "fixed_variant"
        },
        "SO:0001769": {
            "name": "variant_phenotype",
            "def": "A quality inhering in a variant by virtue of its phenotype. [PMID:17597783, SO:ke]"
        },
        "SO:0001770": {
            "name": "benign_variant"
        },
        "SO:0001771": {
            "name": "disease_associated_variant"
        },
        "SO:0001772": {
            "name": "disease_causing_variant"
        },
        "SO:0001773": {
            "name": "lethal_variant"
        },
        "SO:0001774": {
            "name": "quantitative_variant"
        },
        "SO:0001775": {
            "name": "maternal_variant"
        },
        "SO:0001776": {
            "name": "paternal_variant"
        },
        "SO:0001777": {
            "name": "somatic_variant"
        },
        "SO:0001778": {
            "name": "germline_variant"
        },
        "SO:0001779": {
            "name": "pedigree_specific_variant"
        },
        "SO:0001780": {
            "name": "population_specific_variant"
        },
        "SO:0001781": {
            "name": "de_novo_variant"
        },
        "SO:0001782": {
            "name": "TF_binding_site_variant",
            "def": "A sequence variant located within a transcription factor binding site. [EBI:fc]"
        },
        "SO:0001784": {
            "name": "complex_structural_alteration",
            "def": "A structural sequence alteration or rearrangement encompassing one or more genome fragments, with 4 or more breakpoints. [FB:reference_manual, NCBI:th, SO:ke]"
        },
        "SO:0001785": {
            "name": "structural_alteration"
        },
        "SO:0001786": {
            "name": "loss_of_heterozygosity",
            "def": "A functional variant whereby the sequence alteration causes a loss of function of one allele of a gene. [SO:ke]"
        },
        "SO:0001787": {
            "name": "splice_donor_5th_base_variant",
            "def": "A sequence variant that causes a change at the 5th base pair after the start of the intron in the orientation of the transcript. [EBI:gr]"
        },
        "SO:0001788": {
            "name": "U_box",
            "def": "An U-box is a conserved T-rich region upstream of a retroviral polypurine tract that is involved in PPT primer creation during reverse transcription. [PMID:10556309, PMID:11577982, PMID:9649446]"
        },
        "SO:0001789": {
            "name": "mating_type_region",
            "def": "A specialized region in the genomes of some yeast and fungi, the genes of which regulate mating type. [SO:ke]"
        },
        "SO:0001790": {
            "name": "paired_end_fragment",
            "def": "An assembly region that has been sequenced from both ends resulting in a read_pair (mate_pair). [SO:ke]"
        },
        "SO:0001791": {
            "name": "exon_variant",
            "def": "A sequence variant that changes exon sequence. [SO:ke]"
        },
        "SO:0001792": {
            "name": "non_coding_transcript_exon_variant",
            "def": "A sequence variant that changes non-coding exon sequence in a non-coding transcript. [EBI:fc, SO:ke]"
        },
        "SO:0001793": {
            "name": "clone_end",
            "def": "A read from an end of the clone sequence. [SO:ke]"
        },
        "SO:0001794": {
            "name": "point_centromere",
            "def": "A point centromere is a relatively small centromere (about 125 bp DNA) in discrete sequence, found in some yeast including S. cerevisiae. [PMID:7502067, SO:vw]"
        },
        "SO:0001795": {
            "name": "regional_centromere",
            "def": "A regional centromere is a large modular centromere found in fission yeast and higher eukaryotes. It consist of a central core region flanked by inverted inner and outer repeat regions. [PMID:7502067, SO:vw]"
        },
        "SO:0001796": {
            "name": "regional_centromere_central_core",
            "def": "A conserved region within the central region of a modular centromere, where the kinetochore is formed. [SO:vw]"
        },
        "SO:0001797": {
            "name": "centromeric_repeat",
            "def": "A repeat region found within the modular centromere. [SO:ke]"
        },
        "SO:0001798": {
            "name": "regional_centromere_inner_repeat_region",
            "def": "The inner inverted repeat region of a modular centromere and part of the central core surrounding a non-conserved central region. This region is adjacent to the central core, on each chromosome arm. [SO:vw]"
        },
        "SO:0001799": {
            "name": "regional_centromere_outer_repeat_region",
            "def": "The heterochromatic outer repeat region of a modular centromere. These repeats exist in tandem arrays on both chromosome arms. [SO:vw]"
        },
        "SO:0001800": {
            "name": "tasiRNA",
            "def": "The sequence of a 21 nucleotide double stranded, polyadenylated non coding RNA, transcribed from the TAS gene. [PMID:16145017]"
        },
        "SO:0001801": {
            "name": "tasiRNA_primary_transcript",
            "def": "A primary transcript encoding a tasiRNA. [PMID:16145017]"
        },
        "SO:0001802": {
            "name": "increased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is increased with respect to the reference. [SO:ke]"
        },
        "SO:0001803": {
            "name": "decreased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is decreased with respect to the reference. [SO:ke]"
        },
        "SO:0001804": {
            "name": "DDB_box",
            "def": "A conserved polypeptide motif that mediates protein-protein interaction and defines adaptor proteins for DDB1/cullin 4 ubiquitin ligases. [PMID:18794354, PMID:19818632]"
        },
        "SO:0001805": {
            "name": "destruction_box",
            "def": "A conserved polypeptide motif that can be recognized by both Fizzy/Cdc20- and FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is RXXLXXXXN. [PMID:12208841, PMID:1842691]"
        },
        "SO:0001806": {
            "name": "ER_retention_signal",
            "def": "A C-terminal tetrapeptide motif that mediates retention of a protein in (or retrieval to) the endoplasmic reticulum. In mammals the sequence is KDEL, and in fungi HDEL or DDEL. [doi:10.1093/jxb/50.331.157, PMID:2077689]"
        },
        "SO:0001807": {
            "name": "KEN_box",
            "def": "A conserved polypeptide motif that can be recognized by FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is KENXXXN. [PMID:10733526, PMID:1220884, PMID:18426916]"
        },
        "SO:0001808": {
            "name": "mitochondrial_targeting_signal",
            "def": "A polypeptide region that targets a polypeptide to the mitochondrion. [PomBase:mah]"
        },
        "SO:0001809": {
            "name": "signal_anchor",
            "def": "A signal sequence that is not cleaved from the polypeptide. Anchors a Type II membrane protein to the membrane. [http://www.cbs.dtu.dk/services/SignalP/background/biobackground.php]"
        },
        "SO:0001810": {
            "name": "PIP_box",
            "def": "A polypeptide region that mediates binding to PCNA. The consensus sequence is QXX(hh)XX(aa), where (h) denotes residues with moderately hydrophobic side chains and (a) denotes residues with highly hydrophobic aromatic side chains. [PMID:9631646]"
        },
        "SO:0001811": {
            "name": "phosphorylation_site",
            "def": "A post-translationally modified region in which residues of the protein are modified by phosphorylation. [PomBase:mah]"
        },
        "SO:0001812": {
            "name": "transmembrane_helix",
            "def": "A region that traverses the lipid bilayer and adopts a helical secondary structure. [PomBase:mah]"
        },
        "SO:0001813": {
            "name": "vacuolar_sorting_signal",
            "def": "A polypeptide region that targets a polypeptide to the vacuole. [PomBase:mah]"
        },
        "SO:0001814": {
            "name": "coding_variant_quality"
        },
        "SO:0001815": {
            "name": "synonymous"
        },
        "SO:0001816": {
            "name": "non_synonymous"
        },
        "SO:0001817": {
            "name": "inframe",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is divisible by 3. [SO:ke]"
        },
        "SO:0001818": {
            "name": "protein_altering_variant",
            "def": "A sequence_variant which is predicted to change the protein encoded in the coding sequence. [EBI:gr]"
        },
        "SO:0001819": {
            "name": "synonymous_variant",
            "def": "A sequence variant where there is no resulting change to the encoded amino acid. [SO:ke]"
        },
        "SO:0001820": {
            "name": "inframe_indel",
            "def": "A coding sequence variant where the change does not alter the frame of the transcript. [SO:ke]"
        },
        "SO:0001821": {
            "name": "inframe_insertion",
            "def": "An inframe non synonymous variant that inserts bases into in the coding sequence. [EBI:gr]"
        },
        "SO:0001822": {
            "name": "inframe_deletion",
            "def": "An inframe non synonymous variant that deletes bases from the coding sequence. [EBI:gr]"
        },
        "SO:0001823": {
            "name": "conservative_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence between existing codons. [EBI:gr]"
        },
        "SO:0001824": {
            "name": "disruptive_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence within an existing codon. [EBI:gr]"
        },
        "SO:0001825": {
            "name": "conservative_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes one or more entire codons from the coding sequence but does not change any remaining codons. [EBI:gr]"
        },
        "SO:0001826": {
            "name": "disruptive_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes bases from the coding sequence starting within an existing codon. [EBI:gr]"
        },
        "SO:0001827": {
            "name": "mRNA_read",
            "def": "A sequencer read of an mRNA substrate. [SO:ke]"
        },
        "SO:0001828": {
            "name": "genomic_DNA_read",
            "def": "A sequencer read of a genomic DNA substrate. [SO:ke]"
        },
        "SO:0001829": {
            "name": "mRNA_contig",
            "def": "A contig composed of mRNA_reads. [SO:ke]"
        },
        "SO:0001830": {
            "name": "AFLP_fragment",
            "def": "A PCR product obtained by applying the AFLP technique, based on a restriction enzyme digestion of genomic DNA and an amplification of the resulting fragments. [GMOD:ea]"
        },
        "SO:0001831": {
            "name": "protein_hmm_match",
            "def": "A match to a protein HMM such as pfam. [SO:ke]"
        },
        "SO:0001832": {
            "name": "immunoglobulin_region",
            "def": "A region of immunoglobulin sequence, either constant or variable. [SO:ke]"
        },
        "SO:0001833": {
            "name": "V_region",
            "def": "The variable region of an immunoglobulin polypeptide sequence. [SO:ke]"
        },
        "SO:0001834": {
            "name": "C_region",
            "def": "The constant region of an immunoglobulin polypeptide sequence. [SO:ke]"
        },
        "SO:0001835": {
            "name": "N_region",
            "def": "Extra nucleotides inserted between rearranged immunoglobulin segments. [SO:ke]"
        },
        "SO:0001836": {
            "name": "S_region",
            "def": "The switch region of immunoglobulin heavy chains; it is involved in the rearrangement of heavy chain DNA leading to the expression of a different immunoglobulin classes from the same B-cell. [SO:ke]"
        },
        "SO:0001837": {
            "name": "mobile_element_insertion",
            "def": "A kind of insertion where the inserted sequence is a mobile element. [EBI:dvga]"
        },
        "SO:0001838": {
            "name": "novel_sequence_insertion",
            "def": "An insertion the sequence of which cannot be mapped to the reference genome. [NCBI:th]"
        },
        "SO:0001839": {
            "name": "CSL_response_element",
            "def": "A promoter element with consensus sequence GTGRGAA, bound by CSL (CBF1/RBP-JK/Suppressor of Hairless/LAG-1) transcription factors. [PMID:19101542]"
        },
        "SO:0001840": {
            "name": "GATA_box",
            "def": "A GATA transcription factor element containing the consensus sequence WGATAR (in which W indicates A/T and R indicates A/G). [PMID:8321208]"
        },
        "SO:0001841": {
            "name": "polymorphic_pseudogene",
            "def": "Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains the gene is translated. [JAX:hd]"
        },
        "SO:0001842": {
            "name": "AP_1_binding_site",
            "def": "A promoter element with consensus sequence TGACTCA, bound by AP-1 and related transcription factors. [PMID:1899230, PMID:3034432, PMID:3125983]"
        },
        "SO:0001843": {
            "name": "CRE",
            "def": "A promoter element with consensus sequence TGACGTCA; bound by the ATF/CREB family of transcription factors. [PMID:11483355, PMID:11483993]"
        },
        "SO:0001844": {
            "name": "CuRE",
            "def": "A promoter element bound by copper ion-sensing transcription factors such as S. cerevisiae Mac1p or S. pombe Cuf1; the consensus sequence is HTHNNGCTGD (more specifically TTTGCKCR in budding yeast). [PMID:10593913, PMID:9188496, PMID:9211922]"
        },
        "SO:0001845": {
            "name": "DRE",
            "def": "A promoter element with consensus sequence CGWGGWNGMM, bound by transcription factors related to RecA and found in promoters of genes expressed following several types of DNA damage or inhibition of DNA synthesis. [PMID:11073995, PMID:8668127]"
        },
        "SO:0001846": {
            "name": "FLEX_element",
            "def": "A promoter element that has consensus sequence GTAAACAAACAAAM and contains a heptameric core GTAAACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:10747048, PMID:14871934]"
        },
        "SO:0001847": {
            "name": "forkhead_motif",
            "def": "A promoter element with consensus sequence TTTRTTTACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:15195092]"
        },
        "SO:0001848": {
            "name": "homol_D_box",
            "def": "A core promoter element that has the consensus sequence CAGTCACA (or its inverted form TGTGACTG), and plays the role of a TATA box in promoters that do not contain a canonical TATA sequence. [PMID:7501449, PMID:8458332]"
        },
        "SO:0001849": {
            "name": "homol_E_box",
            "def": "A core promoter element that has the consensus sequence ACCCTACCCT (or its inverted form AGGGTAGGGT), and is found near the homol D box in some promoters that use a homol D box instead of a canonical TATA sequence. [PMID:7501449]"
        },
        "SO:0001850": {
            "name": "HSE",
            "def": "A promoter element that consists of at least three copies of the pentanucleotide NGAAN, bound by the heat shock transcription factor HSF. [PMID:17347150, PMID:8689565]"
        },
        "SO:0001851": {
            "name": "iron_repressed_GATA_element",
            "def": "A GATA promoter element with consensus sequence WGATAA, found in promoters of genes repressed in the presence of iron. [PMID:11956219, PMID:17211681]"
        },
        "SO:0001852": {
            "name": "mating_type_M_box",
            "def": "A promoter element with consensus sequence ACAAT, found in promoters of mating type M-specific genes in fission yeast and bound by the transcription factor Mat1-Mc. [PMID:9233811]"
        },
        "SO:0001853": {
            "name": "androgen_response_element",
            "def": "A non-palindromic sequence found in the promoters of genes whose expression is regulated in response to androgen. [PMID:21796522]"
        },
        "SO:0001854": {
            "name": "smFISH_probe",
            "def": "A smFISH is a probe that binds RNA in a single molecule in situ hybridization experiment. [PMID:18806792]"
        },
        "SO:0001855": {
            "name": "MCB",
            "def": "A promoter element with consensus sequence ACGCGT, bound by the transcription factor complex MBF (MCB-binding factor) and found in promoters of genes expressed during the G1/S transition of the cell cycle. [PMID:16285853]"
        },
        "SO:0001856": {
            "name": "CCAAT_motif",
            "def": "A promoter element with consensus sequence CCAAT, bound by a protein complex that represses transcription in response to low iron levels. [PMID:16963626]"
        },
        "SO:0001857": {
            "name": "Ace2_UAS",
            "def": "A promoter element with consensus sequence CCAGCC, bound by the fungal transcription factor Ace2. [PMID:16678171]"
        },
        "SO:0001858": {
            "name": "TR_box",
            "def": "A promoter element with consensus sequence TTCTTTGTTY, bound an HMG-box transcription factor such as S. pombe Ste11, and found in promoters of genes up-regulated early in meiosis. [PMID:1657709]"
        },
        "SO:0001859": {
            "name": "STREP_motif",
            "def": "A promoter element with consensus sequence CCCCTC, bound by the PKA-responsive zinc finger transcription factor Rst2. [PMID:11739717]"
        },
        "SO:0001860": {
            "name": "rDNA_intergenic_spacer_element",
            "def": "A DNA motif that contains a core consensus sequence AGGTAAGGGTAATGCAC, is found in the intergenic regions of rDNA repeats, and is bound by an RNA polymerase I transcription termination factor (e.g. S. pombe Reb1). [PMID:9016645]"
        },
        "SO:0001861": {
            "name": "sterol_regulatory_element",
            "def": "A 10-bp promoter element bound by sterol regulatory element binding proteins (SREBPs), found in promoters of genes involved in sterol metabolism. Many variants of the sequence ATCACCCCAC function as SREs. [GO:mah, PMID:11111080, PMID:16537923]"
        },
        "SO:0001862": {
            "name": "GT_dinucleotide_repeat",
            "def": "A dinucleotide repeat region composed of GT repeating elements. [SO:ke]"
        },
        "SO:0001863": {
            "name": "GTT_trinucleotide_repeat",
            "def": "A trinucleotide repeat region composed of GTT repeating elements. [SO:ke]"
        },
        "SO:0001864": {
            "name": "Sap1_recognition_motif",
            "def": "A DNA motif to which the S. pombe Sap1 protein binds. The consensus sequence is 5'-TARGCAGNTNYAACGMG-3'; it is found at the mating type locus, where it is important for mating type switching, and at replication fork barriers in rDNA repeats. [PMID:16166653, PMID:7651412]"
        },
        "SO:0001865": {
            "name": "CDRE_motif",
            "def": "An RNA polymerase II promoter element found in the promoters of genes regulated by calcineurin. The consensus sequence is GNGGCKCA. [PMID:16928959]"
        },
        "SO:0001866": {
            "name": "BAC_read_contig",
            "def": "A contig of BAC reads. [GMOD:ea]"
        },
        "SO:0001867": {
            "name": "candidate_gene",
            "def": "A gene suspected of being involved in the expression of a trait. [GMOD:ea]"
        },
        "SO:0001868": {
            "name": "positional_candidate_gene",
            "def": "A candidate gene whose association with a trait is based on the gene's location on a chromosome. [GMOD:ea]"
        },
        "SO:0001869": {
            "name": "functional_candidate_gene",
            "def": "A candidate gene whose function has something in common biologically with the trait under investigation. [GMOD:ea]"
        },
        "SO:0001870": {
            "name": "enhancerRNA",
            "def": "A short ncRNA that is transcribed from an enhancer. May have a regulatory function. [doi:10.1038/465173a, SO:cjm]"
        },
        "SO:0001871": {
            "name": "PCB",
            "def": "A promoter element with consensus sequence GNAACR, bound by the transcription factor complex PBF (PCB-binding factor) and found in promoters of genes expressed during the M/G1 transition of the cell cycle. [GO:mah, PMID:12411492]"
        },
        "SO:0001872": {
            "name": "rearrangement_region",
            "def": "A region of a chromosome, where the chromosome has undergone a large structural rearrangement that altered the genome organization. There is no longer synteny to the reference genome. [NCBI:th, PMID:18564416]"
        },
        "SO:0001873": {
            "name": "interchromosomal_breakpoint",
            "def": "A rearrangement breakpoint between two different chromosomes. [NCBI:th]"
        },
        "SO:0001874": {
            "name": "intrachromosomal_breakpoint",
            "def": "A rearrangement breakpoint within the same chromosome. [NCBI:th]"
        },
        "SO:0001875": {
            "name": "unassigned_supercontig",
            "def": "A supercontig that is not been assigned to any ultracontig during a genome assembly project. [GMOD:ea]"
        },
        "SO:0001876": {
            "name": "partial_genomic_sequence_assembly",
            "def": "A partial DNA sequence assembly of a chromosome or full genome, which contains gaps that are filled with N's. [GMOD:ea]"
        },
        "SO:0001877": {
            "name": "lnc_RNA",
            "def": "A non-coding RNA over 200nucleotides in length. [HGNC:mw]"
        },
        "SO:0001878": {
            "name": "feature_variant",
            "def": "A sequence variant that falls entirely or partially within a genomic feature. [EBI:fc, SO:ke]"
        },
        "SO:0001879": {
            "name": "feature_ablation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the deletion, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001880": {
            "name": "feature_amplification",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, an amplification of sequence, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001881": {
            "name": "feature_translocation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, a translocation, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001882": {
            "name": "feature_fusion",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where a deletion fuses genomic features. [SO:ke]"
        },
        "SO:0001883": {
            "name": "transcript_translocation",
            "def": "A feature translocation where the region contains a transcript. [SO:ke]"
        },
        "SO:0001884": {
            "name": "regulatory_region_translocation",
            "def": "A feature translocation where the region contains a regulatory region. [SO:ke]"
        },
        "SO:0001885": {
            "name": "TFBS_translocation",
            "def": "A feature translocation where the region contains a transcription factor binding site. [SO:ke]"
        },
        "SO:0001886": {
            "name": "transcript_fusion",
            "def": "A feature fusion where the deletion brings together transcript regions. [SO:ke]"
        },
        "SO:0001887": {
            "name": "regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together regulatory regions. [SO:ke]"
        },
        "SO:0001888": {
            "name": "TFBS_fusion",
            "def": "A fusion where the deletion brings together transcription factor binding sites. [SO:ke]"
        },
        "SO:0001889": {
            "name": "transcript_amplification",
            "def": "A feature amplification of a region containing a transcript. [SO:ke]"
        },
        "SO:0001890": {
            "name": "transcript_regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together a regulatory region and a transcript region. [SO:ke]"
        },
        "SO:0001891": {
            "name": "regulatory_region_amplification",
            "def": "A feature amplification of a region containing a regulatory region. [SO:ke]"
        },
        "SO:0001892": {
            "name": "TFBS_amplification",
            "def": "A feature amplification of a region containing a transcription factor binding site. [SO:ke]"
        },
        "SO:0001893": {
            "name": "transcript_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcript feature. [SO:ke]"
        },
        "SO:0001894": {
            "name": "regulatory_region_ablation",
            "def": "A feature ablation whereby the deleted region includes a regulatory region. [SO:ke]"
        },
        "SO:0001895": {
            "name": "TFBS_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcription factor binding site. [SO:ke]"
        },
        "SO:0001896": {
            "name": "transposable_element_CDS",
            "def": "A CDS that is part of a transposable element. [SO:ke]"
        },
        "SO:0001897": {
            "name": "transposable_element_pseudogene",
            "def": "A pseudogene contained within a transposable element. [SO:ke]"
        },
        "SO:0001898": {
            "name": "dg_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
        },
        "SO:0001899": {
            "name": "dh_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
        },
        "SO:0001900": {
            "name": "M26_binding_site",
            "def": "A promoter element that contains a core sequence TGACGT, bound by a protein complex that regulates transcription of genes encoding PKA pathway components. [PMID:15448137]"
        },
        "SO:0001901": {
            "name": "AACCCT_box",
            "def": "A conserved 17-bp sequence (5'-ATCA(C/A)AACCCTAACCCT-3') commonly present upstream of the start site of histone transcription units functioning as a transcription factor binding site. [PMID:17452352, PMID:4092687]"
        },
        "SO:0001902": {
            "name": "splice_region",
            "def": "A region surrounding a cis_splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [SO:bm]"
        },
        "SO:0001903": {
            "name": "intronic_lncRNA",
            "def": "A lnc_RNA totally contained within an intron. [PMID:19071207, SO:ke]"
        },
        "SO:0001904": {
            "name": "antisense_lncRNA",
            "def": "Non-coding RNA transcribed from the opposite DNA strand compared with other transcripts and overlap in part with sense RNA. [PMID:19638999]"
        },
        "SO:0001905": {
            "name": "regional_centromere_outer_repeat_transcript",
            "def": "A transcript that is transcribed from the outer repeat region of a regional centromere. [PomBase:mah]"
        },
        "SO:0001906": {
            "name": "feature_truncation",
            "def": "A sequence variant that causes the reduction of a genomic feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001907": {
            "name": "feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001908": {
            "name": "internal_feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature from within the feature rather than from the terminus of the feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001909": {
            "name": "frameshift_elongation",
            "def": "A frameshift variant that causes the translational reading frame to be extended relative to the reference feature. [SO:ke]"
        },
        "SO:0001910": {
            "name": "frameshift_truncation",
            "def": "A frameshift variant that causes the translational reading frame to be shortened relative to the reference feature. [SO:ke]"
        },
        "SO:0001911": {
            "name": "copy_number_increase",
            "def": "A sequence variant where copies of a feature are increased relative to the reference. [SO:ke]"
        },
        "SO:0001912": {
            "name": "copy_number_decrease",
            "def": "A sequence variant where copies of a feature are decreased relative to the reference. [SO:ke]"
        },
        "SO:0001913": {
            "name": "bacterial_RNApol_promoter_sigma_ecf",
            "def": "A bacterial promoter with sigma ecf factor binding dependency. This is a type of bacterial promoters that requires a sigma ECF factor to bind to identified -10 and -35 sequence regions in order to mediate binding of the RNA polymerase to the promoter region as part of transcription initiation. [Invitrogen:kc]"
        },
        "SO:0001914": {
            "name": "rDNA_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:14645529]"
        },
        "SO:0001915": {
            "name": "transcription_start_cluster",
            "def": "A region defined by a cluster of experimentally determined transcription starting sites. [PMID:19624849, PMID:21372179, SO:andrewgibson]"
        },
        "SO:0001916": {
            "name": "CAGE_tag",
            "def": "A CAGE tag is a sequence tag hat corresponds to 5' ends of mRNA at cap sites, produced by cap analysis gene expression and used to identify transcriptional start sites. [SO:andrewgibson]"
        },
        "SO:0001917": {
            "name": "CAGE_cluster",
            "def": "A kind of transcription_initiation_cluster defined by the clustering of CAGE tags on a sequence region. [PMID:16645617, SO:andrewgibson]"
        },
        "SO:0001918": {
            "name": "5_methylcytosine",
            "def": "A cytosine methylated at the 5 carbon. [SO:rtapella]"
        },
        "SO:0001919": {
            "name": "4_methylcytosine",
            "def": "A cytosine methylated at the 4 nitrogen. [SO:rtapella]"
        },
        "SO:0001920": {
            "name": "N6_methyladenine",
            "def": "An adenine methylated at the 6 nitrogen. [SO:rtapella]"
        },
        "SO:0001921": {
            "name": "mitochondrial_contig",
            "def": "A contig of mitochondria derived sequences. [GMOD:ea]"
        },
        "SO:0001922": {
            "name": "mitochondrial_supercontig",
            "def": "A scaffold composed of mitochondrial contigs. [GMOD:ea]"
        },
        "SO:0001923": {
            "name": "TERRA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts contain G rich telomeric RNA repeats and RNA tracts corresponding to adjacent subtelomeric sequences. They are 100-9000 bases long. [PMID:22139915]"
        },
        "SO:0001924": {
            "name": "ARRET",
            "def": "A non coding RNA transcript, complementary to subtelomeric tract of TERRA transcript but devoid of the repeats. [PMID:2139915]"
        },
        "SO:0001925": {
            "name": "ARIA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts consist of C rich repeats. [PMID:22139915]"
        },
        "SO:0001926": {
            "name": "anti_ARRET",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts are antisense of ARRET transcripts. [PMID:22139915]"
        },
        "SO:0001927": {
            "name": "telomeric_transcript",
            "def": "A non-coding transcript derived from the transcript of the telomere. [PMID:22139915]"
        },
        "SO:0001928": {
            "name": "distal_duplication",
            "def": "A duplication of the distal region of a chromosome. [SO:bm]"
        },
        "SO:0001929": {
            "name": "mitochondrial_DNA_read",
            "def": "A sequencer read of a mitochondrial DNA sample. [GMOD:ea]"
        },
        "SO:0001930": {
            "name": "chloroplast_DNA_read",
            "def": "A sequencer read of a chloroplast DNA sample. [GMOD:ea]"
        },
        "SO:0001931": {
            "name": "consensus_gDNA",
            "def": "Genomic DNA sequence produced from some base calling or alignment algorithm which uses aligned or assembled multiple gDNA sequences as input. [GMOD:ea]"
        },
        "SO:0001932": {
            "name": "restriction_enzyme_five_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 5' end. [SO:ke]"
        },
        "SO:0001933": {
            "name": "restriction_enzyme_three_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 3' end. [SO:ke]"
        },
        "SO:0001934": {
            "name": "monomeric_repeat",
            "def": "A repeat_region containing repeat_units of 1 bp that is repeated multiple times in tandem. [SO:ke]"
        },
        "SO:0001935": {
            "name": "H3K20_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H3 protein is tri-methylated. [EBI:nj]"
        },
        "SO:0001936": {
            "name": "H3K36_acetylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is acylated. [EBI:nj]"
        },
        "SO:0001937": {
            "name": "H2BK12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H2B protein is methylated. [EBI:nj]"
        },
        "SO:0001938": {
            "name": "H2AK5_acetylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001939": {
            "name": "H4K12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001940": {
            "name": "H2BK120_acetylation_site",
            "def": "A kind of histone modification site, whereby the 120th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001941": {
            "name": "H4K91_acetylation_site",
            "def": "A kind of histone modification site, whereby the 91st residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001942": {
            "name": "H2BK20_acetylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001943": {
            "name": "H3K4ac_acetylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001944": {
            "name": "H2AK9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001945": {
            "name": "H3K56_acetylation_site",
            "def": "A kind of histone modification site, whereby the 56th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001946": {
            "name": "H2BK15_acetylation_site",
            "def": "A kind of histone modification site, whereby the 15th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001947": {
            "name": "H3R2_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is mono-methylated. [EBI:nj]"
        },
        "SO:0001948": {
            "name": "H3R2_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001949": {
            "name": "H4R3_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 3nd residue (an arginine), from the start of the H4 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001950": {
            "name": "H4K4_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H4 protein is tri-methylated. [EBI:nj]"
        },
        "SO:0001951": {
            "name": "H3K23_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 23rd residue (a lysine), from the start of the H3 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001952": {
            "name": "promoter_flanking_region",
            "def": "A region immediately adjacent to a promoter which may or may not contain transcription factor binding sites. [EBI:nj]"
        },
        "SO:0001953": {
            "name": "restriction_enzyme_assembly_scar",
            "def": "A region of DNA sequence formed from the ligation of two sticky ends where the palindrome is broken and no longer comprises the recognition site and thus cannot be re-cut by the restriction enzymes used to create the sticky ends. [SO:ke]"
        },
        "SO:0001954": {
            "name": "restriction_enzyme_region",
            "def": "A region related to restriction enzyme function. [SO:ke]"
        },
        "SO:0001955": {
            "name": "protein_stability_element",
            "def": "A polypeptide region that proves structure in a protein that affects the stability of the protein. [SO:ke]"
        },
        "SO:0001956": {
            "name": "protease_site",
            "def": "A polypeptide_region that  codes for a protease cleavage site. [SO:ke]"
        },
        "SO:0001957": {
            "name": "RNA_stability_element",
            "def": "RNA secondary structure that affects the stability of an RNA molecule. [SO:ke]"
        },
        "SO:0001958": {
            "name": "lariat_intron",
            "def": "A kind of intron whereby the excision is driven by lariat formation. [SO:ke]"
        },
        "SO:0001959": {
            "name": "TCT_motif",
            "def": "A cis-regulatory element, conserved sequence YYC+1TTTYY, and spans -2 to +6 relative to +1 TSS. It is present in most ribosomal protein genes in Drosophila and mammals but not in the yeast Saccharomyces cerevisiae. Resembles the initiator (TCAKTY in Drosophila) but functionally distinct from initiator. [PMID:20801935, SO:myl]"
        },
        "SO:0001960": {
            "name": "5_hydroxymethylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a hydroxymethyl group at the 5 carbon. [SO:ke]"
        },
        "SO:0001961": {
            "name": "5_formylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a formyl group at the 5 carbon. [SO:ke]"
        },
        "SO:0001962": {
            "name": "modified_adenine",
            "def": "A modified adenine DNA base feature. [SO:ke]"
        },
        "SO:0001963": {
            "name": "modified_cytosine",
            "def": "A modified cytosine DNA base feature. [SO:ke]"
        },
        "SO:0001964": {
            "name": "modified_guanine",
            "def": "A modified guanine DNA base feature. [SO:ke]"
        },
        "SO:0001965": {
            "name": "8_oxoguanine",
            "def": "A modified DNA guanine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
        },
        "SO:0001966": {
            "name": "5_carboxylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a carboxy group at the 5 carbon. [SO:ke]"
        },
        "SO:0001967": {
            "name": "8_oxoadenine",
            "def": "A modified DNA adenine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
        },
        "SO:0001968": {
            "name": "coding_transcript_variant",
            "def": "A transcript variant of a protein coding gene. [SO:ke]"
        },
        "SO:0001969": {
            "name": "coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a coding transcript. [SO:ke]"
        },
        "SO:0001970": {
            "name": "non_coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a non coding transcript. [SO:ke]"
        },
        "SO:0001971": {
            "name": "zinc_finger_binding_site"
        },
        "SO:0001972": {
            "name": "histone_4_acylation_site",
            "def": "A histone 4 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
        },
        "SO:0001973": {
            "name": "histone_3_acetylation_site",
            "def": "A histone 3 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
        },
        "SO:0001974": {
            "name": "CTCF_binding_site",
            "def": "A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG, bound by CCCTF-binding factor. [EBI:nj]"
        },
        "SO:0001975": {
            "name": "five_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 5 prime overhangs. [SO:ke]"
        },
        "SO:0001976": {
            "name": "three_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 3 prime overhangs. [SO:ke]"
        },
        "SO:0001977": {
            "name": "ribonuclease_site",
            "def": "A region of a transcript encoding the cleavage site for a ribonuclease enzyme. [SO:ke]"
        },
        "SO:0001978": {
            "name": "signature",
            "def": "A region of  sequence where developer information is encoded. [SO:ke]"
        },
        "SO:0001979": {
            "name": "RNA_stability_element",
            "def": "A motif that affects the stability of RNA. [PMID:22495308, SO:ke]"
        },
        "SO:0001980": {
            "name": "G_box",
            "def": "A regulatory promoter element identified in mutation experiments, with consensus sequence: CACGTG. Present in promoters, intergenic regions, coding regions, and introns. They are involved in gene expression responses to light and interact with G-box binding factor and I-box binding factor 1a. [PMID:19249238, PMID:8571452, SO:ml]"
        },
        "SO:0001981": {
            "name": "L_box",
            "def": "An orientation dependent  regulatory promoter element, with consensus sequence of TTGCACAN4TTGCACA, found in plants. [PMID:17381552, PMID:2902624, SO:ml]"
        },
        "SO:0001982": {
            "name": "I-box",
            "def": "A plant regulatory promoter motif,  composed of a highly conserved hexamer GATAAG (I-box core). [PMID:2347304, PMID:2902624, SO:ml]"
        },
        "SO:0001983": {
            "name": "5_prime_UTR_premature_start_codon_variant",
            "def": "A 5' UTR variant where a premature start codon is introduced, moved or lost. [SANGER:am]"
        },
        "SO:0001984": {
            "name": "silent_mating_type_cassette_array",
            "def": "A gene cassette array that corresponds to a silenced version of a mating type region. [PomBase:mah]"
        },
        "SO:0001985": {
            "name": "Okazaki_fragment",
            "def": "Any of the DNA segments produced by discontinuous synthesis of the lagging strand during DNA replication. [ISBN:0805350152]"
        },
        "SO:0001986": {
            "name": "upstream_transcript_variant",
            "def": "A feature variant, where the alteration occurs upstream of the transcript TSS. [EBI:gr]"
        },
        "SO:0001987": {
            "name": "downstream_transcript_variant"
        },
        "SO:0001988": {
            "name": "5_prime_UTR_premature_start_codon_gain_variant",
            "def": "A 5' UTR variant where a premature start codon is gained. [Sanger:am]"
        },
        "SO:0001989": {
            "name": "5_prime_UTR_premature_start_codon_loss_variant",
            "def": "A 5' UTR variant where a premature start codon is lost. [SANGER:am]"
        },
        "SO:0001990": {
            "name": "five_prime_UTR_premature_start_codon_location_variant",
            "def": "A 5' UTR variant where a premature start codon is moved. [SANGER:am]"
        },
        "SO:0001991": {
            "name": "consensus_AFLP_fragment",
            "def": "A consensus AFLP fragment is an AFLP sequence produced from any alignment algorithm which uses assembled multiple AFLP sequences as input. [GMOD:ea]"
        },
        "SO:0001992": {
            "name": "nonsynonymous_variant",
            "def": "A non-synonymous variant is an inframe, protein altering variant, resulting in a codon change. [SO:ke]"
        },
        "SO:0001993": {
            "name": "extended_cis_splice_site",
            "def": "Intronic positions associated with cis-splicing. Contains the first and second positions immediately before the exon and the first, second and fifth positions immediately after. [SANGER:am]"
        },
        "SO:0001994": {
            "name": "intron_base_5",
            "def": "Fifth intronic position after the intron exon boundary, close to the 5' edge of the intron. [SANGER:am]"
        },
        "SO:0001995": {
            "name": "extended_intronic_splice_region_variant",
            "def": "A sequence variant occurring in the intron, within 10 bases of exon. [sanger:am]"
        },
        "SO:0001996": {
            "name": "extended_intronic_splice_region",
            "def": "Region of intronic sequence within 10 bases of an exon. [SANGER:am]"
        },
        "SO:0001997": {
            "name": "subtelomere",
            "def": "A heterochromatic region of the chromosome,  adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes and it is transcribed. [POMBE:al]"
        },
        "SO:0001998": {
            "name": "sgRNA",
            "def": "A small RNA oligo, typically about 20 bases, that guides the cas nuclease to a target DNA sequence in the CRISPR/cas mutagenesis method. [PMID:23934893]"
        },
        "SO:0001999": {
            "name": "mating_type_region_motif",
            "def": "DNA motif that is a component of a mating type region. [SO:ke]"
        },
        "SO:0002001": {
            "name": "Y_region",
            "def": "A segment of non-homology between a and alpha mating alleles, found at all three mating loci (HML, MAT, and HMR), has two forms (Ya and Yalpha). [SGD:jd]"
        },
        "SO:0002002": {
            "name": "Z1_region",
            "def": "A mating type region motif, one of two segments of homology found at all three mating loci (HML, MAT, and HMR). [SGD:jd]"
        },
        "SO:0002003": {
            "name": "Z2_region",
            "def": "A mating type region motif, the rightmost segment of homology in the HML and MAT mating loci (not present in HMR). [SGD:jd]"
        },
        "SO:0002004": {
            "name": "ARS_consensus_sequence",
            "def": "The ACS is an 11-bp sequence of the form 5'-WTTTAYRTTTW-3' which is at the core of every yeast ARS, and is necessary but not sufficient for recognition and binding by the origin recognition complex (ORC). Functional ARSs require an ACS, as well as other cis elements in the 5' (C domain) and 3' (B domain) flanking sequences of the ACS. [SGD:jd]"
        },
        "SO:0002005": {
            "name": "DSR_motif",
            "def": "The determinant of selective removal (DSR) motif consists of repeats of U(U/C)AAAC. The motif targets meiotic transcripts for removal during mitosis via the exosome. [PMID:22645662]"
        },
        "SO:0002006": {
            "name": "zinc_repressed_element",
            "def": "A promoter element that has the consensus sequence GNMGATC, and is found in promoters of genes repressed in the presence of zinc. [PMID:24003116, POMBE:mh]"
        },
        "SO:0002007": {
            "name": "MNV",
            "def": "An MNV is a multiple nucleotide variant (substitution) in which the inserted sequence is the same length as the replaced sequence. [NCBI:th]"
        },
        "SO:0002008": {
            "name": "rare_amino_acid_variant",
            "def": "A sequence variant whereby at least one base of a codon encoding a rare amino acid is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002009": {
            "name": "selenocysteine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding selenocysteine  is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002010": {
            "name": "pyrrolysine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding pyrrolysine is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002011": {
            "name": "intragenic_variant",
            "def": "A variant that occurs within a gene but falls outside of all transcript features. This occurs when alternate transcripts of a gene do not share overlapping  sequence. [SO:ke]"
        },
        "SO:0002012": {
            "name": "start_lost",
            "def": "A codon variant that changes at least one base of the canonical start codon. [SO:ke]"
        },
        "SO:0002013": {
            "name": "5_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 5'UTR  with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002014": {
            "name": "5_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 5' UTR, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002015": {
            "name": "3_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 3' UTR  with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002016": {
            "name": "3_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 3' UTR, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002017": {
            "name": "conserved_intergenic_variant",
            "def": "A sequence variant located in a conserved intergenic region, between genes. [SO:ke]"
        },
        "SO:0002018": {
            "name": "conserved_intron_variant",
            "def": "A transcript variant occurring within a conserved region of an intron. [SO:ke]"
        },
        "SO:0002019": {
            "name": "start_retained_variant",
            "def": "A sequence variant where at least one base in the start codon is changed, but the start remains. [SO:ke]"
        },
        "SO:0002020": {
            "name": "boundary_element",
            "def": "Boundary elements are DNA motifs that prevent heterochromatin from spreading into neighboring euchromatic regions. [PMID:24013502]"
        },
        "SO:0002021": {
            "name": "mating_type_region_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:17614787]"
        },
        "SO:0002022": {
            "name": "priRNA",
            "def": "A small RNA molecule, 22-23 nt in size, that is the product of a longer RNA. The production of priRNAs is independent of dicer and involves binding of RNA by argonaute and trimming by triman. In fission yeast, priRNAs trigger the establishment of heterochromatin. PriRNAs are primarily generated from centromeric transcripts (dg and dh repeats), but may also be produced from degradation products of primary transcripts. [PMID:20178743, PMID:24095277, PomBase:al]"
        },
        "SO:0002023": {
            "name": "multiplexing_sequence_identifier",
            "def": "A nucleic tag which is used in a ligation step of library preparation process to allow pooling of samples while maintaining ability to identify individual source material and creation of a multiplexed library. [OBO:prs, PMID:22574170]"
        },
        "SO:0002024": {
            "name": "W_region",
            "def": "The leftmost segment of homology in the HML and MAT mating loci,  but not present in HMR. [SGD:jd]"
        },
        "SO:0002025": {
            "name": "cis_acting_homologous_chromosome_pairing_region",
            "def": "A genome region where chromosome pairing occurs preferentially during homologous chromosome pairing during early meiotic prophase of Meiosis I. [PMID:22582262, PMID:23117617, PMID:24173580, PomBase:vw]"
        },
        "SO:0002026": {
            "name": "intein_encoding_region",
            "def": "The nucleotide sequence which encodes the intein portion of the precursor gene. [PMID:8165123]"
        },
        "SO:0002027": {
            "name": "uORF",
            "def": "A short open reading frame that is found in the 5' untranslated region of an mRNA and plays a role in translational regulation. [PMID:12890013, PMID:16153175, POMBASE:mah]"
        },
        "SO:0002028": {
            "name": "sORF",
            "def": "An open reading frame that encodes a peptide of less than 100 amino acids. [PMID:23970561, PMID:24705786, POMBASE:mah]"
        },
        "SO:0002029": {
            "name": "tnaORF",
            "def": "A translated ORF encoded entirely within the antisense strand of a known protein coding gene. [POMBASE:vw]"
        },
        "SO:0002030": {
            "name": "X_region",
            "def": "One of two segments of homology found at all three mating loci (HML, MAT and HMR). [SGD:jd]"
        },
        "SO:0002031": {
            "name": "shRNA",
            "def": "A short hairpin RNA (shRNA) is an RNA transcript that makes a tight hairpin turn that can be used to silence target gene expression via RNA interference. [PMID:6699500, SO:ke]"
        },
        "SO:0002032": {
            "name": "moR",
            "def": "A non-coding transcript encoded by sequences adjacent to the ends of the 5' and 3' miR-encoding sequences that abut the loop in precursor miRNA. [SO:ke]"
        },
        "SO:0002033": {
            "name": "loR",
            "def": "A short, non coding transcript of loop-derived sequences encoded in precursor miRNA. [SO:ke]"
        },
        "SO:0002034": {
            "name": "miR_encoding_snoRNA_primary_transcript",
            "def": "A snoRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002035": {
            "name": "lncRNA_primary_transcript",
            "def": "A primary transcript encoding a  lncRNA. [SO:ke]"
        },
        "SO:0002036": {
            "name": "miR_encoding_lncRNA_primary_transcript",
            "def": "A lncRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002037": {
            "name": "miR_encoding_tRNA_primary_transcript",
            "def": "A tRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002038": {
            "name": "shRNA_primary_transcript",
            "def": "A primary transcript encoding an shRNA. [SO:ke]"
        },
        "SO:0002039": {
            "name": "miR_encoding_shRNA_primary_transcript",
            "def": "A shRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002040": {
            "name": "vaultRNA_primary_transcript",
            "def": "A primary transcript encoding a  vaultRNA. [SO:ke]"
        },
        "SO:0002041": {
            "name": "miR_encoding_vaultRNA_primary_transcript",
            "def": "A vaultRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002042": {
            "name": "Y_RNA_primary_transcript",
            "def": "A primary transcript encoding a  Y-RNA. [SO:ke]"
        },
        "SO:0002043": {
            "name": "miR_encoding_Y_RNA_primary_transcript",
            "def": "A Y-RNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002044": {
            "name": "TCS_element",
            "def": "A TCS element is a (yeast) transcription factor binding site, bound by the TEA DNA binding domain (DBD) of transcription factors. The consensus site is CATTCC or CATTCT. [PMID:1489142, PMID:20118212, SO:ke]"
        },
        "SO:0002045": {
            "name": "pheromone_response_element",
            "def": "A PRE is a (yeast) TFBS with consensus site [TGAAAC(A/G)]. [PMID:1489142, SO:ke]"
        },
        "SO:0002046": {
            "name": "FRE",
            "def": "A FRE is an enhancer element necessary and sufficient to confer filamentation associated expression in S. cerevisiae. [PMID:1489142, SO:ke]"
        },
        "SO:0002047": {
            "name": "transcription_pause_site",
            "def": "Transcription pause sites are regions of a gene where RNA polymerase may pause during transcription. The functional role of pausing may be to facilitate factor recruitment, RNA folding, and synchronization with translation. Consensus transcription pause site have been observed in E. coli. [PMID:24789973, SO:ke]"
        },
        "SO:0002048": {
            "name": "disabled_reading_frame",
            "def": "A reading frame that could encode a full-length protein but which contains obvious mid-sequence disablements (frameshifts or premature stop codons). [SGD:se]"
        },
        "SO:0002049": {
            "name": "H3K27_acetylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acetylated. [SO:rs]"
        },
        "SO:0002050": {
            "name": "constitutive_promoter",
            "def": "A promoter that allows for continual transcription of gene. [SO:ke]"
        },
        "SO:0002051": {
            "name": "inducible_promoter",
            "def": "A promoter whereby activity is induced by the presence or absence of biotic or abiotic factors. [SO:ke]"
        },
        "SO:0002052": {
            "name": "dominant_negative_variant",
            "def": "A variant where the mutated gene product adversely affects the other (wild type) gene product. [SO:ke]"
        },
        "SO:0002053": {
            "name": "gain_of_function_variant",
            "def": "A sequence variant whereby new or enhanced function is conferred on the gene product. [SO:ke]"
        },
        "SO:0002054": {
            "name": "loss_of_function_variant",
            "def": "A sequence variant whereby the gene product has diminished or abolished function. [SO:ke]"
        },
        "SO:0002055": {
            "name": "null_mutation",
            "def": "A variant whereby the gene product is not functional or the gene product is not produced. [SO:ke]"
        },
        "SO:0002056": {
            "name": "intronic_splicing_silencer",
            "def": "An intronic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
        },
        "SO:0002057": {
            "name": "intronic_splicing_enhancer"
        },
        "SO:0002058": {
            "name": "exonic_splicing_silencer",
            "def": "An exonic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
        },
        "SO:0002059": {
            "name": "recombination_enhancer",
            "def": "A regulatory_region that promotes or induces the process of recombination. [PMID:8861911, SGD:se]"
        },
        "SO:0002060": {
            "name": "interchomosomal_translocation",
            "def": "A translocation where the regions involved are from different chromosomes. [NCBI:th]"
        },
        "SO:0002061": {
            "name": "intrachomosomal_translocation",
            "def": "A translocation where the regions involved are from the same chromosome. [NCBI:th]"
        },
        "SO:0002062": {
            "name": "complex_chromosomal_rearrangement",
            "def": "A contiguous cluster of translocations, usually the result of a single catastrophic event such as chromothripsis or chromoanasynthesis. [NCBI:th]"
        },
        "SO:0002063": {
            "name": "alu_insertion",
            "def": "An insertion of sequence from the Alu family of mobile elements. [NCBI:th]"
        },
        "SO:0002064": {
            "name": "LINE1_insertion",
            "def": "An insertion from the Line1 family of mobile elements. [NCBI:th]"
        },
        "SO:0002065": {
            "name": "SVA_insertion",
            "def": "An insertion of sequence from the SVA family of mobile elements. [NCBI:th]"
        },
        "SO:0005836": {
            "name": "regulatory_region",
            "def": "A region of sequence that is involved in the control of a biological process. [SO:ke]"
        },
        "SO:0005837": {
            "name": "U14_snoRNA_primary_transcript",
            "def": "The primary transcript of an evolutionarily conserved eukaryotic low molecular weight RNA capable of intermolecular hybridization with both homologous and heterologous 18S rRNA. [PMID:2251119]"
        },
        "SO:0005841": {
            "name": "methylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of 2'-O-ribose methylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
        },
        "SO:0005843": {
            "name": "rRNA_cleavage_RNA",
            "def": "An ncRNA that is part of a ribonucleoprotein that cleaves the primary pre-rRNA transcript in the process of producing mature rRNA molecules. [GOC:kgc]"
        },
        "SO:0005845": {
            "name": "exon_of_single_exon_gene",
            "def": "An exon that is the only exon in a gene. [RSC:cb]"
        },
        "SO:0005847": {
            "name": "cassette_array_member"
        },
        "SO:0005848": {
            "name": "gene_cassette_member"
        },
        "SO:0005849": {
            "name": "gene_subarray_member"
        },
        "SO:0005850": {
            "name": "primer_binding_site",
            "def": "Non-covalent primer binding site for initiation of replication, transcription, or reverse transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0005851": {
            "name": "gene_array",
            "def": "An array includes two or more genes, or two or more gene subarrays, contiguously arranged where the individual genes, or subarrays, are either identical in sequence, or essentially so. [SO:ma]"
        },
        "SO:0005852": {
            "name": "gene_subarray",
            "def": "A subarray is, by defintition, a member of a gene array (SO:0005851); the members of a subarray may differ substantially in sequence, but are closely related in function. [SO:ma]"
        },
        "SO:0005853": {
            "name": "gene_cassette",
            "def": "A gene that can be substituted for a related gene at a different site in the genome. [SGD:se]"
        },
        "SO:0005854": {
            "name": "gene_cassette_array",
            "def": "An array of non-functional genes whose members, when captured by recombination form functional genes. [SO:ma]"
        },
        "SO:0005855": {
            "name": "gene_group",
            "def": "A collection of related genes. [SO:ma]"
        },
        "SO:0005856": {
            "name": "selenocysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
        },
        "SO:0005857": {
            "name": "selenocysteinyl_tRNA",
            "def": "A tRNA sequence that has a selenocysteine anticodon, and a 3' selenocysteine binding region. [SO:ke]"
        },
        "SO:0005858": {
            "name": "syntenic_region",
            "def": "A region in which two or more pairs of homologous markers occur on the same chromosome in two or more species. [http://www.informatics.jax.org/silverbook/glossary.shtml]"
        },
        "SO:0100001": {
            "name": "biochemical_region_of_peptide",
            "def": "A region of a peptide that is involved in a biochemical function. [EBIBS:GAR]"
        },
        "SO:0100002": {
            "name": "molecular_contact_region",
            "def": "A region that is involved a contact with another molecule. [EBIBS:GAR]"
        },
        "SO:0100003": {
            "name": "intrinsically_unstructured_polypeptide_region",
            "def": "A region of polypeptide chain with high conformational flexibility. [EBIBS:GAR]"
        },
        "SO:0100004": {
            "name": "catmat_left_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100005": {
            "name": "catmat_left_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170.  The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100006": {
            "name": "catmat_right_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100007": {
            "name": "catmat_right_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170. The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100008": {
            "name": "alpha_beta_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: H-bond between CO of residue(i) and NH of residue(i+4), H-bond between CO of residue(i) and NH of residue(i+3),Phi angles of residues(i+1), (i+2) and (i+3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100009": {
            "name": "lipoprotein_signal_peptide",
            "def": "A peptide that acts as a signal for both membrane translocation and lipid attachment in prokaryotes. [EBIBS:GAR]"
        },
        "SO:0100010": {
            "name": "no_output",
            "def": "An experimental region wherean analysis has been run and not produced any annotation. [EBIBS:GAR]"
        },
        "SO:0100011": {
            "name": "cleaved_peptide_region",
            "def": "The cleaved_peptide_region is the region of a peptide sequence that is cleaved during maturation. [EBIBS:GAR]"
        },
        "SO:0100012": {
            "name": "peptide_coil",
            "def": "Irregular, unstructured regions of a protein's backbone, as distinct from the regular region (namely alpha helix and beta strand - characterised by specific patterns of main-chain hydrogen bonds). [EBIBS:GAR]"
        },
        "SO:0100013": {
            "name": "hydrophobic_region_of_peptide",
            "def": "Hydrophobic regions are regions with a low affinity for water. [EBIBS:GAR]"
        },
        "SO:0100014": {
            "name": "n_terminal_region",
            "def": "The amino-terminal positively-charged region of a signal peptide (approx 1-5 aa). [EBIBS:GAR]"
        },
        "SO:0100015": {
            "name": "c_terminal_region",
            "def": "The more polar, carboxy-terminal region of the signal peptide (approx 3-7 aa). [EBIBS:GAR]"
        },
        "SO:0100016": {
            "name": "central_hydrophobic_region_of_signal_peptide",
            "def": "The central, hydrophobic region of the signal peptide (approx 7-15 aa). [EBIBS:GAR]"
        },
        "SO:0100017": {
            "name": "polypeptide_conserved_motif",
            "def": "A conserved motif is a short (up to 20 amino acids) region of biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
        },
        "SO:0100018": {
            "name": "polypeptide_binding_motif",
            "def": "A polypeptide binding motif is a short (up to 20 amino acids) polypeptide region of biological interest that contains one or more amino acids experimentally shown to bind to a ligand. [EBIBS:GAR]"
        },
        "SO:0100019": {
            "name": "polypeptide_catalytic_motif",
            "def": "A polypeptide catalytic motif is a short (up to 20 amino acids) polypeptide region that contains one or more active site residues. [EBIBS:GAR]"
        },
        "SO:0100020": {
            "name": "polypeptide_DNA_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with DNA. [EBIBS:GAR, SO:ke]"
        },
        "SO:0100021": {
            "name": "polypeptide_conserved_region",
            "def": "A subsection of sequence with biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
        },
        "SO:1000002": {
            "name": "substitution",
            "def": "A sequence alteration where the length of the change in the variant is the same as that of the reference. [SO:ke]"
        },
        "SO:1000005": {
            "name": "complex_substitution",
            "def": "When no simple or well defined DNA mutation event describes the observed DNA change, the keyword \\complex\\ should be used. Usually there are multiple equally plausible explanations for the change. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000008": {
            "name": "point_mutation",
            "def": "A single nucleotide change which has occurred at the same position of a corresponding nucleotide in a reference sequence. [SO:immuno_workshop]"
        },
        "SO:1000009": {
            "name": "transition",
            "def": "Change of a pyrimidine nucleotide, C or T, into an other pyrimidine nucleotide, or change of a purine nucleotide, A or G, into an other purine nucleotide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000010": {
            "name": "pyrimidine_transition",
            "def": "A substitution of a pyrimidine, C or T, for another pyrimidine. [SO:ke]"
        },
        "SO:1000011": {
            "name": "C_to_T_transition",
            "def": "A transition of a cytidine to a thymine. [SO:ke]"
        },
        "SO:1000012": {
            "name": "C_to_T_transition_at_pCpG_site",
            "def": "The transition of cytidine to thymine occurring at a pCpG site as a consequence of the spontaneous deamination of 5'-methylcytidine. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000013": {
            "name": "T_to_C_transition"
        },
        "SO:1000014": {
            "name": "purine_transition",
            "def": "A substitution of a purine, A or G, for another purine. [SO:ke]"
        },
        "SO:1000015": {
            "name": "A_to_G_transition",
            "def": "A transition of an adenine to a guanine. [SO:ke]"
        },
        "SO:1000016": {
            "name": "G_to_A_transition",
            "def": "A transition of a guanine to an adenine. [SO:ke]"
        },
        "SO:1000017": {
            "name": "transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G, or vice versa. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000018": {
            "name": "pyrimidine_to_purine_transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G. [SO:ke]"
        },
        "SO:1000019": {
            "name": "C_to_A_transversion",
            "def": "A transversion from cytidine to adenine. [SO:ke]"
        },
        "SO:1000020": {
            "name": "C_to_G_transversion"
        },
        "SO:1000021": {
            "name": "T_to_A_transversion",
            "def": "A transversion from T to A. [SO:ke]"
        },
        "SO:1000022": {
            "name": "T_to_G_transversion",
            "def": "A transversion from T to G. [SO:ke]"
        },
        "SO:1000023": {
            "name": "purine_to_pyrimidine_transversion",
            "def": "Change of a purine nucleotide, A or G , into a pyrimidine nucleotide C or T. [SO:ke]"
        },
        "SO:1000024": {
            "name": "A_to_C_transversion",
            "def": "A transversion from adenine to cytidine. [SO:ke]"
        },
        "SO:1000025": {
            "name": "A_to_T_transversion",
            "def": "A transversion from adenine to thymine. [SO:ke]"
        },
        "SO:1000026": {
            "name": "G_to_C_transversion",
            "def": "A transversion from guanine to cytidine. [SO:ke]"
        },
        "SO:1000027": {
            "name": "G_to_T_transversion",
            "def": "A transversion from guanine to thymine. [SO:ke]"
        },
        "SO:1000028": {
            "name": "intrachromosomal_mutation",
            "def": "A chromosomal structure variation within a single chromosome. [SO:ke]"
        },
        "SO:1000029": {
            "name": "chromosomal_deletion",
            "def": "An incomplete chromosome. [SO:ke]"
        },
        "SO:1000030": {
            "name": "chromosomal_inversion",
            "def": "An interchromosomal mutation where a region of the chromosome is inverted with respect to wild type. [SO:ke]"
        },
        "SO:1000031": {
            "name": "interchromosomal_mutation",
            "def": "A chromosomal structure variation whereby more than one chromosome is involved. [SO:ke]"
        },
        "SO:1000032": {
            "name": "indel",
            "def": "A sequence alteration which included an insertion and a deletion, affecting 2 or more bases. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, http:http://www.hgvs.org/mutnomen/recs-DNA.html#indel]"
        },
        "SO:1000035": {
            "name": "duplication",
            "def": "An insertion which derives from, or is identical in sequence to, nucleotides present at a known location in the genome. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, NCBI:th]"
        },
        "SO:1000036": {
            "name": "inversion",
            "def": "A continuous nucleotide sequence is inverted in the same position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000037": {
            "name": "chromosomal_duplication",
            "def": "An extra chromosome. [SO:ke]"
        },
        "SO:1000038": {
            "name": "intrachromosomal_duplication",
            "def": "A duplication that occurred within a chromosome. [SO:ke]"
        },
        "SO:1000039": {
            "name": "direct_tandem_duplication",
            "def": "A tandem duplication where the individual regions are in the same orientation. [SO:ke]"
        },
        "SO:1000040": {
            "name": "inverted_tandem_duplication",
            "def": "A tandem duplication where the individual regions are not in the same orientation. [SO:ke]"
        },
        "SO:1000041": {
            "name": "intrachromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred within a chromosome. [SO:ke]"
        },
        "SO:1000042": {
            "name": "compound_chromosome",
            "def": "A chromosome structure variant where a monocentric element is caused by the fusion of two chromosome arms. [SO:ke]"
        },
        "SO:1000043": {
            "name": "Robertsonian_fusion",
            "def": "A non reciprocal translocation whereby the participating chromosomes break at their centromeres and the long arms fuse to form a single chromosome with a single centromere. [http://en.wikipedia.org/wiki/Robertsonian_translocation]"
        },
        "SO:1000044": {
            "name": "chromosomal_translocation",
            "def": "An interchromosomal mutation. Rearrangements that alter the pairing of telomeres are classified as translocations. [FB:reference_manual]"
        },
        "SO:1000045": {
            "name": "ring_chromosome",
            "def": "A ring chromosome is a chromosome whose arms have fused together to form a ring, often with the loss of the ends of the chromosome. [http://en.wikipedia.org/wiki/Ring_chromosome]"
        },
        "SO:1000046": {
            "name": "pericentric_inversion",
            "def": "A chromosomal inversion that includes the centromere. [FB:reference_manual]"
        },
        "SO:1000047": {
            "name": "paracentric_inversion",
            "def": "A chromosomal inversion that does not include the centromere. [FB:reference_manual]"
        },
        "SO:1000048": {
            "name": "reciprocal_chromosomal_translocation",
            "def": "A chromosomal translocation with two breaks; two chromosome segments have simply been exchanged. [FB:reference_manual]"
        },
        "SO:1000049": {
            "name": "sequence_variation_affecting_transcript",
            "def": "Any change in mature, spliced and processed, RNA that results from a change in the corresponding DNA sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000050": {
            "name": "sequence_variant_causing_no_change_in_transcript",
            "def": "No effect on the state of the RNA. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000054": {
            "name": "sequence_variation_affecting_coding_sequence",
            "def": "Any of the amino acid coding triplets of a gene are affected by the DNA mutation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000055": {
            "name": "sequence_variant_causing_initiator_codon_change_in_transcript",
            "def": "The DNA mutation changes, usually destroys, the first coding triplet of a gene. Usually prevents translation although another initiator codon may be used. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000056": {
            "name": "sequence_variant_causing_amino_acid_coding_codon_change_in_transcript",
            "def": "The DNA mutation affects the amino acid coding sequence of a gene; this region includes both the initiator and terminator codons. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000057": {
            "name": "sequence_variant_causing_synonymous_codon_change_in_transcript",
            "def": "The changed codon has the same translation product as the original codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000058": {
            "name": "sequence_variant_causing_non_synonymous_codon_change_in_transcript",
            "def": "A DNA point mutation that causes a substitution of an amino acid by an other. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000059": {
            "name": "sequence_variant_causing_missense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon leads to a new codon coding for a new amino acid. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000060": {
            "name": "sequence_variant_causing_conservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change does not change the gross properties (size, charge, hydrophobicity) of the amino acid at that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000061": {
            "name": "sequence_variant_causing_nonconservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change changes the gross properties (size, charge, hydrophobicity) of the amino acid in that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000062": {
            "name": "sequence_variant_causing_nonsense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet creates a terminator codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000063": {
            "name": "sequence_variant_causing_terminator_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet changes the stop codon, causing an elongated transcript sequence. [SO:ke]"
        },
        "SO:1000064": {
            "name": "sequence_variation_affecting_reading_frame",
            "def": "An umbrella term for terms describing an effect of a sequence variation on the frame of translation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000065": {
            "name": "frameshift_sequence_variation",
            "def": "A mutation causing a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
        },
        "SO:1000066": {
            "name": "sequence_variant_causing_plus_1_frameshift_mutation",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of a nucleotide. [SO:ke]"
        },
        "SO:1000067": {
            "name": "sequence_variant_causing_minus_1_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of a nucleotide. [SO:ke]"
        },
        "SO:1000068": {
            "name": "sequence_variant_causing_plus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of two nucleotides. [SO:ke]"
        },
        "SO:1000069": {
            "name": "sequence_variant_causing_minus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of two nucleotides. [SO:ke]"
        },
        "SO:1000070": {
            "name": "sequence_variant_affecting_transcript_processing",
            "def": "Sequence variant affects the way in which the primary transcriptional product is processed to form the mature transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000071": {
            "name": "sequence_variant_affecting_splicing",
            "def": "A sequence_variant_effect where the way in which the primary transcriptional product is processed to form the mature transcript, specifically by the removal (splicing) of intron sequences is changed. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000072": {
            "name": "sequence_variant_affecting_splice_donor",
            "def": "A sequence_variant_effect that changes the splice donor sequence. [SO:ke]"
        },
        "SO:1000073": {
            "name": "sequence_variant_affecting_splice_acceptor",
            "def": "A sequence_variant_effect that changes the splice acceptor sequence. [SO:ke]"
        },
        "SO:1000074": {
            "name": "sequence_variant_causing_cryptic_splice_activation",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000075": {
            "name": "sequence_variant_affecting_editing",
            "def": "Sequence variant affects the editing of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000076": {
            "name": "sequence_variant_affecting_transcription",
            "def": "Mutation affects the process of transcription, its initiation, progression or termination. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000078": {
            "name": "sequence_variant_decreasing_rate_of_transcription",
            "def": "A sequence variation that decreases the rate a which transcription of the sequence occurs. [SO:ke]"
        },
        "SO:1000079": {
            "name": "sequence_variation_affecting_transcript_sequence"
        },
        "SO:1000080": {
            "name": "sequence_variant_increasing_rate_of_transcription"
        },
        "SO:1000081": {
            "name": "sequence_variant_affecting_rate_of_transcription",
            "def": "A mutation that alters the rate a which transcription of the sequence occurs. [SO:ke]"
        },
        "SO:1000082": {
            "name": "sequence variant_affecting_transcript_stability",
            "def": "Sequence variant affects the stability of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000083": {
            "name": "sequence_variant_increasing_transcript_stability",
            "def": "Sequence variant increases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000084": {
            "name": "sequence_variant_decreasing_transcript_stability",
            "def": "Sequence variant decreases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000085": {
            "name": "sequence_variation_affecting_level_of_transcript",
            "def": "A sequence variation that causes a change in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000086": {
            "name": "sequence_variation_decreasing_level_of_transcript",
            "def": "A sequence variation that causes a decrease in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000087": {
            "name": "sequence_variation_increasing_level_of_transcript",
            "def": "A sequence_variation that causes an increase in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000088": {
            "name": "sequence_variant_affecting_translational_product",
            "def": "A sequence variant causing a change in primary translation product of a transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000089": {
            "name": "sequence_variant_causing_no_change_of_translational_product",
            "def": "The sequence variant at RNA level does not lead to any change in polypeptide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000092": {
            "name": "sequence_variant_causing_complex_change_of_translational_product",
            "def": "Any sequence variant effect that is known at nucleotide level but cannot be explained by using other key terms. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000093": {
            "name": "sequence_variant_causing_amino_acid_substitution",
            "def": "The replacement of a single amino acid by another. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000094": {
            "name": "sequence_variant_causing_conservative_amino_acid_substitution"
        },
        "SO:1000095": {
            "name": "sequence_variant_causing_nonconservative_amino_acid_substitution"
        },
        "SO:1000096": {
            "name": "sequence_variant_causing_amino_acid_insertion",
            "def": "The insertion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000097": {
            "name": "sequence_variant_causing_amino_acid_deletion",
            "def": "The deletion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000098": {
            "name": "sequence_variant_causing_polypeptide_truncation",
            "def": "The translational product is truncated at its C-terminus, usually a result of a nonsense codon change in transcript (SO:1000062). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000099": {
            "name": "sequence_variant_causing_polypeptide_elongation",
            "def": "The extension of the translational product at either (or both) the N-terminus and/or the C-terminus. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000100": {
            "name": "mutation_causing_polypeptide_N_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000101": {
            "name": "mutation_causing_polypeptide_C_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000102": {
            "name": "sequence_variant_affecting_level_of_translational_product"
        },
        "SO:1000103": {
            "name": "sequence_variant_decreasing_level_of_translation_product"
        },
        "SO:1000104": {
            "name": "sequence_variant_increasing_level_of_translation_product"
        },
        "SO:1000105": {
            "name": "sequence_variant_affecting_polypeptide_amino_acid_sequence"
        },
        "SO:1000106": {
            "name": "mutation_causing_inframe_polypeptide_N_terminal_elongation"
        },
        "SO:1000107": {
            "name": "mutation_causing_out_of_frame_polypeptide_N_terminal_elongation"
        },
        "SO:1000108": {
            "name": "mutaton_causing_inframe_polypeptide_C_terminal_elongation"
        },
        "SO:1000109": {
            "name": "mutation_causing_out_of_frame_polypeptide_C_terminal_elongation"
        },
        "SO:1000110": {
            "name": "frame_restoring_sequence_variant",
            "def": "A mutation that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
        },
        "SO:1000111": {
            "name": "sequence_variant_affecting_3D_structure_of_polypeptide",
            "def": "A mutation that changes the amino acid sequence of the peptide in such a way that it changes the 3D structure of the molecule. [SO:ke]"
        },
        "SO:1000112": {
            "name": "sequence_variant_causing_no_3D_structural_change"
        },
        "SO:1000115": {
            "name": "sequence_variant_causing_complex_3D_structural_change"
        },
        "SO:1000116": {
            "name": "sequence_variant_causing_conformational_change"
        },
        "SO:1000117": {
            "name": "sequence_variant_affecting_polypeptide_function"
        },
        "SO:1000118": {
            "name": "sequence_variant_causing_loss_of_function_of_polypeptide"
        },
        "SO:1000119": {
            "name": "sequence_variant_causing_inactive_ligand_binding_site"
        },
        "SO:1000120": {
            "name": "sequence_variant_causing_inactive_catalytic_site"
        },
        "SO:1000121": {
            "name": "sequence_variant_causing_polypeptide_localization_change"
        },
        "SO:1000122": {
            "name": "sequence_variant_causing_polypeptide_post_translational_processing_change"
        },
        "SO:1000123": {
            "name": "polypeptide_post_translational_processing_affected"
        },
        "SO:1000124": {
            "name": "sequence_variant_causing_partial_loss_of_function_of_polypeptide"
        },
        "SO:1000125": {
            "name": "sequence_variant_causing_gain_of_function_of_polypeptide"
        },
        "SO:1000126": {
            "name": "sequence_variant_affecting_transcript_secondary_structure",
            "def": "A sequence variant that affects the secondary structure (folding) of the RNA transcript molecule. [SO:ke]"
        },
        "SO:1000127": {
            "name": "sequence_variant_causing_compensatory_transcript_secondary_structure_mutation"
        },
        "SO:1000132": {
            "name": "sequence_variant_effect",
            "def": "The effect of a change in nucleotide sequence. [SO:ke]"
        },
        "SO:1000134": {
            "name": "sequence_variant_causing_polypeptide_fusion"
        },
        "SO:1000136": {
            "name": "autosynaptic_chromosome",
            "def": "An autosynaptic chromosome is the aneuploid product of recombination between a pericentric inversion and a cytologically wild-type chromosome. [PMID:6804304]"
        },
        "SO:1000138": {
            "name": "homo_compound_chromosome",
            "def": "A compound chromosome whereby two copies of the same chromosomal arm attached to a common centromere. The chromosome is diploid for the arm involved. [SO:ke]"
        },
        "SO:1000140": {
            "name": "hetero_compound_chromosome",
            "def": "A compound chromosome whereby two arms from different chromosomes are connected through the centromere of one of them. [FB:reference_manual, SO:ke]"
        },
        "SO:1000141": {
            "name": "chromosome_fission",
            "def": "A chromosome that occurred by the division of a larger chromosome. [SO:ke]"
        },
        "SO:1000142": {
            "name": "dexstrosynaptic_chromosome",
            "def": "An autosynaptic chromosome carrying the two right (D = dextro) telomeres. [FB:manual]"
        },
        "SO:1000143": {
            "name": "laevosynaptic_chromosome",
            "def": "LS is an autosynaptic chromosome carrying the two left (L = levo) telomeres. [FB:manual]"
        },
        "SO:1000144": {
            "name": "free_duplication",
            "def": "A chromosome structure variation whereby the duplicated sequences are carried as a free centric element. [FB:reference_manual]"
        },
        "SO:1000145": {
            "name": "free_ring_duplication",
            "def": "A ring chromosome which is a copy of another chromosome. [SO:ke]"
        },
        "SO:1000147": {
            "name": "deficient_translocation",
            "def": "A chromosomal deletion whereby a translocation occurs in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
        },
        "SO:1000148": {
            "name": "inversion_cum_translocation",
            "def": "A chromosomal translocation whereby the first two breaks are in the same chromosome, and the region between them is rejoined in inverted order to the other side of the first break, such that both sides of break one are present on the same chromosome. The remaining free ends are joined as a translocation with those resulting from the third break. [FB:reference_manual]"
        },
        "SO:1000149": {
            "name": "bipartite_duplication",
            "def": "An interchromosomal mutation whereby the (large) region between the first two breaks listed is lost, and the two flanking segments (one of them centric) are joined as a translocation to the free ends resulting from the third break. [FB:reference_manual]"
        },
        "SO:1000150": {
            "name": "cyclic_translocation",
            "def": "A chromosomal translocation whereby three breaks occurred in three different chromosomes. The centric segment resulting from the first break listed is joined to the acentric segment resulting from the second, rather than the third. [FB:reference_manual]"
        },
        "SO:1000151": {
            "name": "bipartite_inversion",
            "def": "A chromosomal inversion caused by three breaks in the same chromosome; both central segments are inverted in place (i.e., they are not transposed). [FB:reference_manual]"
        },
        "SO:1000152": {
            "name": "uninverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000153": {
            "name": "inverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
        },
        "SO:1000154": {
            "name": "insertional_duplication",
            "def": "A chromosome duplication involving the insertion of a duplicated region (as opposed to a free duplication). [SO:ke]"
        },
        "SO:1000155": {
            "name": "interchromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred between chromosomes. [SO:ke]"
        },
        "SO:1000156": {
            "name": "inverted_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segment. [FB:reference_manual]"
        },
        "SO:1000157": {
            "name": "uninverted_interchromosomal_transposition",
            "def": "An interchromosomal transition where the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000158": {
            "name": "inverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
        },
        "SO:1000159": {
            "name": "uninverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000160": {
            "name": "unoriented_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000161": {
            "name": "unoriented_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000162": {
            "name": "unoriented_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000170": {
            "name": "uncharacterized_chromosomal_mutation"
        },
        "SO:1000171": {
            "name": "deficient_inversion",
            "def": "A chromosomal deletion whereby three breaks occur in the same chromosome; one central region is lost, and the other is inverted. [FB:reference_manual, SO:ke]"
        },
        "SO:1000173": {
            "name": "tandem_duplication",
            "def": "A duplication consisting of 2 identical adjacent regions. [SO:ke]"
        },
        "SO:1000175": {
            "name": "partially_characterized_chromosomal_mutation"
        },
        "SO:1000180": {
            "name": "sequence_variant_affecting_gene_structure",
            "def": "A sequence_variant_effect that changes the gene structure. [SO:ke]"
        },
        "SO:1000181": {
            "name": "sequence_variant_causing_gene_fusion",
            "def": "A sequence_variant_effect that changes the gene structure by causing a fusion to another gene. [SO:ke]"
        },
        "SO:1000182": {
            "name": "chromosome_number_variation",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
        },
        "SO:1000183": {
            "name": "chromosome_structure_variation"
        },
        "SO:1000184": {
            "name": "sequence_variant_causes_exon_loss",
            "def": "A sequence variant affecting splicing and causes an exon loss. [SO:ke]"
        },
        "SO:1000185": {
            "name": "sequence_variant_causes_intron_gain",
            "def": "A sequence variant effect, causing an intron to be gained by the processed transcript; usually a result of a donor acceptor mutation (SO:1000072). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000186": {
            "name": "sequence_variant_causing_cryptic_splice_donor_activation"
        },
        "SO:1001186": {
            "name": "sequence_variant_causing_cryptic_splice_acceptor_activation"
        },
        "SO:1001187": {
            "name": "alternatively_spliced_transcript",
            "def": "A transcript that is alternatively spliced. [SO:xp]"
        },
        "SO:1001188": {
            "name": "encodes_1_polypeptide",
            "def": "A gene that is alternately spliced, but encodes only one polypeptide. [SO:ke]"
        },
        "SO:1001189": {
            "name": "encodes_greater_than_1_polypeptide",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide. [SO:ke]"
        },
        "SO:1001190": {
            "name": "encodes_different_polypeptides_different_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different stop codons. [SO:ke]"
        },
        "SO:1001191": {
            "name": "encodes_overlapping_peptides_different_start",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start codons. [SO:ke]"
        },
        "SO:1001192": {
            "name": "encodes_disjoint_polypeptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that do not have overlapping peptide sequences. [SO:ke]"
        },
        "SO:1001193": {
            "name": "encodes_overlapping_polypeptides_different_start_and_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start and stop codons. [SO:ke]"
        },
        "SO:1001194": {
            "name": "alternatively_spliced_gene_encoding_greater_than_1_polypeptide_coding_regions_overlapping"
        },
        "SO:1001195": {
            "name": "encodes_overlapping_peptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences. [SO:ke]"
        },
        "SO:1001196": {
            "name": "cryptogene",
            "def": "A maxicircle gene so extensively edited that it cannot be matched to its edited mRNA sequence. [SO:ma]"
        },
        "SO:1001197": {
            "name": "dicistronic_primary_transcript",
            "def": "A primary transcript that has the quality dicistronic. [SO:xp]"
        },
        "SO:1001217": {
            "name": "member_of_regulon"
        },
        "SO:1001244": {
            "name": "alternatively_spliced_transcript_encoding_greater_than_1_polypeptide_different_start_codon_different_stop_codon_coding_regions_non_overlapping"
        },
        "SO:1001246": {
            "name": "CDS_independently_known",
            "def": "A CDS with the evidence status of being independently known. [SO:xp]"
        },
        "SO:1001247": {
            "name": "orphan_CDS",
            "def": "A CDS whose predicted amino acid sequence is unsupported by any experimental evidence or by any match with any other known sequence. [SO:ma]"
        },
        "SO:1001249": {
            "name": "CDS_supported_by_domain_match_data",
            "def": "A CDS that is supported by domain similarity. [SO:xp]"
        },
        "SO:1001251": {
            "name": "CDS_supported_by_sequence_similarity_data",
            "def": "A CDS that is supported by sequence similarity data. [SO:xp]"
        },
        "SO:1001254": {
            "name": "CDS_predicted",
            "def": "A CDS that is predicted. [SO:ke]"
        },
        "SO:1001255": {
            "name": "status_of_coding_sequence"
        },
        "SO:1001259": {
            "name": "CDS_supported_by_EST_or_cDNA_data",
            "def": "A CDS that is supported by similarity to EST or cDNA data. [SO:xp]"
        },
        "SO:1001260": {
            "name": "internal_Shine_Dalgarno_sequence",
            "def": "A Shine-Dalgarno sequence that stimulates recoding through interactions with the anti-Shine-Dalgarno in the RNA of small ribosomal subunits of translating ribosomes. The signal is only operative in Bacteria. [PMID:12519954, SO:ke]"
        },
        "SO:1001261": {
            "name": "recoded_mRNA",
            "def": "The sequence of a mature mRNA transcript, modified before translation or during translation, usually by special cis-acting signals. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
        },
        "SO:1001262": {
            "name": "minus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of -1. [SO:ke]"
        },
        "SO:1001263": {
            "name": "plus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of +1. [SO:ke]"
        },
        "SO:1001264": {
            "name": "mRNA_recoded_by_translational_bypass",
            "def": "A recoded_mRNA where translation was suspended at a particular codon and resumed at a particular non-overlapping downstream codon. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
        },
        "SO:1001265": {
            "name": "mRNA_recoded_by_codon_redefinition",
            "def": "A recoded_mRNA that was modified by an alteration of codon meaning. [SO:ma]"
        },
        "SO:1001266": {
            "name": "stop_codon_redefinition_as_selenocysteine"
        },
        "SO:1001267": {
            "name": "stop_codon_readthrough"
        },
        "SO:1001268": {
            "name": "recoding_stimulatory_region",
            "def": "A site in an mRNA sequence that stimulates the recoding of a region in the same mRNA. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12519954&dopt=Abstract]"
        },
        "SO:1001269": {
            "name": "four_bp_start_codon",
            "def": "A non-canonical start codon with 4 base pairs. [SO:ke]"
        },
        "SO:1001270": {
            "name": "stop_codon_redefinition_as_pyrrolysine"
        },
        "SO:1001271": {
            "name": "archaeal_intron",
            "def": "An intron characteristic of Archaeal tRNA and rRNA genes, where intron transcript generates a bulge-helix-bulge motif that is recognised by a splicing endoribonuclease. [PMID:9301331, SO:ma]"
        },
        "SO:1001272": {
            "name": "tRNA_intron",
            "def": "An intron found in tRNA that is spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
        },
        "SO:1001273": {
            "name": "CTG_start_codon",
            "def": "A non-canonical start codon of sequence CTG. [SO:ke]"
        },
        "SO:1001274": {
            "name": "SECIS_element",
            "def": "The incorporation of selenocysteine into a protein sequence is directed by an in-frame UGA codon (usually a stop codon) within the coding region of the mRNA. Selenoprotein mRNAs contain a conserved secondary structure in the 3' UTR that is required for the distinction of UGA stop from UGA selenocysteine. The selenocysteine insertion sequence (SECIS) is around 60 nt in length and adopts a hairpin structure which is sufficiently well-defined and conserved to act as a computational screen for selenoprotein genes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00031]"
        },
        "SO:1001275": {
            "name": "retron",
            "def": "Sequence coding for a short, single-stranded, DNA sequence via a retrotransposed RNA intermediate; characteristic of some microbial genomes. [SO:ma]"
        },
        "SO:1001277": {
            "name": "three_prime_recoding_site",
            "def": "The recoding stimulatory signal located downstream of the recoding site. [SO:ke]"
        },
        "SO:1001279": {
            "name": "three_prime_stem_loop_structure",
            "def": "A recoding stimulatory region, the stem-loop secondary structural element is downstream of the redefined region. [PMID:12519954, SO:ke]"
        },
        "SO:1001280": {
            "name": "five_prime_recoding_site",
            "def": "The recoding stimulatory signal located upstream of the recoding site. [SO:ke]"
        },
        "SO:1001281": {
            "name": "flanking_three_prime_quadruplet_recoding_signal",
            "def": "Four base pair sequence immediately downstream of the redefined region. The redefined region is a frameshift site. The quadruplet is 2 overlapping codons. [PMID:12519954, SO:ke]"
        },
        "SO:1001282": {
            "name": "UAG_stop_codon_signal",
            "def": "A stop codon signal for a UAG stop codon redefinition. [SO:ke]"
        },
        "SO:1001283": {
            "name": "UAA_stop_codon_signal",
            "def": "A stop codon signal for a UAA stop codon redefinition. [SO:ke]"
        },
        "SO:1001284": {
            "name": "regulon",
            "def": "A group of genes, whether linked as a cluster or not, that respond to a common regulatory signal. [ISBN:0198506732]"
        },
        "SO:1001285": {
            "name": "UGA_stop_codon_signal",
            "def": "A stop codon signal for a UGA stop codon redefinition. [SO:ke]"
        },
        "SO:1001286": {
            "name": "three_prime_repeat_recoding_signal",
            "def": "A recoding stimulatory signal, downstream sequence important for recoding that contains repetitive elements. [PMID:12519954, SO:ke]"
        },
        "SO:1001287": {
            "name": "distant_three_prime_recoding_signal",
            "def": "A recoding signal that is found many hundreds of nucleotides 3' of a redefined stop codon. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8709208&dopt=Abstract]"
        },
        "SO:1001288": {
            "name": "stop_codon_signal",
            "def": "A recoding stimulatory signal that is a stop codon and has effect on efficiency of recoding. [PMID:12519954, SO:ke]"
        },
        "SO:2000061": {
            "name": "databank_entry",
            "def": "The sequence referred to by an entry in a databank such as GenBank or SwissProt. [SO:ke]"
        },
        "SO:3000000": {
            "name": "gene_segment",
            "def": "A gene component region which acts as a recombinational unit of a gene whose functional form is generated through somatic recombination. [GOC:add]"
        }
    };
})(sequenceOntology = exports.sequenceOntology || (exports.sequenceOntology = {}));


/***/ }),

/***/ "./node_modules/buffer-from/index.js":
/*!*******************************************!*\
  !*** ./node_modules/buffer-from/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ "./node_modules/call-signature/index.js":
/*!**********************************************!*\
  !*** ./node_modules/call-signature/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports.parse = parse;
module.exports.generate = generate;

// TODO(jamestalmage): Allow full range of identifier characters instead of just ASCII
//
// This will likely require a build step
//
// SPEC: http://www.ecma-international.org/ecma-262/5.1/#sec-7.6
//
// TOOLING:
//    https://github.com/mathiasbynens/regenerate
//    https://www.npmjs.com/package/regjsgen

var regex = /^\s*(?:([A-Za-z$_][A-Za-z0-9$_]*)\s*\.)?\s*([A-Za-z$_][A-Za-z0-9$_]*)\s*\(\s*((?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*]))?((?:\s*,\s*(?:(?:[A-Za-z$_][A-Za-z0-9$_]*)|(?:\[\s*[A-Za-z$_][A-Za-z0-9$_]*\s*])))+)?\s*\)\s*$/;

function parse(str) {
	var match = regex.exec(str);
	if (!match) {
		return null;
	}

	var callee;
	if (match[1]) {
		callee = {
			type: 'MemberExpression',
			object: match[1],
			member: match[2]
		};
	} else {
		callee = {
			type: 'Identifier',
			name: match[2]
		};
	}

	var args = match[4] || '';
	args = args.split(',');
	if (match[3]) {
		args[0] = match[3];
	}
	var trimmed = [];
	args.forEach(function (str) {
		var optional = false;
		str = str.replace(/\s+/g, '');
		if (!str.length) {
			return;
		}
		if (str.charAt(0) === '[' && str.charAt(str.length - 1) === ']') {
			optional = true;
			str = str.substring(1, str.length - 1);
		}
		trimmed.push({
			name: str,
			optional: optional
		});
	});

	return {
		callee: callee,
		args: trimmed
	};
}

function generate(parsed) {
	var callee;
	if (parsed.callee.type === 'MemberExpression') {
		callee = [
			parsed.callee.object,
			'.',
			parsed.callee.member
		];
	} else {
		callee = [parsed.callee.name];
	}
	return callee.concat([
		'(',
		parsed.args.map(function (arg) {
			return arg.optional ? '[' + arg.name + ']' : arg.name;
		}).join(', '),
		')'
	]).join('');
}


/***/ }),

/***/ "./node_modules/chalk/source/index.js":
/*!********************************************!*\
  !*** ./node_modules/chalk/source/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/ansi-styles/index.js");
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(/*! supports-color */ "./node_modules/supports-color/index.js");
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(/*! ./util */ "./node_modules/chalk/source/util.js");

const {isArray} = Array;

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(/*! ./templates */ "./node_modules/chalk/source/templates.js");
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;


/***/ }),

/***/ "./node_modules/chalk/source/templates.js":
/*!************************************************!*\
  !*** ./node_modules/chalk/source/templates.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/chalk/source/util.js":
/*!*******************************************!*\
  !*** ./node_modules/chalk/source/util.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");
const route = __webpack_require__(/*! ./route */ "./node_modules/color-convert/route.js");

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/concat-stream/index.js":
/*!*********************************************!*\
  !*** ./node_modules/concat-stream/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Writable = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable.js").Writable
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js")
var bufferFrom = __webpack_require__(/*! buffer-from */ "./node_modules/buffer-from/index.js")

if (typeof Uint8Array === 'undefined') {
  var U8 = __webpack_require__(/*! typedarray */ "./node_modules/typedarray/index.js").Uint8Array
} else {
  var U8 = Uint8Array
}

function ConcatStream(opts, cb) {
  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }
  if (!opts) opts = {}

  var encoding = opts.encoding
  var shouldInferEncoding = false

  if (!encoding) {
    shouldInferEncoding = true
  } else {
    encoding =  String(encoding).toLowerCase()
    if (encoding === 'u8' || encoding === 'uint8') {
      encoding = 'uint8array'
    }
  }

  Writable.call(this, { objectMode: true })

  this.encoding = encoding
  this.shouldInferEncoding = shouldInferEncoding

  if (cb) this.on('finish', function () { cb(this.getBody()) })
  this.body = []
}

module.exports = ConcatStream
inherits(ConcatStream, Writable)

ConcatStream.prototype._write = function(chunk, enc, next) {
  this.body.push(chunk)
  next()
}

ConcatStream.prototype.inferEncoding = function (buff) {
  var firstBuffer = buff === undefined ? this.body[0] : buff;
  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
  if (Array.isArray(firstBuffer)) return 'array'
  if (typeof firstBuffer === 'string') return 'string'
  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
  return 'buffer'
}

ConcatStream.prototype.getBody = function () {
  if (!this.encoding && this.body.length === 0) return []
  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
  if (this.encoding === 'array') return arrayConcat(this.body)
  if (this.encoding === 'string') return stringConcat(this.body)
  if (this.encoding === 'buffer') return bufferConcat(this.body)
  if (this.encoding === 'uint8array') return u8Concat(this.body)
  return this.body
}

var isArray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}

function isArrayish (arr) {
  return /Array\]$/.test(Object.prototype.toString.call(arr))
}

function isBufferish (p) {
  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')
}

function stringConcat (parts) {
  var strings = []
  var needsToString = false
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (typeof p === 'string') {
      strings.push(p)
    } else if (Buffer.isBuffer(p)) {
      strings.push(p)
    } else if (isBufferish(p)) {
      strings.push(bufferFrom(p))
    } else {
      strings.push(bufferFrom(String(p)))
    }
  }
  if (Buffer.isBuffer(parts[0])) {
    strings = Buffer.concat(strings)
    strings = strings.toString('utf8')
  } else {
    strings = strings.join('')
  }
  return strings
}

function bufferConcat (parts) {
  var bufs = []
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i]
    if (Buffer.isBuffer(p)) {
      bufs.push(p)
    } else if (isBufferish(p)) {
      bufs.push(bufferFrom(p))
    } else {
      bufs.push(bufferFrom(String(p)))
    }
  }
  return Buffer.concat(bufs)
}

function arrayConcat (parts) {
  var res = []
  for (var i = 0; i < parts.length; i++) {
    res.push.apply(res, parts[i])
  }
  return res
}

function u8Concat (parts) {
  var len = 0
  for (var i = 0; i < parts.length; i++) {
    if (typeof parts[i] === 'string') {
      parts[i] = bufferFrom(parts[i])
    }
    len += parts[i].length
  }
  var u8 = new U8(len)
  for (var i = 0, offset = 0; i < parts.length; i++) {
    var part = parts[i]
    for (var j = 0; j < part.length; j++) {
      u8[offset++] = part[j]
    }
  }
  return u8
}


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.filter */ "./node_modules/core-js/library/modules/es6.array.filter.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.filter;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.for-each */ "./node_modules/core-js/library/modules/es6.array.for-each.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.forEach;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/index-of.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.index-of */ "./node_modules/core-js/library/modules/es6.array.index-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.indexOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.is-array */ "./node_modules/core-js/library/modules/es6.array.is-array.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.isArray;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.map */ "./node_modules/core-js/library/modules/es6.array.map.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.map;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/reduce-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/reduce-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.reduce-right */ "./node_modules/core-js/library/modules/es6.array.reduce-right.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.reduceRight;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.reduce */ "./node_modules/core-js/library/modules/es6.array.reduce.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.reduce;


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/some.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/some.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.array.some */ "./node_modules/core-js/library/modules/es6.array.some.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.some;


/***/ }),

/***/ "./node_modules/core-js/library/fn/map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/library/fn/map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.map */ "./node_modules/core-js/library/modules/es6.map.js");
__webpack_require__(/*! ../modules/es7.map.to-json */ "./node_modules/core-js/library/modules/es7.map.to-json.js");
__webpack_require__(/*! ../modules/es7.map.of */ "./node_modules/core-js/library/modules/es7.map.of.js");
__webpack_require__(/*! ../modules/es7.map.from */ "./node_modules/core-js/library/modules/es7.map.from.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Map;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/create.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.create */ "./node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.keys */ "./node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.keys;


/***/ }),

/***/ "./node_modules/core-js/library/fn/string/ends-with.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/fn/string/ends-with.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.ends-with */ "./node_modules/core-js/library/modules/es6.string.ends-with.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").String.endsWith;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-instance.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-instance.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-from-iterable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-from-iterable.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-methods.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-methods.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-reduce.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-reduce.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-constructor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-species-constructor.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-species-create.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-species-create.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-strong.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection-strong.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/library/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").fastKey;
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/library/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection-to-json.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection-to-json.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/library/modules/_array-from-iterable.js");
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_collection.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_collection.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails-is-regexp.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails-is-regexp.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_for-of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_for-of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-regexp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-sap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine-all.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-from.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-collection-from.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-collection-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-collection-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-species.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-species.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_strict-method.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_strict-method.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-context.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-context.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/library/modules/_is-regexp.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_validate-collection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_validate-collection.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.filter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.filter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.for-each.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.for-each.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(0);
var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.index-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.index-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.is-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.is-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S, 'Array', { isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.map.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.map.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.reduce-right.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.reduce-right.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/library/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.reduce.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.reduce.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/library/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.some.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.some.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/library/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/library/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.map.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.map.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/library/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/library/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/library/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.create.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.create.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.keys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.keys.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.ends-with.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.ends-with.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/library/modules/_string-context.js");
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/library/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.from.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/library/modules/_set-collection-from.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/library/modules/_set-collection-of.js")('Map');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.map.to-json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.map.to-json.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/library/modules/_collection-to-json.js")('Map') });


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/diff-match-patch/index.js":
/*!************************************************!*\
  !*** ./node_modules/diff-match-patch/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
var diff_match_patch = function() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
};


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/**
 * Class representing one diff tuple.
 * ~Attempts to look like a two-element array (which is what this used to be).~
 * Constructor returns an actual two-element array, to allow destructing @JackuB
 * See https://github.com/JackuB/diff-match-patch/issues/14 for details
 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
 * @param {string} text Text to be deleted, inserted, or retained.
 * @constructor
 */
diff_match_patch.Diff = function(op, text) {
  return [op, text];
};

/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number=} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
             new diff_match_patch.Diff(DIFF_INSERT,
                 longtext.substring(i + shorttext.length))];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
            new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
                          diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var subDiff =
              this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = subDiff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, subDiff[j]);
          }
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          // Bail out at 65535 because
          // String.fromCharCode(65536) == String.fromCharCode(0)
          line = text.substring(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  // Allocate 2/3rds of the space for text1, the rest for text2.
  var maxLines = 40000;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text = [];
    for (var j = 0; j < chars.length; j++) {
      text[j] = lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastEquality && (lastEquality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastEquality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastEquality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastEquality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
                    text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] =
              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  if (patch.start2 === null) {
    throw Error('patch not initialized');
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // https://github.com/google/diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] =
          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indices are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;

/***/ }),

/***/ "./node_modules/eastasianwidth/eastasianwidth.js":
/*!*******************************************************!*\
  !*** ./node_modules/eastasianwidth/eastasianwidth.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eaw = {};

if (false) {} else {
  module.exports = eaw;
}

eaw.eastAsianWidth = function(character) {
  var x = character.charCodeAt(0);
  var y = (character.length == 2) ? character.charCodeAt(1) : 0;
  var codePoint = x;
  if ((0xD800 <= x && x <= 0xDBFF) && (0xDC00 <= y && y <= 0xDFFF)) {
    x &= 0x3FF;
    y &= 0x3FF;
    codePoint = (x << 10) | y;
    codePoint += 0x10000;
  }

  if ((0x3000 == codePoint) ||
      (0xFF01 <= codePoint && codePoint <= 0xFF60) ||
      (0xFFE0 <= codePoint && codePoint <= 0xFFE6)) {
    return 'F';
  }
  if ((0x20A9 == codePoint) ||
      (0xFF61 <= codePoint && codePoint <= 0xFFBE) ||
      (0xFFC2 <= codePoint && codePoint <= 0xFFC7) ||
      (0xFFCA <= codePoint && codePoint <= 0xFFCF) ||
      (0xFFD2 <= codePoint && codePoint <= 0xFFD7) ||
      (0xFFDA <= codePoint && codePoint <= 0xFFDC) ||
      (0xFFE8 <= codePoint && codePoint <= 0xFFEE)) {
    return 'H';
  }
  if ((0x1100 <= codePoint && codePoint <= 0x115F) ||
      (0x11A3 <= codePoint && codePoint <= 0x11A7) ||
      (0x11FA <= codePoint && codePoint <= 0x11FF) ||
      (0x2329 <= codePoint && codePoint <= 0x232A) ||
      (0x2E80 <= codePoint && codePoint <= 0x2E99) ||
      (0x2E9B <= codePoint && codePoint <= 0x2EF3) ||
      (0x2F00 <= codePoint && codePoint <= 0x2FD5) ||
      (0x2FF0 <= codePoint && codePoint <= 0x2FFB) ||
      (0x3001 <= codePoint && codePoint <= 0x303E) ||
      (0x3041 <= codePoint && codePoint <= 0x3096) ||
      (0x3099 <= codePoint && codePoint <= 0x30FF) ||
      (0x3105 <= codePoint && codePoint <= 0x312D) ||
      (0x3131 <= codePoint && codePoint <= 0x318E) ||
      (0x3190 <= codePoint && codePoint <= 0x31BA) ||
      (0x31C0 <= codePoint && codePoint <= 0x31E3) ||
      (0x31F0 <= codePoint && codePoint <= 0x321E) ||
      (0x3220 <= codePoint && codePoint <= 0x3247) ||
      (0x3250 <= codePoint && codePoint <= 0x32FE) ||
      (0x3300 <= codePoint && codePoint <= 0x4DBF) ||
      (0x4E00 <= codePoint && codePoint <= 0xA48C) ||
      (0xA490 <= codePoint && codePoint <= 0xA4C6) ||
      (0xA960 <= codePoint && codePoint <= 0xA97C) ||
      (0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
      (0xD7B0 <= codePoint && codePoint <= 0xD7C6) ||
      (0xD7CB <= codePoint && codePoint <= 0xD7FB) ||
      (0xF900 <= codePoint && codePoint <= 0xFAFF) ||
      (0xFE10 <= codePoint && codePoint <= 0xFE19) ||
      (0xFE30 <= codePoint && codePoint <= 0xFE52) ||
      (0xFE54 <= codePoint && codePoint <= 0xFE66) ||
      (0xFE68 <= codePoint && codePoint <= 0xFE6B) ||
      (0x1B000 <= codePoint && codePoint <= 0x1B001) ||
      (0x1F200 <= codePoint && codePoint <= 0x1F202) ||
      (0x1F210 <= codePoint && codePoint <= 0x1F23A) ||
      (0x1F240 <= codePoint && codePoint <= 0x1F248) ||
      (0x1F250 <= codePoint && codePoint <= 0x1F251) ||
      (0x20000 <= codePoint && codePoint <= 0x2F73F) ||
      (0x2B740 <= codePoint && codePoint <= 0x2FFFD) ||
      (0x30000 <= codePoint && codePoint <= 0x3FFFD)) {
    return 'W';
  }
  if ((0x0020 <= codePoint && codePoint <= 0x007E) ||
      (0x00A2 <= codePoint && codePoint <= 0x00A3) ||
      (0x00A5 <= codePoint && codePoint <= 0x00A6) ||
      (0x00AC == codePoint) ||
      (0x00AF == codePoint) ||
      (0x27E6 <= codePoint && codePoint <= 0x27ED) ||
      (0x2985 <= codePoint && codePoint <= 0x2986)) {
    return 'Na';
  }
  if ((0x00A1 == codePoint) ||
      (0x00A4 == codePoint) ||
      (0x00A7 <= codePoint && codePoint <= 0x00A8) ||
      (0x00AA == codePoint) ||
      (0x00AD <= codePoint && codePoint <= 0x00AE) ||
      (0x00B0 <= codePoint && codePoint <= 0x00B4) ||
      (0x00B6 <= codePoint && codePoint <= 0x00BA) ||
      (0x00BC <= codePoint && codePoint <= 0x00BF) ||
      (0x00C6 == codePoint) ||
      (0x00D0 == codePoint) ||
      (0x00D7 <= codePoint && codePoint <= 0x00D8) ||
      (0x00DE <= codePoint && codePoint <= 0x00E1) ||
      (0x00E6 == codePoint) ||
      (0x00E8 <= codePoint && codePoint <= 0x00EA) ||
      (0x00EC <= codePoint && codePoint <= 0x00ED) ||
      (0x00F0 == codePoint) ||
      (0x00F2 <= codePoint && codePoint <= 0x00F3) ||
      (0x00F7 <= codePoint && codePoint <= 0x00FA) ||
      (0x00FC == codePoint) ||
      (0x00FE == codePoint) ||
      (0x0101 == codePoint) ||
      (0x0111 == codePoint) ||
      (0x0113 == codePoint) ||
      (0x011B == codePoint) ||
      (0x0126 <= codePoint && codePoint <= 0x0127) ||
      (0x012B == codePoint) ||
      (0x0131 <= codePoint && codePoint <= 0x0133) ||
      (0x0138 == codePoint) ||
      (0x013F <= codePoint && codePoint <= 0x0142) ||
      (0x0144 == codePoint) ||
      (0x0148 <= codePoint && codePoint <= 0x014B) ||
      (0x014D == codePoint) ||
      (0x0152 <= codePoint && codePoint <= 0x0153) ||
      (0x0166 <= codePoint && codePoint <= 0x0167) ||
      (0x016B == codePoint) ||
      (0x01CE == codePoint) ||
      (0x01D0 == codePoint) ||
      (0x01D2 == codePoint) ||
      (0x01D4 == codePoint) ||
      (0x01D6 == codePoint) ||
      (0x01D8 == codePoint) ||
      (0x01DA == codePoint) ||
      (0x01DC == codePoint) ||
      (0x0251 == codePoint) ||
      (0x0261 == codePoint) ||
      (0x02C4 == codePoint) ||
      (0x02C7 == codePoint) ||
      (0x02C9 <= codePoint && codePoint <= 0x02CB) ||
      (0x02CD == codePoint) ||
      (0x02D0 == codePoint) ||
      (0x02D8 <= codePoint && codePoint <= 0x02DB) ||
      (0x02DD == codePoint) ||
      (0x02DF == codePoint) ||
      (0x0300 <= codePoint && codePoint <= 0x036F) ||
      (0x0391 <= codePoint && codePoint <= 0x03A1) ||
      (0x03A3 <= codePoint && codePoint <= 0x03A9) ||
      (0x03B1 <= codePoint && codePoint <= 0x03C1) ||
      (0x03C3 <= codePoint && codePoint <= 0x03C9) ||
      (0x0401 == codePoint) ||
      (0x0410 <= codePoint && codePoint <= 0x044F) ||
      (0x0451 == codePoint) ||
      (0x2010 == codePoint) ||
      (0x2013 <= codePoint && codePoint <= 0x2016) ||
      (0x2018 <= codePoint && codePoint <= 0x2019) ||
      (0x201C <= codePoint && codePoint <= 0x201D) ||
      (0x2020 <= codePoint && codePoint <= 0x2022) ||
      (0x2024 <= codePoint && codePoint <= 0x2027) ||
      (0x2030 == codePoint) ||
      (0x2032 <= codePoint && codePoint <= 0x2033) ||
      (0x2035 == codePoint) ||
      (0x203B == codePoint) ||
      (0x203E == codePoint) ||
      (0x2074 == codePoint) ||
      (0x207F == codePoint) ||
      (0x2081 <= codePoint && codePoint <= 0x2084) ||
      (0x20AC == codePoint) ||
      (0x2103 == codePoint) ||
      (0x2105 == codePoint) ||
      (0x2109 == codePoint) ||
      (0x2113 == codePoint) ||
      (0x2116 == codePoint) ||
      (0x2121 <= codePoint && codePoint <= 0x2122) ||
      (0x2126 == codePoint) ||
      (0x212B == codePoint) ||
      (0x2153 <= codePoint && codePoint <= 0x2154) ||
      (0x215B <= codePoint && codePoint <= 0x215E) ||
      (0x2160 <= codePoint && codePoint <= 0x216B) ||
      (0x2170 <= codePoint && codePoint <= 0x2179) ||
      (0x2189 == codePoint) ||
      (0x2190 <= codePoint && codePoint <= 0x2199) ||
      (0x21B8 <= codePoint && codePoint <= 0x21B9) ||
      (0x21D2 == codePoint) ||
      (0x21D4 == codePoint) ||
      (0x21E7 == codePoint) ||
      (0x2200 == codePoint) ||
      (0x2202 <= codePoint && codePoint <= 0x2203) ||
      (0x2207 <= codePoint && codePoint <= 0x2208) ||
      (0x220B == codePoint) ||
      (0x220F == codePoint) ||
      (0x2211 == codePoint) ||
      (0x2215 == codePoint) ||
      (0x221A == codePoint) ||
      (0x221D <= codePoint && codePoint <= 0x2220) ||
      (0x2223 == codePoint) ||
      (0x2225 == codePoint) ||
      (0x2227 <= codePoint && codePoint <= 0x222C) ||
      (0x222E == codePoint) ||
      (0x2234 <= codePoint && codePoint <= 0x2237) ||
      (0x223C <= codePoint && codePoint <= 0x223D) ||
      (0x2248 == codePoint) ||
      (0x224C == codePoint) ||
      (0x2252 == codePoint) ||
      (0x2260 <= codePoint && codePoint <= 0x2261) ||
      (0x2264 <= codePoint && codePoint <= 0x2267) ||
      (0x226A <= codePoint && codePoint <= 0x226B) ||
      (0x226E <= codePoint && codePoint <= 0x226F) ||
      (0x2282 <= codePoint && codePoint <= 0x2283) ||
      (0x2286 <= codePoint && codePoint <= 0x2287) ||
      (0x2295 == codePoint) ||
      (0x2299 == codePoint) ||
      (0x22A5 == codePoint) ||
      (0x22BF == codePoint) ||
      (0x2312 == codePoint) ||
      (0x2460 <= codePoint && codePoint <= 0x24E9) ||
      (0x24EB <= codePoint && codePoint <= 0x254B) ||
      (0x2550 <= codePoint && codePoint <= 0x2573) ||
      (0x2580 <= codePoint && codePoint <= 0x258F) ||
      (0x2592 <= codePoint && codePoint <= 0x2595) ||
      (0x25A0 <= codePoint && codePoint <= 0x25A1) ||
      (0x25A3 <= codePoint && codePoint <= 0x25A9) ||
      (0x25B2 <= codePoint && codePoint <= 0x25B3) ||
      (0x25B6 <= codePoint && codePoint <= 0x25B7) ||
      (0x25BC <= codePoint && codePoint <= 0x25BD) ||
      (0x25C0 <= codePoint && codePoint <= 0x25C1) ||
      (0x25C6 <= codePoint && codePoint <= 0x25C8) ||
      (0x25CB == codePoint) ||
      (0x25CE <= codePoint && codePoint <= 0x25D1) ||
      (0x25E2 <= codePoint && codePoint <= 0x25E5) ||
      (0x25EF == codePoint) ||
      (0x2605 <= codePoint && codePoint <= 0x2606) ||
      (0x2609 == codePoint) ||
      (0x260E <= codePoint && codePoint <= 0x260F) ||
      (0x2614 <= codePoint && codePoint <= 0x2615) ||
      (0x261C == codePoint) ||
      (0x261E == codePoint) ||
      (0x2640 == codePoint) ||
      (0x2642 == codePoint) ||
      (0x2660 <= codePoint && codePoint <= 0x2661) ||
      (0x2663 <= codePoint && codePoint <= 0x2665) ||
      (0x2667 <= codePoint && codePoint <= 0x266A) ||
      (0x266C <= codePoint && codePoint <= 0x266D) ||
      (0x266F == codePoint) ||
      (0x269E <= codePoint && codePoint <= 0x269F) ||
      (0x26BE <= codePoint && codePoint <= 0x26BF) ||
      (0x26C4 <= codePoint && codePoint <= 0x26CD) ||
      (0x26CF <= codePoint && codePoint <= 0x26E1) ||
      (0x26E3 == codePoint) ||
      (0x26E8 <= codePoint && codePoint <= 0x26FF) ||
      (0x273D == codePoint) ||
      (0x2757 == codePoint) ||
      (0x2776 <= codePoint && codePoint <= 0x277F) ||
      (0x2B55 <= codePoint && codePoint <= 0x2B59) ||
      (0x3248 <= codePoint && codePoint <= 0x324F) ||
      (0xE000 <= codePoint && codePoint <= 0xF8FF) ||
      (0xFE00 <= codePoint && codePoint <= 0xFE0F) ||
      (0xFFFD == codePoint) ||
      (0x1F100 <= codePoint && codePoint <= 0x1F10A) ||
      (0x1F110 <= codePoint && codePoint <= 0x1F12D) ||
      (0x1F130 <= codePoint && codePoint <= 0x1F169) ||
      (0x1F170 <= codePoint && codePoint <= 0x1F19A) ||
      (0xE0100 <= codePoint && codePoint <= 0xE01EF) ||
      (0xF0000 <= codePoint && codePoint <= 0xFFFFD) ||
      (0x100000 <= codePoint && codePoint <= 0x10FFFD)) {
    return 'A';
  }

  return 'N';
};

eaw.characterLength = function(character) {
  var code = this.eastAsianWidth(character);
  if (code == 'F' || code == 'W' || code == 'A') {
    return 2;
  } else {
    return 1;
  }
};

// Split a string considering surrogate-pairs.
function stringToArray(string) {
  return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
}

eaw.length = function(string) {
  var characters = stringToArray(string);
  var len = 0;
  for (var i = 0; i < characters.length; i++) {
    len = len + this.characterLength(characters[i]);
  }
  return len;
};

eaw.slice = function(text, start, end) {
  textLen = eaw.length(text)
  start = start ? start : 0;
  end = end ? end : 1;
  if (start < 0) {
      start = textLen + start;
  }
  if (end < 0) {
      end = textLen + end;
  }
  var result = '';
  var eawLen = 0;
  var chars = stringToArray(text);
  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];
    var charLen = eaw.length(char);
    if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
        if (eawLen + charLen <= end) {
            result += char;
        } else {
            break;
        }
    }
    eawLen += charLen;
  }
  return result;
};


/***/ }),

/***/ "./node_modules/elementtree/lib/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/elementtree/lib/constants.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var DEFAULT_PARSER = 'sax';

exports.DEFAULT_PARSER = DEFAULT_PARSER;


/***/ }),

/***/ "./node_modules/elementtree/lib/elementpath.js":
/*!*****************************************************!*\
  !*** ./node_modules/elementtree/lib/elementpath.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/elementtree/lib/sprintf.js").sprintf;

var utils = __webpack_require__(/*! ./utils */ "./node_modules/elementtree/lib/utils.js");
var SyntaxError = __webpack_require__(/*! ./errors */ "./node_modules/elementtree/lib/errors.js").SyntaxError;

var _cache = {};

var RE = new RegExp(
  "(" +
  "'[^']*'|\"[^\"]*\"|" +
  "::|" +
  "//?|" +
  "\\.\\.|" +
  "\\(\\)|" +
  "[/.*:\\[\\]\\(\\)@=])|" +
  "((?:\\{[^}]+\\})?[^/\\[\\]\\(\\)@=\\s]+)|" +
  "\\s+", 'g'
);

var xpath_tokenizer = utils.findall.bind(null, RE);

function prepare_tag(next, token) {
  var tag = token[0];

  function select(context, result) {
    var i, len, elem, rv = [];

    for (i = 0, len = result.length; i < len; i++) {
      elem = result[i];
      elem._children.forEach(function(e) {
        if (e.tag === tag) {
          rv.push(e);
        }
      });
    }

    return rv;
  }

  return select;
}

function prepare_star(next, token) {
  function select(context, result) {
    var i, len, elem, rv = [];

    for (i = 0, len = result.length; i < len; i++) {
      elem = result[i];
      elem._children.forEach(function(e) {
        rv.push(e);
      });
    }

    return rv;
  }

  return select;
}

function prepare_dot(next, token) {
  function select(context, result) {
    var i, len, elem, rv = [];

    for (i = 0, len = result.length; i < len; i++) {
      elem = result[i];
      rv.push(elem);
    }

    return rv;
  }

  return select;
}

function prepare_iter(next, token) {
  var tag;
  token = next();

  if (token[1] === '*') {
    tag = '*';
  }
  else if (!token[1]) {
    tag = token[0] || '';
  }
  else {
    throw new SyntaxError(token);
  }

  function select(context, result) {
    var i, len, elem, rv = [];

    for (i = 0, len = result.length; i < len; i++) {
      elem = result[i];
      elem.iter(tag, function(e) {
        if (e !== elem) {
          rv.push(e);
        }
      });
    }

    return rv;
  }

  return select;
}

function prepare_dot_dot(next, token) {
  function select(context, result) {
    var i, len, elem, rv = [], parent_map = context.parent_map;

    if (!parent_map) {
      context.parent_map = parent_map = {};

      context.root.iter(null, function(p) {
        p._children.forEach(function(e) {
          parent_map[e] = p;
        });
      });
    }

    for (i = 0, len = result.length; i < len; i++) {
      elem = result[i];

      if (parent_map.hasOwnProperty(elem)) {
        rv.push(parent_map[elem]);
      }
    }

    return rv;
  }

  return select;
}


function prepare_predicate(next, token) {
  var tag, key, value, select;
  token = next();

  if (token[1] === '@') {
    // attribute
    token = next();

    if (token[1]) {
      throw new SyntaxError(token, 'Invalid attribute predicate');
    }

    key = token[0];
    token = next();

    if (token[1] === ']') {
      select = function(context, result) {
        var i, len, elem, rv = [];

        for (i = 0, len = result.length; i < len; i++) {
          elem = result[i];

          if (elem.get(key)) {
            rv.push(elem);
          }
        }

        return rv;
      };
    }
    else if (token[1] === '=') {
      value = next()[1];

      if (value[0] === '"' || value[value.length - 1] === '\'') {
        value = value.slice(1, value.length - 1);
      }
      else {
        throw new SyntaxError(token, 'Ivalid comparison target');
      }

      token = next();
      select = function(context, result) {
        var i, len, elem, rv = [];

        for (i = 0, len = result.length; i < len; i++) {
          elem = result[i];

          if (elem.get(key) === value) {
            rv.push(elem);
          }
        }

        return rv;
      };
    }

    if (token[1] !== ']') {
      throw new SyntaxError(token, 'Invalid attribute predicate');
    }
  }
  else if (!token[1]) {
    tag = token[0] || '';
    token = next();

    if (token[1] !== ']') {
      throw new SyntaxError(token, 'Invalid node predicate');
    }

    select = function(context, result) {
      var i, len, elem, rv = [];

      for (i = 0, len = result.length; i < len; i++) {
        elem = result[i];

        if (elem.find(tag)) {
          rv.push(elem);
        }
      }

      return rv;
    };
  }
  else {
    throw new SyntaxError(null, 'Invalid predicate');
  }

  return select;
}



var ops = {
  "": prepare_tag,
  "*": prepare_star,
  ".": prepare_dot,
  "..": prepare_dot_dot,
  "//": prepare_iter,
  "[": prepare_predicate,
};

function _SelectorContext(root) {
  this.parent_map = null;
  this.root = root;
}

function findall(elem, path) {
  var selector, result, i, len, token, value, select, context;

  if (_cache.hasOwnProperty(path)) {
    selector = _cache[path];
  }
  else {
    // TODO: Use smarter cache purging approach
    if (Object.keys(_cache).length > 100) {
      _cache = {};
    }

    if (path.charAt(0) === '/') {
      throw new SyntaxError(null, 'Cannot use absolute path on element');
    }

    result = xpath_tokenizer(path);
    selector = [];

    function getToken() {
      return result.shift();
    }

    token = getToken();
    while (true) {
      var c = token[1] || '';
      value = ops[c](getToken, token);

      if (!value) {
        throw new SyntaxError(null, sprintf('Invalid path: %s', path));
      }

      selector.push(value);
      token = getToken();

      if (!token) {
        break;
      }
      else if (token[1] === '/') {
        token = getToken();
      }

      if (!token) {
        break;
      }
    }

    _cache[path] = selector;
  }

  // Execute slector pattern
  result = [elem];
  context = new _SelectorContext(elem);

  for (i = 0, len = selector.length; i < len; i++) {
    select = selector[i];
    result = select(context, result);
  }

  return result || [];
}

function find(element, path) {
  var resultElements = findall(element, path);

  if (resultElements && resultElements.length > 0) {
    return resultElements[0];
  }

  return null;
}

function findtext(element, path, defvalue) {
  var resultElements = findall(element, path);

  if (resultElements && resultElements.length > 0) {
    return resultElements[0].text;
  }

  return defvalue;
}


exports.find = find;
exports.findall = findall;
exports.findtext = findtext;


/***/ }),

/***/ "./node_modules/elementtree/lib/elementtree.js":
/*!*****************************************************!*\
  !*** ./node_modules/elementtree/lib/elementtree.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/elementtree/lib/sprintf.js").sprintf;

var utils = __webpack_require__(/*! ./utils */ "./node_modules/elementtree/lib/utils.js");
var ElementPath = __webpack_require__(/*! ./elementpath */ "./node_modules/elementtree/lib/elementpath.js");
var TreeBuilder = __webpack_require__(/*! ./treebuilder */ "./node_modules/elementtree/lib/treebuilder.js").TreeBuilder;
var get_parser = __webpack_require__(/*! ./parser */ "./node_modules/elementtree/lib/parser.js").get_parser;
var constants = __webpack_require__(/*! ./constants */ "./node_modules/elementtree/lib/constants.js");

var element_ids = 0;

function Element(tag, attrib)
{
  this._id = element_ids++;
  this.tag = tag;
  this.attrib = {};
  this.text = null;
  this.tail = null;
  this._children = [];

  if (attrib) {
    this.attrib = utils.merge(this.attrib, attrib);
  }
}

Element.prototype.toString = function()
{
  return sprintf("<Element %s at %s>", this.tag, this._id);
};

Element.prototype.makeelement = function(tag, attrib)
{
  return new Element(tag, attrib);
};

Element.prototype.len = function()
{
  return this._children.length;
};

Element.prototype.getItem = function(index)
{
  return this._children[index];
};

Element.prototype.setItem = function(index, element)
{
  this._children[index] = element;
};

Element.prototype.delItem = function(index)
{
  this._children.splice(index, 1);
};

Element.prototype.getSlice = function(start, stop)
{
  return this._children.slice(start, stop);
};

Element.prototype.setSlice = function(start, stop, elements)
{
  var i;
  var k = 0;
  for (i = start; i < stop; i++, k++) {
    this._children[i] = elements[k];
  }
};

Element.prototype.delSlice = function(start, stop)
{
  this._children.splice(start, stop - start);
};

Element.prototype.append = function(element)
{
  this._children.push(element);
};

Element.prototype.extend = function(elements)
{
  this._children.concat(elements);
};

Element.prototype.insert = function(index, element)
{
  this._children[index] = element;
};

Element.prototype.remove = function(element)
{
  this._children = this._children.filter(function(e) {
    /* TODO: is this the right way to do this? */
    if (e._id === element._id) {
      return false;
    }
    return true;
  });
};

Element.prototype.getchildren = function() {
  return this._children;
};

Element.prototype.find = function(path)
{
  return ElementPath.find(this, path);
};

Element.prototype.findtext = function(path, defvalue)
{
  return ElementPath.findtext(this, path, defvalue);
};

Element.prototype.findall = function(path, defvalue)
{
  return ElementPath.findall(this, path, defvalue);
};

Element.prototype.clear = function()
{
  this.attrib = {};
  this._children = [];
  this.text = null;
  this.tail = null;
};

Element.prototype.get = function(key, defvalue)
{
  if (this.attrib[key] !== undefined) {
    return this.attrib[key];
  }
  else {
    return defvalue;
  }
};

Element.prototype.set = function(key, value)
{
  this.attrib[key] = value;
};

Element.prototype.keys = function()
{
  return Object.keys(this.attrib);
};

Element.prototype.items = function()
{
  return utils.items(this.attrib);
};

/*
 * In python this uses a generator, but in v8 we don't have em,
 * so we use a callback instead.
 **/
Element.prototype.iter = function(tag, callback)
{
  var self = this;
  var i, child;

  if (tag === "*") {
    tag = null;
  }

  if (tag === null || this.tag === tag) {
    callback(self);
  }

  for (i = 0; i < this._children.length; i++) {
    child = this._children[i];
    child.iter(tag, function(e) {
      callback(e);
    });
  }
};

Element.prototype.itertext = function(callback)
{
  this.iter(null, function(e) {
    if (e.text) {
      callback(e.text);
    }

    if (e.tail) {
      callback(e.tail);
    }
  });
};


function SubElement(parent, tag, attrib) {
  var element = parent.makeelement(tag, attrib);
  parent.append(element);
  return element;
}

function Comment(text) {
  var element = new Element(Comment);
  if (text) {
    element.text = text;
  }
  return element;
}

function CData(text) {
  var element = new Element(CData);
  if (text) {
    element.text = text;
  }
  return element;
}

function ProcessingInstruction(target, text)
{
  var element = new Element(ProcessingInstruction);
  element.text = target;
  if (text) {
    element.text = element.text + " " + text;
  }
  return element;
}

function QName(text_or_uri, tag)
{
  if (tag) {
    text_or_uri = sprintf("{%s}%s", text_or_uri, tag);
  }
  this.text = text_or_uri;
}

QName.prototype.toString = function() {
  return this.text;
};

function ElementTree(element)
{
  this._root = element;
}

ElementTree.prototype.getroot = function() {
  return this._root;
};

ElementTree.prototype._setroot = function(element) {
  this._root = element;
};

ElementTree.prototype.parse = function(source, parser) {
  if (!parser) {
    parser = get_parser(constants.DEFAULT_PARSER);
    parser = new parser.XMLParser(new TreeBuilder());
  }

  parser.feed(source);
  this._root = parser.close();
  return this._root;
};

ElementTree.prototype.iter = function(tag, callback) {
  this._root.iter(tag, callback);
};

ElementTree.prototype.find = function(path) {
  return this._root.find(path);
};

ElementTree.prototype.findtext = function(path, defvalue) {
  return this._root.findtext(path, defvalue);
};

ElementTree.prototype.findall = function(path) {
  return this._root.findall(path);
};

/**
 * Unlike ElementTree, we don't write to a file, we return you a string.
 */
ElementTree.prototype.write = function(options) {
  var sb = [];
  options = utils.merge({
    encoding: 'utf-8',
    xml_declaration: null,
    default_namespace: null,
    method: 'xml'}, options);

  if (options.xml_declaration !== false) {
    sb.push("<?xml version='1.0' encoding='"+options.encoding +"'?>\n");
  }

  if (options.method === "text") {
    _serialize_text(sb, self._root, encoding);
  }
  else {
    var qnames, namespaces, indent, indent_string;
    var x = _namespaces(this._root, options.encoding, options.default_namespace);
    qnames = x[0];
    namespaces = x[1];

    if (options.hasOwnProperty('indent')) {
      indent = 0;
      indent_string = new Array(options.indent + 1).join(' ');
    }
    else {
      indent = false;
    }

    if (options.method === "xml") {
      _serialize_xml(function(data) {
        sb.push(data);
      }, this._root, options.encoding, qnames, namespaces, indent, indent_string);
    }
    else {
      /* TODO: html */
      throw new Error("unknown serialization method "+ options.method);
    }
  }

  return sb.join("");
};

var _namespace_map = {
    /* "well-known" namespace prefixes */
    "http://www.w3.org/XML/1998/namespace": "xml",
    "http://www.w3.org/1999/xhtml": "html",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
    "http://schemas.xmlsoap.org/wsdl/": "wsdl",
    /* xml schema */
    "http://www.w3.org/2001/XMLSchema": "xs",
    "http://www.w3.org/2001/XMLSchema-instance": "xsi",
    /* dublic core */
    "http://purl.org/dc/elements/1.1/": "dc",
};

function register_namespace(prefix, uri) {
  if (/ns\d+$/.test(prefix)) {
    throw new Error('Prefix format reserved for internal use');
  }

  if (_namespace_map.hasOwnProperty(uri) && _namespace_map[uri] === prefix) {
    delete _namespace_map[uri];
  }

  _namespace_map[uri] = prefix;
}


function _escape(text, encoding, isAttribute, isText) {
  if (text) {
    text = text.toString();
    text = text.replace(/&/g, '&amp;');
    text = text.replace(/</g, '&lt;');
    text = text.replace(/>/g, '&gt;');
    if (!isText) {
        text = text.replace(/\n/g, '&#xA;');
        text = text.replace(/\r/g, '&#xD;');
    }
    if (isAttribute) {
      text = text.replace(/"/g, '&quot;');
    }
  }
  return text;
}

/* TODO: benchmark single regex */
function _escape_attrib(text, encoding) {
  return _escape(text, encoding, true);
}

function _escape_cdata(text, encoding) {
  return _escape(text, encoding, false);
}

function _escape_text(text, encoding) {
  return _escape(text, encoding, false, true);
}

function _namespaces(elem, encoding, default_namespace) {
  var qnames = {};
  var namespaces = {};

  if (default_namespace) {
    namespaces[default_namespace] = "";
  }

  function encode(text) {
    return text;
  }

  function add_qname(qname) {
    if (qname[0] === "{") {
      var tmp = qname.substring(1).split("}", 2);
      var uri = tmp[0];
      var tag = tmp[1];
      var prefix = namespaces[uri];

      if (prefix === undefined) {
        prefix = _namespace_map[uri];
        if (prefix === undefined) {
          prefix = "ns" + Object.keys(namespaces).length;
        }
        if (prefix !== "xml") {
          namespaces[uri] = prefix;
        }
      }

      if (prefix) {
        qnames[qname] = sprintf("%s:%s", prefix, tag);
      }
      else {
        qnames[qname] = tag;
      }
    }
    else {
      if (default_namespace) {
        throw new Error('cannot use non-qualified names with default_namespace option');
      }

      qnames[qname] = qname;
    }
  }


  elem.iter(null, function(e) {
    var i;
    var tag = e.tag;
    var text = e.text;
    var items = e.items();

    if (tag instanceof QName && qnames[tag.text] === undefined) {
      add_qname(tag.text);
    }
    else if (typeof(tag) === "string") {
      add_qname(tag);
    }
    else if (tag !== null && tag !== Comment && tag !== CData && tag !== ProcessingInstruction) {
      throw new Error('Invalid tag type for serialization: '+ tag);
    }

    if (text instanceof QName && qnames[text.text] === undefined) {
      add_qname(text.text);
    }

    items.forEach(function(item) {
      var key = item[0],
          value = item[1];
      if (key instanceof QName) {
        key = key.text;
      }

      if (qnames[key] === undefined) {
        add_qname(key);
      }

      if (value instanceof QName && qnames[value.text] === undefined) {
        add_qname(value.text);
      }
    });
  });
  return [qnames, namespaces];
}

function _serialize_xml(write, elem, encoding, qnames, namespaces, indent, indent_string) {
  var tag = elem.tag;
  var text = elem.text;
  var items;
  var i;

  var newlines = indent || (indent === 0);
  write(Array(indent + 1).join(indent_string));

  if (tag === Comment) {
    write(sprintf("<!--%s-->", _escape_cdata(text, encoding)));
  }
  else if (tag === ProcessingInstruction) {
    write(sprintf("<?%s?>", _escape_cdata(text, encoding)));
  }
  else if (tag === CData) {
    text = text || '';
    write(sprintf("<![CDATA[%s]]>", text));
  }
  else {
    tag = qnames[tag];
    if (tag === undefined) {
      if (text) {
        write(_escape_text(text, encoding));
      }
      elem.iter(function(e) {
        _serialize_xml(write, e, encoding, qnames, null, newlines ? indent + 1 : false, indent_string);
      });
    }
    else {
      write("<" + tag);
      items = elem.items();

      if (items || namespaces) {
        items.sort(); // lexical order

        items.forEach(function(item) {
          var k = item[0],
              v = item[1];

            if (k instanceof QName) {
              k = k.text;
            }

            if (v instanceof QName) {
              v = qnames[v.text];
            }
            else {
              v = _escape_attrib(v, encoding);
            }
            write(sprintf(" %s=\"%s\"", qnames[k], v));
        });

        if (namespaces) {
          items = utils.items(namespaces);
          items.sort(function(a, b) { return a[1] < b[1]; });

          items.forEach(function(item) {
            var k = item[1],
                v = item[0];

            if (k) {
              k = ':' + k;
            }

            write(sprintf(" xmlns%s=\"%s\"", k, _escape_attrib(v, encoding)));
          });
        }
      }

      if (text || elem.len()) {
        if (text && text.toString().match(/^\s*$/)) {
            text = null;
        }

        write(">");
        if (!text && newlines) {
          write("\n");
        }

        if (text) {
          write(_escape_text(text, encoding));
        }
        elem._children.forEach(function(e) {
          _serialize_xml(write, e, encoding, qnames, null, newlines ? indent + 1 : false, indent_string);
        });

        if (!text && indent) {
          write(Array(indent + 1).join(indent_string));
        }
        write("</" + tag + ">");
      }
      else {
        write(" />");
      }
    }
  }

  if (newlines) {
    write("\n");
  }
}

function parse(source, parser) {
  var tree = new ElementTree();
  tree.parse(source, parser);
  return tree;
}

function tostring(element, options) {
  return new ElementTree(element).write(options);
}

exports.PI = ProcessingInstruction;
exports.Comment = Comment;
exports.CData = CData;
exports.ProcessingInstruction = ProcessingInstruction;
exports.SubElement = SubElement;
exports.QName = QName;
exports.ElementTree = ElementTree;
exports.ElementPath = ElementPath;
exports.Element = function(tag, attrib) {
  return new Element(tag, attrib);
};

exports.XML = function(data) {
  var et = new ElementTree();
  return et.parse(data);
};

exports.parse = parse;
exports.register_namespace = register_namespace;
exports.tostring = tostring;


/***/ }),

/***/ "./node_modules/elementtree/lib/errors.js":
/*!************************************************!*\
  !*** ./node_modules/elementtree/lib/errors.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var util = __webpack_require__(/*! util */ "util");

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/elementtree/lib/sprintf.js").sprintf;

function SyntaxError(token, msg) {
  msg = msg || sprintf('Syntax Error at token %s', token.toString());
  this.token = token;
  this.message = msg;
  Error.call(this, msg);
}

util.inherits(SyntaxError, Error);

exports.SyntaxError = SyntaxError;


/***/ }),

/***/ "./node_modules/elementtree/lib/parser.js":
/*!************************************************!*\
  !*** ./node_modules/elementtree/lib/parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

/* TODO: support node-expat C++ module optionally */

var util = __webpack_require__(/*! util */ "util");
var parsers = __webpack_require__(/*! ./parsers/index */ "./node_modules/elementtree/lib/parsers/index.js");

function get_parser(name) {
  if (name === 'sax') {
    return parsers.sax;
  }
  else {
    throw new Error('Invalid parser: ' + name);
  }
}


exports.get_parser = get_parser;


/***/ }),

/***/ "./node_modules/elementtree/lib/parsers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/elementtree/lib/parsers/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.sax = __webpack_require__(/*! ./sax */ "./node_modules/elementtree/lib/parsers/sax.js");


/***/ }),

/***/ "./node_modules/elementtree/lib/parsers/sax.js":
/*!*****************************************************!*\
  !*** ./node_modules/elementtree/lib/parsers/sax.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! util */ "util");

var sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");

var TreeBuilder = __webpack_require__(/*! ./../treebuilder */ "./node_modules/elementtree/lib/treebuilder.js").TreeBuilder;

function XMLParser(target) {
  this.parser = sax.parser(true);

  this.target = (target) ? target : new TreeBuilder();

  this.parser.onopentag = this._handleOpenTag.bind(this);
  this.parser.ontext = this._handleText.bind(this);
  this.parser.oncdata = this._handleCdata.bind(this);
  this.parser.ondoctype = this._handleDoctype.bind(this);
  this.parser.oncomment = this._handleComment.bind(this);
  this.parser.onclosetag = this._handleCloseTag.bind(this);
  this.parser.onerror = this._handleError.bind(this);
}

XMLParser.prototype._handleOpenTag = function(tag) {
  this.target.start(tag.name, tag.attributes);
};

XMLParser.prototype._handleText = function(text) {
  this.target.data(text);
};

XMLParser.prototype._handleCdata = function(text) {
  this.target.data(text);
};

XMLParser.prototype._handleDoctype = function(text) {
};

XMLParser.prototype._handleComment = function(comment) {
};

XMLParser.prototype._handleCloseTag = function(tag) {
  this.target.end(tag);
};

XMLParser.prototype._handleError = function(err) {
  throw err;
};

XMLParser.prototype.feed = function(chunk) {
  this.parser.write(chunk);
};

XMLParser.prototype.close = function() {
  this.parser.close();
  return this.target.close();
};

exports.XMLParser = XMLParser;


/***/ }),

/***/ "./node_modules/elementtree/lib/sprintf.js":
/*!*************************************************!*\
  !*** ./node_modules/elementtree/lib/sprintf.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var cache = {};


// Do any others need escaping?
var TO_ESCAPE = {
  '\'': '\\\'',
  '\n': '\\n'
};


function populate(formatter) {
  var i, type,
      key = formatter,
      prev = 0,
      arg = 1,
      builder = 'return \'';

  for (i = 0; i < formatter.length; i++) {
    if (formatter[i] === '%') {
      type = formatter[i + 1];

      switch (type) {
        case 's':
          builder += formatter.slice(prev, i) + '\' + arguments[' + arg + '] + \'';
          prev = i + 2;
          arg++;
          break;
        case 'j':
          builder += formatter.slice(prev, i) + '\' + JSON.stringify(arguments[' + arg + ']) + \'';
          prev = i + 2;
          arg++;
          break;
        case '%':
          builder += formatter.slice(prev, i + 1);
          prev = i + 2;
          i++;
          break;
      }


    } else if (TO_ESCAPE[formatter[i]]) {
      builder += formatter.slice(prev, i) + TO_ESCAPE[formatter[i]];
      prev = i + 1;
    }
  }

  builder += formatter.slice(prev) + '\';';
  cache[key] = new Function(builder);
}


/**
 * A fast version of sprintf(), which currently only supports the %s and %j.
 * This caches a formatting function for each format string that is used, so
 * you should only use this sprintf() will be called many times with a single
 * format string and a limited number of format strings will ever be used (in
 * general this means that format strings should be string literals).
 *
 * @param {String} formatter A format string.
 * @param {...String} var_args Values that will be formatted by %s and %j.
 * @return {String} The formatted output.
 */
exports.sprintf = function(formatter, var_args) {
  if (!cache[formatter]) {
    populate(formatter);
  }

  return cache[formatter].apply(null, arguments);
};


/***/ }),

/***/ "./node_modules/elementtree/lib/treebuilder.js":
/*!*****************************************************!*\
  !*** ./node_modules/elementtree/lib/treebuilder.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function TreeBuilder(element_factory) {
  this._data = [];
  this._elem = [];
  this._last = null;
  this._tail = null;
  if (!element_factory) {
    /* evil circular dep */
    element_factory = __webpack_require__(/*! ./elementtree */ "./node_modules/elementtree/lib/elementtree.js").Element;
  }
  this._factory = element_factory;
}

TreeBuilder.prototype.close = function() {
  return this._last;
};

TreeBuilder.prototype._flush = function() {
  if (this._data) {
    if (this._last !== null) {
      var text = this._data.join("");
      if (this._tail) {
        this._last.tail = text;
      }
      else {
        this._last.text = text;
      }
    }
    this._data = [];
  }
};

TreeBuilder.prototype.data = function(data) {
  this._data.push(data);
};

TreeBuilder.prototype.start = function(tag, attrs) {
  this._flush();
  var elem = this._factory(tag, attrs);
  this._last = elem;

  if (this._elem.length) {
    this._elem[this._elem.length - 1].append(elem);
  }

  this._elem.push(elem);

  this._tail = null;
};

TreeBuilder.prototype.end = function(tag) {
  this._flush();
  this._last = this._elem.pop();
  if (this._last.tag !== tag) {
    throw new Error("end tag mismatch");
  }
  this._tail = 1;
  return this._last;
};

exports.TreeBuilder = TreeBuilder;


/***/ }),

/***/ "./node_modules/elementtree/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/elementtree/lib/utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 *  Copyright 2011 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

/**
 * @param {Object} hash.
 * @param {Array} ignored.
 */
function items(hash, ignored) {
  ignored = ignored || null;
  var k, rv = [];

  function is_ignored(key) {
    if (!ignored || ignored.length === 0) {
      return false;
    }

    return ignored.indexOf(key);
  }

  for (k in hash) {
    if (hash.hasOwnProperty(k) && !(is_ignored(ignored))) {
      rv.push([k, hash[k]]);
    }
  }

  return rv;
}


function findall(re, str) {
  var match, matches = [];

  while ((match = re.exec(str))) {
      matches.push(match);
  }

  return matches;
}

function merge(a, b) {
  var c = {}, attrname;

  for (attrname in a) {
    if (a.hasOwnProperty(attrname)) {
      c[attrname] = a[attrname];
    }
  }
  for (attrname in b) {
    if (b.hasOwnProperty(attrname)) {
      c[attrname] = b[attrname];
    }
  }
  return c;
}

exports.items = items;
exports.findall = findall;
exports.merge = merge;


/***/ }),

/***/ "./node_modules/empower-core/index.js":
/*!********************************************!*\
  !*** ./node_modules/empower-core/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * empower-core - Power Assert feature enhancer for assert function/object.
 *
 * https://github.com/twada/power-assert-runtime/packages/empower-core
 *
 * Copyright (c) 2013-2018 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/twada/power-assert-runtime/blob/master/LICENSE
 */
var create = __webpack_require__(/*! core-js/library/fn/object/create */ "./node_modules/core-js/library/fn/object/create.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var defaultOptions = __webpack_require__(/*! ./lib/default-options */ "./node_modules/empower-core/lib/default-options.js");
var Decorator = __webpack_require__(/*! ./lib/decorator */ "./node_modules/empower-core/lib/decorator.js");
var define = __webpack_require__(/*! ./lib/define-properties */ "./node_modules/empower-core/lib/define-properties.js");
var slice = Array.prototype.slice;

/**
 * Enhance Power Assert feature to assert function/object.
 * @param assert target assert function or object to enhance
 * @param options enhancement options
 * @return enhanced assert function/object
 */
function empowerCore (assert, options) {
    var typeOfAssert = (typeof assert);
    var enhancedAssert;
    if ((typeOfAssert !== 'object' && typeOfAssert !== 'function') || assert === null) {
        throw new TypeError('empower-core argument should be a function or object.');
    }
    if (isEmpowered(assert)) {
        return assert;
    }
    switch (typeOfAssert) {
    case 'function':
        enhancedAssert = empowerAssertFunction(assert, options);
        break;
    case 'object':
        enhancedAssert = empowerAssertObject(assert, options);
        break;
    default:
        throw new Error('Cannot be here');
    }
    define(enhancedAssert, { _empowered: true });
    return enhancedAssert;
}

function empowerAssertObject (assertObject, options) {
    var config = assign(defaultOptions(), options);
    var target = config.destructive ? assertObject : create(assertObject);
    var decorator = new Decorator(target, config);
    return assign(target, decorator.enhancement());
}

function empowerAssertFunction (assertFunction, options) {
    var config = assign(defaultOptions(), options);
    if (config.destructive) {
        throw new Error('cannot use destructive:true to function.');
    }
    var decorator = new Decorator(assertFunction, config);
    var enhancement = decorator.enhancement();
    var powerAssert;
    if (typeof enhancement === 'function') {
        powerAssert = function powerAssert () {
            return enhancement.apply(null, slice.apply(arguments));
        };
    } else {
        powerAssert = function powerAssert () {
            return assertFunction.apply(null, slice.apply(arguments));
        };
    }
    assign(powerAssert, assertFunction);
    return assign(powerAssert, enhancement);
}

function isEmpowered (assertObjectOrFunction) {
    return assertObjectOrFunction._empowered;
}

empowerCore.defaultOptions = defaultOptions;
module.exports = empowerCore;


/***/ }),

/***/ "./node_modules/empower-core/lib/decorate.js":
/*!***************************************************!*\
  !*** ./node_modules/empower-core/lib/decorate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var some = __webpack_require__(/*! core-js/library/fn/array/some */ "./node_modules/core-js/library/fn/array/some.js");
var map = __webpack_require__(/*! core-js/library/fn/array/map */ "./node_modules/core-js/library/fn/array/map.js");

function decorate (callSpec, decorator) {
    var numArgsToCapture = callSpec.numArgsToCapture;

    return function decoratedAssert () {
        var context, message, hasMessage = false;

        // see: https://github.com/twada/empower-core/pull/8#issue-127859465
        // see: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; ++i) {
            args[i] = arguments[i];
        }

        if (numArgsToCapture === (args.length - 1)) {
            message = args.pop();
            hasMessage = true;
        }

        var invocation = {
            thisObj: this,
            values: args,
            message: message,
            hasMessage: hasMessage
        };

        if (some(args, isCaptured)) {
            invocation.values = map(args.slice(0, numArgsToCapture), function (arg) {
                if (isNotCaptured(arg)) {
                    return arg;
                }
                if (!context) {
                    context = {
                        source: arg.source,
                        args: []
                    };
                }
                context.args.push({
                    value: arg.powerAssertContext.value,
                    events: arg.powerAssertContext.events
                });
                return arg.powerAssertContext.value;
            });

            return decorator.concreteAssert(callSpec, invocation, context);
        } else {
            return decorator.concreteAssert(callSpec, invocation);
        }
    };
}

function isNotCaptured (value) {
    return !isCaptured(value);
}

function isCaptured (value) {
    return (typeof value === 'object') &&
        (value !== null) &&
        (typeof value.powerAssertContext !== 'undefined');
}

module.exports = decorate;


/***/ }),

/***/ "./node_modules/empower-core/lib/decorator.js":
/*!****************************************************!*\
  !*** ./node_modules/empower-core/lib/decorator.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var filter = __webpack_require__(/*! core-js/library/fn/array/filter */ "./node_modules/core-js/library/fn/array/filter.js");
var map = __webpack_require__(/*! core-js/library/fn/array/map */ "./node_modules/core-js/library/fn/array/map.js");
var signature = __webpack_require__(/*! call-signature */ "./node_modules/call-signature/index.js");
var decorate = __webpack_require__(/*! ./decorate */ "./node_modules/empower-core/lib/decorate.js");
var keys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");


function Decorator (receiver, config) {
    this.receiver = receiver;
    this.config = config;
    this.onError = config.onError;
    this.onSuccess = config.onSuccess;
    this.signatures = map(config.patterns, parse);
    this.wrapOnlySignatures = map(config.wrapOnlyPatterns, parse);
}

Decorator.prototype.enhancement = function () {
    var that = this;
    var container = this.container();
    var wrappedMethods = [];

    function attach(matcherSpec, enhanced) {
        var matcher = matcherSpec.parsed;
        var methodName = detectMethodName(matcher.callee);
        if (typeof that.receiver[methodName] !== 'function' || wrappedMethods.indexOf(methodName) !== -1) {
            return;
        }
        var callSpec = {
            thisObj: that.receiver,
            func: that.receiver[methodName],
            numArgsToCapture: numberOfArgumentsToCapture(matcherSpec),
            matcherSpec: matcherSpec,
            enhanced: enhanced
        };
        container[methodName] = callSpec.enhancedFunc = decorate(callSpec, that);
        wrappedMethods.push(methodName);
    }

    forEach(filter(this.signatures, methodCall), function (matcher) {
        attach(matcher, true);
    });

    forEach(filter(this.wrapOnlySignatures, methodCall), function (matcher) {
        attach(matcher, false);
    });

    return container;
};

Decorator.prototype.container = function () {
    var basement = {};
    if (typeof this.receiver === 'function') {
        var candidates = filter(this.signatures, functionCall);
        var enhanced = true;
        if (candidates.length === 0) {
            enhanced = false;
            candidates = filter(this.wrapOnlySignatures, functionCall);
        }
        if (candidates.length === 1) {
            var callSpec = {
                thisObj: null,
                func: this.receiver,
                numArgsToCapture: numberOfArgumentsToCapture(candidates[0]),
                matcherSpec: candidates[0],
                enhanced: enhanced
            };
            basement = callSpec.enhancedFunc = decorate(callSpec, this);
        }
    }
    return basement;
};

Decorator.prototype.concreteAssert = function (callSpec, invocation, context) {
    var func = callSpec.func;
    var thisObj = this.config.bindReceiver ? callSpec.thisObj : invocation.thisObj;
    var enhanced = callSpec.enhanced;
    var args = invocation.values;
    var message = invocation.message;
    var matcherSpec = callSpec.matcherSpec;

    if (context && typeof this.config.modifyMessageBeforeAssert === 'function') {
        message = this.config.modifyMessageBeforeAssert({originalMessage: message, powerAssertContext: context});
    }
    args = args.concat(message);

    var data = {
        thisObj: invocation.thisObj,
        assertionFunction: callSpec.enhancedFunc,
        originalMessage: message,
        defaultMessage: matcherSpec.defaultMessage,
        matcherSpec: matcherSpec,
        enhanced: enhanced,
        args: args
    };

    if (context) {
        data.powerAssertContext = context;
    }

    return this._callFunc(func, thisObj, args, data);
};

// see: https://github.com/twada/empower-core/pull/8#issuecomment-173480982
Decorator.prototype._callFunc = function (func, thisObj, args, data) {
    var ret;
    try {
        ret = func.apply(thisObj, args);
    } catch (e) {
        data.assertionThrew = true;
        data.error = e;
        return this.onError.call(thisObj, data);
    }
    data.assertionThrew = false;
    data.returnValue = ret;
    return this.onSuccess.call(thisObj, data);
};

function numberOfArgumentsToCapture (matcherSpec) {
    var matcher = matcherSpec.parsed;
    var len = matcher.args.length;
    var lastArg;
    if (0 < len) {
        lastArg = matcher.args[len - 1];
        if (lastArg.name === 'message' && lastArg.optional) {
            len -= 1;
        }
    }
    return len;
}


function detectMethodName (callee) {
    if (callee.type === 'MemberExpression') {
        return callee.member;
    }
    return null;
}


function functionCall (matcherSpec) {
    return matcherSpec.parsed.callee.type === 'Identifier';
}


function methodCall (matcherSpec) {
    return matcherSpec.parsed.callee.type === 'MemberExpression';
}

function parse(matcherSpec) {
    if (typeof matcherSpec === 'string') {
        matcherSpec = {pattern: matcherSpec};
    }
    var ret = {};
    forEach(keys(matcherSpec), function (key) {
        ret[key] = matcherSpec[key];
    });
    ret.parsed = signature.parse(matcherSpec.pattern);
    return ret;
}


module.exports = Decorator;


/***/ }),

/***/ "./node_modules/empower-core/lib/default-options.js":
/*!**********************************************************!*\
  !*** ./node_modules/empower-core/lib/default-options.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function defaultOptions () {
    return {
        destructive: false,
        bindReceiver: true,
        onError: onError,
        onSuccess: onSuccess,
        patterns: [
            'assert(value, [message])',
            'assert.ok(value, [message])',
            'assert.equal(actual, expected, [message])',
            'assert.notEqual(actual, expected, [message])',
            'assert.strictEqual(actual, expected, [message])',
            'assert.notStrictEqual(actual, expected, [message])',
            'assert.deepEqual(actual, expected, [message])',
            'assert.notDeepEqual(actual, expected, [message])',
            'assert.deepStrictEqual(actual, expected, [message])',
            'assert.notDeepStrictEqual(actual, expected, [message])'
        ],
        wrapOnlyPatterns: []
    };
};

function onError (errorEvent) {
    var e = errorEvent.error;
    if (errorEvent.powerAssertContext && /^AssertionError/.test(e.name)) {
        e.powerAssertContext = errorEvent.powerAssertContext;
    }
    throw e;
}

function onSuccess(successEvent) {
    return successEvent.returnValue;
}


/***/ }),

/***/ "./node_modules/empower-core/lib/define-properties.js":
/*!************************************************************!*\
  !*** ./node_modules/empower-core/lib/define-properties.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defineProperty = __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js");
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var keys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");

module.exports = function defineProperties (obj, map) {
    forEach(keys(map), function (name) {
        defineProperty(obj, name, {
            configurable: true,
            enumerable: false,
            value: map[name],
            writable: true
        });
    });
};


/***/ }),

/***/ "./node_modules/empower/index.js":
/*!***************************************!*\
  !*** ./node_modules/empower/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * empower - Power Assert feature enhancer for assert function/object.
 *
 * https://github.com/power-assert-js/empower
 *
 * Copyright (c) 2013-2018 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/empower/blob/master/MIT-LICENSE.txt
 */
var empowerCore = __webpack_require__(/*! empower-core */ "./node_modules/empower-core/index.js");
var defaultOptions = __webpack_require__(/*! ./lib/default-options */ "./node_modules/empower/lib/default-options.js");
var capturable = __webpack_require__(/*! ./lib/capturable */ "./node_modules/empower/lib/capturable.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var define = __webpack_require__(/*! ./lib/define-properties */ "./node_modules/empower/lib/define-properties.js");

/**
 * Enhance Power Assert feature to assert function/object.
 * @param assert target assert function or object to enhance
 * @param formatter power assert format function
 * @param options enhancement options
 * @return enhanced assert function/object
 */
function empower (assert, formatter, options) {
    var config = assign(defaultOptions(), options);
    var eagerEvaluation = !(config.modifyMessageOnRethrow || config.saveContextOnRethrow);
    // see: https://github.com/power-assert-js/empower/pull/26
    var shouldRecreateAssertionError = (function isStackUnchanged () {
        if (typeof assert !== 'function') {
            return false;
        }
        if (typeof assert.AssertionError !== 'function') {
            return false;
        }
        var ae = new assert.AssertionError({
            actual: 123,
            expected: 456,
            operator: '==='
        });
        ae.message = '[REPLACED MESSAGE]';
        return !(/REPLACED MESSAGE/.test(ae.stack)) && /123 === 456/.test(ae.stack);
    })();

    var empowerCoreConfig = assign(config, {
        modifyMessageBeforeAssert: function (beforeAssertEvent) {
            var message = beforeAssertEvent.originalMessage;
            if (!eagerEvaluation) {
                return message;
            }
            return buildPowerAssertText(formatter, message, beforeAssertEvent.powerAssertContext);
        },
        onError: function onError (errorEvent) {
            var e = errorEvent.error;
            if (!/^AssertionError/.test(e.name)) {
                throw e;
            }
            if (!errorEvent.powerAssertContext) {
                throw e;
            }
            var poweredMessage;
            if (config.modifyMessageOnRethrow || config.saveContextOnRethrow) {
                poweredMessage = buildPowerAssertText(formatter, errorEvent.originalMessage, errorEvent.powerAssertContext);
                if (shouldRecreateAssertionError) {
                    e = new assert.AssertionError({
                        message: poweredMessage,
                        actual: e.actual,
                        expected: e.expected,
                        operator: e.operator,
                        stackStartFunction: e.stackStartFunction || onError
                    });
                    e.generatedMessage = false;
                }
            }
            if (config.modifyMessageOnRethrow && !shouldRecreateAssertionError) {
                e.message = poweredMessage;
                e.generatedMessage = false;
            }
            if (config.saveContextOnRethrow) {
                e.powerAssertContext = errorEvent.powerAssertContext;
            }
            throw e;
        }
    });
    var enhancedAssert = empowerCore(assert, empowerCoreConfig);
    define(enhancedAssert, capturable());
    return enhancedAssert;
}

function buildPowerAssertText (formatter, message, context) {
    // console.log(message);
    var powerAssertText = formatter(context);
    return message ? message + ' ' + powerAssertText : powerAssertText;
};

empower.defaultOptions = defaultOptions;
module.exports = empower;


/***/ }),

/***/ "./node_modules/empower/lib/capturable.js":
/*!************************************************!*\
  !*** ./node_modules/empower/lib/capturable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function capturable () {
    var events = [];

    function _capt (value, espath) {
        events.push({value: value, espath: espath});
        return value;
    }

    function _expr (value, args) {
        var captured = events;
        events = [];
        var source = {
            content: args.content,
            filepath: args.filepath,
            line: args.line
        };
        if (args.generator) {
            source.generator = true;
        }
        if (args.async) {
            source.async = true;
        }
        return {
            powerAssertContext: {
                value: value,
                events: captured
            },
            source: source
        };
    }

    return {
        _capt: _capt,
        _expr: _expr
    };
};


/***/ }),

/***/ "./node_modules/empower/lib/default-options.js":
/*!*****************************************************!*\
  !*** ./node_modules/empower/lib/default-options.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var empowerCore = __webpack_require__(/*! empower-core */ "./node_modules/empower-core/index.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");

module.exports = function defaultOptions () {
    return assign(empowerCore.defaultOptions(), {
        modifyMessageOnRethrow: false,
        saveContextOnRethrow: false
    });
};


/***/ }),

/***/ "./node_modules/empower/lib/define-properties.js":
/*!*******************************************************!*\
  !*** ./node_modules/empower/lib/define-properties.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defineProperty = __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js");
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var keys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");

module.exports = function defineProperties (obj, map) {
    forEach(keys(map), function (name) {
        defineProperty(obj, name, {
            configurable: true,
            enumerable: false,
            value: map[name],
            writable: true
        });
    });
};


/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),

/***/ "./node_modules/espurify/index.js":
/*!****************************************!*\
  !*** ./node_modules/espurify/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * espurify - Clone new AST without extra properties
 *
 * https://github.com/estools/espurify
 *
 * Copyright (c) 2014-2018 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/estools/espurify/blob/master/MIT-LICENSE.txt
 */


var createWhitelist = __webpack_require__(/*! ./lib/create-whitelist */ "./node_modules/espurify/lib/create-whitelist.js");
var cloneWithWhitelist = __webpack_require__(/*! ./lib/clone-ast */ "./node_modules/espurify/lib/clone-ast.js");

function createCloneFunction (options) {
  return cloneWithWhitelist(createWhitelist(options));
}

var espurify = createCloneFunction();
espurify.customize = createCloneFunction;
espurify.cloneWithWhitelist = cloneWithWhitelist;
module.exports = espurify;


/***/ }),

/***/ "./node_modules/espurify/lib/ast-properties.js":
/*!*****************************************************!*\
  !*** ./node_modules/espurify/lib/ast-properties.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  ArrayExpression: ['type', 'elements'],
  ArrayPattern: ['type', 'elements'],
  ArrowFunctionExpression: ['type', 'id', 'params', 'body', 'generator', 'expression', 'async'],
  AssignmentExpression: ['type', 'operator', 'left', 'right'],
  AssignmentPattern: ['type', 'left', 'right'],
  AwaitExpression: ['type', 'argument'],
  BinaryExpression: ['type', 'operator', 'left', 'right'],
  BlockStatement: ['type', 'body'],
  BreakStatement: ['type', 'label'],
  CallExpression: ['type', 'callee', 'arguments'],
  CatchClause: ['type', 'param', 'guard', 'body'],
  ClassBody: ['type', 'body'],
  ClassDeclaration: ['type', 'id', 'superClass', 'body'],
  ClassExpression: ['type', 'id', 'superClass', 'body'],
  ConditionalExpression: ['type', 'test', 'consequent', 'alternate'],
  ContinueStatement: ['type', 'label'],
  DebuggerStatement: ['type'],
  DoWhileStatement: ['type', 'body', 'test'],
  EmptyStatement: ['type'],
  ExportAllDeclaration: ['type', 'source'],
  ExportDefaultDeclaration: ['type', 'declaration'],
  ExportNamedDeclaration: ['type', 'declaration', 'specifiers', 'source'],
  ExportSpecifier: ['type', 'exported', 'local'],
  ExpressionStatement: ['type', 'expression'],
  ForInStatement: ['type', 'left', 'right', 'body'],
  ForOfStatement: ['type', 'left', 'right', 'body', 'await'],
  ForStatement: ['type', 'init', 'test', 'update', 'body'],
  FunctionDeclaration: ['type', 'id', 'params', 'body', 'generator', 'async'],
  FunctionExpression: ['type', 'id', 'params', 'body', 'generator', 'async'],
  Identifier: ['type', 'name'],
  IfStatement: ['type', 'test', 'consequent', 'alternate'],
  ImportDeclaration: ['type', 'specifiers', 'source'],
  ImportDefaultSpecifier: ['type', 'local'],
  ImportNamespaceSpecifier: ['type', 'local'],
  ImportSpecifier: ['type', 'imported', 'local'],
  LabeledStatement: ['type', 'label', 'body'],
  Literal: ['type', 'value', 'regex'],
  LogicalExpression: ['type', 'operator', 'left', 'right'],
  MemberExpression: ['type', 'object', 'property', 'computed'],
  MetaProperty: ['type', 'meta', 'property'],
  MethodDefinition: ['type', 'key', 'value', 'kind', 'computed', 'static'],
  NewExpression: ['type', 'callee', 'arguments'],
  ObjectExpression: ['type', 'properties'],
  ObjectPattern: ['type', 'properties'],
  Program: ['type', 'body', 'sourceType'],
  Property: ['type', 'key', 'value', 'kind', 'method', 'shorthand', 'computed'],
  RestElement: ['type', 'argument'],
  ReturnStatement: ['type', 'argument'],
  SequenceExpression: ['type', 'expressions'],
  SpreadElement: ['type', 'argument'],
  Super: ['type'],
  SwitchCase: ['type', 'test', 'consequent'],
  SwitchStatement: ['type', 'discriminant', 'cases', 'lexical'],
  TaggedTemplateExpression: ['type', 'tag', 'quasi'],
  TemplateElement: ['type', 'tail', 'value'],
  TemplateLiteral: ['type', 'quasis', 'expressions'],
  ThisExpression: ['type'],
  ThrowStatement: ['type', 'argument'],
  TryStatement: ['type', 'block', 'handler', 'finalizer'],
  UnaryExpression: ['type', 'operator', 'prefix', 'argument'],
  UpdateExpression: ['type', 'operator', 'argument', 'prefix'],
  VariableDeclaration: ['type', 'declarations', 'kind'],
  VariableDeclarator: ['type', 'id', 'init'],
  WhileStatement: ['type', 'test', 'body'],
  WithStatement: ['type', 'object', 'body'],
  YieldExpression: ['type', 'argument', 'delegate']
};


/***/ }),

/***/ "./node_modules/espurify/lib/clone-ast.js":
/*!************************************************!*\
  !*** ./node_modules/espurify/lib/clone-ast.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(/*! core-js/library/fn/array/is-array */ "./node_modules/core-js/library/fn/array/is-array.js");
var objectKeys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");
var indexOf = __webpack_require__(/*! core-js/library/fn/array/index-of */ "./node_modules/core-js/library/fn/array/index-of.js");
var Map = __webpack_require__(/*! core-js/library/fn/map */ "./node_modules/core-js/library/fn/map.js");
var reduce = __webpack_require__(/*! core-js/library/fn/array/reduce */ "./node_modules/core-js/library/fn/array/reduce.js");

module.exports = function cloneWithWhitelist (astWhiteList) {
  var whitelist = reduce(objectKeys(astWhiteList), function (props, key) {
    var propNames = astWhiteList[key];
    var prepend = (indexOf(propNames, 'type') === -1) ? ['type'] : [];
    props[key] = prepend.concat(propNames || []);
    return props;
  }, {});

  function cloneNodeOrObject (obj, seen) {
    var props = obj.type ? whitelist[obj.type] : null;
    if (props) {
      return cloneNode(obj, props, seen);
    } else {
      return cloneObject(obj, seen);
    }
  }

  function cloneArray (ary, seen) {
    var i = ary.length;
    var clone = [];
    while (i--) {
      clone[i] = cloneOf(ary[i], seen);
    }
    return clone;
  }

  function cloneNode (node, props, seen) {
    var i, len, key;
    var clone = {};
    for (i = 0, len = props.length; i < len; i += 1) {
      key = props[i];
      if (node.hasOwnProperty(key)) {
        clone[key] = cloneOf(node[key], seen);
      }
    }
    return clone;
  }

  function cloneObject (obj, seen) {
    var props = objectKeys(obj);
    var i, len, key, value;
    var clone = {};
    for (i = 0, len = props.length; i < len; i += 1) {
      key = props[i];
      value = obj[key];
      if (seen.has(value)) {
        continue;
      }
      clone[key] = cloneOf(value, seen);
    }
    return clone;
  }

  function cloneOf (val, seen) {
    if (typeof val === 'object' && val !== null) {
      seen.set(val, true);
      if (val instanceof RegExp) {
        return new RegExp(val);
      } else if (isArray(val)) {
        return cloneArray(val, seen);
      } else {
        return cloneNodeOrObject(val, seen);
      }
    } else {
      return val;
    }
  }

  function cloneRoot (obj) {
    var seen = new Map();
    seen.set(obj, true);
    return cloneNodeOrObject(obj, seen);
  }

  return cloneRoot;
};


/***/ }),

/***/ "./node_modules/espurify/lib/create-whitelist.js":
/*!*******************************************************!*\
  !*** ./node_modules/espurify/lib/create-whitelist.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultProps = __webpack_require__(/*! ./ast-properties */ "./node_modules/espurify/lib/ast-properties.js");
var objectKeys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");

module.exports = function createWhitelist (options) {
  var opts = assign({}, options);
  var typeName, i, len;
  var keys = objectKeys(defaultProps);
  var result = {};
  for (i = 0, len = keys.length; i < len; i += 1) {
    typeName = keys[i];
    result[typeName] = defaultProps[typeName].concat(opts.extra || []);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/estraverse/estraverse.js":
/*!***********************************************!*\
  !*** ./node_modules/estraverse/estraverse.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP,
        REMOVE;

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportExpression: 'ImportExpression',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportExpression: ['source'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (Array.isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (Array.isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (Array.isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = __webpack_require__(/*! ./package.json */ "./node_modules/estraverse/package.json").version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),

/***/ "./node_modules/estraverse/package.json":
/*!**********************************************!*\
  !*** ./node_modules/estraverse/package.json ***!
  \**********************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, bugs, bundleDependencies, deprecated, description, devDependencies, engines, homepage, license, main, maintainers, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"estraverse@^4.1.0\",\"_id\":\"estraverse@4.3.0\",\"_inBundle\":false,\"_integrity\":\"sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==\",\"_location\":\"/estraverse\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"estraverse@^4.1.0\",\"name\":\"estraverse\",\"escapedName\":\"estraverse\",\"rawSpec\":\"^4.1.0\",\"saveSpec\":null,\"fetchSpec\":\"^4.1.0\"},\"_requiredBy\":[\"/eslint-scope\",\"/power-assert-context-reducer-ast\",\"/power-assert-context-traversal\"],\"_resolved\":\"https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz\",\"_shasum\":\"398ad3f3c5a24948be7725e83d11a7de28cdbd1d\",\"_spec\":\"estraverse@^4.1.0\",\"_where\":\"/home/runner/work/sboltools/sboltools/node_modules/power-assert-context-traversal\",\"bugs\":{\"url\":\"https://github.com/estools/estraverse/issues\"},\"bundleDependencies\":false,\"deprecated\":false,\"description\":\"ECMAScript JS AST traversal functions\",\"devDependencies\":{\"babel-preset-env\":\"^1.6.1\",\"babel-register\":\"^6.3.13\",\"chai\":\"^2.1.1\",\"espree\":\"^1.11.0\",\"gulp\":\"^3.8.10\",\"gulp-bump\":\"^0.2.2\",\"gulp-filter\":\"^2.0.0\",\"gulp-git\":\"^1.0.1\",\"gulp-tag-version\":\"^1.3.0\",\"jshint\":\"^2.5.6\",\"mocha\":\"^2.1.0\"},\"engines\":{\"node\":\">=4.0\"},\"homepage\":\"https://github.com/estools/estraverse\",\"license\":\"BSD-2-Clause\",\"main\":\"estraverse.js\",\"maintainers\":[{\"name\":\"Yusuke Suzuki\",\"email\":\"utatane.tea@gmail.com\",\"url\":\"http://github.com/Constellation\"}],\"name\":\"estraverse\",\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/estools/estraverse.git\"},\"scripts\":{\"lint\":\"jshint estraverse.js\",\"test\":\"npm run-script lint && npm run-script unit-test\",\"unit-test\":\"mocha --compilers js:babel-register\"},\"version\":\"4.3.0\"}");

/***/ }),

/***/ "./node_modules/genbankjs/genbank.js":
/*!*******************************************!*\
  !*** ./node_modules/genbankjs/genbank.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {


exports.parseGBF = function parseGBF(gbf) {

    gbf = gbf.split('\n');

    for(var origin = 0; origin < gbf.length; ++ origin)
        if(gbf[origin].indexOf('ORIGIN') === 0)
            break;

    var record = {

        /* Collapse everything after the origin (the sequence) into a single
         * string, removing line numbers and spaces.
         */
        sequence: gbf.slice(origin + 1).map(function(line) {

            return line.trim().split(' ').slice(1).join('');

        }).join('')

    };

    /* Parse everything before the ORIGIN (the annotations) with parseFlatFile
     */
    parseFlatFile(gbf.slice(0, origin)).forEach(function(field) {

        switch(field.name)
        {
        case 'LOCUS':

            /* LOCUS       SCU49845                5028 bp    DNA     PLN 23-MAR-2010 */
            var locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([A-Z]+) +(\d\d-[A-Z]{3}-\d{4})/);

            if(locus !== null) {

                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.division = locus[4];
                record.modified = locus[5];
            }

            /* LOCUS       SCU49845                5028 bp    DNA     linear   PLN 23-MAR-2010 */
            locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([a-z]+) +([A-Z]+) +(\d\d-[A-Z]{3}-\d{4})/);

            if(locus !== null) {

                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.moleculeTypeDisp = locus[4];
                record.division = locus[5];
                record.modified = locus[6];
            }

            /* LOCUS       Ga0070195_11      1491782 bp      DNA linear      29-MAR-2016 */
            locus = field.value[0].match(/([^\s]+) +(\d+) bp +([A-Z]+) +([a-z]+) +(\d\d-[A-Z]{3}-\d{4})/);

            if(locus !== null) {

                record.locusName = locus[1];
                record.sequenceLength = locus[2];
                record.moleculeType = locus[3];
                record.moleculeTypeDisp = locus[4];
                record.modified = locus[5];
            }

            break;

        case 'DEFINITION':

            record.definition = field.value.join(' ');
            break;

        case 'ACCESSION':

            record.accession = field.value.join(' ');
            break;

        case 'VERSION':

            record.version = field.value.join(' ');
            break;

        case 'KEYWORDS':

            if(field.value == '.')
                break;

            /* TODO */

            break;

        case 'SOURCE':

            record.source = {
                name: field.value.join(' ')
            };

            field.children.forEach(function(subfield) {

                if(subfield.name == 'ORGANISM') {

                    record.source.organism = {

                        name: subfield.value[0],

                        lineage: subfield.value.slice(1).join(' ').split('; ').map(function(s) {

                            s = s.trim();

                            return s[s.length - 1] == '.' ? s.slice(0, s.length - 1) : s;
                        })
                    };
                }
            });

            break;

        case 'REFERENCE':

            if(record.references === undefined)
                record.references = [];

            var bases = field.value[0].match(/^([0-9]+) +\(bases ([0-9]+) to ([0-9]+)\)$/);

            var reference = bases !== null ? {

                number: parseInt(bases[1]),
                start: parseInt(bases[2]),
                end: parseInt(bases[3])

            } : {};

            field.children.forEach(function(subfield) {
                switch(subfield.name)
                {
                case 'AUTHORS':
                    reference.authors = subfield.value.join(' ');
                    break;

                case 'TITLE':
                    reference.title = subfield.value.join(' ');
                    break;

                case 'JOURNAL':
                    reference.journal = subfield.value.join(' ');
                    break;

                case 'PUBMED':
                    reference.pubmed = subfield.value.join(' ');
                    break;
                };
            });

            record.references.push(reference);

            break;

       case 'FEATURES':

            record.features = [];

            field.children.forEach(function(feature) {

                var location = ''

                for(var i = 0; i < feature.value.length; ++ i) {

                    if(feature.value[i][0] === '/')
                        break

                    location += feature.value[i]
                }

                var f = {
                    key: feature.name,
                    location: parseLocation(location)
                };

                var qualifier;

                /* TODO look for/process specific qualifiers?
                 */
                for(; i < feature.value.length; ++ i) {

                    var qualifierLine = feature.value[i];

                    if(qualifierLine[0] === '/') {

                        qualifier = qualifierLine.split('=')[0];
 
                        var value = qualifierLine.split('"')[1];

                        if(!f[qualifier])
                            f[qualifier] = [ value ]
                        else
                            f[qualifier].push(value)

                    } else {

                        var value = qualifierLine.split('"')[0];

                        if(qualifier !== '/translation')
                            value = ' ' + value

                        f[qualifier][f[qualifier].length - 1] += value
                    }

                }

                record.features.push(f);
            });

            break;
        };
    });

    if(record.references){

        record.references = record.references.sort(function(a, b) {
            return a.number - b.number;
        });
    }
	
    return record;
}


function parseLocation(location) {

    var match = location.match(/([a-z]+)\((.*)\)/)

    if(match !== null) {

        var modifier = match[1]

        if(modifier === 'complement') {

            var innerLocation = parseLocation(match[2])

            innerLocation.strand = 'complementary'

            return innerLocation

        } else if(modifier === 'join') {

            return match[2].split(',').map(parseLocation)

        } else {

            throw new Error('unknown modifier: ' + modifier)

        }

    } else {

        var partial3Prime = location.indexOf('<') !== -1;
        var partial5Prime = location.indexOf('>') !== -1;

        var startEndMatch = location.replace(/[<>]/g, '').match(/^([0-9]+)\.\.([0-9]+)$/);

        if ( startEndMatch == null && location.match(/^([0-9]+)$/) ){
            return {
                start: parseInt(location),
                end: parseInt(location),
                partial3Prime: partial3Prime,
                partial5Prime: partial5Prime
            }
        } else {
            return {
                start: parseInt(startEndMatch[1]),
                end: parseInt(startEndMatch[2]),
                partial3Prime: partial3Prime,
                partial5Prime: partial5Prime
            }
        }
    }
}

function parseFlatFile(lines) {

    function getIndent(line) {

        for(var indent = 0; line[indent] == ' '; )
            ++ indent;

        return indent;
    }

    function readFields(indent) {

        var fields = [],
            field,
            valueColumn;

        while(lines.length > 0) {

            var line = lines[0];

            var lineIndent = getIndent(line);

            if(lineIndent < indent)
                break;

            if(lineIndent > indent) {

                if(lineIndent != valueColumn) {

                    /* children of prev field
                     */
                    field.children = readFields(lineIndent);
                    continue;
                }

                /* continuation
                 */
                field.value.push(line.slice(lineIndent));
            }

            if(lineIndent == indent) {

                /* new field
                 */
                var delim = line.indexOf(' ', lineIndent);

                valueColumn = delim + getIndent(line.slice(delim));

                field = {
                    name: line.slice(lineIndent, delim),
                    value: [ line.slice(valueColumn) ]
                };

                fields.push(field);
            }

            lines = lines.slice(1);
        }

        return fields;
    }

    return readFields(0);
}



/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(/*! util */ "util");
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "./node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/ansi-styles/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/ansi-styles/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
const colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/json-colorizer/node_modules/color-convert/index.js");

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/chalk/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/chalk/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ "./node_modules/escape-string-regexp/index.js");
const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/json-colorizer/node_modules/ansi-styles/index.js");
const stdoutColor = __webpack_require__(/*! supports-color */ "./node_modules/json-colorizer/node_modules/supports-color/index.js").stdout;

const template = __webpack_require__(/*! ./templates.js */ "./node_modules/json-colorizer/node_modules/chalk/templates.js");

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/chalk/templates.js":
/*!*********************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/chalk/templates.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/color-convert/conversions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/color-convert/conversions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/json-colorizer/node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/color-convert/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/color-convert/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/json-colorizer/node_modules/color-convert/conversions.js");
var route = __webpack_require__(/*! ./route */ "./node_modules/json-colorizer/node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/color-convert/route.js":
/*!*************************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/color-convert/route.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/json-colorizer/node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/color-name/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/color-name/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/has-flag/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/has-flag/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),

/***/ "./node_modules/json-colorizer/node_modules/supports-color/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/json-colorizer/node_modules/supports-color/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/json-colorizer/node_modules/has-flag/index.js");

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),

/***/ "./node_modules/json-colorizer/src/lib/colorizer.js":
/*!**********************************************************!*\
  !*** ./node_modules/json-colorizer/src/lib/colorizer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const chalk = __webpack_require__(/*! chalk */ "./node_modules/json-colorizer/node_modules/chalk/index.js");
const get = __webpack_require__(/*! lodash.get */ "./node_modules/lodash.get/index.js");

const defaultColors = {
  BRACE: 'gray',
  BRACKET: 'gray',
  COLON: 'gray',
  COMMA: 'gray',
  STRING_KEY: 'magenta',
  STRING_LITERAL: 'yellow',
  NUMBER_LITERAL: 'green',
  BOOLEAN_LITERAL: 'cyan',
  NULL_LITERAL: 'white'
};

exports.colorize = function colorize(tokens, options = {}) {
  const colors = options.colors || {};

  return tokens.reduce((acc, token) => {
    const colorKey = colors[token.type] || defaultColors[token.type];
    const colorFn = colorKey && colorKey[0] === '#' ? chalk.hex(colorKey) : get(chalk, colorKey);

    return acc + (colorFn ? colorFn(token.value) : token.value);
  }, '');
};


/***/ }),

/***/ "./node_modules/json-colorizer/src/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/json-colorizer/src/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const lexer = __webpack_require__(/*! ./lexer */ "./node_modules/json-colorizer/src/lib/lexer.js");
const colorizer = __webpack_require__(/*! ./colorizer */ "./node_modules/json-colorizer/src/lib/colorizer.js");

module.exports = function colorizeJson(json, options) {
  return colorizer.colorize(lexer.getTokens(json, options), options);
};


/***/ }),

/***/ "./node_modules/json-colorizer/src/lib/lexer.js":
/*!******************************************************!*\
  !*** ./node_modules/json-colorizer/src/lib/lexer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const tokenTypes = [
  { regex: /^\s+/, tokenType: 'WHITESPACE' },
  { regex: /^[{}]/, tokenType: 'BRACE' },
  { regex: /^[[\]]/, tokenType: 'BRACKET' },
  { regex: /^:/, tokenType: 'COLON' },
  { regex: /^,/, tokenType: 'COMMA' },
  { regex: /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?/i, tokenType: 'NUMBER_LITERAL' },
  { regex: /^"(?:\\.|[^"\\])*"(?=\s*:)/, tokenType: 'STRING_KEY' },
  { regex: /^"(?:\\.|[^"\\])*"/, tokenType: 'STRING_LITERAL' },
  { regex: /^true|^false/, tokenType: 'BOOLEAN_LITERAL' },
  { regex: /^null/, tokenType: 'NULL_LITERAL' }
];

exports.getTokens = function getTokens(json, options = {}) {
  let input;

  if (options.pretty) {
    const inputObj = typeof json === 'string' ? JSON.parse(json) : json;
    input = JSON.stringify(inputObj, null, 2);
  } else {
    input = typeof json === 'string' ? json : JSON.stringify(json);
  }

  let tokens = [];
  let foundToken;

  do {
    foundToken = false;
    for (let i = 0; i < tokenTypes.length; i++) {
      const match = tokenTypes[i].regex.exec(input);
      if (match) {
        tokens.push({ type: tokenTypes[i].tokenType, value: match[0] });
        input = input.substring(match[0].length);
        foundToken = true;
        break;
      }
    }
  } while (_allTokensAnalyzed(input, foundToken));

  return tokens;
};

/**
 * @author Willian Magalhães Gonçalves
 * @description Are all tokens analyzed?
 * @param {*} input - Input
 * @param {*} foundToken - Found token
 * @returns {boolean} checkResult - Check result
 * @private
 */
function _allTokensAnalyzed(input, foundToken) {
  const safeInput = input || {};

  const inputLength = safeInput.length;
  return inputLength > 0 && foundToken;
}


/***/ }),

/***/ "./node_modules/lodash.get/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.get/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/nanoid/format.js":
/*!***************************************!*\
  !*** ./node_modules/nanoid/format.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Secure random string generator with custom alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * @param {generator} random The random bytes generator.
 * @param {string} alphabet Symbols to be used in new random string.
 * @param {size} size The number of symbols in new random string.
 *
 * @return {string} Random string.
 *
 * @example
 * const format = require('nanoid/format')
 *
 * function random (size) {
 *   const result = []
 *   for (let i = 0; i < size; i++) {
 *     result.push(randomByte())
 *   }
 *   return result
 * }
 *
 * format(random, "abcdef", 5) //=> "fbaef"
 *
 * @name format
 * @function
 */
module.exports = function (random, alphabet, size) {
  // We can’t use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  var mask = (2 << 31 - Math.clz32((alphabet.length - 1) | 1)) - 1
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).
  var step = Math.ceil(1.6 * mask * size / alphabet.length)
  var id = ''

  while (true) {
    var bytes = random(step)
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || ''
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
}

/**
 * @callback generator
 * @param {number} bytes The number of bytes to generate.
 * @return {number[]} Random bytes.
 */


/***/ }),

/***/ "./node_modules/nanoid/random.js":
/*!***************************************!*\
  !*** ./node_modules/nanoid/random.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var crypto = __webpack_require__(/*! crypto */ "crypto")

if (crypto.randomFillSync) {
  // We reuse buffers with the same size to avoid memory fragmentations
  // for better performance
  var buffers = { }
  module.exports = function (bytes) {
    var buffer = buffers[bytes]
    if (!buffer) {
      // `Buffer.allocUnsafe()` faster because it don’t clean memory.
      // We do not need it, since we will fill memory with new bytes anyway.
      buffer = Buffer.allocUnsafe(bytes)
      if (bytes <= 255) buffers[bytes] = buffer
    }
    return crypto.randomFillSync(buffer)
  }
} else {
  module.exports = crypto.randomBytes
}


/***/ }),

/***/ "./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/*! exports provided: default, Headers, Request, Response, FetchError */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchError", function() { return FetchError; });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zlib */ "zlib");






// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;
const format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;

const streamDestructionSupported = 'destroy' in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;
const resolve_url = url__WEBPACK_IMPORTED_MODULE_2__.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_3__ : http__WEBPACK_IMPORTED_MODULE_1__).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH,
				finishFlush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflate());
					} else {
						body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress === 'function') {
				body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

/* harmony default export */ __webpack_exports__["default"] = (fetch);



/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/power-assert-context-formatter/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/power-assert-context-formatter/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/create-formatter */ "./node_modules/power-assert-context-formatter/lib/create-formatter.js");


/***/ }),

/***/ "./node_modules/power-assert-context-formatter/lib/create-formatter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/power-assert-context-formatter/lib/create-formatter.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var ContextTraversal = __webpack_require__(/*! power-assert-context-traversal */ "./node_modules/power-assert-context-traversal/index.js");
var LegacyContextTraversal = __webpack_require__(/*! ./legacy-context-traversal */ "./node_modules/power-assert-context-formatter/lib/legacy-context-traversal.js");
var StringWriter = __webpack_require__(/*! ./string-writer */ "./node_modules/power-assert-context-formatter/lib/string-writer.js");
var defaultOptions = __webpack_require__(/*! ./default-options */ "./node_modules/power-assert-context-formatter/lib/default-options.js");
var reduce = __webpack_require__(/*! core-js/library/fn/array/reduce */ "./node_modules/core-js/library/fn/array/reduce.js");

/**
 * options.reducers [array]
 * options.renderers [array]
 * options.outputOffset [number]
 * options.lineSeparator [string]
 * options.legacy [boolean]
 */
function createFormatter (options) {
    var formatterConfig = assign({}, defaultOptions(), options);
    var reducers = formatterConfig.reducers || [];
    var rendererConfigs = formatterConfig.renderers;
    var len = rendererConfigs.length;

    return function (powerAssertContext) {
        var context = reduce(reducers, function (prevContext, reducer) {
            return reducer(prevContext);
        }, powerAssertContext);
        var writer = new StringWriter(formatterConfig);
        var traversal;
        if (formatterConfig.legacy) {
            traversal = new LegacyContextTraversal(context);
            traversal.setWritable(writer);
        } else {
            traversal = new ContextTraversal(context);
        }
        for (var i = 0; i < len; i += 1) {
            var RendererClass;
            var renderer;
            var config = rendererConfigs[i];
            if (typeof config === 'object') {
                RendererClass = config.ctor;
                renderer = new RendererClass(config.options);
            } else if (typeof config === 'function') {
                RendererClass = config;
                renderer = new RendererClass();
            }
            renderer.init(traversal);
            if (typeof renderer.setWritable === 'function') {
                renderer.setWritable(writer);
            }
        }
        traversal.traverse();
        writer.write('');
        return writer.toString();
    };
}

createFormatter.StringWriter = StringWriter;
module.exports = createFormatter;


/***/ }),

/***/ "./node_modules/power-assert-context-formatter/lib/default-options.js":
/*!****************************************************************************!*\
  !*** ./node_modules/power-assert-context-formatter/lib/default-options.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function defaultOptions () {
    return {
        reducers: [
        ],
        legacy: false,
        outputOffset: 2,
        lineSeparator: '\n'
    };
};


/***/ }),

/***/ "./node_modules/power-assert-context-formatter/lib/legacy-context-traversal.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/power-assert-context-formatter/lib/legacy-context-traversal.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ContextTraversal = __webpack_require__(/*! power-assert-context-traversal */ "./node_modules/power-assert-context-traversal/index.js");
var inherits = __webpack_require__(/*! util */ "util").inherits;
var slice = Array.prototype.slice;

function LegacyContextTraversal (powerAssertContext) {
    ContextTraversal.call(this, powerAssertContext);
}
inherits(LegacyContextTraversal, ContextTraversal);

LegacyContextTraversal.prototype.setWritable = function (writer) {
    this.writer = writer;
};

LegacyContextTraversal.prototype.on = function () {
    var args = slice.apply(arguments);
    if (args[0] === 'render') {
        args[0] = 'end';
    }
    ContextTraversal.prototype.on.apply(this, args);
};

LegacyContextTraversal.prototype.emit = function () {
    var args = slice.apply(arguments);
    if (args[0] === 'end') {
        args[1] = this.writer;
    }
    ContextTraversal.prototype.emit.apply(this, args);
};

module.exports = LegacyContextTraversal;


/***/ }),

/***/ "./node_modules/power-assert-context-formatter/lib/string-writer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/power-assert-context-formatter/lib/string-writer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function spacerStr (len) {
    var str = '';
    for(var i = 0; i < len; i += 1) {
        str += ' ';
    }
    return str;
}

function StringWriter (config) {
    this.lines = [];
    this.lineSeparator = config.lineSeparator;
    this.regex = new RegExp(this.lineSeparator, 'g');
    this.spacer = spacerStr(config.outputOffset);
}

StringWriter.prototype.write = function (str) {
    this.lines.push(this.spacer + str.replace(this.regex, this.lineSeparator + this.spacer));
};

StringWriter.prototype.toString = function () {
    var str = this.lines.join(this.lineSeparator);
    this.lines.length = 0;
    return str;
};

module.exports = StringWriter;


/***/ }),

/***/ "./node_modules/power-assert-context-reducer-ast/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/power-assert-context-reducer-ast/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parser = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.es.js");
__webpack_require__(/*! acorn-es7-plugin */ "./node_modules/acorn-es7-plugin/acorn-es7-plugin.js")(parser);
var estraverse = __webpack_require__(/*! estraverse */ "./node_modules/estraverse/estraverse.js");
var purifyAst = __webpack_require__(/*! espurify */ "./node_modules/espurify/index.js").customize({extra: ['range']});
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");

module.exports = function (powerAssertContext) {
    var source = powerAssertContext.source;
    if (source.ast && source.tokens && source.visitorKeys) {
        return powerAssertContext;
    }
    var astAndTokens;
    try {
        astAndTokens = parse(source);
    } catch (e) {
        return assign({}, powerAssertContext, { source: assign({}, source, { error: e }) });
    }
    var newSource = assign({}, source, {
        ast: purifyAst(astAndTokens.expression),
        tokens: astAndTokens.tokens,
        visitorKeys: estraverse.VisitorKeys
    });
    return assign({}, powerAssertContext, { source: newSource });
};

function parserOptions(tokens) {
    return {
        sourceType: 'module',
        ecmaVersion: 2018,
        locations: true,
        ranges: false,
        onToken: tokens,
        plugins: {asyncawait: true}
    };
}

function parse (source) {
    var code = source.content;
    var ast, tokens;

    function doParse(wrapper) {
        var content = wrapper ? wrapper(code) : code;
        var tokenBag = [];
        ast = parser.parse(content, parserOptions(tokenBag));
        if (wrapper) {
            ast = ast.body[0].body;
            tokens = tokenBag.slice(6, -2);
        } else {
            tokens = tokenBag.slice(0, -1);
        }
    }

    if (source.async) {
        doParse(wrappedInAsync);
    } else if (source.generator) {
        doParse(wrappedInGenerator);
    } else {
        doParse();
    }

    var exp = ast.body[0].expression;
    var columnOffset = exp.loc.start.column;
    var offsetTree = estraverse.replace(exp, {
        keys: estraverse.VisitorKeys,
        enter: function (eachNode) {
            if (!eachNode.loc && eachNode.range) {
                // skip already visited node
                return eachNode;
            }
            eachNode.range = [
                eachNode.loc.start.column - columnOffset,
                eachNode.loc.end.column - columnOffset
            ];
            delete eachNode.loc;
            return eachNode;
        }
    });

    return {
        tokens: offsetAndSlimDownTokens(tokens),
        expression: offsetTree
    };
}

function wrappedInGenerator (jsCode) {
    return 'function *wrapper() { ' + jsCode + ' }';
}

function wrappedInAsync (jsCode) {
    return 'async function wrapper() { ' + jsCode + ' }';
}

function offsetAndSlimDownTokens (tokens) {
    var i, token, newToken, result = [];
    var columnOffset;
    for(i = 0; i < tokens.length; i += 1) {
        token = tokens[i];
        if (i === 0) {
            columnOffset = token.loc.start.column;
        }
        newToken = {
            type: {
                label: token.type.label
            }
        };
        if (typeof token.value !== 'undefined') {
            newToken.value = token.value;
        }
        newToken.range = [
            token.loc.start.column - columnOffset,
            token.loc.end.column - columnOffset
        ];
        result.push(newToken);
    }
    return result;
}


/***/ }),

/***/ "./node_modules/power-assert-context-traversal/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/power-assert-context-traversal/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/context-traversal */ "./node_modules/power-assert-context-traversal/lib/context-traversal.js");


/***/ }),

/***/ "./node_modules/power-assert-context-traversal/lib/context-traversal.js":
/*!******************************************************************************!*\
  !*** ./node_modules/power-assert-context-traversal/lib/context-traversal.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var inherits = __webpack_require__(/*! util */ "util").inherits;
var estraverse = __webpack_require__(/*! estraverse */ "./node_modules/estraverse/estraverse.js");
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var reduce = __webpack_require__(/*! core-js/library/fn/array/reduce */ "./node_modules/core-js/library/fn/array/reduce.js");
var locationOf = __webpack_require__(/*! ./location */ "./node_modules/power-assert-context-traversal/lib/location.js");
var literalPattern = /^(?:String|Numeric|Null|Boolean|RegExp)?Literal$/;
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");

function ContextTraversal (powerAssertContext) {
    this.powerAssertContext = powerAssertContext;
    EventEmitter.call(this);
}
inherits(ContextTraversal, EventEmitter);

ContextTraversal.prototype.traverse = function () {
    var _this = this;
    var source = _this.powerAssertContext.source;
    parseIfJson(source, 'ast');
    parseIfJson(source, 'tokens');
    parseIfJson(source, 'visitorKeys');
    _this.emit('start', this.powerAssertContext);
    forEach(this.powerAssertContext.args, function (capturedArgument) {
        onEachEsNode(capturedArgument, source, function (esNode) {
            _this.emit('data', esNode);
        });
    });
    _this.emit('end');
};

function parseIfJson (source, propName) {
    if (typeof source[propName] === 'string') {
        source[propName] = JSON.parse(source[propName]);
    }
}

function onEachEsNode(capturedArgument, source, callback) {
    var espathToValue = reduce(capturedArgument.events, function (accum, ev) {
        accum[ev.espath] = ev.value;
        return accum;
    }, {});
    var nodeStack = [];
    estraverse.traverse(source.ast, {
        keys: source.visitorKeys,
        enter: function (currentNode, parentNode) {
            var parentEsNode = (0 < nodeStack.length) ? nodeStack[nodeStack.length - 1] : null;
            var esNode = createEsNode(this.path(), currentNode, espathToValue, source.content, source.tokens, parentEsNode);
            nodeStack.push(esNode);
            callback(esNode);
        },
        leave: function (currentNode, parentNode) {
            nodeStack.pop();
        }
    });
}

function isLiteral (node) {
    return literalPattern.test(node.type);
}

function createEsNode (path, currentNode, espathToValue, jsCode, tokens, parent) {
    var espath = path ? path.join('/') : '';
    return {
        espath: espath,
        parent: parent,
        key: path ? path[path.length - 1] : null,
        node: currentNode,
        code: jsCode.slice(currentNode.range[0], currentNode.range[1]),
        value: isLiteral(currentNode) ? currentNode.value : espathToValue[espath],
        isCaptured: espathToValue.hasOwnProperty(espath),
        range: locationOf(currentNode, tokens)
    };
}

module.exports = ContextTraversal;


/***/ }),

/***/ "./node_modules/power-assert-context-traversal/lib/location.js":
/*!*********************************************************************!*\
  !*** ./node_modules/power-assert-context-traversal/lib/location.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var syntax = __webpack_require__(/*! estraverse */ "./node_modules/estraverse/estraverse.js").Syntax;

function locationOf(currentNode, tokens) {
    switch(currentNode.type) {
    case syntax.MemberExpression:
        return propertyLocationOf(currentNode, tokens);
    case syntax.CallExpression:
        if (currentNode.callee.type === syntax.MemberExpression) {
            return propertyLocationOf(currentNode.callee, tokens);
        }
        break;
    case syntax.BinaryExpression:
    case syntax.LogicalExpression:
    case syntax.AssignmentExpression:
        return infixOperatorLocationOf(currentNode, tokens);
    default:
        break;
    }
    return currentNode.range;
}

function propertyLocationOf(memberExpression, tokens) {
    var prop = memberExpression.property;
    var token;
    if (!memberExpression.computed) {
        return prop.range;
    }
    token = findLeftBracketTokenOf(memberExpression, tokens);
    return token ? token.range : prop.range;
}

// calculate location of infix operator for BinaryExpression, AssignmentExpression and LogicalExpression.
function infixOperatorLocationOf (expression, tokens) {
    var token = findOperatorTokenOf(expression, tokens);
    return token ? token.range : expression.left.range;
}

function findLeftBracketTokenOf(expression, tokens) {
    var fromColumn = expression.property.range[0];
    return searchToken(tokens, function (token, index) {
        var prevToken;
        if (token.range[0] === fromColumn) {
            prevToken = tokens[index - 1];
            // if (prevToken.type === 'Punctuator' && prevToken.value === '[') {  // esprima
            if (prevToken.type.label === '[') {  // acorn
                return prevToken;
            }
        }
        return undefined;
    });
}

function findOperatorTokenOf(expression, tokens) {
    var fromColumn = expression.left.range[1];
    var toColumn = expression.right.range[0];
    return searchToken(tokens, function (token, index) {
        if (fromColumn < token.range[0] &&
            token.range[1] < toColumn &&
            token.value === expression.operator) {
            return token;
        }
        return undefined;
    });
}

function searchToken(tokens, predicate) {
    var i, token, found;
    for(i = 0; i < tokens.length; i += 1) {
        token = tokens[i];
        found = predicate(token, i);
        if (found) {
            return found;
        }
    }
    return undefined;
}

module.exports = locationOf;


/***/ }),

/***/ "./node_modules/power-assert-formatter/index.js":
/*!******************************************************!*\
  !*** ./node_modules/power-assert-formatter/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * power-assert-formatter.js - Power Assert output formatter
 *
 * https://github.com/power-assert-js/power-assert-formatter
 *
 * Copyright (c) 2013-2016 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/power-assert-formatter/blob/master/MIT-LICENSE.txt
 */


module.exports = __webpack_require__(/*! ./lib/create */ "./node_modules/power-assert-formatter/lib/create.js");


/***/ }),

/***/ "./node_modules/power-assert-formatter/lib sync recursive":
/*!******************************************************!*\
  !*** ./node_modules/power-assert-formatter/lib sync ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/power-assert-formatter/lib sync recursive";

/***/ }),

/***/ "./node_modules/power-assert-formatter/lib/create.js":
/*!***********************************************************!*\
  !*** ./node_modules/power-assert-formatter/lib/create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createFormatter = __webpack_require__(/*! power-assert-context-formatter */ "./node_modules/power-assert-context-formatter/index.js");
var appendAst = __webpack_require__(/*! power-assert-context-reducer-ast */ "./node_modules/power-assert-context-reducer-ast/index.js");
var FileRenderer = __webpack_require__(/*! power-assert-renderer-file */ "./node_modules/power-assert-renderer-file/index.js");
var AssertionRenderer = __webpack_require__(/*! power-assert-renderer-assertion */ "./node_modules/power-assert-renderer-assertion/index.js");
var DiagramRenderer = __webpack_require__(/*! power-assert-renderer-diagram */ "./node_modules/power-assert-renderer-diagram/index.js");
var ComparisonRenderer = __webpack_require__(/*! power-assert-renderer-comparison */ "./node_modules/power-assert-renderer-comparison/index.js");
var defaultOptions = __webpack_require__(/*! ./default-options */ "./node_modules/power-assert-formatter/lib/default-options.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var map = __webpack_require__(/*! core-js/library/fn/array/map */ "./node_modules/core-js/library/fn/array/map.js");

// "Browserify can only analyze static requires. It is not in the scope of browserify to handle dynamic requires."
// https://github.com/substack/node-browserify/issues/377
var defaultRendererClasses = {
    './built-in/file': FileRenderer,
    './built-in/assertion': AssertionRenderer,
    './built-in/diagram': DiagramRenderer,
    './built-in/binary-expression': ComparisonRenderer
};

function toRendererClass (rendererName) {
    var RendererClass;
    if (typeof rendererName === 'function') {
        RendererClass = rendererName;
    } else if (typeof rendererName === 'string') {
        if (defaultRendererClasses[rendererName]) {
            RendererClass = defaultRendererClasses[rendererName];
        } else {
            RendererClass = __webpack_require__("./node_modules/power-assert-formatter/lib sync recursive")(rendererName);
        }
    }
    return RendererClass;
}

function create (options) {
    var config = assign(defaultOptions(), options);
    var rendererClasses = map(config.renderers, toRendererClass);
    var renderers = map(rendererClasses, function (clazz) {
        return { ctor: clazz, options: config };
    });
    return createFormatter(assign({}, config, {
        reducers: [
            appendAst
        ],
        renderers: renderers,
        legacy: true
    }));
}

create.renderers = {
    AssertionRenderer: AssertionRenderer,
    FileRenderer: FileRenderer,
    DiagramRenderer: DiagramRenderer,
    BinaryExpressionRenderer: ComparisonRenderer
};
create.defaultOptions = defaultOptions;
module.exports = create;


/***/ }),

/***/ "./node_modules/power-assert-formatter/lib/default-options.js":
/*!********************************************************************!*\
  !*** ./node_modules/power-assert-formatter/lib/default-options.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function defaultOptions () {
    return {
        lineDiffThreshold: 5,
        maxDepth: 1,
        outputOffset: 2,
        anonymous: 'Object',
        circular: '#@Circular#',
        lineSeparator: '\n',
        ambiguousEastAsianCharWidth: 2,
        renderers: [
            './built-in/file',
            './built-in/assertion',
            './built-in/diagram',
            './built-in/binary-expression'
        ]
    };
};


/***/ }),

/***/ "./node_modules/power-assert-renderer-assertion/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/power-assert-renderer-assertion/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BaseRenderer = __webpack_require__(/*! power-assert-renderer-base */ "./node_modules/power-assert-renderer-base/index.js");
var stringWidth = __webpack_require__(/*! power-assert-util-string-width */ "./node_modules/power-assert-util-string-width/index.js");
var inherits = __webpack_require__(/*! util */ "util").inherits;

function AssertionRenderer () {
    BaseRenderer.call(this);
}
inherits(AssertionRenderer, BaseRenderer);

AssertionRenderer.prototype.onStart = function (context) {
    this.context = context;
    this.assertionLine = context.source.content;
};

AssertionRenderer.prototype.onEnd = function () {
    this.write('');
    this.write(this.assertionLine);
    var e = this.context.source.error;
    if (e && e instanceof SyntaxError) {
        var re = /Unexpected token \(1\:(\d+)\)/;
        var matchResult = re.exec(e.message);
        if (matchResult) {
            var syntaxErrorIndex = Number(matchResult[1]);
            this.renderValueAt(syntaxErrorIndex, '?');
            this.renderValueAt(syntaxErrorIndex, '?');
            this.renderValueAt(syntaxErrorIndex, e.toString());
            this.renderValueAt(0, '');
            this.renderValueAt(0, 'If you are using `babel-plugin-espower` and want to use experimental syntax in your assert(), you should set `embedAst` option to true.');
            this.renderValueAt(0, 'see: https://github.com/power-assert-js/babel-plugin-espower#optionsembedast');
        }
    }
};

AssertionRenderer.prototype.renderValueAt = function (idx, str) {
    var row = createRow(stringWidth(this.assertionLine), ' ');
    replaceColumn(idx, row, str);
    this.write(row.join(''));
};

function replaceColumn (columnIndex, row, str) {
    var i, width = stringWidth(str);
    for (i = 0; i < width; i += 1) {
        row.splice(columnIndex + i, 1, str.charAt(i));
    }
}

function createRow (numCols, initial) {
    var row = [], i;
    for(i = 0; i < numCols; i += 1) {
        row[i] = initial;
    }
    return row;
}

module.exports = AssertionRenderer;


/***/ }),

/***/ "./node_modules/power-assert-renderer-base/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/power-assert-renderer-base/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function BaseRenderer () {
}

BaseRenderer.prototype.init = function (traversal) {
    var _this = this;
    traversal.on('start', function (context) {
        _this.onStart(context);
    });
    traversal.on('data', function (esNode) {
        _this.onData(esNode);
    });
    traversal.on('end', function () {
        _this.onEnd();
    });
};

BaseRenderer.prototype.setWritable = function (writable) {
    this.writable = writable;
};

// API
BaseRenderer.prototype.onStart = function (context) {
};

// API
BaseRenderer.prototype.onData = function (esNode) {
};

// API
BaseRenderer.prototype.onEnd = function () {
};

// API
BaseRenderer.prototype.write = function (str) {
    this.writable.write(str);
};

module.exports = BaseRenderer;


/***/ }),

/***/ "./node_modules/power-assert-renderer-comparison/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/power-assert-renderer-comparison/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BaseRenderer = __webpack_require__(/*! power-assert-renderer-base */ "./node_modules/power-assert-renderer-base/index.js");
var inherits = __webpack_require__(/*! util */ "util").inherits;
var typeName = __webpack_require__(/*! type-name */ "./node_modules/type-name/index.js");
var keys = __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js");
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var udiff = __webpack_require__(/*! ./lib/udiff */ "./node_modules/power-assert-renderer-comparison/lib/udiff.js");
var stringifier = __webpack_require__(/*! stringifier */ "./node_modules/stringifier/index.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var defaultOptions = __webpack_require__(/*! ./lib/default-options */ "./node_modules/power-assert-renderer-comparison/lib/default-options.js");
var literalPattern = /^(?:String|Numeric|Null|Boolean|RegExp)?Literal$/;

function isLiteral (node) {
    return literalPattern.test(node.type);
}

/**
 * options.stringify [function]
 * options.maxDepth [number]
 * options.lineSeparator [string]
 * options.anonymous [string]
 * options.circular [string]
 * 
 * options.diff [function]
 * options.lineDiffThreshold [number]
 */
function ComparisonRenderer (config) {
    BaseRenderer.call(this);
    this.config = assign({}, defaultOptions(), config);
    if (typeof this.config.stringify === 'function') {
        this.stringify = this.config.stringify;
    } else {
        this.stringify = stringifier(this.config);
    }
    if (typeof this.config.diff === 'function') {
        this.diff = this.config.diff;
    } else {
        this.diff = udiff(this.config);
    }
    this.espathToPair = {};
}
inherits(ComparisonRenderer, BaseRenderer);

ComparisonRenderer.prototype.onData = function (esNode) {
    var pair;
    if (!esNode.isCaptured) {
        if (isTargetBinaryExpression(esNode.parent) && isLiteral(esNode.node)) {
            this.espathToPair[esNode.parent.espath][esNode.key] = {code: esNode.code, value: esNode.value};
        }
        return;
    }
    if (isTargetBinaryExpression(esNode.parent)) {
        this.espathToPair[esNode.parent.espath][esNode.key] = {code: esNode.code, value: esNode.value};
    }
    if (isTargetBinaryExpression(esNode)) {
        pair = {
            operator: esNode.node.operator,
            value: esNode.value
        };
        this.espathToPair[esNode.espath] = pair;
    }
};

ComparisonRenderer.prototype.onEnd = function () {
    var _this = this;
    var pairs = [];
    forEach(keys(this.espathToPair), function (espath) {
        var pair = _this.espathToPair[espath];
        if (pair.left && pair.right) {
            pairs.push(pair);
        }
    });
    forEach(pairs, function (pair) {
        _this.compare(pair);
    });
};

ComparisonRenderer.prototype.compare = function (pair) {
    if (isStringDiffTarget(pair)) {
        this.showStringDiff(pair);
    } else {
        this.showExpectedAndActual(pair);
    }
};

ComparisonRenderer.prototype.showExpectedAndActual = function (pair) {
    this.write('');
    this.write('[' + typeName(pair.right.value) + '] ' + pair.right.code);
    this.write('=> ' + this.stringify(pair.right.value));
    this.write('[' + typeName(pair.left.value)  + '] ' + pair.left.code);
    this.write('=> ' + this.stringify(pair.left.value));
};

ComparisonRenderer.prototype.showStringDiff = function (pair) {
    this.write('');
    this.write('--- [string] ' + pair.right.code);
    this.write('+++ [string] ' + pair.left.code);
    this.write(this.diff(pair.right.value, pair.left.value, this.config));
};

function isTargetBinaryExpression (esNode) {
    return esNode &&
        esNode.node.type === 'BinaryExpression' &&
        (esNode.node.operator === '===' || esNode.node.operator === '==') &&
        esNode.isCaptured &&
        !(esNode.value);
}

function isStringDiffTarget(pair) {
    return typeof pair.left.value === 'string' && typeof pair.right.value === 'string';
}

ComparisonRenderer.udiff = udiff;
module.exports = ComparisonRenderer;


/***/ }),

/***/ "./node_modules/power-assert-renderer-comparison/lib/default-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/power-assert-renderer-comparison/lib/default-options.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function defaultOptions () {
    return {
        lineDiffThreshold: 5,
        maxDepth: 2,
        indent: null,
        outputOffset: 2,
        anonymous: 'Object',
        circular: '#@Circular#',
        lineSeparator: '\n'
    };
};


/***/ }),

/***/ "./node_modules/power-assert-renderer-comparison/lib/udiff.js":
/*!********************************************************************!*\
  !*** ./node_modules/power-assert-renderer-comparison/lib/udiff.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DiffMatchPatch = __webpack_require__(/*! diff-match-patch */ "./node_modules/diff-match-patch/index.js");
var dmp = new DiffMatchPatch();

function udiff (config) {
    return function diff (text1, text2) {
        var patch;
        if (config && shouldUseLineLevelDiff(text1, config)) {
            patch = udiffLines(text1, text2);
        } else {
            patch = udiffChars(text1, text2);
        }
        return decodeURIComponent(patch);
    };
}

function shouldUseLineLevelDiff (text, config) {
    return config.lineDiffThreshold < text.split(/\r\n|\r|\n/).length;
}

function udiffLines(text1, text2) {
    /*jshint camelcase: false */
    var a = dmp.diff_linesToChars_(text1, text2);
    var diffs = dmp.diff_main(a.chars1, a.chars2, false);
    dmp.diff_charsToLines_(diffs, a.lineArray);
    dmp.diff_cleanupSemantic(diffs);
    return dmp.patch_toText(dmp.patch_make(text1, diffs));
}

function udiffChars (text1, text2) {
    /*jshint camelcase: false */
    var diffs = dmp.diff_main(text1, text2, false);
    dmp.diff_cleanupSemantic(diffs);
    return dmp.patch_toText(dmp.patch_make(text1, diffs));
}

module.exports = udiff;


/***/ }),

/***/ "./node_modules/power-assert-renderer-diagram/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/power-assert-renderer-diagram/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BaseRenderer = __webpack_require__(/*! power-assert-renderer-base */ "./node_modules/power-assert-renderer-base/index.js");
var inherits = __webpack_require__(/*! util */ "util").inherits;
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var stringifier = __webpack_require__(/*! stringifier */ "./node_modules/stringifier/index.js");
var stringWidth = __webpack_require__(/*! power-assert-util-string-width */ "./node_modules/power-assert-util-string-width/index.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var defaultOptions = __webpack_require__(/*! ./lib/default-options */ "./node_modules/power-assert-renderer-diagram/lib/default-options.js");

/**
 * options.stringify [function]
 * options.maxDepth [number]
 * options.lineSeparator [string]
 * options.anonymous [string]
 * options.circular [string]
 * 
 * options.widthOf [function]
 * options.ambiguousEastAsianCharWidth [number]
 */
function DiagramRenderer (config) {
    BaseRenderer.call(this);
    this.config = assign({}, defaultOptions(), config);
    this.events = [];
    if (typeof this.config.stringify === 'function') {
        this.stringify = this.config.stringify;
    } else {
        this.stringify = stringifier(this.config);
    }
    if (typeof this.config.widthOf === 'function') {
        this.widthOf = this.config.widthOf;
    } else {
        this.widthOf = (this.config.ambiguousEastAsianCharWidth === 1) ? stringWidth.narrow : stringWidth;
    }
    this.initialVertivalBarLength = 1;
}
inherits(DiagramRenderer, BaseRenderer);

DiagramRenderer.prototype.onStart = function (context) {
    this.assertionLine = context.source.content;
    this.initializeRows();
};

DiagramRenderer.prototype.onData = function (esNode) {
    if (!esNode.isCaptured) {
        return;
    }
    this.events.push({value: esNode.value, leftIndex: esNode.range[0]});
};

DiagramRenderer.prototype.onEnd = function () {
    this.events.sort(rightToLeft);
    this.constructRows(this.events);
    var _this = this;
    forEach(this.rows, function (columns) {
        _this.write(columns.join(''));
    });
};

DiagramRenderer.prototype.initializeRows = function () {
    this.rows = [];
    for (var i = 0; i <= this.initialVertivalBarLength; i += 1) {
        this.addOneMoreRow();
    }
};

DiagramRenderer.prototype.newRowFor = function (assertionLine) {
    return createRow(this.widthOf(assertionLine), ' ');
};

DiagramRenderer.prototype.addOneMoreRow = function () {
    this.rows.push(this.newRowFor(this.assertionLine));
};

DiagramRenderer.prototype.lastRow = function () {
    return this.rows[this.rows.length - 1];
};

DiagramRenderer.prototype.renderVerticalBarAt = function (columnIndex) {
    var i, lastRowIndex = this.rows.length - 1;
    for (i = 0; i < lastRowIndex; i += 1) {
        this.rows[i].splice(columnIndex, 1, '|');
    }
};

DiagramRenderer.prototype.renderValueAt = function (columnIndex, dumpedValue) {
    var i, width = this.widthOf(dumpedValue);
    for (i = 0; i < width; i += 1) {
        this.lastRow().splice(columnIndex + i, 1, dumpedValue.charAt(i));
    }
};

DiagramRenderer.prototype.isOverlapped = function (prevCapturing, nextCaputuring, dumpedValue) {
    return (typeof prevCapturing !== 'undefined') && this.startColumnFor(prevCapturing) <= (this.startColumnFor(nextCaputuring) + this.widthOf(dumpedValue));
};

DiagramRenderer.prototype.constructRows = function (capturedEvents) {
    var that = this;
    var prevCaptured;
    forEach(capturedEvents, function (captured) {
        var dumpedValue = that.stringify(captured.value);
        if (that.isOverlapped(prevCaptured, captured, dumpedValue)) {
            that.addOneMoreRow();
        }
        that.renderVerticalBarAt(that.startColumnFor(captured));
        that.renderValueAt(that.startColumnFor(captured), dumpedValue);
        prevCaptured = captured;
    });
};

DiagramRenderer.prototype.startColumnFor = function (captured) {
    return this.widthOf(this.assertionLine.slice(0, captured.leftIndex));
};

function createRow (numCols, initial) {
    var row = [], i;
    for(i = 0; i < numCols; i += 1) {
        row[i] = initial;
    }
    return row;
}

function rightToLeft (a, b) {
    return b.leftIndex - a.leftIndex;
}

module.exports = DiagramRenderer;


/***/ }),

/***/ "./node_modules/power-assert-renderer-diagram/lib/default-options.js":
/*!***************************************************************************!*\
  !*** ./node_modules/power-assert-renderer-diagram/lib/default-options.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function defaultOptions () {
    return {
        ambiguousEastAsianCharWidth: 2,
        maxDepth: 2,
        indent: null,
        outputOffset: 2,
        anonymous: 'Object',
        circular: '#@Circular#',
        lineSeparator: '\n'
    };
};


/***/ }),

/***/ "./node_modules/power-assert-renderer-file/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/power-assert-renderer-file/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BaseRenderer = __webpack_require__(/*! power-assert-renderer-base */ "./node_modules/power-assert-renderer-base/index.js");
var inherits = __webpack_require__(/*! util */ "util").inherits;

function FileRenderer () {
    BaseRenderer.call(this);
}
inherits(FileRenderer, BaseRenderer);

FileRenderer.prototype.onStart = function (context) {
    this.filepath = context.source.filepath;
    this.lineNumber = context.source.line;
};

FileRenderer.prototype.onEnd = function () {
    if (this.filepath) {
        this.write('# ' + [this.filepath, this.lineNumber].join(':'));
    } else {
        this.write('# at line: ' + this.lineNumber);
    }
};

module.exports = FileRenderer;


/***/ }),

/***/ "./node_modules/power-assert-util-string-width/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/power-assert-util-string-width/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var eaw = __webpack_require__(/*! eastasianwidth */ "./node_modules/eastasianwidth/eastasianwidth.js");

function stringWidth (ambiguousCharWidth) {
    return function widthOf (str) {
        var i, code, width = 0;
        for(i = 0; i < str.length; i+=1) {
            code = eaw.eastAsianWidth(str.charAt(i));
            switch(code) {
            case 'F':
            case 'W':
                width += 2;
                break;
            case 'H':
            case 'Na':
            case 'N':
                width += 1;
                break;
            case 'A':
                width += ambiguousCharWidth;
                break;
            }
        }
        return width;
    };
}

module.exports = stringWidth(2);
module.exports.narrow = stringWidth(1);


/***/ }),

/***/ "./node_modules/power-assert/index.js":
/*!********************************************!*\
  !*** ./node_modules/power-assert/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * power-assert.js - Power Assert in JavaScript.
 *
 * https://github.com/power-assert-js/power-assert
 *
 * Copyright (c) 2013-2018 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/power-assert/blob/master/MIT-LICENSE.txt
 */


var baseAssert = __webpack_require__(/*! assert */ "assert");
var _deepEqual = __webpack_require__(/*! universal-deep-strict-equal */ "./node_modules/universal-deep-strict-equal/index.js");
var empower = __webpack_require__(/*! empower */ "./node_modules/empower/index.js");
var formatter = __webpack_require__(/*! power-assert-formatter */ "./node_modules/power-assert-formatter/index.js");
var assign = __webpack_require__(/*! xtend/mutable */ "./node_modules/xtend/mutable.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var empowerOptions = {
    modifyMessageOnRethrow: true,
    saveContextOnRethrow: true
};

if (typeof baseAssert.deepStrictEqual !== 'function') {
    baseAssert.deepStrictEqual = function deepStrictEqual (actual, expected, message) {
        if (!_deepEqual(actual, expected, true)) {
            baseAssert.fail(actual, expected, message, 'deepStrictEqual');
        }
    };
}
if (typeof baseAssert.notDeepStrictEqual !== 'function') {
    baseAssert.notDeepStrictEqual = function notDeepStrictEqual (actual, expected, message) {
        if (_deepEqual(actual, expected, true)) {
            baseAssert.fail(actual, expected, message, 'notDeepStrictEqual');
        }
    };
}

function customize (customOptions) {
    var options = customOptions || {};
    var applyEmpower = function (fn) {
        return empower(
            fn,
            formatter(options.output),
            assign({}, empowerOptions, options.assertion)
        );
    };
    var poweredAssert = applyEmpower(baseAssert);
    poweredAssert.customize = customize;
    if (typeof baseAssert.strict === 'function') {
        poweredAssert.strict = applyEmpower(baseAssert.strict);
    } else {
        var strict = applyEmpower(baseAssert);
        poweredAssert.strict = assign(strict, {
            equal: strict.strictEqual,
            deepEqual: strict.deepStrictEqual,
            notEqual: strict.notStrictEqual,
            notDeepEqual: strict.notDeepStrictEqual
        });
    }
    poweredAssert.strict.strict = poweredAssert.strict;
    return poweredAssert;
}

var defaultAssert = customize();
define(defaultAssert, { '__esModule': true });
defaultAssert['default'] = defaultAssert;
module.exports = defaultAssert;


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}



/***/ }),

/***/ "./node_modules/rdf-ext/lib/environment.js":
/*!*************************************************!*\
  !*** ./node_modules/rdf-ext/lib/environment.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function mixin (rdf) {
  rdf.PrefixMap = function (prefixes) {
    this.addAll(prefixes)
  }

  rdf.PrefixMap.prototype.addAll = function (prefixes) {
    for (var prefix in prefixes) {
      this[prefix] = prefixes[prefix]
    }
  }

  rdf.PrefixMap.prototype.resolve = function (curie) {
    if (curie.indexOf('://') !== -1) {
      throw new Error('string looks like an IRI')
    }

    var separator = curie.indexOf(':')

    if (separator === -1) {
      throw new Error('separator not found')
    }

    var prefix = curie.substr(0, separator).toLowerCase()

    if (!(prefix in this)) {
      throw new Error('prefix is not defined')
    }

    return this[prefix].concat(curie.substr(separator + 1))
  }

  rdf.PrefixMap.prototype.setDefault = function (namespace) {
    this[''] = namespace
  }

  rdf.PrefixMap.prototype.shrink = function (iri) {
    var reserved = ['addAll', 'resolve', 'setDefault', 'shrink']

    for (var prefix in this) {
      if (reserved.indexOf(prefix) !== -1) {
        continue
      }

      var namespace = this[prefix]

      if (iri.substr(0, namespace.length) === namespace) {
        return prefix + ':' + iri.substr(namespace.length)
      }
    }

    return iri
  }

  rdf.TermMap = function (i) {
    return Object.defineProperties({}, {
      resolve: {
        writable: false, configurable: false, enumerable: true, value: function (term) {
          if (this[term]) { return this[term] }
          if (this['']) { return this[''].concat(term) }
          return null
        }
      },
      shrink: {
        writable: false, configurable: false, enumerable: true, value: function (iri) {
          for (var t in this) {
            if (this[t] === iri) {
              return t
            }
          }

          return iri
        }
      },
      setDefault: {
        writable: false, configurable: false, enumerable: true, value: function (iri) {
          this[''] = iri
        }
      },
      addAll: {
        writable: false, configurable: false, enumerable: true, value: function (terms, override) {
          for (var t in terms) {
            if (!this[t] || override) {
              this[t] = terms[t]
            }
          }

          return this
        }
      }
    }).addAll(i)
  }

  rdf.Profile = function (i) {
    return Object.defineProperties({}, {
      prefixes: {writable: false, configurable: false, enumerable: true, value: new rdf.PrefixMap()},
      terms: {writable: false, configurable: false, enumerable: true, value: new rdf.TermMap()},
      resolve: {
        writable: false, configurable: false, enumerable: true, value: function (tp) {
          return tp.indexOf(':') >= 0 ? this.prefixes.resolve(tp) : this.terms.resolve(tp)
        }
      },
      setDefaultVocabulary: {
        writable: false, configurable: false, enumerable: true, value: function (iri) {
          this.terms.setDefault(iri)
        }
      },
      setDefaultPrefix: {
        writable: false, configurable: false, enumerable: true, value: function (iri) {
          this.prefixes.setDefault(iri)
        }
      },
      setTerm: {
        writable: false, configurable: false, enumerable: true, value: function (term, iri) {
          this.terms[term] = iri
        }
      },
      setPrefix: {
        writable: false, configurable: false, enumerable: true, value: function (prefix, iri) {
          this.prefixes[prefix] = iri
        }
      },
      importProfile: {
        writable: false, configurable: false, enumerable: true, value: function (profile, override) {
          if (!profile) { return this }
          this.prefixes.addAll(profile.prefixes, override)
          this.terms.addAll(profile.terms, override)
          return this
        }
      }
    }).importProfile(i)
  }

  rdf.RDFEnvironment = function () {
    var rp = {
      terms: {}, prefixes: {
        owl: 'http://www.w3.org/2002/07/owl#',
        rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
        rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
        rdfa: 'http://www.w3.org/ns/rdfa#',
        xhv: 'http://www.w3.org/1999/xhtml/vocab#',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xsd: 'http://www.w3.org/2001/XMLSchema#'
      }
    }

    var xsd = {}

    var x = ['string', 'boolean', 'dateTime', 'date', 'time', 'int', 'double', 'float', 'decimal', 'integer',
      'nonPositiveInteger', 'negativeInteger', 'long', 'int', 'short', 'byte', 'nonNegativeInteger',
      'unsignedLong', 'unsignedInt', 'unsignedShort', 'unsignedByte', 'positiveInteger']

    for (var v in x) {
      xsd[x[v]] = rp.prefixes.xsd.concat(x[v])
    }

    return Object.defineProperties(new rdf.Profile(rp), {
      createBlankNode: {
        writable: false, configurable: false, enumerable: true, value: function () {
          return new rdf.BlankNode()
        }
      },
      createNamedNode: {
        writable: false, configurable: false, enumerable: true, value: function (iri) {
          return new rdf.NamedNode(iri)
        }
      },
      createLiteral: {
        writable: false, configurable: false, enumerable: true, value: function (value, language, datatype) {
          return new rdf.Literal(value, language, datatype)
          /* var l = null
          var dt = arguments[2]
          var v = value

          if (arguments[1]) {
            if (arguments[1].hasOwnProperty('interfaceName')) {
              dt = arguments[1]
            } else {
              l = arguments[1]
            }
          }

          if (dt) {
            switch (dt.valueOf()) {
              case xsd.string:
                v = String(v)
                break
              case xsd['boolean']:
                v = (Boolean(v === 'false' ? false : v)).valueOf()
                break
              case xsd['float']:
              case xsd.integer:
              case xsd['long']:
              case xsd['double']:
              case xsd.decimal:
              case xsd.nonPositiveInteger:
              case xsd.nonNegativeInteger:
              case xsd.negativeInteger:
              case xsd['int']:
              case xsd.unsignedLong:
              case xsd.positiveInteger:
              case xsd['short']:
              case xsd.unsignedInt:
              case xsd['byte']:
              case xsd.unsignedShort:
              case xsd.unsignedByte:
                v = (Number(v)).valueOf()
                break
              case xsd['date']:
              case xsd.time:
              case xsd.dateTime:
                v = new Date(v)
                break
            }
          }

          return new rdf.Literal(value, l, dt, v) */
        }
      },
      createTriple: {
        writable: false, configurable: false, enumerable: true, value: function (s, p, o) {
          return new rdf.Triple(s, p, o)
        }
      },
      createGraph: {
        writable: false, configurable: true, enumerable: true, value: function (a) {
          return new rdf.Graph(a)
        }
      },
      createAction: {
        writable: false, configurable: false, enumerable: true, value: function (t, a) {
          return new rdf.TripleAction(t, a)
        }
      },
      createProfile: {
        writable: false, configurable: false, enumerable: true, value: function (empty) {
          return new rdf.Profile(!empty ? this : null)
        }
      },
      createTermMap: {
        writable: false, configurable: false, enumerable: true, value: function (empty) {
          return new rdf.TermMap(!empty ? this.terms : null)
        }
      },
      createPrefixMap: {
        writable: false, configurable: false, enumerable: true, value: function (empty) {
          return new rdf.PrefixMap(!empty ? this.prefixes : null)
        }
      }
    })
  }

  var singleton = new rdf.RDFEnvironment()

  Object.keys(singleton).forEach(function (property) {
    rdf[property] = singleton[property]
  })
}

module.exports = mixin


/***/ }),

/***/ "./node_modules/rdf-ext/lib/parsers.js":
/*!*********************************************!*\
  !*** ./node_modules/rdf-ext/lib/parsers.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Parsers (parsers) {
  var self = this

  if (parsers) {
    Object.keys(parsers).forEach(function (mediaType) {
      self[mediaType] = parsers[mediaType]
    })
  }
}

Parsers.prototype.list = function () {
  var propertyBlackList = ['list', 'findParsers', 'parse', 'process', 'stream']

  return Object.keys(this)
    .filter(function (property) {
      return propertyBlackList.indexOf(property) === -1
    })
}

Parsers.prototype.findParsers = function (mediaType) {
  if (!(mediaType in this)) {
    return null
  }

  var parsers = this[mediaType]

  if (!Array.isArray(parsers)) {
    parsers = [parsers]
  }

  return parsers
}

Parsers.prototype.parse = function (mediaType, data, callback, base, filter, graph) {
  var parsers = this.findParsers(mediaType)

  if (!parsers) {
    return Promise.reject('no parser for mime type: ' + mediaType + ' found')
  }

  // TODO: try other parsers on error
  return parsers.shift().parse(data, callback, base, filter, graph)
}

Parsers.prototype.process = function (mediaType, data, callback, base, filter, done) {
  var parsers = this.findParsers(mediaType)

  if (!parsers) {
    return Promise.reject('no parser for mime type: ' + mediaType + ' found')
  }

  // TODO: try other parsers on error
  return parsers.shift().process(data, callback, base, filter, done)
}

Parsers.prototype.stream = function (mediaType, inputStream, base, filter) {
  var parsers = this.findParsers(mediaType)

  if (!parsers) {
    return null
  }

  // TODO: try other parsers on error
  return parsers.shift().stream(inputStream, base, filter)
}

module.exports = Parsers


/***/ }),

/***/ "./node_modules/rdf-ext/lib/serializers.js":
/*!*************************************************!*\
  !*** ./node_modules/rdf-ext/lib/serializers.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Serializers (serializers) {
  var self = this

  if (serializers) {
    Object.keys(serializers).forEach(function (mediaType) {
      self[mediaType] = serializers[mediaType]
    })
  }
}

Serializers.prototype.list = function () {
  var propertyBlackList = ['list', 'findSerializer', 'serialize', 'stream']

  return Object.keys(this)
    .filter(function (property) {
      return propertyBlackList.indexOf(property) === -1
    })
}

Serializers.prototype.findSerializer = function (mediaType) {
  if (!(mediaType in this)) {
    return null
  }

  return this[mediaType]
}

Serializers.prototype.serialize = function (mediaType, graph, callback) {
  var serializer = this.findSerializer(mediaType)

  if (!serializer) {
    return Promise.reject('no serializer for mime type: ' + mediaType + ' found')
  }

  return serializer.serialize(graph, callback)
}

Serializers.prototype.stream = function (mediaType, inputStream, base, filter) {
  var serializer = this.findSerializer(mediaType)

  if (!serializer) {
    return null
  }

  return serializer.stream(inputStream, base, filter)
}

module.exports = Serializers


/***/ }),

/***/ "./node_modules/rdf-ext/lib/utils-browser.js":
/*!***************************************************!*\
  !*** ./node_modules/rdf-ext/lib/utils-browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* global XMLHttpRequest */
var utils = {}

utils.defaultRequest = function (method, requestUrl, headers, content, callback) {

  // support require module compatible function call
  if (typeof method === 'object') {
    callback = requestUrl
    requestUrl = method.url
    headers = method.headers
    content = method.body
    method = method.method
  }

  return new Promise(function (resolve, reject) {
    callback = callback || function () {}

    var xhr = new XMLHttpRequest()

    xhr.onreadystatechange = function () {
      if (xhr.readyState === xhr.DONE) {
        var headerLines = xhr.getAllResponseHeaders().split('\r\n')
        var resHeaders = {}

        for (var i = 0; i < headerLines.length; i++) {
          var headerLine = headerLines[i].split(': ', 2)

          resHeaders[headerLine[0].toLowerCase()] = headerLine[1]
        }

        callback(xhr.status, resHeaders, xhr.responseText)

        resolve({
          statusCode: xhr.status,
          headers: resHeaders,
          content: xhr.responseText
        })
      }
    }

    xhr.open(method, requestUrl, true)

    for (var header in headers) {
      xhr.setRequestHeader(header, headers[header])
    }

    xhr.send(content)
  })
}

utils.corsProxyRequest = function (proxyUrl, method, requestUrl, headers, content, callback) {
  var url = proxyUrl + '?url=' + encodeURIComponent(requestUrl)

  return utils.defaultRequest(method, url, headers, content, callback)
}

utils.mixin = function (rdf) {
  rdf.defaultRequest = utils.defaultRequest
  rdf.corsProxyRequest = utils.corsProxyRequest
}

module.exports = utils.mixin


/***/ }),

/***/ "./node_modules/rdf-ext/lib/utils-node.js":
/*!************************************************!*\
  !*** ./node_modules/rdf-ext/lib/utils-node.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__(/*! http */ "http")
var https = __webpack_require__(/*! https */ "https")
var url = __webpack_require__(/*! url */ "url")

var utils = {}

utils.defaultRequest = function (method, requestUrl, headers, content, callback) {

  // support require module compatible function call
  if (typeof method === 'object') {
    callback = requestUrl
    requestUrl = method.url
    headers = method.headers
    content = method.body
    method = method.method
  }

  return new Promise(function (resolve, reject) {
    callback = callback || function () {}

    var options = url.parse(requestUrl)
    var client = http

    options.hash = null
    options.method = method
    options.headers = headers

    if (options.protocol === 'https:') {
      client = https
    }

    var req = client.request(options, function (res) {
      var resContent = ''

      res.setEncoding('utf8')

      res.on('data', function (chunk) {
        resContent += chunk
      })

      res.on('end', function () {
        callback(res.statusCode, res.headers, resContent)

        resolve({
          statusCode: res.statusCode,
          headers: res.headers,
          content: resContent
        })
      })
    })

    req.on('error', function (error) {
      callback(null, null, null, error)

      reject(error)
    })

    if (content) {
      req.write(content)
    }

    req.end()
  })
}

utils.mixin = function (rdf) {
  rdf.defaultRequest = utils.defaultRequest
}

module.exports = utils.mixin


/***/ }),

/***/ "./node_modules/rdf-ext/lib/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/rdf-ext/lib/utils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var utils = {}

/*
 * generic filters
 */
utils.filter = {}

utils.filter.namedNode = function (node) {
  return node.interfaceName === 'NamedNode'
}

utils.filter.blankNode = function (node) {
  return node.interfaceName === 'BlankNode'
}

utils.filter.literal = function (node) {
  return node.interfaceName === 'Literal'
}

utils.filter.namedNodeSubject = function (subject) {
  return function (triple) {
    return triple.subject.interfaceName !== 'NamedNode' || triple.subject.equals(subject)
  }
}

/*
 * list triple parts
 */
utils.list = {}

utils.list.tripleParts = function (graph, part, filter) {
  var nodes = {}

  filter = filter || function () { return true }

  graph.forEach(function (triple) {
    nodes[triple[part].toString()] = triple[part]
  })

  nodes = Object.keys(nodes)
    .map(function (key) {
      return nodes[key]
    })
    .filter(function (node) {
      return filter(node)
    })

  return nodes
}

utils.list.subjects = function (graph, filter) {
  return utils.list.tripleParts(graph, 'subject', filter)
}

utils.list.predicates = function (graph, filter) {
  return utils.list.tripleParts(graph, 'predicate', filter)
}

utils.list.objects = function (graph, filter) {
  return utils.list.tripleParts(graph, 'object', filter)
}

/*
 * Creates a subgraph by traversing a graph with filter support
 */
utils.createSubGraph = function (rdf, graph, entry, filter) {
  var processedEntries = {}
  var subGraph = rdf.createGraph()

  var processSubject = function (entries) {
    if (entries.length === 0) {
      return
    }

    var newEntries = []
    var matches = rdf.createGraph()

    entries.forEach(function (entry) {
      matches.addAll(graph.match(entry))
    })

    if (filter) {
      matches = matches.filter(filter)
    }

    matches.forEach(function (match) {
      var key = match.object.toString()

      if (!(key in processedEntries)) {
        newEntries.push(match.object)
        processedEntries[key] = true
      }
    })

    subGraph.addAll(matches)

    processSubject(newEntries)
  }

  processSubject([entry])

  return subGraph
}

/*
 * Create a subgraph based on a named node subject without crossing named node borders
 */
utils.createSubGraphByNamedNodeSubject = function (rdf, graph, subject) {
  return rdf.utils.createSubGraph(graph, subject, utils.filter.namedNodeSubject(subject))
}

/*
 * Fills a store based on createSubGraphByNamedNodeSubject for all named node subjects
 */
utils.splitGraphByNamedNodeSubject = function (rdf, graph, store) {
  store = store || rdf.createStore()

  var adds = []

  utils.list.subjects(graph, utils.filter.namedNode).forEach(function (subject) {
    adds.push(store.add(subject, utils.createSubGraphByNamedNodeSubject(rdf, graph, subject)))
  })

  return Promise.all(adds).then(function () {
    return store
  })
}

/*
 * namespace mapping
 */
utils.mapNamespaceNode = function (rdf, node, search, replace) {
  // process only named nodes...
  if (node.interfaceName !== 'NamedNode') {
    return node
  }

  // ...that start with search
  if (node.nominalValue.toString().indexOf(search) !== 0) {
    return node
  }

  // create new named node with replace + original node without search
  return rdf.createNamedNode(replace + node.nominalValue.toString().substr(search.length))
}

utils.mapNamespaceTriple = function (rdf, triple, search, replace) {
  return rdf.createTriple(
    utils.mapNamespaceNode(rdf, triple.subject, search, replace),
    utils.mapNamespaceNode(rdf, triple.predicate, search, replace),
    utils.mapNamespaceNode(rdf, triple.object, search, replace)
  )
}

utils.mapNamespaceGraph = function (rdf, graph, search, replace) {
  var mappedGraph = rdf.createGraph()

  graph.forEach(function (triple) {
    mappedGraph.add(utils.mapNamespaceTriple(rdf, triple, search, replace))
  })

  return mappedGraph
}

utils.mixin = function (rdf) {
  rdf.utils = {}
  rdf.utils.filter = utils.filter
  rdf.utils.list = utils.list
  rdf.utils.createSubGraph = utils.createSubGraph.bind(null, rdf)
  rdf.utils.createSubGraphByNamedNodeSubject = utils.createSubGraphByNamedNodeSubject.bind(null, rdf)
  rdf.utils.splitGraphByNamedNodeSubject = utils.splitGraphByNamedNodeSubject.bind(null, rdf)
  rdf.utils.mapNamespaceNode = utils.mapNamespaceNode.bind(null, rdf)
  rdf.utils.mapNamespaceTriple = utils.mapNamespaceTriple.bind(null, rdf)
  rdf.utils.mapNamespaceGraph = utils.mapNamespaceGraph.bind(null, rdf)
  rdf.utils.mimeTypeParserMap = utils.mimeTypeParserMap
  rdf.utils.mimeTypeSerializerMap = utils.mimeTypeSerializerMap
  rdf.utils.parse = utils.parse
  rdf.utils.serialize = utils.serialize
}

module.exports = utils.mixin


/***/ }),

/***/ "./node_modules/rdf-ext/rdf-ext.js":
/*!*****************************************!*\
  !*** ./node_modules/rdf-ext/rdf-ext.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */
var rdf = __webpack_require__(/*! rdf-graph-array */ "./node_modules/rdf-graph-array/index.js")
var InMemoryStore = __webpack_require__(/*! rdf-store-inmemory */ "./node_modules/rdf-store-inmemory/index.js")
var Parsers = __webpack_require__(/*! ./lib/parsers */ "./node_modules/rdf-ext/lib/parsers.js")
var Serializers = __webpack_require__(/*! ./lib/serializers */ "./node_modules/rdf-ext/lib/serializers.js")

var mixin = function (rdf, options) {
  options = options || {}

  __webpack_require__(/*! ./lib/environment */ "./node_modules/rdf-ext/lib/environment.js")(rdf)

  if (typeof window !== 'undefined') {
    window.rdf = rdf
  }

  rdf.defaultRequest = null
  rdf.corsProxyRequest = null

  __webpack_require__(/*! ./lib/utils */ "./node_modules/rdf-ext/lib/utils.js")(rdf)

  if (typeof process !== 'undefined' && process.versions && process.versions.node) {
    __webpack_require__(/*! ./lib/utils-node */ "./node_modules/rdf-ext/lib/utils-node.js")(rdf)
  } else {
    __webpack_require__(/*! ./lib/utils-browser */ "./node_modules/rdf-ext/lib/utils-browser.js")(rdf)
  }

  rdf.createBlankNode = function () {
    return new rdf.BlankNode()
  }

  rdf.createNamedNode = function (iri) {
    return new rdf.NamedNode(iri)
  }

  rdf.createLiteral = function (value, language, datatype) {
    return new rdf.Literal(value, language, datatype)
  }

  rdf.createTriple = function (subject, predicate, object) {
    return new rdf.Triple(subject, predicate, object)
  }

  rdf.createQuad = function (subject, predicate, object, graph) {
    return new rdf.Quad(subject, predicate, object, graph)
  }

  rdf.createGraph = function (triples) {
    return new rdf.Graph(triples)
  }

  // Use InMemoryStore as default store
  rdf.createStore = function (options) {
    options = options || {}
    options.rdf = options.rdf || rdf

    return new InMemoryStore(options)
  }

  rdf.Parsers = Parsers
  rdf.parsers = new Parsers()

  rdf.Serializers = Serializers
  rdf.serializers = new Serializers()

  return rdf
}

mixin(rdf)

module.exports = rdf


/***/ }),

/***/ "./node_modules/rdf-graph-abstract/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rdf-graph-abstract/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var normalize = __webpack_require__(/*! rdf-normalize */ "./node_modules/rdf-normalize/index.js")

var rdf = {}

rdf.encodeString = function (s) {
  var out = ''
  var skip = false
  var _g1 = 0
  var _g = s.length

  while (_g1 < _g) {
    var i = _g1++

    if (!skip) {
      var code = s.charCodeAt(i)

      if (code >= 55296 && code <= 56319) {
        var low = s.charCodeAt(i + 1)
        code = (code - 55296) * 1024 + (low - 56320) + 65536
        skip = true
      }

      if (code > 1114111) {
        throw new Error('Char out of range')
      }

      var hex = '00000000'.concat((Number(code)).toString(16).toUpperCase())

      if (code >= 65536) {
        out += '\\' + hex.slice(-8)
      } else {
        if (code >= 127 || code <= 31) {
          switch (code) {
            case 9: out += '\\t'; break
            case 10: out += '\\n'; break
            case 13: out += '\\r'; break
            default: out += '\\u' + hex.slice(-4); break
          }
        } else {
          switch (code) {
            case 34: out += '\\"'; break
            case 92: out += '\\\\'; break
            default: out += s.charAt(i); break
          }
        }
      }
    } else {
      skip = !skip
    }
  }
  return out
}

rdf.AbstractGraph = function (constructor, other) {
  this.constructor = constructor

  Object.defineProperty(this, 'length', {
    get: function () { return this.toArray().length }
  })

  if (other) {
    this.addAll(other)
  }
}

rdf.AbstractGraph.prototype.addAll = function (other) {
  var self = this

  other.forEach(function (quad) {
    self.add(quad)
  })

  return this
}

rdf.AbstractGraph.prototype.clone = function () {
  return new this.constructor(this)
}

rdf.AbstractGraph.prototype.difference = function (other) {
  var difference = new this.constructor()

  this.forEach(function (quad) {
    if (!other.includes(quad)) {
      difference.add(quad)
    }
  })

  return difference
}

rdf.AbstractGraph.prototype.equals = function (other) {
  return normalize(this) === normalize(other)
}

rdf.AbstractGraph.prototype.every = function (callback) {
  return this.toArray().every(callback)
}

rdf.AbstractGraph.prototype.filter = function (callback) {
  return new this.constructor(this.toArray().filter(callback))
}

rdf.AbstractGraph.prototype.forEach = function (callback) {
  var self = this

  self.toArray().forEach(function (quad) {
    callback(quad, self)
  })
}

rdf.AbstractGraph.prototype.includes = function (quad) {
  return this.match(quad.subject, quad.predicate, quad.object, quad.graph).length === 1
}

rdf.AbstractGraph.prototype.intersection = function (other) {
  var intersection = new this.constructor()

  this.forEach(function (quad) {
    if (other.includes(quad)) {
      intersection.add(quad)
    }
  })

  return intersection
}

rdf.AbstractGraph.prototype.map = function (callback) {
  var self = this

  return self.toArray().map(function (quad) {
    return callback(quad, self)
  })
}

rdf.AbstractGraph.prototype.match = function (subject, predicate, object, graph) {
  return new rdf.Graph(this.toArray().filter(function (quad) {
    if (graph && (!quad.graph || !quad.graph.equals(graph))) {
      return false
    }

    if (subject && !quad.subject.equals(subject)) {
      return false
    }

    if (predicate && !quad.predicate.equals(predicate)) {
      return false
    }

    if (object && !quad.object.equals(object)) {
      return false
    }

    return true
  }))
}

rdf.AbstractGraph.prototype.merge = function (other) {
  return this.clone().addAll(other)
}

rdf.AbstractGraph.prototype.removeMatches = function (subject, predicate, object, graph) {
  var self = this
  var matches = self.match(subject, predicate, object, graph)

  matches.forEach(function (quad) {
    self.remove(quad)
  })

  return self
}

rdf.AbstractGraph.prototype.some = function (callback) {
  return this.toArray().some(callback)
}

rdf.AbstractGraph.prototype.toString = function () {
  return this.toArray()
    .map(function (quad) {
      return quad.toString()
    })
    .join('\n')
}

module.exports = rdf


/***/ }),

/***/ "./node_modules/rdf-graph-array-sboljs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/rdf-graph-array-sboljs/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rdf = __webpack_require__(/*! rdf-graph-abstract */ "./node_modules/rdf-graph-abstract/index.js")
var util = __webpack_require__(/*! util */ "util")

rdf.NamedNode = function (iri) {
  this.interfaceName = 'NamedNode'
  this.nominalValue = iri
}

rdf.NamedNode.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      return this.nominalValue === other.nominalValue
    }
  }

  return false
}

rdf.NamedNode.prototype.toNT = function () {
  return '<' + rdf.encodeString(this.nominalValue) + '>'
}

rdf.NamedNode.prototype.toString = function () {
  return this.nominalValue
}

rdf.NamedNode.prototype.valueOf = function () {
  return this.nominalValue
}

rdf.BlankNode = function () {
  this.interfaceName = 'BlankNode'
  this.nominalValue = 'b' + (++rdf.BlankNode.nextId)
}

rdf.BlankNode.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      return this.nominalValue === other.nominalValue
    }
  }

  return false
}

rdf.BlankNode.prototype.toNT = function () {
  return '_:' + rdf.encodeString(this.nominalValue)
}

rdf.BlankNode.prototype.toString = function () {
  return '_:' + this.nominalValue
}

rdf.BlankNode.prototype.valueOf = function () {
  return this.nominalValue
}

rdf.BlankNode.nextId = 0

rdf.Literal = function (value, language, datatype, native) {
  this.interfaceName = 'Literal'
  this.nominalValue = value

  if (language) {
    this.language = language
    this.datatype = rdf.Literal.langString
  } else {
    this.language = null

    if (datatype) {
      this.datatype = new rdf.NamedNode(datatype.toString())
    } else {
      this.datatype = rdf.Literal.string
    }
  }

  this.native = native
}

rdf.Literal.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      if (this.nominalValue.toString() !== other.nominalValue.toString()) {
        return false
      }

      if (this.language !== other.language) {
        return false
      }

      if ((this.datatype && !this.datatype.equals(other.datatype))) {
        return false
      }

      return true
    }
  }

  return false
}

rdf.Literal.prototype.toNT = function () {
  var string = '"' + rdf.encodeString(this.nominalValue.toString()) + '"'

  if (this.language) {
    string += '@' + this.language
  }

  if (this.datatype && !rdf.Literal.string.equals(this.datatype) && !rdf.Literal.langString.equals(this.datatype)) {
    string += '^^' + this.datatype.toNT()
  }

  return string
}

rdf.Literal.prototype.toString = function () {
  return this.nominalValue
}

rdf.Literal.langString = new rdf.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')
rdf.Literal.string = new rdf.NamedNode('http://www.w3.org/2001/XMLSchema#string')

rdf.Triple = function (subject, predicate, object) {
  this.subject = subject
  this.predicate = predicate
  this.object = object
}

rdf.Triple.prototype.equals = function (other) {
  return this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object)
}

rdf.Triple.prototype.toNT = function () {
  return this.toString()
}

rdf.Triple.prototype.toQuad = function (graph) {
  return new rdf.Quad(this.subject, this.predicate, this.object, graph)
}

rdf.Triple.prototype.toString = function () {
  return this.subject.toNT() + ' ' + this.predicate.toNT() + ' ' + this.object.toNT() + ' .'
}

rdf.Quad = function (subject, predicate, object, graph) {
  this.subject = subject
  this.predicate = predicate
  this.object = object
  this.graph = graph
}

rdf.Quad.prototype.equals = function (other) {
  return this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph)
}

rdf.Quad.prototype.toNT = function () {
  return this.toString()
}

rdf.Quad.prototype.toString = function () {
  return this.subject.toNT() + ' ' + this.predicate.toNT() + ' ' + this.object.toNT() + ' ' + this.graph.toNT() + ' .'
}

rdf.Quad.prototype.toTriple = function () {
  return new rdf.Triple(this.subject, this.predicate, this.object)
}

rdf.Graph = function (other) {
  this.actions = []

  this._graph = []

  this._gspo = {}
  this._gops = {}

  rdf.AbstractGraph.call(this, rdf.Graph, other)
}

util.inherits(rdf.Graph, rdf.AbstractGraph)

rdf.Graph.prototype.add = function (quad) {
  var i = rdf.Graph.index(quad)

  this._gspo[i.g] = this._gspo[i.g] || {}
  this._gspo[i.g][i.s] = this._gspo[i.g][i.s] || {}
  this._gspo[i.g][i.s][i.p] = this._gspo[i.g][i.s][i.p] || {}

  this._gops[i.g] = this._gops[i.g] || {}
  this._gops[i.g][i.o] = this._gops[i.g][i.o] || {}
  this._gops[i.g][i.o][i.p] = this._gops[i.g][i.o][i.p] || {}

  if (!this._gspo[i.g][i.s][i.p][i.o]) {
    this._gspo[i.g][i.s][i.p][i.o] = quad
    this._gops[i.g][i.o][i.p][i.s] = quad
    this._graph.push(quad)
    this.actions.forEach(function (action) {
      action.run(quad)
    })
  }

  return this
}

rdf.Graph.prototype.addAction = function (action) {
  // TODO: implement me
}

rdf.Graph.prototype.remove = function (quad) {
  var i = rdf.Graph.index(quad)

  if (this._gspo[i.g][i.s][i.p][i.o]) {
    delete this._gspo[i.g][i.s][i.p][i.o]
    delete this._gops[i.g][i.o][i.p][i.s]
    this._graph.splice(this._graph.indexOf(quad), 1)
  }
}

rdf.Graph.prototype.toArray = function () {
  return this._graph.slice(0)
}

rdf.Graph.index = function (quad) {
  return {
    g: quad.graph ? quad.graph.toString() : null,
    s: quad.subject.toString(),
    p: quad.predicate.toString(),
    o: quad.object.toString()
  }
}

function objValues(obj) {

    return Object.keys(obj).map((key) => obj[key])

}

rdf.Graph.prototype.match = function (subject, predicate, object, graph) {

  var g = graph ? graph.toString() : null
  var s = subject ? subject.toString() : null
  var p = predicate ? predicate.toString() : null
  var o = object ? object.toString() : null

  if(g === '[object Object]')
      throw new Error('g not a uri?')

  if(s === '[object Object]')
      throw new Error('s not a uri?')

  if(p === '[object Object]')
      throw new Error('p not a uri?')

  if(o === '[object Object]')
      throw new Error('o not a uri?') 

  if(s && p && o) {

      var gIdx = this._gspo[g]

      if(!gIdx)
          return new rdf.Graph()

      var sIdx = gIdx[s]

      if(!sIdx)
          return new rdf.Graph()

      var pIdx = sIdx[p]

      if(!pIdx)
          return new rdf.Graph()

      var quad = pIdx[o]

      if(quad)
          return new rdf.Graph([ quad ])

      return new rdf.Graph()
  }

  if(s && p && !o) {

      var gIdx = this._gspo[g]

      if(!gIdx)
          return new rdf.Graph()

      var sIdx = gIdx[s]

      if(!sIdx)
          return new rdf.Graph()

      var pIdx = sIdx[p]

      if(!pIdx)
          return new rdf.Graph()

      return new rdf.Graph(objValues(pIdx))
  }

  if(!s && p && o) {

      var gIdx = this._gops[g]

      if(!gIdx)
          return new rdf.Graph()

      var oIdx = gIdx[o]

      if(!oIdx)
          return new rdf.Graph()

      var pIdx = oIdx[p]

      if(!pIdx)
          return new rdf.Graph()

      return new rdf.Graph(objValues(pIdx))
  }

  if(s && !p && !o) {

      var gIdx = this._gspo[g]

      if(!gIdx)
          return new rdf.Graph()

      var sIdx = gIdx[s]

      if(!sIdx)
          return new rdf.Graph()

      return new rdf.Graph([].concat.apply([], objValues(sIdx).map(objValues)))
  }

  var results = new rdf.Graph(this.toArray().filter(function (quad) {
    if (graph && (!quad.graph || !quad.graph.equals(graph))) {
      return false
    }

    if (subject && !quad.subject.equals(subject)) {
      return false
    }

    if (predicate && !quad.predicate.equals(predicate)) {
      return false
    }

    if (object && !quad.object.equals(object)) {
      return false
    }

    return true
  }))

  //console.warn('slow lookup: { ' + s + ', ' + p + ', ' + o + '} [' + results.toArray().length + ' matches]')

  return results

}
module.exports = rdf


/***/ }),

/***/ "./node_modules/rdf-graph-array/index.js":
/*!***********************************************!*\
  !*** ./node_modules/rdf-graph-array/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rdf = __webpack_require__(/*! rdf-graph-abstract */ "./node_modules/rdf-graph-abstract/index.js")
var util = __webpack_require__(/*! util */ "util")

rdf.NamedNode = function (iri) {
  this.interfaceName = 'NamedNode'
  this.nominalValue = iri
}

rdf.NamedNode.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      return this.nominalValue === other.nominalValue
    }
  }

  return false
}

rdf.NamedNode.prototype.toNT = function () {
  return '<' + rdf.encodeString(this.nominalValue) + '>'
}

rdf.NamedNode.prototype.toString = function () {
  return this.nominalValue
}

rdf.NamedNode.prototype.valueOf = function () {
  return this.nominalValue
}

rdf.BlankNode = function () {
  this.interfaceName = 'BlankNode'
  this.nominalValue = 'b' + (++rdf.BlankNode.nextId)
}

rdf.BlankNode.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      return this.nominalValue === other.nominalValue
    }
  }

  return false
}

rdf.BlankNode.prototype.toNT = function () {
  return '_:' + rdf.encodeString(this.nominalValue)
}

rdf.BlankNode.prototype.toString = function () {
  return '_:' + this.nominalValue
}

rdf.BlankNode.prototype.valueOf = function () {
  return this.nominalValue
}

rdf.BlankNode.nextId = 0

rdf.Literal = function (value, language, datatype, native) {
  this.interfaceName = 'Literal'
  this.nominalValue = value

  if (language) {
    this.language = language
    this.datatype = rdf.Literal.langString
  } else {
    this.language = null

    if (datatype) {
      this.datatype = new rdf.NamedNode(datatype.toString())
    } else {
      this.datatype = rdf.Literal.string
    }
  }

  this.native = native
}

rdf.Literal.prototype.equals = function (other) {
  if (typeof other === 'string') {
    return this.nominalValue === other
  }

  if (typeof other === 'object') {
    if (other.constructor.name === 'RegExp') {
      return other.test(this.nominalValue)
    }

    if (other.interfaceName === this.interfaceName) {
      if (this.nominalValue.toString() !== other.nominalValue.toString()) {
        return false
      }

      if (this.language !== other.language) {
        return false
      }

      if ((this.datatype && !this.datatype.equals(other.datatype))) {
        return false
      }

      return true
    }
  }

  return false
}

rdf.Literal.prototype.toNT = function () {
  var string = '"' + rdf.encodeString(this.nominalValue.toString()) + '"'

  if (this.language) {
    string += '@' + this.language
  }

  if (this.datatype && !rdf.Literal.string.equals(this.datatype) && !rdf.Literal.langString.equals(this.datatype)) {
    string += '^^' + this.datatype.toNT()
  }

  return string
}

rdf.Literal.prototype.toString = function () {
  return this.nominalValue
}

rdf.Literal.langString = new rdf.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')
rdf.Literal.string = new rdf.NamedNode('http://www.w3.org/2001/XMLSchema#string')

rdf.Triple = function (subject, predicate, object) {
  this.subject = subject
  this.predicate = predicate
  this.object = object
}

rdf.Triple.prototype.equals = function (other) {
  return this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object)
}

rdf.Triple.prototype.toNT = function () {
  return this.toString()
}

rdf.Triple.prototype.toQuad = function (graph) {
  return new rdf.Quad(this.subject, this.predicate, this.object, graph)
}

rdf.Triple.prototype.toString = function () {
  return this.subject.toNT() + ' ' + this.predicate.toNT() + ' ' + this.object.toNT() + ' .'
}

rdf.Quad = function (subject, predicate, object, graph) {
  this.subject = subject
  this.predicate = predicate
  this.object = object
  this.graph = graph
}

rdf.Quad.prototype.equals = function (other) {
  return this.subject.equals(other.subject) && this.predicate.equals(other.predicate) && this.object.equals(other.object) && this.graph.equals(other.graph)
}

rdf.Quad.prototype.toNT = function () {
  return this.toString()
}

rdf.Quad.prototype.toString = function () {
  return this.subject.toNT() + ' ' + this.predicate.toNT() + ' ' + this.object.toNT() + ' ' + this.graph.toNT() + ' .'
}

rdf.Quad.prototype.toTriple = function () {
  return new rdf.Triple(this.subject, this.predicate, this.object)
}

rdf.Graph = function (other) {
  this.actions = []

  this._graph = []
  this._gspo = {}

  rdf.AbstractGraph.call(this, rdf.Graph, other)
}

util.inherits(rdf.Graph, rdf.AbstractGraph)

rdf.Graph.prototype.add = function (quad) {
  var i = rdf.Graph.index(quad)

  this._gspo[i.g] = this._gspo[i.g] || {}
  this._gspo[i.g][i.s] = this._gspo[i.g][i.s] || {}
  this._gspo[i.g][i.s][i.p] = this._gspo[i.g][i.s][i.p] || {}

  if (!this._gspo[i.g][i.s][i.p][i.o]) {
    this._gspo[i.g][i.s][i.p][i.o] = quad
    this._graph.push(quad)
    this.actions.forEach(function (action) {
      action.run(quad)
    })
  }

  return this
}

rdf.Graph.prototype.addAction = function (action) {
  // TODO: implement me
}

rdf.Graph.prototype.remove = function (quad) {
  var i = rdf.Graph.index(quad)

  if (this._gspo[i.g][i.s][i.p][i.o]) {
    delete this._gspo[i.g][i.s][i.p][i.o]
    this._graph.splice(this._graph.indexOf(quad), 1)
  }
}

rdf.Graph.prototype.toArray = function () {
  return this._graph.slice(0)
}

rdf.Graph.index = function (quad) {
  return {
    g: quad.graph ? quad.graph.toString() : null,
    s: quad.subject.toString(),
    p: quad.predicate.toString(),
    o: quad.object.toString()
  }
}

module.exports = rdf


/***/ }),

/***/ "./node_modules/rdf-normalize/index.js":
/*!*********************************************!*\
  !*** ./node_modules/rdf-normalize/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var jsonldNormalize = __webpack_require__(/*! ./jsonld-normalize */ "./node_modules/rdf-normalize/jsonld-normalize.js")

function createPlainNode (node) {
  if (!node) {
    return null
  }

  var plain = {}

  if (node.interfaceName === 'NamedNode') {
    plain.type = 'IRI'
    plain.value = node.nominalValue
  } else if (node.interfaceName === 'BlankNode') {
    plain.type = 'blank node'
    plain.value = node.toString()
  } else if (node.interfaceName === 'Literal') {
    plain.type = 'literal'
    plain.value = node.nominalValue
    plain.datatype = node.datatype.nominalValue
    plain.language = node.language
  }

  return plain
}

function createPlainTriple (triple) {
  return {
    subject: createPlainNode(triple.subject),
    predicate: createPlainNode(triple.predicate),
    object: createPlainNode(triple.object)
  }
}

function createPlainDataset (graph) {
  var dataset = {}

  graph.forEach(function (quad) {
    var name = '@default'

    if ('graph' in quad && quad.graph.nominalValue) {
      name = quad.graph.nominalValue
    }

    if (!(name in dataset)) {
      dataset[name] = []
    }

    dataset[name].push(createPlainTriple(quad))
  })

  return dataset
}

function normalize (graph) {
  return jsonldNormalize(createPlainDataset(graph))
}

module.exports = normalize


/***/ }),

/***/ "./node_modules/rdf-normalize/jsonld-normalize.js":
/*!********************************************************!*\
  !*** ./node_modules/rdf-normalize/jsonld-normalize.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2014 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// constants
    var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';

    var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
    var RDF_LANGSTRING = RDF + 'langString';

    /**
     * Constructs a new JSON-LD Processor.
     */
    var Processor = function() {};

    /**
     * Performs normalization on the given RDF dataset.
     *
     * @param dataset the RDF dataset to normalize.
     * @param options the normalization options.
     * @param callback(err, normalized) called once the operation completes.
     */
    Processor.prototype.normalize = function(dataset, options, callback) {
      // create quads and map bnodes to their associated quads
      var quads = [];
      var bnodes = {};
      for(var graphName in dataset) {
        var triples = dataset[graphName];
        if(graphName === '@default') {
          graphName = null;
        }
        for(var ti = 0; ti < triples.length; ++ti) {
          var quad = triples[ti];
          if(graphName !== null) {
            if(graphName.indexOf('_:') === 0) {
              quad.name = {type: 'blank node', value: graphName};
            } else {
              quad.name = {type: 'IRI', value: graphName};
            }
          }
          quads.push(quad);

          var attrs = ['subject', 'object', 'name'];
          for(var ai = 0; ai < attrs.length; ++ai) {
            var attr = attrs[ai];
            if(quad[attr] && quad[attr].type === 'blank node') {
              var id = quad[attr].value;
              if(id in bnodes) {
                bnodes[id].quads.push(quad);
              } else {
                bnodes[id] = {quads: [quad]};
              }
            }
          }
        }
      }

      // mapping complete, start canonical naming
      var namer = new UniqueNamer('_:c14n');
      return hashBlankNodes(Object.keys(bnodes));

      // generates unique and duplicate hashes for bnodes
      function hashBlankNodes(unnamed) {
        var nextUnnamed = [];
        var duplicates = {};
        var unique = {};

        // TODO: instead of N calls to setImmediate, run
        // atomic normalization parts for a specified
        // slice of time (perhaps configurable) as this
        // will better utilize CPU and improve performance
        // as JS processing speed improves

        // hash quads for each unnamed bnode
        return hashUnnamed(0);
        function hashUnnamed(i) {
          if(i === unnamed.length) {
            // done, name blank nodes
            return nameBlankNodes(unique, duplicates, nextUnnamed);
          }

          // hash unnamed bnode
          var bnode = unnamed[i];
          var hash = _hashQuads(bnode, bnodes);

          // store hash as unique or a duplicate
          if(hash in duplicates) {
            duplicates[hash].push(bnode);
            nextUnnamed.push(bnode);
          } else if(hash in unique) {
            duplicates[hash] = [unique[hash], bnode];
            nextUnnamed.push(unique[hash]);
            nextUnnamed.push(bnode);
            delete unique[hash];
          } else {
            unique[hash] = bnode;
          }

          // hash next unnamed bnode
          return hashUnnamed(i + 1);
        }
      }

      // names unique hash bnodes
      function nameBlankNodes(unique, duplicates, unnamed) {
        // name unique bnodes in sorted hash order
        var named = false;
        var hashes = Object.keys(unique).sort();
        for(var i = 0; i < hashes.length; ++i) {
          var bnode = unique[hashes[i]];
          namer.getName(bnode);
          named = true;
        }

        if(named) {
          // continue to hash bnodes if a bnode was assigned a name
          return hashBlankNodes(unnamed);
        } else {
          // name the duplicate hash bnodes
          return nameDuplicates(duplicates);
        }
      }

      // names duplicate hash bnodes
      function nameDuplicates(duplicates) {
        // enumerate duplicate hash groups in sorted order
        var hashes = Object.keys(duplicates).sort();

        // process each group
        return processGroup(0);
        function processGroup(i) {
          if(i === hashes.length) {
            // done, create JSON-LD array
            return createArray();
          }

          // name each group member
          var group = duplicates[hashes[i]];
          var results = [];
          return nameGroupMember(group, 0);
          function nameGroupMember(group, n) {
            if(n === group.length) {
              // name bnodes in hash order
              results.sort(function(a, b) {
                a = a.hash;
                b = b.hash;
                return (a < b) ? -1 : ((a > b) ? 1 : 0);
              });
              for(var r = 0; r < results.length; ++r) {
                // name all bnodes in path namer in key-entry order
                // Note: key-order is preserved in javascript
                for(var key in results[r].pathNamer.existing) {
                  namer.getName(key);
                }
              }
              return processGroup(i + 1);
            }

            // skip already-named bnodes
            var bnode = group[n];
            if(namer.isNamed(bnode)) {
              return nameGroupMember(group, n + 1);
            }

            // hash bnode paths
            var pathNamer = new UniqueNamer('_:b');
            pathNamer.getName(bnode);
            return _hashPaths(bnode, bnodes, namer, pathNamer,
              function(err, result) {
                if(err) {
                  return callback(err);
                }
                results.push(result);
                return nameGroupMember(group, n + 1);
              });
          }
        }
      }

      // creates the sorted array of RDF quads
      function createArray() {
        var normalized = [];

        /* Note: At this point all bnodes in the set of RDF quads have been
         assigned canonical names, which have been stored in the 'namer' object.
         Here each quad is updated by assigning each of its bnodes its new name
         via the 'namer' object. */

        // update bnode names in each quad and serialize
        for(var i = 0; i < quads.length; ++i) {
          var quad = quads[i];
          var attrs = ['subject', 'object', 'name'];
          for(var ai = 0; ai < attrs.length; ++ai) {
            var attr = attrs[ai];
            if(quad[attr] && quad[attr].type === 'blank node' &&
              quad[attr].value.indexOf('_:c14n') !== 0) {
              quad[attr].value = namer.getName(quad[attr].value);
            }
          }
          normalized.push(_toNQuad(quad, quad.name ? quad.name.value : null));
        }

        // sort normalized output
        return normalized.sort().join('');
      }
    };

    /**
     * Hashes all of the quads about a blank node.
     *
     * @param id the ID of the bnode to hash quads for.
     * @param bnodes the mapping of bnodes to quads.
     *
     * @return the new hash.
     */
    function _hashQuads(id, bnodes) {
      // return cached hash
      if('hash' in bnodes[id]) {
        return bnodes[id].hash;
      }

      // serialize all of bnode's quads
      var quads = bnodes[id].quads;
      var nquads = [];
      for(var i = 0; i < quads.length; ++i) {
        nquads.push(_toNQuad(
          quads[i], quads[i].name ? quads[i].name.value : null, id));
      }
      // sort serialized quads
      nquads.sort();
      // return hashed quads
      var hash = bnodes[id].hash = sha1.hash(nquads);
      return hash;
    }

    /**
     * Produces a hash for the paths of adjacent bnodes for a bnode,
     * incorporating all information about its subgraph of bnodes. This
     * method will recursively pick adjacent bnode permutations that produce the
     * lexicographically-least 'path' serializations.
     *
     * @param id the ID of the bnode to hash paths for.
     * @param bnodes the map of bnode quads.
     * @param namer the canonical bnode namer.
     * @param pathNamer the namer used to assign names to adjacent bnodes.
     * @param callback(err, result) called once the operation completes.
     */
    function _hashPaths(id, bnodes, namer, pathNamer, callback) {
      // create SHA-1 digest
      var md = sha1.create();

      // group adjacent bnodes by hash, keep properties and references separate
      var groups = {};
      var groupHashes;
      var quads = bnodes[id].quads;
      return groupNodes(0);
      function groupNodes(i) {
        if(i === quads.length) {
          // done, hash groups
          groupHashes = Object.keys(groups).sort();
          return hashGroup(0);
        }

        // get adjacent bnode
        var quad = quads[i];
        var bnode = _getAdjacentBlankNodeName(quad.subject, id);
        var direction = null;
        if(bnode !== null) {
          // normal property
          direction = 'p';
        } else {
          bnode = _getAdjacentBlankNodeName(quad.object, id);
          if(bnode !== null) {
            // reverse property
            direction = 'r';
          }
        }

        if(bnode !== null) {
          // get bnode name (try canonical, path, then hash)
          var name;
          if(namer.isNamed(bnode)) {
            name = namer.getName(bnode);
          } else if(pathNamer.isNamed(bnode)) {
            name = pathNamer.getName(bnode);
          } else {
            name = _hashQuads(bnode, bnodes);
          }

          // hash direction, property, and bnode name/hash
          var md = sha1.create();
          md.update(direction);
          md.update(quad.predicate.value);
          md.update(name);
          var groupHash = md.digest();

          // add bnode to hash group
          if(groupHash in groups) {
            groups[groupHash].push(bnode);
          } else {
            groups[groupHash] = [bnode];
          }
        }

        return groupNodes(i + 1);
      }

      // hashes a group of adjacent bnodes
      function hashGroup(i) {
        if(i === groupHashes.length) {
          // done, return SHA-1 digest and path namer
          return callback(null, {hash: md.digest(), pathNamer: pathNamer});
        }

        // digest group hash
        var groupHash = groupHashes[i];
        md.update(groupHash);

        // choose a path and namer from the permutations
        var chosenPath = null;
        var chosenNamer = null;
        var permutator = new Permutator(groups[groupHash]);
        return permutate();
        function permutate() {
          var permutation = permutator.next();
          var pathNamerCopy = pathNamer.clone();

          // build adjacent path
          var path = '';
          var recurse = [];
          for(var n in permutation) {
            var bnode = permutation[n];

            // use canonical name if available
            if(namer.isNamed(bnode)) {
              path += namer.getName(bnode);
            } else {
              // recurse if bnode isn't named in the path yet
              if(!pathNamerCopy.isNamed(bnode)) {
                recurse.push(bnode);
              }
              path += pathNamerCopy.getName(bnode);
            }

            // skip permutation if path is already >= chosen path
            if(chosenPath !== null && path.length >= chosenPath.length &&
              path > chosenPath) {
              return nextPermutation(true);
            }
          }

          // does the next recursion
          return nextRecursion(0);
          function nextRecursion(n) {
            if(n === recurse.length) {
              // done, do next permutation
              return nextPermutation(false);
            }

            // do recursion
            var bnode = recurse[n];
            return _hashPaths(bnode, bnodes, namer, pathNamerCopy,
              function(err, result) {
                if(err) {
                  return callback(err);
                }
                path += pathNamerCopy.getName(bnode) + '<' + result.hash + '>';
                pathNamerCopy = result.pathNamer;

                // skip permutation if path is already >= chosen path
                if(chosenPath !== null && path.length >= chosenPath.length &&
                  path > chosenPath) {
                  return nextPermutation(true);
                }

                // do next recursion
                return nextRecursion(n + 1);
              });
          }

          // stores the results of this permutation and runs the next
          function nextPermutation(skipped) {
            if(!skipped && (chosenPath === null || path < chosenPath)) {
              chosenPath = path;
              chosenNamer = pathNamerCopy;
            }

            // do next permutation
            if(permutator.hasNext()) {
              return permutate();
            } else {
              // digest chosen path and update namer
              md.update(chosenPath);
              pathNamer = chosenNamer;

              // hash the next group
              return hashGroup(i + 1);
            }
          }
        }
      }
    }

    /**
     * A helper function that gets the blank node name from an RDF quad node
     * (subject or object). If the node is a blank node and its value
     * does not match the given blank node ID, it will be returned.
     *
     * @param node the RDF quad node.
     * @param id the ID of the blank node to look next to.
     *
     * @return the adjacent blank node name or null if none was found.
     */
    function _getAdjacentBlankNodeName(node, id) {
      return (node.type === 'blank node' && node.value !== id ? node.value : null);
    }

    /**
     * Clones an object, array, or string/number. If a typed JavaScript object
     * is given, such as a Date, it will be converted to a string.
     *
     * @param value the value to clone.
     *
     * @return the cloned value.
     */
    function _clone(value) {
      if(value && typeof value === 'object') {
        var rval;
        if(Array.isArray(value)) {
          rval = [];
          for(var i = 0; i < value.length; ++i) {
            rval[i] = _clone(value[i]);
          }
        } else if(typeof value === 'object') {
          rval = {};
          for(var key in value) {
            rval[key] = _clone(value[key]);
          }
        } else {
          rval = value.toString();
        }
        return rval;
      }
      return value;
    }

    /**
     * Converts an RDF triple and graph name to an N-Quad string (a single quad).
     *
     * @param triple the RDF triple to convert.
     * @param graphName the name of the graph containing the triple, null for
     *          the default graph.
     * @param bnode the bnode the quad is mapped to (optional, for use
     *          during normalization only).
     *
     * @return the N-Quad string.
     */
    function _toNQuad(triple, graphName, bnode) {
      var s = triple.subject;
      var p = triple.predicate;
      var o = triple.object;
      var g = graphName;

      var quad = '';

      // subject is an IRI
      if(s.type === 'IRI') {
        quad += '<' + s.value + '>';
      } else if(bnode) {
        // bnode normalization mode
        quad += (s.value === bnode) ? '_:a' : '_:z';
      } else {
        // bnode normal mode
        quad += s.value;
      }
      quad += ' ';

      // predicate is an IRI
      if(p.type === 'IRI') {
        quad += '<' + p.value + '>';
      } else if(bnode) {
        // FIXME: TBD what to do with bnode predicates during normalization
        // bnode normalization mode
        quad += '_:p';
      } else {
        // bnode normal mode
        quad += p.value;
      }
      quad += ' ';

      // object is IRI, bnode, or literal
      if(o.type === 'IRI') {
        quad += '<' + o.value + '>';
      } else if(o.type === 'blank node') {
        // normalization mode
        if(bnode) {
          quad += (o.value === bnode) ? '_:a' : '_:z';
        } else {
          // normal mode
          quad += o.value;
        }
      } else {
        var escaped = o.value
          .replace(/\\/g, '\\\\')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/\"/g, '\\"');
        quad += '"' + escaped + '"';
        if(o.datatype === RDF_LANGSTRING) {
          if(o.language) {
            quad += '@' + o.language;
          }
        } else if(o.datatype !== XSD_STRING) {
          quad += '^^<' + o.datatype + '>';
        }
      }

      // graph
      if(g !== null) {
        if(g.indexOf('_:') !== 0) {
          quad += ' <' + g + '>';
        } else if(bnode) {
          quad += ' _:g';
        } else {
          quad += ' ' + g;
        }
      }

      quad += ' .\n';
      return quad;
    }

    /**
     * Creates a new UniqueNamer. A UniqueNamer issues unique names, keeping
     * track of any previously issued names.
     *
     * @param prefix the prefix to use ('<prefix><counter>').
     */
    function UniqueNamer(prefix) {
      this.prefix = prefix;
      this.counter = 0;
      this.existing = {};
    }

    /**
     * Copies this UniqueNamer.
     *
     * @return a copy of this UniqueNamer.
     */
    UniqueNamer.prototype.clone = function() {
      var copy = new UniqueNamer(this.prefix);
      copy.counter = this.counter;
      copy.existing = _clone(this.existing);
      return copy;
    };

    /**
     * Gets the new name for the given old name, where if no old name is given
     * a new name will be generated.
     *
     * @param [oldName] the old name to get the new name for.
     *
     * @return the new name.
     */
    UniqueNamer.prototype.getName = function(oldName) {
      // return existing old name
      if(oldName && oldName in this.existing) {
        return this.existing[oldName];
      }

      // get next name
      var name = this.prefix + this.counter;
      this.counter += 1;

      // save mapping
      if(oldName) {
        this.existing[oldName] = name;
      }

      return name;
    };

    /**
     * Returns true if the given oldName has already been assigned a new name.
     *
     * @param oldName the oldName to check.
     *
     * @return true if the oldName has been assigned a new name, false if not.
     */
    UniqueNamer.prototype.isNamed = function(oldName) {
      return (oldName in this.existing);
    };

    /**
     * A Permutator iterates over all possible permutations of the given array
     * of elements.
     *
     * @param list the array of elements to iterate over.
     */
    var Permutator = function(list) {
      // original array
      this.list = list.sort();
      // indicates whether there are more permutations
      this.done = false;
      // directional info for permutation algorithm
      this.left = {};
      for(var i = 0; i < list.length; ++i) {
        this.left[list[i]] = true;
      }
    };

    /**
     * Returns true if there is another permutation.
     *
     * @return true if there is another permutation, false if not.
     */
    Permutator.prototype.hasNext = function() {
      return !this.done;
    };

    /**
     * Gets the next permutation. Call hasNext() to ensure there is another one
     * first.
     *
     * @return the next permutation.
     */
    Permutator.prototype.next = function() {
      // copy current permutation
      var rval = this.list.slice();

      /* Calculate the next permutation using the Steinhaus-Johnson-Trotter
       permutation algorithm. */

      // get largest mobile element k
      // (mobile: element is greater than the one it is looking at)
      var k = null;
      var pos = 0;
      var length = this.list.length;
      for(var i = 0; i < length; ++i) {
        var element = this.list[i];
        var left = this.left[element];
        if((k === null || element > k) &&
          ((left && i > 0 && element > this.list[i - 1]) ||
          (!left && i < (length - 1) && element > this.list[i + 1]))) {
          k = element;
          pos = i;
        }
      }

      // no more permutations
      if(k === null) {
        this.done = true;
      } else {
        // swap k and the element it is looking at
        var swap = this.left[k] ? pos - 1 : pos + 1;
        this.list[pos] = this.list[swap];
        this.list[swap] = k;

        // reverse the direction of all elements larger than k
        for(var i = 0; i < length; ++i) {
          if(this.list[i] > k) {
            this.left[this.list[i]] = !this.left[this.list[i]];
          }
        }
      }

      return rval;
    };

// SHA-1 API
    var sha1 = {};

    var crypto = __webpack_require__(/*! crypto */ "crypto");
    sha1.create = function() {
      var md = crypto.createHash('sha1');
      return {
        update: function(data) {
          md.update(data, 'utf8');
        },
        digest: function() {
          return md.digest('hex');
        }
      };
    };

    /**
     * Hashes the given array of quads and returns its hexadecimal SHA-1 message
     * digest.
     *
     * @param nquads the list of serialized quads to hash.
     *
     * @return the hexadecimal SHA-1 message digest.
     */
    sha1.hash = function(nquads) {
      var md = sha1.create();
      for(var i = 0; i < nquads.length; ++i) {
        md.update(nquads[i]);
      }
      return md.digest();
    };

function normalize (dataset) {
  var processor = new Processor()

  return processor.normalize(dataset)
}

module.exports = normalize


/***/ }),

/***/ "./node_modules/rdf-parser-abstract/index.js":
/*!***************************************************!*\
  !*** ./node_modules/rdf-parser-abstract/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var concatStream = __webpack_require__(/*! concat-stream */ "./node_modules/concat-stream/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js")
var Readable = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable.js").Readable

function AbstractParser (rdf) {
  this.rdf = rdf
}

AbstractParser.prototype.parse = function (data, callback, base, filter, graph) {
  var self = this

  graph = graph || self.rdf.createGraph()

  var pushTriple = function (triple) {
    graph.add(triple)
  }

  return new Promise(function (resolve, reject) {
    self.process(data, pushTriple, base, filter).then(function() {
      // callback API
      if (callback) {
        process.nextTick(function () {
            callback(null, graph)
        })
      }

      // Promise API
      resolve(graph)
    }).catch(function(error) {
      if (callback) {
        process.nextTick(function () {
            callback(error)
        })
      }
    
      reject(error)
    })
  })
}

AbstractParser.prototype.stream = function (inputStream, base, filter) {
  var self = this

  var outputStream = new AbstractParser.TripleReadStream()

  AbstractParser.streamToData(inputStream).then(function (data) {
    self.process(data, function (triple) {
      outputStream.push(triple)
    }, base, filter, function (error) {
      if (error) {
        outputStream.emit('error', error)
      } else {
        outputStream.emit('end')
      }
    })
  }).catch(function (error) {
    outputStream.emit('error', error)
  })

  return outputStream
}

AbstractParser.streamToData = function (stream) {
  return new Promise(function (resolve, reject) {
    if (typeof stream !== 'object' || typeof stream.read !== 'function') {
      return resolve(stream)
    }

    stream.on('error', function (error) {
      reject(error)
    })

    stream.pipe(concatStream(function (data) {
      resolve(data)
    }))
  })
}

AbstractParser.TripleReadStream = function () {
  Readable.call(this, {objectMode: true})

  this._read = function () {
    return 0
  }
}

inherits(AbstractParser.TripleReadStream, Readable)

module.exports = AbstractParser


/***/ }),

/***/ "./node_modules/rdf-parser-dom/browser.js":
/*!************************************************!*\
  !*** ./node_modules/rdf-parser-dom/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global DOMParser */
var util = __webpack_require__(/*! util */ "util")
var AbstractParser = __webpack_require__(/*! rdf-parser-abstract */ "./node_modules/rdf-parser-abstract/index.js")

function DomParser (rdf) {
  AbstractParser.call(this, rdf)
}

util.inherits(DomParser, AbstractParser)

DomParser.prototype.parseHtmlDom = function (toparse, base) {
  var parser = new DOMParser()

  return parser.parseFromString(toparse, 'text/html')
}

DomParser.prototype.parseXmlDom = function (toparse, base) {
  var parser = new DOMParser()

  return parser.parseFromString(toparse, 'application/xml')
}

module.exports = DomParser


/***/ }),

/***/ "./node_modules/rdf-parser-dom/index.js":
/*!**********************************************!*\
  !*** ./node_modules/rdf-parser-dom/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (process.browser) {
  module.exports = __webpack_require__(/*! ./browser */ "./node_modules/rdf-parser-dom/browser.js")
} else {
  module.exports = __webpack_require__(/*! ./node */ "./node_modules/rdf-parser-dom/node.js")
}


/***/ }),

/***/ "./node_modules/rdf-parser-dom/node.js":
/*!*********************************************!*\
  !*** ./node_modules/rdf-parser-dom/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! util */ "util")
var xmldom = __webpack_require__(/*! xmldom */ "./node_modules/xmldom/dom-parser.js")
var AbstractParser = __webpack_require__(/*! rdf-parser-abstract */ "./node_modules/rdf-parser-abstract/index.js")

function DomParser (rdf) {
  AbstractParser.call(this, rdf)
}

util.inherits(DomParser, AbstractParser)

DomParser.prototype.parseHtmlDom = function (toparse, base) {
  var parser = new (xmldom.DOMParser)()

  parser.options.errorHandler = {
    warning: function () {},
    error: function () {},
    fatalError: function () {}
  }

  return parser.parseFromString(toparse, 'text/html')
}

DomParser.prototype.parseXmlDom = function (toparse, base) {
  var parser = new (xmldom.DOMParser)()

  parser.options.errorHandler = {
    warning: function () {},
    error: function () {},
    fatalError: function () {}
  }

  return parser.parseFromString(toparse, 'application/xml')
}

module.exports = DomParser


/***/ }),

/***/ "./node_modules/rdf-parser-rdfxml/index.js":
/*!*************************************************!*\
  !*** ./node_modules/rdf-parser-rdfxml/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 *  RDF/XML PARSER
 *
 * Version 0.1
 *  Parser believed to be in full positive RDF/XML parsing compliance
 *  with the possible exception of handling deprecated RDF attributes
 *  appropriately. Parser is believed to comply fully with other W3C
 *  and industry standards where appropriate (DOM, ECMAScript, &c.)
 *
 *  Author: David Sheets <dsheets@mit.edu>
 *
 * W3C� SOFTWARE NOTICE AND LICENSE
 * http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
 * This work (and included software, documentation such as READMEs, or
 * other related items) is being provided by the copyright holders under
 * the following license. By obtaining, using and/or copying this work,
 * you (the licensee) agree that you have read, understood, and will
 * comply with the following terms and conditions.
 *
 * Permission to copy, modify, and distribute this software and its
 * documentation, with or without modification, for any purpose and
 * without fee or royalty is hereby granted, provided that you include
 * the following on ALL copies of the software and documentation or
 * portions thereof, including modifications:
 *
 * 1. The full text of this NOTICE in a location viewable to users of
 * the redistributed or derivative work.
 * 2. Any pre-existing intellectual property disclaimers, notices, or terms and
 * conditions. If none exist, the W3C Software Short Notice should be
 * included (hypertext is preferred, text is permitted) within the body
 * of any redistributed or derivative code.
 * 3. Notice of any changes or modifications to the files, including the
 * date changes were made. (We recommend you provide URIs to the location
 * from which the code is derived.)
 *
 * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS," AND COPYRIGHT
 * HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS
 * FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR
 * DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
 * TRADEMARKS OR OTHER RIGHTS.
 *
 * COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL
 * OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR
 * DOCUMENTATION.
 *
 * The name and trademarks of copyright holders may NOT be used in
 * advertising or publicity pertaining to the software without specific,
 * written prior permission. Title to copyright in this software and any
 * associated documentation will at all times remain with copyright
 * holders.
 */
/**
 * @class Class defining an RDFParser resource object tied to an RDFStore
 *
 * @author David Sheets <dsheets@mit.edu>
 * @version 0.1
 *
 * @constructor
 * @param {RDFStore} store An RDFStore object
 */

var RdfLibParser = function(store){
  var RDFParser = {};

  /** Standard namespaces that we know how to handle @final
   *  @member RDFParser
   */
  RDFParser.ns = {'RDF': "http://www.w3.org/1999/02/22-rdf-syntax-ns#", 'RDFS': "http://www.w3.org/2000/01/rdf-schema#"};

  /** DOM Level 2 node type magic numbers @final
   *  @member RDFParser
   */
  RDFParser.nodeType = {'ELEMENT': 1, 'ATTRIBUTE': 2, 'TEXT': 3,
    'CDATA_SECTION': 4, 'ENTITY_REFERENCE': 5,
    'ENTITY': 6, 'PROCESSING_INSTRUCTION': 7,
    'COMMENT': 8, 'DOCUMENT': 9, 'DOCUMENT_TYPE': 10,
    'DOCUMENT_FRAGMENT': 11, 'NOTATION': 12};

  /**
   * Frame class for namespace and base URI lookups
   * Base lookups will always resolve because the parser knows
   * the default base.
   *
   * @private
   */

  this.frameFactory = function(parser, parent, element){
    return {'NODE': 1, 'ARC': 2, 'parent': parent, 'parser': parser, 'store': parser.store, 'element': element,
      'lastChild': 0, 'base': null, 'lang': null, 'node': null, 'nodeType': null, 'listIndex': 1, 'rdfid': null, 'datatype': null, 'collection': false, /** Terminate the frame and notify the store that we're done */
      'terminateFrame': function(){
        if (this.collection){

          this.node.close();
        }
      }
      , /** Add a symbol of a certain type to the this frame */'addSymbol': function(type, uri){
        uri = uriJoin(uri, this.base);
        this.node = this.store.sym(uri);

        this.nodeType = type;
      }
      , /** Load any constructed triples into the store */'loadTriple': function(){
        if (this.parent.parent.collection){
          this.parent.parent.node.append(this.node);
        }
        else {
          this.store.add(this.parent.parent.node, this.parent.node, this.node, this.parser.why);
        }
        if (this.parent.rdfid != null){
          // reify
          var triple = this.store.sym(uriJoin("#" + this.parent.rdfid, this.base));
          this.store.add(triple, this.store.sym(RDFParser.ns.RDF + "type"), this.store.sym(RDFParser.ns.RDF + "Statement"), this.parser.why);
          this.store.add(triple, this.store.sym(RDFParser.ns.RDF + "subject"), this.parent.parent.node, this.parser.why);
          this.store.add(triple, this.store.sym(RDFParser.ns.RDF + "predicate"), this.parent.node, this.parser.why);

          this.store.add(triple, this.store.sym(RDFParser.ns.RDF + "object"), this.node, this.parser.why);
        }
      }
      , /** Check if it's OK to load a triple */'isTripleToLoad': function(){

        return (this.parent != null && this.parent.parent != null && this.nodeType === this.NODE && this.parent.nodeType ===
        this.ARC && this.parent.parent.nodeType === this.NODE);
      }
      , /** Add a symbolic node to this frame */'addNode': function(uri){
        this.addSymbol(this.NODE, uri);
        if (this.isTripleToLoad()){

          this.loadTriple();
        }
      }
      , /** Add a collection node to this frame */'addCollection': function(){
        this.nodeType = this.NODE;
        this.node = this.store.collection();
        this.collection = true;
        if (this.isTripleToLoad()){

          this.loadTriple();
        }
      }
      , /** Add a collection arc to this frame */'addCollectionArc': function(){

        this.nodeType = this.ARC;
      }
      , /** Add a bnode to this frame */'addBNode': function(id){
        if (id != null){
          if (this.parser.bnodes[id] != null){
            this.node = this.parser.bnodes[id];
          }
          else {
            this.node = this.parser.bnodes[id] = this.store.bnode();
          }
        }
        else {
          this.node = this.store.bnode();
        }
        this.nodeType = this.NODE;
        if (this.isTripleToLoad()){

          this.loadTriple();
        }
      }
      , /** Add an arc or property to this frame */'addArc': function(uri){
        if (uri === RDFParser.ns.RDF + "li"){
          uri = RDFParser.ns.RDF + "_" + this.parent.listIndex;
          this.parent.listIndex++;
        }

        this.addSymbol(this.ARC, uri);
      }
      , /** Add a literal to this frame */'addLiteral': function(value){
        if (this.parent.datatype){
          this.node = this.store.literal(value, "", this.store.sym(this.parent.datatype));
        }
        else {
          this.node = this.store.literal(value, this.lang);
        }
        this.nodeType = this.NODE;
        if (this.isTripleToLoad()){
          this.loadTriple();
        }
      }
    };
  };

  //from the OpenLayers source .. needed to get around IE problems.
  this.getAttributeNodeNS = function(node, uri, name){
    var attributeNode = null;
    if (node.getAttributeNodeNS){
      attributeNode = node.getAttributeNodeNS(uri, name);
    }
    else {
      var attributes = node.attributes;
      var potentialNode, fullName;
      for (var i = 0;i < attributes.length; ++ i){
        potentialNode = attributes[i];
        if (potentialNode.namespaceURI === uri){
          fullName = (potentialNode.prefix) ? (potentialNode.prefix +":" + name): name;
          if (fullName === potentialNode.nodeName){
            attributeNode = potentialNode;
            break;
          }
        }
      }
    }
    return attributeNode;
  };


  /** Our triple store reference @private */

  this.store = store;/** Our identified blank nodes @private */
  this.bnodes = {};/** A context for context-aware stores @private */
  this.why = null;/** Reification flag */
  this.reify = false;

  /**
   * Build our initial scope frame and parse the DOM into triples
   * @param {DOMTree} document The DOM to parse
   * @param {String} base The base URL to use
   * @param {Object} why The context to which this resource belongs
   */

  this.parse = function(document, base, why){
    var children = document.childNodes;// clean up for the next run
    this.cleanParser();// figure out the root element
    var root;
    if (document.nodeType === RDFParser.nodeType.DOCUMENT){
      for (var c = 0;c < children.length;c++){
        if (children[c].nodeType === RDFParser.nodeType.ELEMENT){
          root = children[c];
          break;
        }
      }
    }
    else if (document.nodeType === RDFParser.nodeType.ELEMENT){
      root = document;
    }
    else {
      throw new Error("RDFParser: can't find root in " + base +". Halting. ");
      // return false;
    }
    this.why = why;// our topmost frame
    var f = this.frameFactory(this);
    this.base = base;
    f.base = base;
    f.lang = '';
    this.parseDOM(this.buildFrame(f, root));
    return true;
  };

  this.parseDOM = function(frame){
    // a DOM utility function used in parsing
    var rdfid;
    var elementURI = function(el){
      var result = "";
      if (el.namespaceURI == null){
        throw new Error("RDF/XML syntax error: No namespace for " + el.localName + " in " + this.base);
      }
      if (el.namespaceURI){
        result = result + el.namespaceURI;
      }
      if (el.localName){
        result = result + el.localName;
      }
      else if (el.nodeName){
        if (el.nodeName.indexOf(":") >= 0)result = result + el.nodeName.split(":")[1];
        else result = result + el.nodeName;
      }
      return result;
    }.bind(this);
    var dig = true;// if we'll dig down in the tree on the next iter
    while (frame.parent){
      var dom = frame.element;
      var attrs = dom.attributes;
      if (dom.nodeType === RDFParser.nodeType.TEXT || dom.nodeType === RDFParser.nodeType.CDATA_SECTION){
        //we have a literal
        if(frame.parent.nodeType == frame.NODE) {
          //must have had attributes, store as rdf:value
          frame.addArc(RDFParser.ns.RDF + 'value');
          frame = this.buildFrame(frame);
        }
        frame.addLiteral(dom.nodeValue);
      }
      else if (elementURI(dom)!== RDFParser.ns.RDF + "RDF"){
        // not root
        if (frame.parent && frame.parent.collection){
          // we're a collection element
          frame.addCollectionArc();
          frame = this.buildFrame(frame, frame.element);
          frame.parent.element = null;
        }
        if ( ! frame.parent || ! frame.parent.nodeType || frame.parent.nodeType === frame.ARC){
          // we need a node
          var about = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "about") || this.getAttributeNodeNS(dom, null, "about");
          rdfid = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "ID");
          if (about && rdfid){
            throw new Error("RDFParser: " + dom.nodeName + " has both rdf:id and rdf:about." +
              " Halting. Only one of these" + " properties may be specified on a" + " node.");
          }
          if (!about && rdfid){
            frame.addNode("#" + rdfid.nodeValue);
            dom.removeAttributeNode(rdfid);
          }
          else if (about == null && rdfid == null){
            var bnid = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "nodeID");
            if (bnid){
              frame.addBNode(bnid.nodeValue);
              dom.removeAttributeNode(bnid);
            }
            else {
              frame.addBNode();
            }
          }
          else {
            frame.addNode(about.nodeValue);
            dom.removeAttributeNode(about);
          }
          // Typed nodes
          var rdftype = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "type");
          if (RDFParser.ns.RDF + "Description" !== elementURI(dom)){
            rdftype = {'nodeValue': elementURI(dom)};
          }
          if (rdftype != null){
            this.store.add(frame.node, this.store.sym(RDFParser.ns.RDF + "type"), this.store.sym(uriJoin(rdftype.nodeValue,
              frame.base)), this.why);
            if (rdftype.nodeName){
              dom.removeAttributeNode(rdftype);
            }
          }
          // Property Attributes
          for (var x = attrs.length - 1;x >= 0;x--){
            this.store.add(frame.node, this.store.sym(elementURI(attrs[x])), this.store.literal(attrs[x].nodeValue,
              frame.lang), this.why);
          }
        }
        else {
          // we should add an arc (or implicit bnode+arc)
          frame.addArc(elementURI(dom));// save the arc's rdf:ID if it has one
          if (this.reify){
            rdfid = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "ID");
            if (rdfid){
              frame.rdfid = rdfid.nodeValue;
              dom.removeAttributeNode(rdfid);
            }
          }
          var parsetype = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "parseType");
          var datatype = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "datatype");
          if (datatype){
            frame.datatype = datatype.nodeValue;
            dom.removeAttributeNode(datatype);
          }
          if (parsetype){
            var nv = parsetype.nodeValue;
            if (nv === "Literal"){
              frame.datatype = RDFParser.ns.RDF + "XMLLiteral";// (this.buildFrame(frame)).addLiteral(dom)
              // should work but doesn't
              frame = this.buildFrame(frame);
              frame.addLiteral(dom);
              dig = false;
            }
            else if (nv === "Resource"){
              frame = this.buildFrame(frame, frame.element);
              frame.parent.element = null;
              frame.addBNode();
            }
            else if (nv === "Collection"){
              frame = this.buildFrame(frame, frame.element);
              frame.parent.element = null;
              frame.addCollection();
            }
            dom.removeAttributeNode(parsetype);
          }
          if (attrs.length !== 0){
            var resource = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "resource");
            var bnid2 = this.getAttributeNodeNS(dom, RDFParser.ns.RDF, "nodeID");
            frame = this.buildFrame(frame);
            if (resource){
              frame.addNode(resource.nodeValue);
              dom.removeAttributeNode(resource);
            }
            else {
              if (bnid2){
                frame.addBNode(bnid2.nodeValue);
                dom.removeAttributeNode(bnid2);
              }
              else {
                frame.addBNode();
              }
            }
            for (var x1 = attrs.length - 1; x1 >= 0; x1--){
              var f = this.buildFrame(frame);
              f.addArc(elementURI(attrs[x1]));
              if (elementURI(attrs[x1])=== RDFParser.ns.RDF + "type"){
                (this.buildFrame(f)).addNode(attrs[x1].nodeValue);
              }
              else {
                (this.buildFrame(f)).addLiteral(attrs[x1].nodeValue);
              }
            }
          }
          else if (dom.childNodes.length === 0){
            (this.buildFrame(frame)).addLiteral("");
          }
        }
      }// rdf:RDF
      // dig dug
      dom = frame.element;
      while (frame.parent){
        var pframe = frame;
        while (dom == null){
          frame = frame.parent;
          dom = frame.element;
        }
        var candidate = dom.childNodes && dom.childNodes[frame.lastChild];
        if (!candidate || ! dig){
          frame.terminateFrame();
          if ( ! (frame = frame.parent)){
            break;
          }// done
          dom = frame.element;
          dig = true;
        }
        else if ((candidate.nodeType !== RDFParser.nodeType.ELEMENT &&
          candidate.nodeType !== RDFParser.nodeType.TEXT &&
          candidate.nodeType !== RDFParser.nodeType.CDATA_SECTION) ||
          ((candidate.nodeType === RDFParser.nodeType.TEXT ||
          candidate.nodeType === RDFParser.nodeType.CDATA_SECTION) &&
          dom.childNodes.length !== 1)){
          frame.lastChild++;
        }
        else {
          // not a leaf
          frame.lastChild++;
          frame = this.buildFrame(pframe, dom.childNodes[frame.lastChild - 1]);
          break;
        }
      }
    }// while
  };

  /**
   * Cleans out state from a previous parse run
   * @private
   */
  this.cleanParser = function(){
    this.bnodes = {};
    this.why = null;
  };

  /**
   * Builds scope frame
   * @private
   */
  this.buildFrame = function(parent, element){
    var frame = this.frameFactory(this, parent, element);
    if (parent){
      frame.base = parent.base;
      frame.lang = parent.lang;
    }
    if (!element || element.nodeType === RDFParser.nodeType.TEXT ||
      element.nodeType === RDFParser.nodeType.CDATA_SECTION){
      return frame;
    }
    var attrs = element.attributes;
    var base = element.getAttributeNode("xml:base");
    if (base != null){
      frame.base = base.nodeValue;
      element.removeAttribute("xml:base");
    }
    var lang = element.getAttributeNode("xml:lang");
    if (lang != null){
      frame.lang = lang.nodeValue;
      element.removeAttribute("xml:lang");
    }
    // remove all extraneous xml and xmlns attributes
    for (var x = attrs.length - 1;x >= 0;x--){
      if (attrs[x].nodeName.substr(0, 3) === "xml"){
        if (attrs[x].name.slice(0, 6) === 'xmlns:'){
          var uri = attrs[x].nodeValue;// alert('base for namespac attr:'+this.base);
          if (this.base) uri = uriJoin(uri, this.base);
          this.store.setPrefixForURI(attrs[x].name.slice(6), uri);
        }
        //		alert('rdfparser: xml atribute: '+attrs[x].name) //@@
        element.removeAttributeNode(attrs[x]);
      }
    }
    return frame;
  };
};


// taken from rdflib/uri.coffee
var uriJoin = function(given, base) {
  var baseColon, baseHash, baseScheme, baseSingle, colon, lastSlash, path;
  baseHash = base.indexOf('#');
  if (baseHash > 0) {
    base = base.slice(0, baseHash);
  }
  if (given.length === 0) {
    return base;
  }
  if (given.indexOf('#') === 0) {
    return base + given;
  }
  colon = given.indexOf(':');
  if (colon >= 0) {
    return given;
  }
  baseColon = base.indexOf(':');
  if (base.length === 0) {
    return given;
  }
  if (baseColon < 0) {
    alert("Invalid base: " + base + " in join with given: " + given);
    return given;
  }
  baseScheme = base.slice(0, +baseColon + 1 || 9e9);
  if (given.indexOf('//') === 0) {
    return baseScheme + given;
  }
  if (base.indexOf('//', baseColon) === baseColon + 1) {
    baseSingle = base.indexOf('/', baseColon + 3);
    if (baseSingle < 0) {
      if (base.length - baseColon - 3 > 0) {
        return base + '/' + given;
      } else {
        return baseScheme + given;
      }
    }
  } else {
    baseSingle = base.indexOf('/', baseColon + 1);
    if (baseSingle < 0) {
      if (base.length - baseColon - 1 > 0) {
        return base + '/' + given;
      } else {
        return baseScheme + given;
      }
    }
  }
  if (given.indexOf('/') === 0) {
    return base.slice(0, baseSingle) + given;
  }
  path = base.slice(baseSingle);
  lastSlash = path.lastIndexOf('/');
  if (lastSlash < 0) {
    return baseScheme + given;
  }
  if (lastSlash >= 0 && lastSlash < path.length - 1) {
    path = path.slice(0, +lastSlash + 1 || 9e9);
  }
  path += given;
  while (path.match(/[^\/]*\/\.\.\//)) {
    path = path.replace(/[^\/]*\/\.\.\//, '');
  }
  path = path.replace(/\.\//g, '');
  path = path.replace(/\/\.$/, '/');
  return base.slice(0, baseSingle) + path;
};


// RDF-Interface API
var rdf = __webpack_require__(/*! rdf-ext */ "./node_modules/rdf-ext/rdf-ext.js")
var util = __webpack_require__(/*! util */ "util")
var DomParser = __webpack_require__(/*! rdf-parser-dom */ "./node_modules/rdf-parser-dom/index.js")

var RdfXmlParser = function () {
  DomParser.call(this, rdf)
}

util.inherits(RdfXmlParser, DomParser)

RdfXmlParser.prototype.process = function (toparse, callback, base, filter, done) {
  var self = this;

  return new Promise(function (resolve, reject) {
    base = base || '';
    filter = filter || function() { return true; };
    done = done || function () {};

    // convert an array of DOM nodes to a XML string
    var domNodesToString = function (nodes) {
      var xmlString = '';

      for(var i=0; i<nodes.length; i++) {
        xmlString += nodes[i].toString();
      }

      return xmlString;
    };

    // rdflib store interface
    var store = {};

    store.add = function (s, p, o ) {
      var triple = self.rdf.createTriple(s, p, o);

      if (filter(triple)) {
        callback(triple);
      }
    };

    store.bnode = function () { return self.rdf.createBlankNode(); };

    store.literal = function (value, language, type) {
      // parse type literal
      if (type && type.toString() === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral') {
        value = domNodesToString(value.childNodes);
      }

      return self.rdf.createLiteral(value, language, type);
    };

    store.setPrefixForURI = function () {}; // that's the place to implement prefix mapping

    store.sym = function (iri) { return self.rdf.createNamedNode(iri); };

    try {
      if (typeof toparse === 'string') {
        toparse = self.parseXmlDom(toparse);
      }

      new RdfLibParser(store).parse(toparse, base);
    } catch (error) {
      done(error);
      reject(error);
    }

    done();
    resolve();
  });
}

// add singleton methods to class
var instance = new RdfXmlParser()

for (var property in instance) {
  RdfXmlParser[property] = instance[property]
}

module.exports = RdfXmlParser


/***/ }),

/***/ "./node_modules/rdf-serializer-ntriples/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rdf-serializer-ntriples/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const SerializerStream = __webpack_require__(/*! ./lib/SerializerStream */ "./node_modules/rdf-serializer-ntriples/lib/SerializerStream.js")
const Sink = __webpack_require__(/*! rdf-sink */ "./node_modules/rdf-sink/index.js")

class Serializer extends Sink {
  constructor () {
    super(SerializerStream)
  }
}

module.exports = Serializer


/***/ }),

/***/ "./node_modules/rdf-serializer-ntriples/lib/SerializerStream.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rdf-serializer-ntriples/lib/SerializerStream.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Readable = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable.js")

class SerializerStream extends Readable {
  constructor (input) {
    super()

    this._read = () => {}

    input.on('data', (quad) => {
      this.push(quad.toCanonical() + '\n')
    })

    input.on('end', () => {
      this.push(null)
    })

    input.on('error', (err) => {
      this.emit('error', err)
    })
  }
}

module.exports = SerializerStream


/***/ }),

/***/ "./node_modules/rdf-sink/index.js":
/*!****************************************!*\
  !*** ./node_modules/rdf-sink/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Sink {
  constructor (Impl, options) {
    this.Impl = Impl
    this.options = options
  }

  import (input, options) {
    let output = new this.Impl(input, Object.assign({}, this.options, options))

    input.on('end', () => {
      if (!output.readable) {
        output.emit('end')
      }
    })

    input.on('error', (err) => {
      output.emit('error', err)
    })

    return output
  }
}

module.exports = Sink


/***/ }),

/***/ "./node_modules/rdf-store-abstract/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rdf-store-abstract/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function AbstractStore () {
}

AbstractStore.prototype.add = function () {
  throw new Error('not implemented')
}

AbstractStore.prototype.delete = function () {
  throw new Error('not implemented')
}

AbstractStore.prototype.graph = function () {
  throw new Error('not implemented')
}

AbstractStore.prototype.match = function (subject, predicate, object, iri, callback, limit) {
  var self = this

  callback = callback || function () {}

  return self.graph(iri).then(function (graph) {
    if (graph) {
      graph = graph.match(subject, predicate, object, limit)
    }

    callback(null, graph)

    return graph
  })
}

AbstractStore.prototype.merge = function (iri, graph, callback) {
  var self = this

  callback = callback || function () {}

  return self.graph(iri).then(function (existing) {
    if (existing) {
      existing.addAll(graph)
    } else {
      existing = graph
    }

    return self.add(iri, existing, callback)
  }).then(function () {
    return graph
  })
}

AbstractStore.prototype.remove = function (iri, graph, callback) {
  var self = this

  callback = callback || function () {}

  return self.graph(iri).then(function (existing) {
    if (existing) {
      return self.add(iri, existing.difference(graph))
    }
  }).then(callback)
}

AbstractStore.prototype.removeMatches = function (subject, predicate, object, iri, callback) {
  var self = this

  callback = callback || function () {}

  return self.graph(iri).then(function (existing) {
    if (existing) {
      return self.add(iri, existing.removeMatches(subject, predicate, object))
    }
  }).then(callback)
}

module.exports = AbstractStore


/***/ }),

/***/ "./node_modules/rdf-store-inmemory/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rdf-store-inmemory/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! util */ "util")
var AbstractStore = __webpack_require__(/*! rdf-store-abstract */ "./node_modules/rdf-store-abstract/index.js")

function iriToKey (iri) {
  // default graph
  if (iri === true) {
    return iri
  }

  // all graphs
  if (!iri) {
    return null
  }

  return iri.toString()
}

function InMemoryStore (options) {
  options = options || {}

  this.rdf = options.rdf || __webpack_require__(/*! rdf-ext */ "./node_modules/rdf-ext/rdf-ext.js")
  this.graphs = {}

  AbstractStore.call(this)
}

util.inherits(InMemoryStore, AbstractStore)

InMemoryStore.prototype.add = function (iri, graph, callback) {
  var self = this

  iri = iriToKey(iri)
  callback = callback || function () {}

  return new Promise(function (resolve) {
    self.graphs[iri] = self.rdf.createGraph()
    self.graphs[iri].addAll(graph)

    callback(null, graph)
    resolve(graph)
  })
}

InMemoryStore.prototype.delete = function (iri, callback) {
  var self = this

  iri = iriToKey(iri)
  callback = callback || function () {}

  return new Promise(function (resolve) {
    if (iri in self.graphs) {
      delete self.graphs[iri]
    }

    callback()
    resolve()
  })
}

InMemoryStore.prototype.graph = function (iri, callback) {
  var self = this

  iri = iriToKey(iri)
  callback = callback || function () {}

  return new Promise(function (resolve) {
    var graph = null

    if (iri) {
      graph = self.graphs[iri]
    } else {
      graph = self.rdf.createGraph()

      Object.keys(self.graphs).forEach(function (iri) {
        graph.addAll(self.graphs[iri])
      })
    }

    callback(null, graph)
    resolve(graph)
  })
}

module.exports = InMemoryStore


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Activity_1 = __webpack_require__(/*! ./prov/Activity */ "./node_modules/rdfoo-prov/dist/prov/Activity.js");
exports.Activity = Activity_1.default;
const Agent_1 = __webpack_require__(/*! ./prov/Agent */ "./node_modules/rdfoo-prov/dist/prov/Agent.js");
exports.Agent = Agent_1.default;
const Association_1 = __webpack_require__(/*! ./prov/Association */ "./node_modules/rdfoo-prov/dist/prov/Association.js");
exports.Association = Association_1.default;
const Plan_1 = __webpack_require__(/*! ./prov/Plan */ "./node_modules/rdfoo-prov/dist/prov/Plan.js");
exports.Plan = Plan_1.default;
const ProvView_1 = __webpack_require__(/*! ./prov/ProvView */ "./node_modules/rdfoo-prov/dist/prov/ProvView.js");
exports.ProvView = ProvView_1.default;
const Usage_1 = __webpack_require__(/*! ./prov/Usage */ "./node_modules/rdfoo-prov/dist/prov/Usage.js");
exports.Usage = Usage_1.default;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/Activity.js":
/*!*******************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/Activity.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Association_1 = __webpack_require__(/*! ./Association */ "./node_modules/rdfoo-prov/dist/prov/Association.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const Plan_1 = __webpack_require__(/*! ./Plan */ "./node_modules/rdfoo-prov/dist/prov/Plan.js");
const Usage_1 = __webpack_require__(/*! ./Usage */ "./node_modules/rdfoo-prov/dist/prov/Usage.js");
const ProvFacade_1 = __webpack_require__(/*! ./ProvFacade */ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js");
class Activity extends ProvFacade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Prov.Activity;
    }
    get associations() {
        return this.getUriProperties(bioterms_1.Predicates.Prov.qualifiedAssociation)
            .map((uri) => new Association_1.default(this.view, uri));
    }
    get plan() {
        let plan = this.getUriProperty(bioterms_1.Predicates.Prov.hadPlan);
        if (!plan) {
            return undefined;
        }
        return new Plan_1.default(this.view, plan);
    }
    set plan(plan) {
        if (plan === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.hadPlan);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.hadPlan, plan.uri);
        }
    }
    get usage() {
        let usage = this.getUriProperty(bioterms_1.Predicates.Prov.qualifiedUsage);
        if (!usage) {
            return undefined;
        }
        return new Usage_1.default(this.view, usage);
    }
    set usage(usage) {
        if (usage === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.qualifiedUsage);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.qualifiedUsage, usage.uri);
        }
    }
    get association() {
        let association = this.getUriProperty(bioterms_1.Predicates.Prov.qualifiedAssociation);
        if (!association) {
            return undefined;
        }
        return new Association_1.default(this.view, association);
    }
    set association(association) {
        if (association === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.qualifiedAssociation);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.qualifiedAssociation, association.uri);
        }
    }
}
exports.default = Activity;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/Agent.js":
/*!****************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/Agent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const ProvFacade_1 = __webpack_require__(/*! ./ProvFacade */ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js");
class Agent extends ProvFacade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Prov.Agent;
    }
}
exports.default = Agent;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/Association.js":
/*!**********************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/Association.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Agent_1 = __webpack_require__(/*! ./Agent */ "./node_modules/rdfoo-prov/dist/prov/Agent.js");
const Plan_1 = __webpack_require__(/*! ./Plan */ "./node_modules/rdfoo-prov/dist/prov/Plan.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const ProvFacade_1 = __webpack_require__(/*! ./ProvFacade */ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js");
class Association extends ProvFacade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Prov.Association;
    }
    get agent() {
        let agent = this.getUriProperty(bioterms_1.Predicates.Prov.agent);
        if (!agent) {
            return undefined;
        }
        return new Agent_1.default(this.view, agent);
    }
    set agent(agent) {
        if (agent === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.agent);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.agent, agent.uri);
        }
    }
    get plan() {
        let plan = this.getUriProperty(bioterms_1.Predicates.Prov.hadPlan);
        if (!plan) {
            return undefined;
        }
        return new Plan_1.default(this.view, plan);
    }
    set plan(plan) {
        if (plan === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.hadPlan);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.hadPlan, plan.uri);
        }
    }
    get role() {
        return this.getUriProperty(bioterms_1.Predicates.Prov.hadRole);
    }
    set role(role) {
        this.setUriProperty(bioterms_1.Predicates.Prov.hadRole, role);
    }
}
exports.default = Association;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/Plan.js":
/*!***************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/Plan.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const ProvFacade_1 = __webpack_require__(/*! ./ProvFacade */ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js");
class Plan extends ProvFacade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Prov.Plan;
    }
}
exports.default = Plan;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js":
/*!*********************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/ProvFacade.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
class ProvFacade extends rdfoo_1.Facade {
    constructor(view, uri) {
        super(view.graph, uri);
        this.view = view;
    }
}
exports.default = ProvFacade;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/ProvView.js":
/*!*******************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/ProvView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const Activity_1 = __webpack_require__(/*! ./Activity */ "./node_modules/rdfoo-prov/dist/prov/Activity.js");
const Usage_1 = __webpack_require__(/*! ./Usage */ "./node_modules/rdfoo-prov/dist/prov/Usage.js");
const Agent_1 = __webpack_require__(/*! ./Agent */ "./node_modules/rdfoo-prov/dist/prov/Agent.js");
const Plan_1 = __webpack_require__(/*! ./Plan */ "./node_modules/rdfoo-prov/dist/prov/Plan.js");
const Association_1 = __webpack_require__(/*! ./Association */ "./node_modules/rdfoo-prov/dist/prov/Association.js");
class ProvView extends rdfoo_1.GraphViewBasic {
    uriToFacade(uri) {
        let types = this.getTypes(uri);
        for (let type of types) {
            if (type === bioterms_1.Types.Prov.Activity) {
                return new Activity_1.default(this, uri);
            }
            if (type === bioterms_1.Types.Prov.Agent) {
                return new Agent_1.default(this, uri);
            }
            if (type === bioterms_1.Types.Prov.Association) {
                return new Association_1.default(this, uri);
            }
            if (type === bioterms_1.Types.Prov.Plan) {
                return new Plan_1.default(this, uri);
            }
            if (type === bioterms_1.Types.Prov.Usage) {
                return new Usage_1.default(this, uri);
            }
        }
    }
    get activities() {
        return this.instancesOfType(bioterms_1.Types.Prov.Activity).map(uri => new Activity_1.default(this, uri));
    }
    get agents() {
        return this.instancesOfType(bioterms_1.Types.Prov.Agent).map(uri => new Agent_1.default(this, uri));
    }
    get associations() {
        return this.instancesOfType(bioterms_1.Types.Prov.Association).map(uri => new Association_1.default(this, uri));
    }
    get plans() {
        return this.instancesOfType(bioterms_1.Types.Prov.Plan).map(uri => new Plan_1.default(this, uri));
    }
    get usages() {
        return this.instancesOfType(bioterms_1.Types.Prov.Usage).map(uri => new Usage_1.default(this, uri));
    }
}
exports.default = ProvView;


/***/ }),

/***/ "./node_modules/rdfoo-prov/dist/prov/Usage.js":
/*!****************************************************!*\
  !*** ./node_modules/rdfoo-prov/dist/prov/Usage.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js");
const ProvFacade_1 = __webpack_require__(/*! ./ProvFacade */ "./node_modules/rdfoo-prov/dist/prov/ProvFacade.js");
class Usage extends ProvFacade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Prov.Usage;
    }
    get entity() {
        let entity = this.getUriProperty(bioterms_1.Predicates.Prov.entity);
        if (entity === undefined)
            return undefined;
        return this.view.uriToFacade(entity);
    }
    set entity(entity) {
        if (entity === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.entity);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.entity, entity.uri);
        }
    }
    get role() {
        return this.getUriProperty(bioterms_1.Predicates.Prov.hadRole);
    }
    set role(role) {
        this.setUriProperty(bioterms_1.Predicates.Prov.hadRole, role);
    }
}
exports.default = Usage;


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Predicates.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/Predicates.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js");
var Predicates;
(function (Predicates) {
    Predicates.a = Prefixes_1.Prefixes.rdf + 'type';
    let SBOL1;
    (function (SBOL1) {
        SBOL1.nucleotides = Prefixes_1.Prefixes.sbol1 + 'nucleotides';
        SBOL1.subComponent = Prefixes_1.Prefixes.sbol1 + 'subComponent';
        SBOL1.dnaSequence = Prefixes_1.Prefixes.sbol1 + 'dnaSequence';
        SBOL1.bioStart = Prefixes_1.Prefixes.sbol1 + 'bioStart';
        SBOL1.bioEnd = Prefixes_1.Prefixes.sbol1 + 'bioEnd';
        SBOL1.displayId = Prefixes_1.Prefixes.sbol1 + 'displayId';
        SBOL1.name = Prefixes_1.Prefixes.sbol1 + 'name';
        SBOL1.description = Prefixes_1.Prefixes.sbol1 + 'description';
        SBOL1.annotation = Prefixes_1.Prefixes.sbol1 + 'annotation';
        SBOL1.strand = Prefixes_1.Prefixes.sbol1 + 'strand';
        SBOL1.component = Prefixes_1.Prefixes.sbol1 + 'component';
        SBOL1.precedes = Prefixes_1.Prefixes.sbol1 + 'precedes';
    })(SBOL1 = Predicates.SBOL1 || (Predicates.SBOL1 = {}));
    let SBOL2;
    (function (SBOL2) {
        SBOL2.component = Prefixes_1.Prefixes.sbol2 + 'component';
        SBOL2.module = Prefixes_1.Prefixes.sbol2 + 'module';
        SBOL2.definition = Prefixes_1.Prefixes.sbol2 + 'definition';
        SBOL2.functionalComponent = Prefixes_1.Prefixes.sbol2 + 'functionalComponent';
        SBOL2.role = Prefixes_1.Prefixes.sbol2 + 'role';
        SBOL2.location = Prefixes_1.Prefixes.sbol2 + 'location';
        SBOL2.start = Prefixes_1.Prefixes.sbol2 + 'start';
        SBOL2.end = Prefixes_1.Prefixes.sbol2 + 'end';
        SBOL2.at = Prefixes_1.Prefixes.sbol2 + 'at';
        SBOL2.sequenceAnnotation = Prefixes_1.Prefixes.sbol2 + 'sequenceAnnotation';
        SBOL2.sequenceConstraint = Prefixes_1.Prefixes.sbol2 + 'sequenceConstraint';
        SBOL2.orientation = Prefixes_1.Prefixes.sbol2 + 'orientation';
        SBOL2.displayId = Prefixes_1.Prefixes.sbol2 + 'displayId';
        SBOL2.version = Prefixes_1.Prefixes.sbol2 + 'version';
        SBOL2.access = Prefixes_1.Prefixes.sbol2 + 'access';
        SBOL2.mapsTo = Prefixes_1.Prefixes.sbol2 + 'mapsTo';
        SBOL2.local = Prefixes_1.Prefixes.sbol2 + 'local';
        SBOL2.remote = Prefixes_1.Prefixes.sbol2 + 'remote';
        SBOL2.refinement = Prefixes_1.Prefixes.sbol2 + 'refinement';
        SBOL2.interaction = Prefixes_1.Prefixes.sbol2 + 'interaction';
        SBOL2.participation = Prefixes_1.Prefixes.sbol2 + 'participation';
        SBOL2.participant = Prefixes_1.Prefixes.sbol2 + 'participant';
        SBOL2.type = Prefixes_1.Prefixes.sbol2 + 'type';
        SBOL2.sequence = Prefixes_1.Prefixes.sbol2 + 'sequence';
        SBOL2.encoding = Prefixes_1.Prefixes.sbol2 + 'encoding';
        SBOL2.elements = Prefixes_1.Prefixes.sbol2 + 'elements';
        SBOL2.persistentIdentity = Prefixes_1.Prefixes.sbol2 + 'persistentIdentity';
        SBOL2.restriction = Prefixes_1.Prefixes.sbol2 + 'restriction';
        SBOL2.subject = Prefixes_1.Prefixes.sbol2 + 'subject';
        SBOL2.object = Prefixes_1.Prefixes.sbol2 + 'object';
        SBOL2.member = Prefixes_1.Prefixes.sbol2 + 'member';
        SBOL2.model = Prefixes_1.Prefixes.sbol2 + 'model';
        SBOL2.framework = Prefixes_1.Prefixes.sbol2 + 'framework';
        SBOL2.language = Prefixes_1.Prefixes.sbol2 + 'language';
        SBOL2.source = Prefixes_1.Prefixes.sbol2 + 'source';
        SBOL2.attachment = Prefixes_1.Prefixes.sbol2 + 'attachment';
        SBOL2.format = Prefixes_1.Prefixes.sbol2 + 'format';
        SBOL2.size = Prefixes_1.Prefixes.sbol2 + 'size';
        SBOL2.hash = Prefixes_1.Prefixes.sbol2 + 'hash';
        SBOL2.built = Prefixes_1.Prefixes.sbol2 + 'built';
        SBOL2.experimentalData = Prefixes_1.Prefixes.sbol2 + 'experimentalData';
        SBOL2.sourceLocation = Prefixes_1.Prefixes.sbol2 + 'sourceLocation';
        SBOL2.measure = Prefixes_1.Prefixes.sbol2 + 'measure';
    })(SBOL2 = Predicates.SBOL2 || (Predicates.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        SBOLX.subComponent = Prefixes_1.Prefixes.sbolx + 'subComponent';
        SBOLX.instanceOf = Prefixes_1.Prefixes.sbolx + 'instanceOf';
        SBOLX.role = Prefixes_1.Prefixes.sbolx + 'role';
        SBOLX.location = Prefixes_1.Prefixes.sbolx + 'location';
        SBOLX.start = Prefixes_1.Prefixes.sbolx + 'start';
        SBOLX.end = Prefixes_1.Prefixes.sbolx + 'end';
        SBOLX.at = Prefixes_1.Prefixes.sbolx + 'at';
        SBOLX.sequenceAnnotation = Prefixes_1.Prefixes.sbolx + 'sequenceAnnotation';
        SBOLX.sequenceConstraint = Prefixes_1.Prefixes.sbolx + 'sequenceConstraint';
        SBOLX.orientation = Prefixes_1.Prefixes.sbolx + 'orientation';
        SBOLX.id = Prefixes_1.Prefixes.sbolx + 'id';
        SBOLX.version = Prefixes_1.Prefixes.sbolx + 'version';
        SBOLX.access = Prefixes_1.Prefixes.sbolx + 'access';
        SBOLX.mapsTo = Prefixes_1.Prefixes.sbolx + 'mapsTo';
        SBOLX.local = Prefixes_1.Prefixes.sbolx + 'local';
        SBOLX.remote = Prefixes_1.Prefixes.sbolx + 'remote';
        SBOLX.refinement = Prefixes_1.Prefixes.sbolx + 'refinement';
        SBOLX.interaction = Prefixes_1.Prefixes.sbolx + 'interaction';
        SBOLX.participation = Prefixes_1.Prefixes.sbolx + 'participation';
        SBOLX.participant = Prefixes_1.Prefixes.sbolx + 'participant';
        SBOLX.type = Prefixes_1.Prefixes.sbolx + 'type';
        SBOLX.sequence = Prefixes_1.Prefixes.sbolx + 'sequence';
        SBOLX.encoding = Prefixes_1.Prefixes.sbolx + 'encoding';
        SBOLX.elements = Prefixes_1.Prefixes.sbolx + 'elements';
        SBOLX.persistentIdentity = Prefixes_1.Prefixes.sbolx + 'persistentIdentity';
        SBOLX.restriction = Prefixes_1.Prefixes.sbolx + 'restriction';
        SBOLX.subject = Prefixes_1.Prefixes.sbolx + 'subject';
        SBOLX.object = Prefixes_1.Prefixes.sbolx + 'object';
        SBOLX.member = Prefixes_1.Prefixes.sbolx + 'member';
        SBOLX.model = Prefixes_1.Prefixes.sbolx + 'model';
        SBOLX.framework = Prefixes_1.Prefixes.sbolx + 'framework';
        SBOLX.language = Prefixes_1.Prefixes.sbolx + 'language';
        SBOLX.source = Prefixes_1.Prefixes.sbolx + 'source';
        SBOLX.attachment = Prefixes_1.Prefixes.sbolx + 'attachment';
        SBOLX.format = Prefixes_1.Prefixes.sbolx + 'format';
        SBOLX.size = Prefixes_1.Prefixes.sbolx + 'size';
        SBOLX.hash = Prefixes_1.Prefixes.sbolx + 'hash';
        SBOLX.built = Prefixes_1.Prefixes.sbolx + 'built';
        SBOLX.experimentalData = Prefixes_1.Prefixes.sbolx + 'experimentalData';
        SBOLX.sourceLocation = Prefixes_1.Prefixes.sbolx + 'sourceLocation';
        SBOLX.measure = Prefixes_1.Prefixes.sbolx + 'measure';
    })(SBOLX = Predicates.SBOLX || (Predicates.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        SBOL3.subComponent = Prefixes_1.Prefixes.sbol3 + 'subComponent';
        SBOL3.instanceOf = Prefixes_1.Prefixes.sbol3 + 'instanceOf';
        SBOL3.role = Prefixes_1.Prefixes.sbol3 + 'role';
        SBOL3.hasLocation = Prefixes_1.Prefixes.sbol3 + 'hasLocation';
        SBOL3.start = Prefixes_1.Prefixes.sbol3 + 'start';
        SBOL3.end = Prefixes_1.Prefixes.sbol3 + 'end';
        SBOL3.at = Prefixes_1.Prefixes.sbol3 + 'at';
        SBOL3.hasFeature = Prefixes_1.Prefixes.sbol3 + 'hasFeature';
        SBOL3.hasConstraint = Prefixes_1.Prefixes.sbol3 + 'hasConstraint';
        SBOL3.orientation = Prefixes_1.Prefixes.sbol3 + 'orientation';
        SBOL3.displayId = Prefixes_1.Prefixes.sbol3 + 'displayId';
        SBOL3.name = Prefixes_1.Prefixes.sbol3 + 'name';
        SBOL3.description = Prefixes_1.Prefixes.sbol3 + 'description';
        SBOL3.access = Prefixes_1.Prefixes.sbol3 + 'access';
        SBOL3.mapsTo = Prefixes_1.Prefixes.sbol3 + 'mapsTo';
        SBOL3.local = Prefixes_1.Prefixes.sbol3 + 'local';
        SBOL3.remote = Prefixes_1.Prefixes.sbol3 + 'remote';
        SBOL3.refinement = Prefixes_1.Prefixes.sbol3 + 'refinement';
        SBOL3.hasInteraction = Prefixes_1.Prefixes.sbol3 + 'hasInteraction';
        SBOL3.hasInterface = Prefixes_1.Prefixes.sbol3 + 'hasInterface';
        SBOL3.hasParticipation = Prefixes_1.Prefixes.sbol3 + 'hasParticipation';
        SBOL3.participant = Prefixes_1.Prefixes.sbol3 + 'participant';
        SBOL3.type = Prefixes_1.Prefixes.sbol3 + 'type';
        SBOL3.hasSequence = Prefixes_1.Prefixes.sbol3 + 'hasSequence';
        SBOL3.encoding = Prefixes_1.Prefixes.sbol3 + 'encoding';
        SBOL3.elements = Prefixes_1.Prefixes.sbol3 + 'elements';
        SBOL3.persistentIdentity = Prefixes_1.Prefixes.sbol3 + 'persistentIdentity';
        SBOL3.restriction = Prefixes_1.Prefixes.sbol3 + 'restriction';
        SBOL3.subject = Prefixes_1.Prefixes.sbol3 + 'subject';
        SBOL3.object = Prefixes_1.Prefixes.sbol3 + 'object';
        SBOL3.member = Prefixes_1.Prefixes.sbol3 + 'member';
        SBOL3.hasModel = Prefixes_1.Prefixes.sbol3 + 'hasModel';
        SBOL3.framework = Prefixes_1.Prefixes.sbol3 + 'framework';
        SBOL3.language = Prefixes_1.Prefixes.sbol3 + 'language';
        SBOL3.source = Prefixes_1.Prefixes.sbol3 + 'source';
        SBOL3.hasAttachment = Prefixes_1.Prefixes.sbol3 + 'hasAttachment';
        SBOL3.format = Prefixes_1.Prefixes.sbol3 + 'format';
        SBOL3.size = Prefixes_1.Prefixes.sbol3 + 'size';
        SBOL3.hash = Prefixes_1.Prefixes.sbol3 + 'hash';
        SBOL3.built = Prefixes_1.Prefixes.sbol3 + 'built';
        SBOL3.experimentalData = Prefixes_1.Prefixes.sbol3 + 'experimentalData';
        SBOL3.sourceLocation = Prefixes_1.Prefixes.sbol3 + 'sourceLocation';
        SBOL3.hasMeasure = Prefixes_1.Prefixes.sbol3 + 'hasMeasure';
    })(SBOL3 = Predicates.SBOL3 || (Predicates.SBOL3 = {}));
    let Dcterms;
    (function (Dcterms) {
        Dcterms.title = Prefixes_1.Prefixes.dcterms + 'title';
        Dcterms.description = Prefixes_1.Prefixes.dcterms + 'description';
    })(Dcterms = Predicates.Dcterms || (Predicates.Dcterms = {}));
    let SVG;
    (function (SVG) {
        SVG.fontFamily = Prefixes_1.Prefixes.svg + 'font-family';
        SVG.fontSize = Prefixes_1.Prefixes.svg + 'font-size';
        SVG.fontStyle = Prefixes_1.Prefixes.svg + 'font-style';
    })(SVG = Predicates.SVG || (Predicates.SVG = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.encodedBy = Prefixes_1.Prefixes.sybio + 'encodedBy';
        SyBiOnt.EC = Prefixes_1.Prefixes.sybio + 'EC';
        SyBiOnt.isBalanced = Prefixes_1.Prefixes.sybio + 'isBalanced';
        SyBiOnt.isReactionClass = Prefixes_1.Prefixes.sybio + 'isReactionClass';
        SyBiOnt.inPolymerization = Prefixes_1.Prefixes.sybio + 'inPolymerization';
        SyBiOnt.inTransport = Prefixes_1.Prefixes.sybio + 'inTransport';
        SyBiOnt.reactionDirection = Prefixes_1.Prefixes.sybio + 'reactionDirection';
        SyBiOnt.hasReactionParticipant = Prefixes_1.Prefixes.sybio + 'hasReactionParticipant';
        SyBiOnt.referencesCompound = Prefixes_1.Prefixes.sybio + 'referencesCompound';
        SyBiOnt.reactionSide = Prefixes_1.Prefixes.sybio + 'reactionSide';
        SyBiOnt.reactionSummary = Prefixes_1.Prefixes.sybio + 'reactionSummary';
        SyBiOnt.stoicRatio = Prefixes_1.Prefixes.sybio + 'stoichiometricRatio';
        SyBiOnt.compoundCharge = Prefixes_1.Prefixes.sybio + 'compoundCharge';
        SyBiOnt.compoundFormula = Prefixes_1.Prefixes.sybio + 'compoundFormula';
        SyBiOnt.compoundMass = Prefixes_1.Prefixes.sybio + 'compoundMass';
        SyBiOnt.compoundSmilesFormula = Prefixes_1.Prefixes.sybio + 'compoundSmilesFormula';
        SyBiOnt.interactsWith = Prefixes_1.Prefixes.sybio + 'interactsWith';
        SyBiOnt.taxId = Prefixes_1.Prefixes.sybio + 'taxId';
    })(SyBiOnt = Predicates.SyBiOnt || (Predicates.SyBiOnt = {}));
    let Prov;
    (function (Prov) {
        Prov.wasDerivedFrom = Prefixes_1.Prefixes.prov + 'wasDerivedFrom';
        Prov.wasGeneratedBy = Prefixes_1.Prefixes.prov + 'wasGeneratedBy';
        Prov.qualifiedAssociation = Prefixes_1.Prefixes.prov + 'qualifiedAssociation';
        Prov.qualifiedUsage = Prefixes_1.Prefixes.prov + 'qualifiedUsage';
        Prov.startedAtTime = Prefixes_1.Prefixes.prov + 'startedAtTime';
        Prov.endedAtTime = Prefixes_1.Prefixes.prov + 'endedAtTime';
        Prov.wasInformedBy = Prefixes_1.Prefixes.prov + 'wasInformedBy';
        Prov.agent = Prefixes_1.Prefixes.prov + 'agent';
        Prov.entity = Prefixes_1.Prefixes.prov + 'entity';
        Prov.hadRole = Prefixes_1.Prefixes.prov + 'hadRole';
        Prov.hadPlan = Prefixes_1.Prefixes.prov + 'hadPlan';
    })(Prov = Predicates.Prov || (Predicates.Prov = {}));
    let Enrichment;
    (function (Enrichment) {
        Enrichment.hint = Prefixes_1.Prefixes.enrichment + 'hint';
        Enrichment.orfStart = Prefixes_1.Prefixes.enrichment + 'orfStart';
        Enrichment.orfEnd = Prefixes_1.Prefixes.enrichment + 'orfEnd';
    })(Enrichment = Predicates.Enrichment || (Predicates.Enrichment = {}));
    let Measure;
    (function (Measure) {
        Measure.hasNumericalValue = Prefixes_1.Prefixes.measure + 'hasNumericalValue';
        Measure.hasUnit = Prefixes_1.Prefixes.measure + 'hasUnit';
    })(Measure = Predicates.Measure || (Predicates.Measure = {}));
})(Predicates = exports.Predicates || (exports.Predicates = {}));


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js":
/*!************************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Prefixes;
(function (Prefixes) {
    Prefixes.sbol1 = 'http://sbols.org/v1#';
    Prefixes.sbol2 = 'http://sbols.org/v2#';
    Prefixes.sbolx = 'http://sboldata.org/sbolx#';
    Prefixes.sbol3 = 'http://sbols.org/v3#';
    Prefixes.rdf = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
    Prefixes.visual = 'http://wiki.synbiohub.org/wiki/Terms/visual#';
    Prefixes.sequenceOntologyPurl = 'http://purl.org/obo/owl/SO#';
    Prefixes.sequenceOntologyIdentifiersOrg = 'http://identifiers.org/so/';
    Prefixes.go = 'http://identifiers.org/go/';
    Prefixes.dcterms = 'http://purl.org/dc/terms/';
    Prefixes.rdfs = 'http://www.w3.org/2000/01/rdf-schema#';
    Prefixes.svg = 'http://www.w3.org/2000/svg#';
    Prefixes.sbo = 'http://identifiers.org/biomodels.sbo/';
    Prefixes.sybio = 'http://www.sybio.ncl.ac.uk#';
    Prefixes.prov = 'http://www.w3.org/ns/prov#';
    Prefixes.enrichment = 'http://wiki.synbiohub.org/wiki/Terms/enrichment#';
    Prefixes.measure = 'http://www.ontology-of-units-of-measure.org/resource/om-2/';
})(Prefixes = exports.Prefixes || (exports.Prefixes = {}));
function prefixify(uri) {
    uri = '' + uri;
    for (var i = 0; i < keys.length; ++i) {
        const prefix = keys[i];
        const uriPrefix = Prefixes[prefix];
        if (uri.indexOf(uriPrefix) === 0) {
            return prefix + ':' + uri.slice(uriPrefix.length);
        }
    }
    return uri;
}
exports.prefixify = prefixify;
const keys = Object.keys(Prefixes);


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Specifiers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/Specifiers.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js");
var Specifiers;
(function (Specifiers) {
    let SBOL2;
    (function (SBOL2) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbol2 + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbol2 + 'reverseComplement';
        })(Orientation = SBOL2.Orientation || (SBOL2.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbol2 + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbol2 + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbol2 + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbol2 + 'none';
        })(Direction = SBOL2.Direction || (SBOL2.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbol2 + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbol2 + 'private';
        })(Access = SBOL2.Access || (SBOL2.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOL2.Type || (SBOL2.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOL2.SequenceEncoding || (SBOL2.SequenceEncoding = {}));
        let SequenceConstraint;
        (function (SequenceConstraint) {
            SequenceConstraint.Precedes = Prefixes_1.Prefixes.sbol2 + 'precedes';
            SequenceConstraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbol2 + 'oppositeOrientationAs';
        })(SequenceConstraint = SBOL2.SequenceConstraint || (SBOL2.SequenceConstraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbol2 + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbol2 + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbol2 + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbol2 + 'learn';
        })(ProvRole = SBOL2.ProvRole || (SBOL2.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbol2 + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbol2 + 'useRemote';
        })(MapsToRefinement = SBOL2.MapsToRefinement || (SBOL2.MapsToRefinement = {}));
    })(SBOL2 = Specifiers.SBOL2 || (Specifiers.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbolx + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbolx + 'reverseComplement';
        })(Orientation = SBOLX.Orientation || (SBOLX.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbolx + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbolx + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbolx + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbolx + 'none';
        })(Direction = SBOLX.Direction || (SBOLX.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbolx + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbolx + 'private';
        })(Access = SBOLX.Access || (SBOLX.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOLX.Type || (SBOLX.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOLX.SequenceEncoding || (SBOLX.SequenceEncoding = {}));
        let SequenceConstraint;
        (function (SequenceConstraint) {
            SequenceConstraint.Precedes = Prefixes_1.Prefixes.sbolx + 'precedes';
            SequenceConstraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbolx + 'oppositeOrientationAs';
        })(SequenceConstraint = SBOLX.SequenceConstraint || (SBOLX.SequenceConstraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbolx + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbolx + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbolx + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbolx + 'learn';
        })(ProvRole = SBOLX.ProvRole || (SBOLX.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbolx + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbolx + 'useRemote';
        })(MapsToRefinement = SBOLX.MapsToRefinement || (SBOLX.MapsToRefinement = {}));
    })(SBOLX = Specifiers.SBOLX || (Specifiers.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        let Orientation;
        (function (Orientation) {
            Orientation.Inline = Prefixes_1.Prefixes.sbol3 + 'inline';
            Orientation.ReverseComplement = Prefixes_1.Prefixes.sbol3 + 'reverseComplement';
        })(Orientation = SBOL3.Orientation || (SBOL3.Orientation = {}));
        let Direction;
        (function (Direction) {
            Direction.Input = Prefixes_1.Prefixes.sbol3 + 'in';
            Direction.Output = Prefixes_1.Prefixes.sbol3 + 'out';
            Direction.InputAndOutput = Prefixes_1.Prefixes.sbol3 + 'inout';
            Direction.None = Prefixes_1.Prefixes.sbol3 + 'none';
        })(Direction = SBOL3.Direction || (SBOL3.Direction = {}));
        let Access;
        (function (Access) {
            Access.PublicAccess = Prefixes_1.Prefixes.sbol3 + 'public';
            Access.PrivateAccess = Prefixes_1.Prefixes.sbol3 + 'private';
        })(Access = SBOL3.Access || (SBOL3.Access = {}));
        let Type;
        (function (Type) {
            Type.DNA = 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion';
            Type.RNA = 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion';
            Type.Protein = 'http://www.biopax.org/release/biopax-level3.owl#Protein';
            Type.SmallMolecule = 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule';
            Type.Complex = 'http://www.biopax.org/release/biopax-level3.owl#Complex';
            Type.Effector = 'http://identifiers.org/chebi/CHEBI:35224';
            Type.Circular = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000988';
        })(Type = SBOL3.Type || (SBOL3.Type = {}));
        let SequenceEncoding;
        (function (SequenceEncoding) {
            SequenceEncoding.NucleicAcid = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.RNA = 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html';
            SequenceEncoding.AminoAcid = 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/';
        })(SequenceEncoding = SBOL3.SequenceEncoding || (SBOL3.SequenceEncoding = {}));
        let Constraint;
        (function (Constraint) {
            Constraint.Precedes = Prefixes_1.Prefixes.sbol3 + 'precedes';
            Constraint.OppositeOrientationAs = Prefixes_1.Prefixes.sbol3 + 'oppositeOrientationAs';
        })(Constraint = SBOL3.Constraint || (SBOL3.Constraint = {}));
        let ProvRole;
        (function (ProvRole) {
            ProvRole.Design = Prefixes_1.Prefixes.sbol3 + 'design';
            ProvRole.Build = Prefixes_1.Prefixes.sbol3 + 'build';
            ProvRole.Test = Prefixes_1.Prefixes.sbol3 + 'test';
            ProvRole.Learn = Prefixes_1.Prefixes.sbol3 + 'learn';
        })(ProvRole = SBOL3.ProvRole || (SBOL3.ProvRole = {}));
        let MapsToRefinement;
        (function (MapsToRefinement) {
            MapsToRefinement.UseLocal = Prefixes_1.Prefixes.sbol3 + 'useLocal';
            MapsToRefinement.UseRemote = Prefixes_1.Prefixes.sbol3 + 'useRemote';
        })(MapsToRefinement = SBOL3.MapsToRefinement || (SBOL3.MapsToRefinement = {}));
    })(SBOL3 = Specifiers.SBOL3 || (Specifiers.SBOL3 = {}));
    let Visual;
    (function (Visual) {
        /* opacity
         */
        Visual.Blackbox = Prefixes_1.Prefixes.visual + 'blackbox';
        Visual.Whitebox = Prefixes_1.Prefixes.visual + 'whitebox';
        /* display modes
         */
        Visual.Float = Prefixes_1.Prefixes.visual + 'float';
        Visual.Backbone = Prefixes_1.Prefixes.visual + 'backbone';
        /* orientation
         */
        Visual.Forward = Prefixes_1.Prefixes.visual + 'forward';
        Visual.Reverse = Prefixes_1.Prefixes.visual + 'reverse';
        /* expandability
         */
        Visual.Expandable = Prefixes_1.Prefixes.visual + 'expandable';
        Visual.NotExpandable = Prefixes_1.Prefixes.visual + 'notExpandable';
        Visual.AnchorTop = Prefixes_1.Prefixes.visual + 'anchorTop';
        Visual.AnchorMid = Prefixes_1.Prefixes.visual + 'anchorMid';
        Visual.AnchorBottom = Prefixes_1.Prefixes.visual + 'anchorBottom';
    })(Visual = Specifiers.Visual || (Specifiers.Visual = {}));
    let SO;
    (function (SO) {
        SO.CDS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000316';
        SO.Promoter = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000167';
        SO.RBS = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000139';
        SO.RestrictionSite = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0001687';
        SO.Terminator = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000141';
        SO.OriginOfReplication = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000296';
        SO.OriginOfTransfer = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000724';
        SO.PlasmidBackbone = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000755';
        SO.EngineeredRegion = Prefixes_1.Prefixes.sequenceOntologyIdentifiersOrg + 'SO:0000804';
    })(SO = Specifiers.SO || (Specifiers.SO = {}));
    let SBO;
    (function (SBO) {
        SBO.Inhibition = Prefixes_1.Prefixes.sbo + 'SBO:0000169';
        SBO.Inhibitor = Prefixes_1.Prefixes.sbo + 'SBO:0000020';
        SBO.Inhibited = Prefixes_1.Prefixes.sbo + 'SBO:0000642';
        SBO.Stimulation = Prefixes_1.Prefixes.sbo + 'SBO:0000170';
        SBO.Stimulator = Prefixes_1.Prefixes.sbo + 'SBO:0000459';
        SBO.Stimulated = Prefixes_1.Prefixes.sbo + 'SBO:0000643';
        SBO.GeneticProduction = Prefixes_1.Prefixes.sbo + 'SBO:0000589';
        SBO.Product = Prefixes_1.Prefixes.sbo + 'SBO:0000011';
        SBO.Modifier = Prefixes_1.Prefixes.sbo + 'SBO:0000019';
        SBO.Promoter = Prefixes_1.Prefixes.sbo + 'SBO:0000598';
        SBO.Control = Prefixes_1.Prefixes.sbo + 'SBO:0000168';
    })(SBO = Specifiers.SBO || (Specifiers.SBO = {}));
    let GO;
    (function (GO) {
        GO.ProteinDepolymerization = Prefixes_1.Prefixes.go + 'GO:0051261';
        GO.CovalentChromatinModification = Prefixes_1.Prefixes.go + 'GO:0016569';
        GO.ProteinProcessing = Prefixes_1.Prefixes.go + 'GO:0016485';
        GO.ProteinBinding = Prefixes_1.Prefixes.go + 'GO:0005515';
        GO.CatalyticActivity = Prefixes_1.Prefixes.go + 'GO:0003824';
    })(GO = Specifiers.GO || (Specifiers.GO = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.Bidirectional = Prefixes_1.Prefixes.sybio + 'Bidirectional';
        SyBiOnt.LeftToRight = Prefixes_1.Prefixes.sybio + 'LeftToRight';
        SyBiOnt.RightToLeft = Prefixes_1.Prefixes.sybio + 'RightToLeft';
        SyBiOnt.UndefinedDirection = Prefixes_1.Prefixes.sybio + 'UndefinedDirection';
        SyBiOnt.LeftSide = Prefixes_1.Prefixes.sybio + 'LeftSide';
        SyBiOnt.RightSide = Prefixes_1.Prefixes.sybio + 'RightSide';
    })(SyBiOnt = Specifiers.SyBiOnt || (Specifiers.SyBiOnt = {}));
})(Specifiers = exports.Specifiers || (exports.Specifiers = {}));


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/Types.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js");
var Types;
(function (Types) {
    let SBOL1;
    (function (SBOL1) {
        SBOL1.DnaComponent = Prefixes_1.Prefixes.sbol1 + 'DnaComponent';
        SBOL1.DnaSequence = Prefixes_1.Prefixes.sbol1 + 'DnaSequence';
        SBOL1.Collection = Prefixes_1.Prefixes.sbol1 + 'Collection';
        SBOL1.SequenceAnnotation = Prefixes_1.Prefixes.sbol1 + 'SequenceAnnotation';
    })(SBOL1 = Types.SBOL1 || (Types.SBOL1 = {}));
    let SBOL2;
    (function (SBOL2) {
        SBOL2.ModuleDefinition = Prefixes_1.Prefixes.sbol2 + 'ModuleDefinition';
        SBOL2.ComponentDefinition = Prefixes_1.Prefixes.sbol2 + 'ComponentDefinition';
        SBOL2.Module = Prefixes_1.Prefixes.sbol2 + 'Module';
        SBOL2.Component = Prefixes_1.Prefixes.sbol2 + 'Component';
        SBOL2.Range = Prefixes_1.Prefixes.sbol2 + 'Range';
        SBOL2.Cut = Prefixes_1.Prefixes.sbol2 + 'Cut';
        SBOL2.GenericLocation = Prefixes_1.Prefixes.sbol2 + 'GenericLocation';
        SBOL2.SequenceAnnotation = Prefixes_1.Prefixes.sbol2 + 'SequenceAnnotation';
        SBOL2.SequenceConstraint = Prefixes_1.Prefixes.sbol2 + 'SequenceConstraint';
        SBOL2.Interaction = Prefixes_1.Prefixes.sbol2 + 'Interaction';
        SBOL2.Participation = Prefixes_1.Prefixes.sbol2 + 'Participation';
        SBOL2.Collection = Prefixes_1.Prefixes.sbol2 + 'Collection';
        SBOL2.FunctionalComponent = Prefixes_1.Prefixes.sbol2 + 'FunctionalComponent';
        SBOL2.Sequence = Prefixes_1.Prefixes.sbol2 + 'Sequence';
        SBOL2.MapsTo = Prefixes_1.Prefixes.sbol2 + 'MapsTo';
        SBOL2.Attachment = Prefixes_1.Prefixes.sbol2 + 'Attachment';
        SBOL2.Model = Prefixes_1.Prefixes.sbol2 + 'Model';
        SBOL2.Implementation = Prefixes_1.Prefixes.sbol2 + 'Implementation';
        SBOL2.Experiment = Prefixes_1.Prefixes.sbol2 + 'Experiment';
        SBOL2.ExperimentalData = Prefixes_1.Prefixes.sbol2 + 'ExperimentalData';
    })(SBOL2 = Types.SBOL2 || (Types.SBOL2 = {}));
    let SBOLX;
    (function (SBOLX) {
        SBOLX.Component = Prefixes_1.Prefixes.sbolx + 'Component';
        SBOLX.SubComponent = Prefixes_1.Prefixes.sbolx + 'SubComponent';
        SBOLX.Range = Prefixes_1.Prefixes.sbolx + 'Range';
        SBOLX.Cut = Prefixes_1.Prefixes.sbolx + 'Cut';
        SBOLX.SequenceConstraint = Prefixes_1.Prefixes.sbolx + 'SequenceConstraint';
        SBOLX.Interaction = Prefixes_1.Prefixes.sbolx + 'Interaction';
        SBOLX.Participation = Prefixes_1.Prefixes.sbolx + 'Participation';
        SBOLX.Collection = Prefixes_1.Prefixes.sbolx + 'Collection';
        SBOLX.Sequence = Prefixes_1.Prefixes.sbolx + 'Sequence';
        SBOLX.OrientedLocation = Prefixes_1.Prefixes.sbolx + 'OrientedLocation';
        SBOLX.SequenceAnnotation = Prefixes_1.Prefixes.sbolx + 'SequenceAnnotation';
        SBOLX.Attachment = Prefixes_1.Prefixes.sbolx + 'Attachment';
        SBOLX.Model = Prefixes_1.Prefixes.sbolx + 'Model';
        SBOLX.Implementation = Prefixes_1.Prefixes.sbolx + 'Implementation';
        SBOLX.MapsTo = Prefixes_1.Prefixes.sbolx + 'MapsTo';
        SBOLX.Experiment = Prefixes_1.Prefixes.sbolx + 'Experiment';
        SBOLX.ExperimentalData = Prefixes_1.Prefixes.sbolx + 'ExperimentalData';
    })(SBOLX = Types.SBOLX || (Types.SBOLX = {}));
    let SBOL3;
    (function (SBOL3) {
        SBOL3.Component = Prefixes_1.Prefixes.sbol3 + 'Component';
        SBOL3.SubComponent = Prefixes_1.Prefixes.sbol3 + 'SubComponent';
        SBOL3.Range = Prefixes_1.Prefixes.sbol3 + 'Range';
        SBOL3.Cut = Prefixes_1.Prefixes.sbol3 + 'Cut';
        SBOL3.EntireSequence = Prefixes_1.Prefixes.sbol3 + 'EntireSequence';
        SBOL3.Constraint = Prefixes_1.Prefixes.sbol3 + 'Constraint';
        SBOL3.Interaction = Prefixes_1.Prefixes.sbol3 + 'Interaction';
        SBOL3.Participation = Prefixes_1.Prefixes.sbol3 + 'Participation';
        SBOL3.Collection = Prefixes_1.Prefixes.sbol3 + 'Collection';
        SBOL3.Sequence = Prefixes_1.Prefixes.sbol3 + 'Sequence';
        SBOL3.OrientedLocation = Prefixes_1.Prefixes.sbol3 + 'OrientedLocation';
        SBOL3.SequenceAnnotation = Prefixes_1.Prefixes.sbol3 + 'SequenceAnnotation';
        SBOL3.Attachment = Prefixes_1.Prefixes.sbol3 + 'Attachment';
        SBOL3.Model = Prefixes_1.Prefixes.sbol3 + 'Model';
        SBOL3.Implementation = Prefixes_1.Prefixes.sbol3 + 'Implementation';
        SBOL3.MapsTo = Prefixes_1.Prefixes.sbol3 + 'MapsTo';
        SBOL3.Experiment = Prefixes_1.Prefixes.sbol3 + 'Experiment';
        SBOL3.ExperimentalData = Prefixes_1.Prefixes.sbol3 + 'ExperimentalData';
        SBOL3.Namespace = Prefixes_1.Prefixes.sbol3 + 'Namespace';
    })(SBOL3 = Types.SBOL3 || (Types.SBOL3 = {}));
    let Visual;
    (function (Visual) {
        Visual.ModuleDepiction = Prefixes_1.Prefixes.visual + 'ModuleDepiction';
        Visual.ComponentDepiction = Prefixes_1.Prefixes.visual + 'ComponentDepiction';
        Visual.Glyph = Prefixes_1.Prefixes.visual + 'Glyph';
        Visual.Label = Prefixes_1.Prefixes.visual + 'Label';
    })(Visual = Types.Visual || (Types.Visual = {}));
    let SyBiOnt;
    (function (SyBiOnt) {
        SyBiOnt.Protein = Prefixes_1.Prefixes.sybio + 'Protein';
        SyBiOnt.InduciblePromoter = Prefixes_1.Prefixes.sybio + 'InduciblePromoter';
        SyBiOnt.Reaction = Prefixes_1.Prefixes.sybio + 'Reaction';
        SyBiOnt.ReactionParticipant = Prefixes_1.Prefixes.sybio + 'ReactionParticipant';
        SyBiOnt.Compound = Prefixes_1.Prefixes.sybio + 'Compound';
    })(SyBiOnt = Types.SyBiOnt || (Types.SyBiOnt = {}));
    let Prov;
    (function (Prov) {
        Prov.Agent = Prefixes_1.Prefixes.prov + 'Agent';
        Prov.Association = Prefixes_1.Prefixes.prov + 'Association';
        Prov.Activity = Prefixes_1.Prefixes.prov + 'Activity';
        Prov.Usage = Prefixes_1.Prefixes.prov + 'Usage';
        Prov.Plan = Prefixes_1.Prefixes.prov + 'Plan';
    })(Prov = Types.Prov || (Types.Prov = {}));
    let Enrichment;
    (function (Enrichment) {
        Enrichment.GeneProduct = Prefixes_1.Prefixes.enrichment + 'GeneProduct';
    })(Enrichment = Types.Enrichment || (Types.Enrichment = {}));
    let Measure;
    (function (Measure_1) {
        Measure_1.Measure = Prefixes_1.Prefixes.measure + 'Measure';
    })(Measure = Types.Measure || (Types.Measure = {}));
})(Types = exports.Types || (exports.Types = {}));


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Prefixes_1 = __webpack_require__(/*! ./Prefixes */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Prefixes.js");
exports.Prefixes = Prefixes_1.Prefixes;
exports.prefixify = Prefixes_1.prefixify;
const Types_1 = __webpack_require__(/*! ./Types */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Types.js");
exports.Types = Types_1.Types;
const Predicates_1 = __webpack_require__(/*! ./Predicates */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Predicates.js");
exports.Predicates = Predicates_1.Predicates;
const Specifiers_1 = __webpack_require__(/*! ./Specifiers */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/Specifiers.js");
exports.Specifiers = Specifiers_1.Specifiers;
const sequenceOntology_1 = __webpack_require__(/*! ./sequenceOntology */ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/sequenceOntology.js");
exports.sequenceOntology = sequenceOntology_1.sequenceOntology;
exports.uriToName = sequenceOntology_1.uriToName;


/***/ }),

/***/ "./node_modules/rdfoo-prov/node_modules/bioterms/dist/sequenceOntology.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rdfoo-prov/node_modules/bioterms/dist/sequenceOntology.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function uriToName(uri) {
    let temp = uri.split('/');
    let id = temp.pop();
    let entry = sequenceOntology.so[id];
    if (!entry)
        return undefined;
    let name = entry['name'];
    return name;
}
exports.uriToName = uriToName;
var sequenceOntology;
(function (sequenceOntology) {
    sequenceOntology.so = {
        "SO:0000000": {
            "name": "Sequence_Ontology"
        },
        "SO:0000001": {
            "name": "region",
            "def": "A sequence_feature with an extent greater than zero. A nucleotide region is composed of bases and a polypeptide region is composed of amino acids. [SO:ke]"
        },
        "SO:0000002": {
            "name": "sequence_secondary_structure",
            "def": "A folded sequence. [SO:ke]"
        },
        "SO:0000003": {
            "name": "G_quartet",
            "def": "G-quartets are unusual nucleic acid structures consisting of a planar arrangement where each guanine is hydrogen bonded by hoogsteen pairing to another guanine in the quartet. [http://www.ncbi.nlm.nih.gov/pubmed/7919797?dopt=Abstract]"
        },
        "SO:0000004": {
            "name": "interior_coding_exon"
        },
        "SO:0000005": {
            "name": "satellite_DNA",
            "def": "The many tandem repeats (identical or related) of a short basic repeating unit; many have a base composition or other property different from the genome average that allows them to be separated from the bulk (main band) genomic DNA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000006": {
            "name": "PCR_product",
            "def": "A region amplified by a PCR reaction. [SO:ke]"
        },
        "SO:0000007": {
            "name": "read_pair",
            "def": "One of a pair of sequencing reads in which the two members of the pair are related by originating at either end of a clone insert. [SO:ls]"
        },
        "SO:0000008": {
            "name": "gene_sensu_your_favorite_organism"
        },
        "SO:0000009": {
            "name": "gene_class"
        },
        "SO:0000010": {
            "name": "protein_coding"
        },
        "SO:0000011": {
            "name": "non_protein_coding"
        },
        "SO:0000012": {
            "name": "scRNA_primary_transcript",
            "def": "The primary transcript of any one of several small cytoplasmic RNA molecules present in the cytoplasm and sometimes nucleus of a Eukaryote. [http://www.ebi.ac.uk/embl/WebFeat/align/scRNA_s.html]"
        },
        "SO:0000013": {
            "name": "scRNA",
            "def": "A small non coding RNA sequence, present in the cytoplasm. [SO:ke]"
        },
        "SO:0000014": {
            "name": "INR_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters required for the correct positioning of the polymerase for the start of transcription. Overlaps the TSS. The mammalian consensus sequence is YYAN(T|A)YY; the Drosophila consensus sequence is TCA(G|T)t(T|C). In each the A is at position +1 with respect to the TSS. Functionally similar to the TATA box element. [PMID:12651739, PMID:16858867]"
        },
        "SO:0000015": {
            "name": "DPE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters; Positioned from +28 to +32 with respect to the TSS (+1). Experimental results suggest that the DPE acts in conjunction with the INR_motif to provide a binding site for TFIID in the absence of a TATA box to mediate transcription of TATA-less promoters. Consensus sequence (A|G)G(A|T)(C|T)(G|A|C). [PMID:12651739:12537576, PMID:16858867]"
        },
        "SO:0000016": {
            "name": "BREu_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements at -37 to -32 with respect to the TSS (+1). Consensus sequence is (G|C)(G|C)(G|A)CGCC. Binds TFIIB. [PMID:12651739, PMID:16858867]"
        },
        "SO:0000017": {
            "name": "PSE_motif",
            "def": "A sequence element characteristic of the promoters of snRNA genes transcribed by RNA polymerase II or by RNA polymerase III. Located between -45 and -60 relative to the TSS. The human PSE_motif consensus sequence is TCACCNTNA(C|G)TNAAAAG(T|G). [PMID:12651739]"
        },
        "SO:0000018": {
            "name": "linkage_group",
            "def": "A group of loci that can be grouped in a linear order representing the different degrees of linkage among the genes concerned. [ISBN:038752046]"
        },
        "SO:0000020": {
            "name": "RNA_internal_loop",
            "def": "A region of double stranded RNA where the bases do not conform to WC base pairing. The loop is closed on both sides by canonical base pairing. If the interruption to base pairing occurs on one strand only, it is known as a bulge. [SO:ke]"
        },
        "SO:0000021": {
            "name": "asymmetric_RNA_internal_loop",
            "def": "An internal RNA loop where one of the strands includes more bases than the corresponding region on the other strand. [SO:ke]"
        },
        "SO:0000022": {
            "name": "A_minor_RNA_motif",
            "def": "A region forming a motif, composed of adenines, where the minor groove edges are inserted into the minor groove of another helix. [SO:ke]"
        },
        "SO:0000023": {
            "name": "K_turn_RNA_motif",
            "def": "The kink turn (K-turn) is an RNA structural motif that creates a sharp (~120 degree) bend between two continuous helices. [SO:ke]"
        },
        "SO:0000024": {
            "name": "sarcin_like_RNA_motif",
            "def": "A loop in ribosomal RNA containing the sites of attack for ricin and sarcin. [http://www.ncbi.nlm.nih.gov/pubmed/7897662]"
        },
        "SO:0000025": {
            "name": "symmetric_RNA_internal_loop",
            "def": "An internal RNA loop where the extent of the loop on both stands is the same size. [SO:ke]"
        },
        "SO:0000026": {
            "name": "RNA_junction_loop"
        },
        "SO:0000027": {
            "name": "RNA_hook_turn"
        },
        "SO:0000028": {
            "name": "base_pair"
        },
        "SO:0000029": {
            "name": "WC_base_pair",
            "def": "The canonical base pair, where two bases interact via WC edges, with glycosidic bonds oriented cis relative to the axis of orientation. [PMID:12177293]"
        },
        "SO:0000030": {
            "name": "sugar_edge_base_pair",
            "def": "A type of non-canonical base-pairing. [PMID:12177293]"
        },
        "SO:0000031": {
            "name": "aptamer",
            "def": "DNA or RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
        },
        "SO:0000032": {
            "name": "DNA_aptamer",
            "def": "DNA molecules that have been selected from random pools based on their ability to bind other molecules. [http:aptamer.icmb.utexas.edu]"
        },
        "SO:0000033": {
            "name": "RNA_aptamer",
            "def": "RNA molecules that have been selected from random pools based on their ability to bind other molecules. [http://aptamer.icmb.utexas.edu]"
        },
        "SO:0000034": {
            "name": "morpholino_oligo",
            "def": "Morpholino oligos are synthesized from four different Morpholino subunits, each of which contains one of the four genetic bases (A, C, G, T) linked to a 6-membered morpholine ring. Eighteen to 25 subunits of these four subunit types are joined in a specific order by non-ionic phosphorodiamidate intersubunit linkages to give a Morpholino. [http://www.gene-tools.com/]"
        },
        "SO:0000035": {
            "name": "riboswitch",
            "def": "A riboswitch is a part of an mRNA that can act as a direct sensor of small molecules to control their own expression. A riboswitch is a cis element in the 5' end of an mRNA, that acts as a direct sensor of metabolites. [PMID:2820954]"
        },
        "SO:0000036": {
            "name": "matrix_attachment_site",
            "def": "A DNA region that is required for the binding of chromatin to the nuclear matrix. [SO:ma]"
        },
        "SO:0000037": {
            "name": "locus_control_region",
            "def": "A DNA region that includes DNAse hypersensitive sites located 5' to a gene that confers the high-level, position-independent, and copy number-dependent expression to that gene. [SO:ma]"
        },
        "SO:0000038": {
            "name": "match_set",
            "def": "A collection of match parts. [SO:ke]"
        },
        "SO:0000039": {
            "name": "match_part",
            "def": "A part of a match, for example an hsp from blast is a match_part. [SO:ke]"
        },
        "SO:0000040": {
            "name": "genomic_clone",
            "def": "A clone of a DNA region of a genome. [SO:ma]"
        },
        "SO:0000041": {
            "name": "sequence_operation",
            "def": "An operation that can be applied to a sequence, that results in a change. [SO:ke]"
        },
        "SO:0000042": {
            "name": "pseudogene_attribute",
            "def": "An attribute of a pseudogene (SO:0000336). [SO:ma]"
        },
        "SO:0000043": {
            "name": "processed_pseudogene",
            "def": "A pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promoters, but often including a polyA tail. [SO:xp]"
        },
        "SO:0000044": {
            "name": "pseudogene_by_unequal_crossing_over",
            "def": "A pseudogene caused by unequal crossing over at recombination. [SO:ke]"
        },
        "SO:0000045": {
            "name": "delete",
            "def": "To remove a subsection of sequence. [SO:ke]"
        },
        "SO:0000046": {
            "name": "insert",
            "def": "To insert a subsection of sequence. [SO:ke]"
        },
        "SO:0000047": {
            "name": "invert",
            "def": "To invert a subsection of sequence. [SO:ke]"
        },
        "SO:0000048": {
            "name": "substitute",
            "def": "To substitute a subsection of sequence for another. [SO:ke]"
        },
        "SO:0000049": {
            "name": "translocate",
            "def": "To translocate a subsection of sequence. [SO:ke]"
        },
        "SO:0000050": {
            "name": "gene_part",
            "def": "A part of a gene, that has no other route in the ontology back to region. This concept is necessary for logical inference as these parts must have the properties of region. It also allows us to associate all the parts of genes with a gene. [SO:ke]"
        },
        "SO:0000051": {
            "name": "probe",
            "def": "A DNA sequence used experimentally to detect the presence or absence of a complementary nucleic acid. [SO:ma]"
        },
        "SO:0000052": {
            "name": "assortment_derived_deficiency"
        },
        "SO:0000053": {
            "name": "sequence_variant_affecting_regulatory_region",
            "def": "A sequence_variant_effect which changes the regulatory region of a gene. [SO:ke]"
        },
        "SO:0000054": {
            "name": "aneuploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
        },
        "SO:0000055": {
            "name": "hyperploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as extra chromosomes are present. [SO:ke]"
        },
        "SO:0000056": {
            "name": "hypoploid",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number as some chromosomes are missing. [SO:ke]"
        },
        "SO:0000057": {
            "name": "operator",
            "def": "A regulatory element of an operon to which activators or repressors bind thereby effecting translation of genes in that operon. [SO:ma]"
        },
        "SO:0000058": {
            "name": "assortment_derived_aneuploid"
        },
        "SO:0000059": {
            "name": "nuclease_binding_site",
            "def": "A binding site that, of a nucleotide molecule, that interacts selectively and non-covalently with polypeptide residues of a nuclease. [SO:cb]"
        },
        "SO:0000060": {
            "name": "compound_chromosome_arm"
        },
        "SO:0000061": {
            "name": "restriction_enzyme_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a restriction enzyme. [SO:cb]"
        },
        "SO:0000062": {
            "name": "deficient_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
        },
        "SO:0000063": {
            "name": "deficient_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a translocation in which one of the four broken ends loses a segment before re-joining. [SO:ke]"
        },
        "SO:0000064": {
            "name": "gene_by_transcript_attribute"
        },
        "SO:0000065": {
            "name": "free_chromosome_arm",
            "def": "A chromosome structure variation whereby an arm exists as an individual chromosome element. [SO:ke]"
        },
        "SO:0000066": {
            "name": "gene_by_polyadenylation_attribute"
        },
        "SO:0000067": {
            "name": "gene_to_gene_feature"
        },
        "SO:0000068": {
            "name": "overlapping",
            "def": "An attribute describing a gene that has a sequence that overlaps the sequence of another gene. [SO:ke]"
        },
        "SO:0000069": {
            "name": "inside_intron",
            "def": "An attribute to describe a gene when it is located within the intron of another gene. [SO:ke]"
        },
        "SO:0000070": {
            "name": "inside_intron_antiparallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the opposite strand. [SO:ke]"
        },
        "SO:0000071": {
            "name": "inside_intron_parallel",
            "def": "An attribute to describe a gene when it is located within the intron of another gene and on the same strand. [SO:ke]"
        },
        "SO:0000072": {
            "name": "end_overlapping_gene"
        },
        "SO:0000073": {
            "name": "five_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's 3' region. [SO:ke]"
        },
        "SO:0000074": {
            "name": "five_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the five prime region overlaps with another gene's five prime region. [SO:ke]"
        },
        "SO:0000075": {
            "name": "three_prime_three_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 3' region. [SO:ke]"
        },
        "SO:0000076": {
            "name": "three_prime_five_prime_overlap",
            "def": "An attribute to describe a gene when the 3' region overlaps with another gene's 5' region. [SO:ke]"
        },
        "SO:0000077": {
            "name": "antisense",
            "def": "A region sequence that is complementary to a sequence of messenger RNA. [SO:ke]"
        },
        "SO:0000078": {
            "name": "polycistronic_transcript",
            "def": "A transcript that is polycistronic. [SO:xp]"
        },
        "SO:0000079": {
            "name": "dicistronic_transcript",
            "def": "A transcript that is dicistronic. [SO:ke]"
        },
        "SO:0000080": {
            "name": "operon_member"
        },
        "SO:0000081": {
            "name": "gene_array_member"
        },
        "SO:0000082": {
            "name": "processed_transcript_attribute"
        },
        "SO:0000083": {
            "name": "macronuclear_sequence"
        },
        "SO:0000084": {
            "name": "micronuclear_sequence"
        },
        "SO:0000085": {
            "name": "gene_by_genome_location"
        },
        "SO:0000086": {
            "name": "gene_by_organelle_of_genome"
        },
        "SO:0000087": {
            "name": "nuclear_gene",
            "def": "A gene from nuclear sequence. [SO:xp]"
        },
        "SO:0000088": {
            "name": "mt_gene",
            "def": "A gene located in mitochondrial sequence. [SO:xp]"
        },
        "SO:0000089": {
            "name": "kinetoplast_gene",
            "def": "A gene located in kinetoplast sequence. [SO:xp]"
        },
        "SO:0000090": {
            "name": "plastid_gene",
            "def": "A gene from plastid sequence. [SO:xp]"
        },
        "SO:0000091": {
            "name": "apicoplast_gene",
            "def": "A gene from apicoplast sequence. [SO:xp]"
        },
        "SO:0000092": {
            "name": "ct_gene",
            "def": "A gene from chloroplast sequence. [SO:xp]"
        },
        "SO:0000093": {
            "name": "chromoplast_gene",
            "def": "A gene from chromoplast_sequence. [SO:xp]"
        },
        "SO:0000094": {
            "name": "cyanelle_gene",
            "def": "A gene from cyanelle sequence. [SO:xp]"
        },
        "SO:0000095": {
            "name": "leucoplast_gene",
            "def": "A plastid gene from leucoplast sequence. [SO:xp]"
        },
        "SO:0000096": {
            "name": "proplastid_gene",
            "def": "A gene from proplastid sequence. [SO:ke]"
        },
        "SO:0000097": {
            "name": "nucleomorph_gene",
            "def": "A gene from nucleomorph sequence. [SO:xp]"
        },
        "SO:0000098": {
            "name": "plasmid_gene",
            "def": "A gene from plasmid sequence. [SO:xp]"
        },
        "SO:0000099": {
            "name": "proviral_gene",
            "def": "A gene from proviral sequence. [SO:xp]"
        },
        "SO:0000100": {
            "name": "endogenous_retroviral_gene",
            "def": "A proviral gene with origin endogenous retrovirus. [SO:xp]"
        },
        "SO:0000101": {
            "name": "transposable_element",
            "def": "A transposon or insertion sequence. An element that can insert in a variety of DNA sequences. [http://www.sci.sdsu.edu/~smaloy/Glossary/T.html]"
        },
        "SO:0000102": {
            "name": "expressed_sequence_match",
            "def": "A match to an EST or cDNA sequence. [SO:ke]"
        },
        "SO:0000103": {
            "name": "clone_insert_end",
            "def": "The end of the clone insert. [SO:ke]"
        },
        "SO:0000104": {
            "name": "polypeptide",
            "def": "A sequence of amino acids linked by peptide bonds which may lack appreciable tertiary structure and may not be liable to irreversible denaturation. [SO:ma]"
        },
        "SO:0000105": {
            "name": "chromosome_arm",
            "def": "A region of the chromosome between the centromere and the telomere. Human chromosomes have two arms, the p arm (short) and the q arm (long) which are separated from each other by the centromere. [http://www.medterms.com/script/main/art.asp?articlekey=5152]"
        },
        "SO:0000106": {
            "name": "non_capped_primary_transcript"
        },
        "SO:0000107": {
            "name": "sequencing_primer"
        },
        "SO:0000108": {
            "name": "mRNA_with_frameshift",
            "def": "An mRNA with a frameshift. [SO:xp]"
        },
        "SO:0000109": {
            "name": "sequence_variant_obs",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
        },
        "SO:0000110": {
            "name": "sequence_feature",
            "def": "Any extent of continuous biological sequence. [LAMHDI:mb, SO:ke]"
        },
        "SO:0000111": {
            "name": "transposable_element_gene",
            "def": "A gene encoded within a transposable element. For example gag, int, env and pol are the transposable element genes of the TY element in yeast. [SO:ke]"
        },
        "SO:0000112": {
            "name": "primer",
            "def": "An oligo to which new deoxyribonucleotides can be added by DNA polymerase. [SO:ke]"
        },
        "SO:0000113": {
            "name": "proviral_region",
            "def": "A viral sequence which has integrated into a host genome. [SO:ke]"
        },
        "SO:0000114": {
            "name": "methylated_cytosine",
            "def": "A methylated deoxy-cytosine. [SO:ke]"
        },
        "SO:0000115": {
            "name": "transcript_feature"
        },
        "SO:0000116": {
            "name": "edited",
            "def": "An attribute describing a sequence that is modified by editing. [SO:ke]"
        },
        "SO:0000117": {
            "name": "transcript_with_readthrough_stop_codon"
        },
        "SO:0000118": {
            "name": "transcript_with_translational_frameshift",
            "def": "A transcript with a translational frameshift. [SO:xp]"
        },
        "SO:0000119": {
            "name": "regulated",
            "def": "An attribute to describe a sequence that is regulated. [SO:ke]"
        },
        "SO:0000120": {
            "name": "protein_coding_primary_transcript",
            "def": "A primary transcript that, at least in part, encodes one or more proteins. [SO:ke]"
        },
        "SO:0000121": {
            "name": "forward_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000122": {
            "name": "RNA_sequence_secondary_structure",
            "def": "A folded RNA sequence. [SO:ke]"
        },
        "SO:0000123": {
            "name": "transcriptionally_regulated",
            "def": "An attribute describing a gene that is regulated at transcription. [SO:ma]"
        },
        "SO:0000124": {
            "name": "transcriptionally_constitutive",
            "def": "Expressed in relatively constant amounts without regard to cellular environmental conditions such as the concentration of a particular substrate. [SO:ke]"
        },
        "SO:0000125": {
            "name": "transcriptionally_induced",
            "def": "An inducer molecule is required for transcription to occur. [SO:ke]"
        },
        "SO:0000126": {
            "name": "transcriptionally_repressed",
            "def": "A repressor molecule is required for transcription to stop. [SO:ke]"
        },
        "SO:0000127": {
            "name": "silenced_gene",
            "def": "A gene that is silenced. [SO:xp]"
        },
        "SO:0000128": {
            "name": "gene_silenced_by_DNA_modification",
            "def": "A gene that is silenced by DNA modification. [SO:xp]"
        },
        "SO:0000129": {
            "name": "gene_silenced_by_DNA_methylation",
            "def": "A gene that is silenced by DNA methylation. [SO:xp]"
        },
        "SO:0000130": {
            "name": "post_translationally_regulated",
            "def": "An attribute describing a gene that is regulated after it has been translated. [SO:ke]"
        },
        "SO:0000131": {
            "name": "translationally_regulated",
            "def": "An attribute describing a gene that is regulated as it is translated. [SO:ke]"
        },
        "SO:0000132": {
            "name": "reverse_primer",
            "def": "A single stranded oligo used for polymerase chain reaction. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000133": {
            "name": "epigenetically_modified",
            "def": "This attribute describes a gene where heritable changes other than those in the DNA sequence occur. These changes include: modification to the DNA (such as DNA methylation, the covalent modification of cytosine), and post-translational modification of histones. [SO:ke]"
        },
        "SO:0000134": {
            "name": "genomically_imprinted",
            "def": "Imprinted genes are epigenetically modified genes that are expressed monoallelically according to their parent of origin. [SO:ke]"
        },
        "SO:0000135": {
            "name": "maternally_imprinted",
            "def": "The maternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
        },
        "SO:0000136": {
            "name": "paternally_imprinted",
            "def": "The paternal copy of the gene is modified, rendering it transcriptionally silent. [SO:ke]"
        },
        "SO:0000137": {
            "name": "allelically_excluded",
            "def": "Allelic exclusion is a process occurring in diploid organisms, where a gene is inactivated and not expressed in that cell. [SO:ke]"
        },
        "SO:0000138": {
            "name": "gene_rearranged_at_DNA_level",
            "def": "An epigenetically modified gene, rearranged at the DNA level. [SO:xp]"
        },
        "SO:0000139": {
            "name": "ribosome_entry_site",
            "def": "Region in mRNA where ribosome assembles. [SO:ke]"
        },
        "SO:0000140": {
            "name": "attenuator",
            "def": "A sequence segment located within the five prime end of an mRNA that causes premature termination of translation. [SO:as]"
        },
        "SO:0000141": {
            "name": "terminator",
            "def": "The sequence of DNA located either at the end of the transcript that causes RNA polymerase to terminate transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000142": {
            "name": "DNA_sequence_secondary_structure",
            "def": "A folded DNA sequence. [SO:ke]"
        },
        "SO:0000143": {
            "name": "assembly_component",
            "def": "A region of known length which may be used to manufacture a longer region. [SO:ke]"
        },
        "SO:0000144": {
            "name": "primary_transcript_attribute"
        },
        "SO:0000145": {
            "name": "recoded_codon",
            "def": "A codon that has been redefined at translation. The redefinition may be as a result of translational bypass, translational frameshifting or stop codon readthrough. [SO:xp]"
        },
        "SO:0000146": {
            "name": "capped",
            "def": "An attribute describing when a sequence, usually an mRNA is capped by the addition of a modified guanine nucleotide at the 5' end. [SO:ke]"
        },
        "SO:0000147": {
            "name": "exon",
            "def": "A region of the transcript sequence within a gene which is not removed from the primary RNA transcript by RNA splicing. [SO:ke]"
        },
        "SO:0000148": {
            "name": "supercontig",
            "def": "One or more contigs that have been ordered and oriented using end-read information. Contains gaps that are filled with N's. [SO:ls]"
        },
        "SO:0000149": {
            "name": "contig",
            "def": "A contiguous sequence derived from sequence assembly. Has no gaps, but may contain N's from unavailable bases. [SO:ls]"
        },
        "SO:0000150": {
            "name": "read",
            "def": "A sequence obtained from a single sequencing experiment. Typically a read is produced when a base calling program interprets information from a chromatogram trace file produced from a sequencing machine. [SO:rd]"
        },
        "SO:0000151": {
            "name": "clone",
            "def": "A piece of DNA that has been inserted in a vector so that it can be propagated in a host bacterium or some other organism. [SO:ke]"
        },
        "SO:0000152": {
            "name": "YAC",
            "def": "Yeast Artificial Chromosome, a vector constructed from the telomeric, centromeric, and replication origin sequences needed for replication in yeast cells. [SO:ma]"
        },
        "SO:0000153": {
            "name": "BAC",
            "def": "Bacterial Artificial Chromosome, a cloning vector that can be propagated as mini-chromosomes in a bacterial host. [SO:ma]"
        },
        "SO:0000154": {
            "name": "PAC",
            "def": "The P1-derived artificial chromosome are DNA constructs that are derived from the DNA of P1 bacteriophage. They can carry large amounts (about 100-300 kilobases) of other sequences for a variety of bioengineering purposes. It is one type of vector used to clone DNA fragments (100- to 300-kb insert size; average, 150 kb) in Escherichia coli cells. [http://en.wikipedia.org/wiki/P1-derived_artificial_chromosome]"
        },
        "SO:0000155": {
            "name": "plasmid",
            "def": "A self replicating, using the hosts cellular machinery, often circular nucleic acid molecule that is distinct from a chromosome in the organism. [SO:ma]"
        },
        "SO:0000156": {
            "name": "cosmid",
            "def": "A cloning vector that is a hybrid of lambda phages and a plasmid that can be propagated as a plasmid or packaged as a phage,since they retain the lambda cos sites. [SO:ma]"
        },
        "SO:0000157": {
            "name": "phagemid",
            "def": "A plasmid which carries within its sequence a bacteriophage replication origin. When the host bacterium is infected with \\helper\\ phage, a phagemid is replicated along with the phage DNA and packaged into phage capsids. [SO:ma]"
        },
        "SO:0000158": {
            "name": "fosmid",
            "def": "A cloning vector that utilizes the E. coli F factor. [SO:ma]"
        },
        "SO:0000159": {
            "name": "deletion",
            "def": "The point at which one or more contiguous nucleotides were excised. [SO:ke]"
        },
        "SO:0000160": {
            "name": "lambda_clone",
            "def": "A linear clone derived from lambda bacteriophage. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
        },
        "SO:0000161": {
            "name": "methylated_adenine",
            "def": "A modified  base in which adenine has been methylated. [SO:ke]"
        },
        "SO:0000162": {
            "name": "splice_site",
            "def": "Consensus region of primary transcript bordering junction of splicing. A region that overlaps exactly 2 base and adjacent_to splice_junction. [SO:cjm, SO:ke]"
        },
        "SO:0000163": {
            "name": "five_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 5' edge of the intron. A splice_site that is downstream_adjacent_to exon and starts intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
        },
        "SO:0000164": {
            "name": "three_prime_cis_splice_site",
            "def": "Intronic 2 bp region bordering the exon, at the 3' edge of the intron. A splice_site that is upstream_adjacent_to exon and finishes intron. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html, SO:cjm, SO:ke]"
        },
        "SO:0000165": {
            "name": "enhancer",
            "def": "A cis-acting sequence that increases the utilization of (some) eukaryotic promoters, and can function in either orientation and in any location (upstream or downstream) relative to the promoter. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000166": {
            "name": "enhancer_bound_by_factor",
            "def": "An enhancer bound by a factor. [SO:xp]"
        },
        "SO:0000167": {
            "name": "promoter",
            "def": "A regulatory_region composed of the TSS(s) and binding sites for TF_complexes of the basal transcription machinery. [SO:regcreative]"
        },
        "SO:0000168": {
            "name": "restriction_enzyme_cut_site",
            "def": "A specific nucleotide sequence of DNA at or near which a particular restriction enzyme cuts the DNA. [SO:ma]"
        },
        "SO:0000169": {
            "name": "RNApol_I_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase I binds, to begin transcription. [SO:ke]"
        },
        "SO:0000170": {
            "name": "RNApol_II_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase II binds, to begin transcription. [SO:ke]"
        },
        "SO:0000171": {
            "name": "RNApol_III_promoter",
            "def": "A DNA sequence in eukaryotic DNA to which RNA polymerase III binds, to begin transcription. [SO:ke]"
        },
        "SO:0000172": {
            "name": "CAAT_signal",
            "def": "Part of a conserved sequence located about 75-bp upstream of the start point of eukaryotic transcription units which may be involved in RNA polymerase binding; consensus=GG(C|T)CAATCT. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000173": {
            "name": "GC_rich_promoter_region",
            "def": "A conserved GC-rich region located upstream of the start point of eukaryotic transcription units which may occur in multiple copies or in either orientation; consensus=GGGCGG. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000174": {
            "name": "TATA_box",
            "def": "A conserved AT-rich septamer found about 25-bp before the start point of many eukaryotic RNA polymerase II transcript units; may be involved in positioning the enzyme for correct initiation; consensus=TATA(A|T)A(A|T). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:16858867]"
        },
        "SO:0000175": {
            "name": "minus_10_signal",
            "def": "A conserved region about 10-bp upstream of the start point of bacterial transcription units which may be involved in binding RNA polymerase; consensus=TAtAaT. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000176": {
            "name": "minus_35_signal",
            "def": "A conserved hexamer about 35-bp upstream of the start point of bacterial transcription units; consensus=TTGACa or TGTTGACA. This region is associated with sigma factor 70. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000177": {
            "name": "cross_genome_match",
            "def": "A nucleotide match against a sequence from another organism. [SO:ma]"
        },
        "SO:0000178": {
            "name": "operon",
            "def": "A group of contiguous genes transcribed as a single (polycistronic) mRNA from a single regulatory region. [SO:ma]"
        },
        "SO:0000179": {
            "name": "clone_insert_start",
            "def": "The start of the clone insert. [SO:ke]"
        },
        "SO:0000180": {
            "name": "retrotransposon",
            "def": "A transposable element that is incorporated into a chromosome by a mechanism that requires reverse transcriptase. [http://www.dddmag.com/Glossary.aspx#r]"
        },
        "SO:0000181": {
            "name": "translated_nucleotide_match",
            "def": "A match against a translated sequence. [SO:ke]"
        },
        "SO:0000182": {
            "name": "DNA_transposon",
            "def": "A transposon where the mechanism of transposition is via a DNA intermediate. [SO:ke]"
        },
        "SO:0000183": {
            "name": "non_transcribed_region",
            "def": "A region of the gene which is not transcribed. [SO:ke]"
        },
        "SO:0000184": {
            "name": "U2_intron",
            "def": "A major type of spliceosomal intron spliced by the U2 spliceosome, that includes U1, U2, U4/U6 and U5 snRNAs. [PMID:9428511]"
        },
        "SO:0000185": {
            "name": "primary_transcript",
            "def": "A transcript that in its initial state requires modification to be functional. [SO:ma]"
        },
        "SO:0000186": {
            "name": "LTR_retrotransposon",
            "def": "A retrotransposon flanked by long terminal repeat sequences. [SO:ke]"
        },
        "SO:0000187": {
            "name": "repeat_family",
            "def": "A group of characterized repeat sequences. [SO:ke]"
        },
        "SO:0000188": {
            "name": "intron",
            "def": "A region of a primary transcript that is transcribed, but removed from within the transcript by splicing together the sequences (exons) on either side of it. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000189": {
            "name": "non_LTR_retrotransposon",
            "def": "A retrotransposon without long terminal repeat sequences. [SO:ke]"
        },
        "SO:0000190": {
            "name": "five_prime_intron"
        },
        "SO:0000191": {
            "name": "interior_intron"
        },
        "SO:0000192": {
            "name": "three_prime_intron"
        },
        "SO:0000193": {
            "name": "RFLP_fragment",
            "def": "A DNA fragment used as a reagent to detect the polymorphic genomic loci by hybridizing against the genomic DNA digested with a given restriction enzyme. [GOC:pj]"
        },
        "SO:0000194": {
            "name": "LINE_element",
            "def": "A dispersed repeat family with many copies, each from 1 to 6 kb long. New elements are generated by retroposition of a transcribed copy. Typically the LINE contains 2 ORF's one of which is reverse transcriptase, and 3'and 5' direct repeats. [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
        },
        "SO:0000195": {
            "name": "coding_exon",
            "def": "An exon whereby at least one base is part of a codon (here, 'codon' is inclusive of the stop_codon). [SO:ke]"
        },
        "SO:0000196": {
            "name": "five_prime_coding_exon_coding_region",
            "def": "The sequence of the five_prime_coding_exon that codes for protein. [SO:cjm]"
        },
        "SO:0000197": {
            "name": "three_prime_coding_exon_coding_region",
            "def": "The sequence of the three_prime_coding_exon that codes for protein. [SO:cjm]"
        },
        "SO:0000198": {
            "name": "noncoding_exon",
            "def": "An exon that does not contain any codons. [SO:ke]"
        },
        "SO:0000199": {
            "name": "translocation",
            "def": "A region of nucleotide sequence that has translocated to a new position. The observed adjacency of two previously separated regions. [NCBI:th, SO:ke]"
        },
        "SO:0000200": {
            "name": "five_prime_coding_exon",
            "def": "The 5' most coding exon. [SO:ke]"
        },
        "SO:0000201": {
            "name": "interior_exon",
            "def": "An exon that is bounded by 5' and 3' splice sites. [PMID:10373547]"
        },
        "SO:0000202": {
            "name": "three_prime_coding_exon",
            "def": "The coding exon that is most 3-prime on a given transcript. [SO:ma]"
        },
        "SO:0000203": {
            "name": "UTR",
            "def": "Messenger RNA sequences that are untranslated and lie five prime or three prime to sequences which are translated. [SO:ke]"
        },
        "SO:0000204": {
            "name": "five_prime_UTR",
            "def": "A region at the 5' end of a mature transcript (preceding the initiation codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000205": {
            "name": "three_prime_UTR",
            "def": "A region at the 3' end of a mature transcript (following the stop codon) that is not translated into a protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000206": {
            "name": "SINE_element",
            "def": "A repetitive element, a few hundred base pairs long, that is dispersed throughout the genome. A common human SINE is the Alu element. [SO:ke]"
        },
        "SO:0000207": {
            "name": "simple_sequence_length_variation"
        },
        "SO:0000208": {
            "name": "terminal_inverted_repeat_element",
            "def": "A DNA transposable element defined as having termini with perfect, or nearly perfect short inverted repeats, generally 10 - 40 nucleotides long. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
        },
        "SO:0000209": {
            "name": "rRNA_primary_transcript",
            "def": "A primary transcript encoding a ribosomal RNA. [SO:ke]"
        },
        "SO:0000210": {
            "name": "tRNA_primary_transcript",
            "def": "A primary transcript encoding a transfer RNA (SO:0000253). [SO:ke]"
        },
        "SO:0000211": {
            "name": "alanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding alanyl tRNA. [SO:ke]"
        },
        "SO:0000212": {
            "name": "arginine_tRNA_primary_transcript",
            "def": "A primary transcript encoding arginyl tRNA (SO:0000255). [SO:ke]"
        },
        "SO:0000213": {
            "name": "asparagine_tRNA_primary_transcript",
            "def": "A primary transcript encoding asparaginyl tRNA (SO:0000256). [SO:ke]"
        },
        "SO:0000214": {
            "name": "aspartic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding aspartyl tRNA (SO:0000257). [SO:ke]"
        },
        "SO:0000215": {
            "name": "cysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding cysteinyl tRNA (SO:0000258). [SO:ke]"
        },
        "SO:0000216": {
            "name": "glutamic_acid_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutaminyl tRNA (SO:0000260). [SO:ke]"
        },
        "SO:0000217": {
            "name": "glutamine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glutamyl tRNA (SO:0000260). [SO:ke]"
        },
        "SO:0000218": {
            "name": "glycine_tRNA_primary_transcript",
            "def": "A primary transcript encoding glycyl tRNA (SO:0000263). [SO:ke]"
        },
        "SO:0000219": {
            "name": "histidine_tRNA_primary_transcript",
            "def": "A primary transcript encoding histidyl tRNA (SO:0000262). [SO:ke]"
        },
        "SO:0000220": {
            "name": "isoleucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding isoleucyl tRNA (SO:0000263). [SO:ke]"
        },
        "SO:0000221": {
            "name": "leucine_tRNA_primary_transcript",
            "def": "A primary transcript encoding leucyl tRNA (SO:0000264). [SO:ke]"
        },
        "SO:0000222": {
            "name": "lysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding lysyl tRNA (SO:0000265). [SO:ke]"
        },
        "SO:0000223": {
            "name": "methionine_tRNA_primary_transcript",
            "def": "A primary transcript encoding methionyl tRNA (SO:0000266). [SO:ke]"
        },
        "SO:0000224": {
            "name": "phenylalanine_tRNA_primary_transcript",
            "def": "A primary transcript encoding phenylalanyl tRNA (SO:0000267). [SO:ke]"
        },
        "SO:0000225": {
            "name": "proline_tRNA_primary_transcript",
            "def": "A primary transcript encoding prolyl tRNA (SO:0000268). [SO:ke]"
        },
        "SO:0000226": {
            "name": "serine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
        },
        "SO:0000227": {
            "name": "threonine_tRNA_primary_transcript",
            "def": "A primary transcript encoding threonyl tRNA (SO:000270). [SO:ke]"
        },
        "SO:0000228": {
            "name": "tryptophan_tRNA_primary_transcript",
            "def": "A primary transcript encoding tryptophanyl tRNA (SO:000271). [SO:ke]"
        },
        "SO:0000229": {
            "name": "tyrosine_tRNA_primary_transcript",
            "def": "A primary transcript encoding tyrosyl tRNA (SO:000272). [SO:ke]"
        },
        "SO:0000230": {
            "name": "valine_tRNA_primary_transcript",
            "def": "A primary transcript encoding valyl tRNA (SO:000273). [SO:ke]"
        },
        "SO:0000231": {
            "name": "snRNA_primary_transcript",
            "def": "A primary transcript encoding a small nuclear RNA (SO:0000274). [SO:ke]"
        },
        "SO:0000232": {
            "name": "snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar mRNA (SO:0000275). [SO:ke]"
        },
        "SO:0000233": {
            "name": "mature_transcript",
            "def": "A transcript which has undergone the necessary modifications, if any, for its function. In eukaryotes this includes, for example, processing of introns, cleavage, base modification, and modifications to the 5' and/or the 3' ends, other than addition of bases. In bacteria functional mRNAs are usually not modified. [SO:ke]"
        },
        "SO:0000234": {
            "name": "mRNA",
            "def": "Messenger RNA is the intermediate molecule between DNA and protein. It includes UTR and coding sequences. It does not contain introns. [SO:ma]"
        },
        "SO:0000235": {
            "name": "TF_binding_site",
            "def": "A region of a nucleotide molecule that binds a Transcription Factor or Transcription Factor complex [GO:0005667]. [SO:ke]"
        },
        "SO:0000236": {
            "name": "ORF",
            "def": "The in-frame interval between the stop codons of a reading frame which when read as sequential triplets, has the potential of encoding a sequential string of amino acids. TER(NNN)nTER. [SGD:rb, SO:ma]"
        },
        "SO:0000237": {
            "name": "transcript_attribute"
        },
        "SO:0000238": {
            "name": "foldback_element",
            "def": "A transposable element with extensive secondary structure, characterized by large modular imperfect long inverted repeats. [http://www.genetics.org/cgi/reprint/156/4/1983.pdf]"
        },
        "SO:0000239": {
            "name": "flanking_region",
            "def": "The sequences extending on either side of a specific region. [SO:ke]"
        },
        "SO:0000240": {
            "name": "chromosome_variation"
        },
        "SO:0000241": {
            "name": "internal_UTR",
            "def": "A UTR bordered by the terminal and initial codons of two CDSs in a polycistronic transcript. Every UTR is either 5', 3' or internal. [SO:cjm]"
        },
        "SO:0000242": {
            "name": "untranslated_region_polycistronic_mRNA",
            "def": "The untranslated sequence separating the 'cistrons' of multicistronic mRNA. [SO:ke]"
        },
        "SO:0000243": {
            "name": "internal_ribosome_entry_site",
            "def": "Sequence element that recruits a ribosomal subunit to internal mRNA for translation initiation. [SO:ke]"
        },
        "SO:0000244": {
            "name": "four_cutter_restriction_site"
        },
        "SO:0000245": {
            "name": "mRNA_by_polyadenylation_status"
        },
        "SO:0000246": {
            "name": "polyadenylated",
            "def": "A attribute describing the addition of a poly A tail to the 3' end of a mRNA molecule. [SO:ke]"
        },
        "SO:0000247": {
            "name": "mRNA_not_polyadenylated"
        },
        "SO:0000248": {
            "name": "sequence_length_variation"
        },
        "SO:0000249": {
            "name": "six_cutter_restriction_site"
        },
        "SO:0000250": {
            "name": "modified_RNA_base_feature",
            "def": "A post_transcriptionally modified base. [SO:ke]"
        },
        "SO:0000251": {
            "name": "eight_cutter_restriction_site"
        },
        "SO:0000252": {
            "name": "rRNA",
            "def": "RNA that comprises part of a ribosome, and that can provide both structural scaffolding and catalytic activity. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, ISBN:0198506732]"
        },
        "SO:0000253": {
            "name": "tRNA",
            "def": "Transfer RNA (tRNA) molecules are approximately 80 nucleotides in length. Their secondary structure includes four short double-helical elements and three loops (D, anti-codon, and T loops). Further hydrogen bonds mediate the characteristic L-shaped molecular structure. Transfer RNAs have two regions of fundamental functional importance: the anti-codon, which is responsible for specific mRNA codon recognition, and the 3' end, to which the tRNA's corresponding amino acid is attached (by aminoacyl-tRNA synthetases). Transfer RNAs cope with the degeneracy of the genetic code in two manners: having more than one tRNA (with a specific anti-codon) for a particular amino acid; and 'wobble' base-pairing, i.e. permitting non-standard base-pairing at the 3rd anti-codon position. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00005, ISBN:0198506732]"
        },
        "SO:0000254": {
            "name": "alanyl_tRNA",
            "def": "A tRNA sequence that has an alanine anticodon, and a 3' alanine binding region. [SO:ke]"
        },
        "SO:0000255": {
            "name": "rRNA_small_subunit_primary_transcript",
            "def": "A primary transcript encoding a small ribosomal subunit RNA. [SO:ke]"
        },
        "SO:0000256": {
            "name": "asparaginyl_tRNA",
            "def": "A tRNA sequence that has an asparagine anticodon, and a 3' asparagine binding region. [SO:ke]"
        },
        "SO:0000257": {
            "name": "aspartyl_tRNA",
            "def": "A tRNA sequence that has an aspartic acid anticodon, and a 3' aspartic acid binding region. [SO:ke]"
        },
        "SO:0000258": {
            "name": "cysteinyl_tRNA",
            "def": "A tRNA sequence that has a cysteine anticodon, and a 3' cysteine binding region. [SO:ke]"
        },
        "SO:0000259": {
            "name": "glutaminyl_tRNA",
            "def": "A tRNA sequence that has a glutamine anticodon, and a 3' glutamine binding region. [SO:ke]"
        },
        "SO:0000260": {
            "name": "glutamyl_tRNA",
            "def": "A tRNA sequence that has a glutamic acid anticodon, and a 3' glutamic acid binding region. [SO:ke]"
        },
        "SO:0000261": {
            "name": "glycyl_tRNA",
            "def": "A tRNA sequence that has a glycine anticodon, and a 3' glycine binding region. [SO:ke]"
        },
        "SO:0000262": {
            "name": "histidyl_tRNA",
            "def": "A tRNA sequence that has a histidine anticodon, and a 3' histidine binding region. [SO:ke]"
        },
        "SO:0000263": {
            "name": "isoleucyl_tRNA",
            "def": "A tRNA sequence that has an isoleucine anticodon, and a 3' isoleucine binding region. [SO:ke]"
        },
        "SO:0000264": {
            "name": "leucyl_tRNA",
            "def": "A tRNA sequence that has a leucine anticodon, and a 3' leucine binding region. [SO:ke]"
        },
        "SO:0000265": {
            "name": "lysyl_tRNA",
            "def": "A tRNA sequence that has a lysine anticodon, and a 3' lysine binding region. [SO:ke]"
        },
        "SO:0000266": {
            "name": "methionyl_tRNA",
            "def": "A tRNA sequence that has a methionine anticodon, and a 3' methionine binding region. [SO:ke]"
        },
        "SO:0000267": {
            "name": "phenylalanyl_tRNA",
            "def": "A tRNA sequence that has a phenylalanine anticodon, and a 3' phenylalanine binding region. [SO:ke]"
        },
        "SO:0000268": {
            "name": "prolyl_tRNA",
            "def": "A tRNA sequence that has a proline anticodon, and a 3' proline binding region. [SO:ke]"
        },
        "SO:0000269": {
            "name": "seryl_tRNA",
            "def": "A tRNA sequence that has a serine anticodon, and a 3' serine binding region. [SO:ke]"
        },
        "SO:0000270": {
            "name": "threonyl_tRNA",
            "def": "A tRNA sequence that has a threonine anticodon, and a 3' threonine binding region. [SO:ke]"
        },
        "SO:0000271": {
            "name": "tryptophanyl_tRNA",
            "def": "A tRNA sequence that has a tryptophan anticodon, and a 3' tryptophan binding region. [SO:ke]"
        },
        "SO:0000272": {
            "name": "tyrosyl_tRNA",
            "def": "A tRNA sequence that has a tyrosine anticodon, and a 3' tyrosine binding region. [SO:ke]"
        },
        "SO:0000273": {
            "name": "valyl_tRNA",
            "def": "A tRNA sequence that has a valine anticodon, and a 3' valine binding region. [SO:ke]"
        },
        "SO:0000274": {
            "name": "snRNA",
            "def": "A small nuclear RNA molecule involved in pre-mRNA splicing and processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, PMID:11733745, WB:ems]"
        },
        "SO:0000275": {
            "name": "snoRNA",
            "def": "A snoRNA (small nucleolar RNA) is any one of a class of small RNAs that are associated with the eukaryotic nucleus as components of small nucleolar ribonucleoproteins. They participate in the processing or modifications of many RNAs, mostly ribosomal RNAs (rRNAs) though snoRNAs are also known to target other classes of RNA, including spliceosomal RNAs, tRNAs, and mRNAs via a stretch of sequence that is complementary to a sequence in the targeted RNA. [GOC:kgc]"
        },
        "SO:0000276": {
            "name": "miRNA",
            "def": "Small, ~22-nt, RNA molecule that is the endogenous transcript of a miRNA gene (or the product of other non coding RNA genes. Micro RNAs are produced from precursor molecules (SO:0000647) that can form local hairpin structures, which ordinarily are processed (usually via the Dicer pathway) such that a single miRNA molecule accumulates from one arm of a hairpin precursor molecule. Micro RNAs may trigger the cleavage of their target molecules or act as translational repressors. [PMID:11081512, PMID:12592000]"
        },
        "SO:0000277": {
            "name": "bound_by_factor",
            "def": "An attribute describing a sequence that is bound by another molecule. [SO:ke]"
        },
        "SO:0000278": {
            "name": "transcript_bound_by_nucleic_acid",
            "def": "A transcript that is bound by a nucleic acid. [SO:xp]"
        },
        "SO:0000279": {
            "name": "transcript_bound_by_protein",
            "def": "A transcript that is bound by a protein. [SO:xp]"
        },
        "SO:0000280": {
            "name": "engineered_gene",
            "def": "A gene that is engineered. [SO:xp]"
        },
        "SO:0000281": {
            "name": "engineered_foreign_gene",
            "def": "A gene that is engineered and foreign. [SO:xp]"
        },
        "SO:0000282": {
            "name": "mRNA_with_minus_1_frameshift",
            "def": "An mRNA with a minus 1 frameshift. [SO:xp]"
        },
        "SO:0000283": {
            "name": "engineered_foreign_transposable_element_gene",
            "def": "A transposable_element that is engineered and foreign. [SO:xp]"
        },
        "SO:0000284": {
            "name": "type_I_enzyme_restriction_site",
            "def": "The recognition site is bipartite and interrupted. [http://www.promega.com]"
        },
        "SO:0000285": {
            "name": "foreign_gene",
            "def": "A gene that is foreign. [SO:xp]"
        },
        "SO:0000286": {
            "name": "long_terminal_repeat",
            "def": "A sequence directly repeated at both ends of a defined sequence, of the sort typically found in retroviruses. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000287": {
            "name": "fusion_gene",
            "def": "A gene that is a fusion. [SO:xp]"
        },
        "SO:0000288": {
            "name": "engineered_fusion_gene",
            "def": "A fusion gene that is engineered. [SO:xp]"
        },
        "SO:0000289": {
            "name": "microsatellite",
            "def": "A repeat_region containing repeat_units of 2 to 10 bp repeated in tandem. [http://www.informatics.jax.org/silver/glossary.shtml, NCBI:th]"
        },
        "SO:0000290": {
            "name": "dinucleotide_repeat_microsatellite_feature"
        },
        "SO:0000291": {
            "name": "trinucleotide_repeat_microsatellite_feature"
        },
        "SO:0000292": {
            "name": "repetitive_element"
        },
        "SO:0000293": {
            "name": "engineered_foreign_repetitive_element",
            "def": "A repetitive element that is engineered and foreign. [SO:xp]"
        },
        "SO:0000294": {
            "name": "inverted_repeat",
            "def": "The sequence is complementarily repeated on the opposite strand. It is a palindrome, and it may, or may not be hyphenated. Examples: GCTGATCAGC, or GCTGA-----TCAGC. [SO:ke]"
        },
        "SO:0000295": {
            "name": "U12_intron",
            "def": "A type of spliceosomal intron spliced by the U12 spliceosome, that includes U11, U12, U4atac/U6atac and U5 snRNAs. [PMID:9428511]"
        },
        "SO:0000296": {
            "name": "origin_of_replication",
            "def": "The origin of replication; starting site for duplication of a nucleic acid molecule to give two identical copies. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000297": {
            "name": "D_loop",
            "def": "Displacement loop; a region within mitochondrial DNA in which a short stretch of RNA is paired with one strand of DNA, displacing the original partner DNA strand in this region; also used to describe the displacement of a region of one strand of duplex DNA by a single stranded invader in the reaction catalyzed by RecA protein. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000298": {
            "name": "recombination_feature"
        },
        "SO:0000299": {
            "name": "specific_recombination_site"
        },
        "SO:0000300": {
            "name": "recombination_feature_of_rearranged_gene"
        },
        "SO:0000301": {
            "name": "vertebrate_immune_system_gene_recombination_feature"
        },
        "SO:0000302": {
            "name": "J_gene_recombination_feature",
            "def": "Recombination signal including J-heptamer, J-spacer and J-nonamer in 5' of J-region of a J-gene or J-sequence. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000303": {
            "name": "clip",
            "def": "Part of the primary transcript that is clipped off during processing. [SO:ke]"
        },
        "SO:0000304": {
            "name": "type_II_enzyme_restriction_site",
            "def": "The recognition site is either palindromic, partially palindromic or an interrupted palindrome. Cleavage occurs within the recognition site. [http://www.promega.com]"
        },
        "SO:0000305": {
            "name": "modified_DNA_base",
            "def": "A modified nucleotide, i.e. a nucleotide other than A, T, C. G. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000306": {
            "name": "methylated_DNA_base_feature",
            "def": "A nucleotide modified by methylation. [SO:ke]"
        },
        "SO:0000307": {
            "name": "CpG_island",
            "def": "Regions of a few hundred to a few thousand bases in vertebrate genomes that are relatively GC and CpG rich; they are typically unmethylated and often found near the 5' ends of genes. [SO:rd]"
        },
        "SO:0000308": {
            "name": "sequence_feature_locating_method"
        },
        "SO:0000309": {
            "name": "computed_feature"
        },
        "SO:0000310": {
            "name": "predicted_ab_initio_computation"
        },
        "SO:0000311": {
            "name": "computed_feature_by_similarity",
            "def": ". [SO:ma]"
        },
        "SO:0000312": {
            "name": "experimentally_determined",
            "def": "Attribute to describe a feature that has been experimentally verified. [SO:ke]"
        },
        "SO:0000313": {
            "name": "stem_loop",
            "def": "A double-helical region of nucleic acid formed by base-pairing between adjacent (inverted) complementary sequences. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000314": {
            "name": "direct_repeat",
            "def": "A repeat where the same sequence is repeated in the same direction. Example: GCTGA-followed by-GCTGA. [SO:ke]"
        },
        "SO:0000315": {
            "name": "TSS",
            "def": "The first base where RNA polymerase begins to synthesize the RNA transcript. [SO:ke]"
        },
        "SO:0000316": {
            "name": "CDS",
            "def": "A contiguous sequence which begins with, and includes, a start codon and ends with, and includes, a stop codon. [SO:ma]"
        },
        "SO:0000317": {
            "name": "cDNA_clone",
            "def": "Complementary DNA; A piece of DNA copied from an mRNA and spliced into a vector for propagation in a suitable host. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
        },
        "SO:0000318": {
            "name": "start_codon",
            "def": "First codon to be translated by a ribosome. [SO:ke]"
        },
        "SO:0000319": {
            "name": "stop_codon",
            "def": "In mRNA, a set of three nucleotides that indicates the end of information for protein synthesis. [SO:ke]"
        },
        "SO:0000320": {
            "name": "intronic_splice_enhancer",
            "def": "Sequences within the intron that modulate splice site selection for some introns. [SO:ke]"
        },
        "SO:0000321": {
            "name": "mRNA_with_plus_1_frameshift",
            "def": "An mRNA with a plus 1 frameshift. [SO:ke]"
        },
        "SO:0000322": {
            "name": "nuclease_hypersensitive_site"
        },
        "SO:0000323": {
            "name": "coding_start",
            "def": "The first base to be translated into protein. [SO:ke]"
        },
        "SO:0000324": {
            "name": "tag",
            "def": "A nucleotide sequence that may be used to identify a larger sequence. [SO:ke]"
        },
        "SO:0000325": {
            "name": "rRNA_large_subunit_primary_transcript",
            "def": "A primary transcript encoding a large ribosomal subunit RNA. [SO:ke]"
        },
        "SO:0000326": {
            "name": "SAGE_tag",
            "def": "A short diagnostic sequence tag, serial analysis of gene expression (SAGE), that allows the quantitative and simultaneous analysis of a large number of transcripts. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=7570003&dopt=Abstract]"
        },
        "SO:0000327": {
            "name": "coding_end",
            "def": "The last base to be translated into protein. It does not include the stop codon. [SO:ke]"
        },
        "SO:0000328": {
            "name": "microarray_oligo"
        },
        "SO:0000329": {
            "name": "mRNA_with_plus_2_frameshift",
            "def": "An mRNA with a plus 2 frameshift. [SO:xp]"
        },
        "SO:0000330": {
            "name": "conserved_region",
            "def": "Region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000331": {
            "name": "STS",
            "def": "Short (typically a few hundred base pairs) DNA sequence that has a single occurrence in a genome and whose location and base sequence are known. [http://www.biospace.com]"
        },
        "SO:0000332": {
            "name": "coding_conserved_region",
            "def": "Coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000333": {
            "name": "exon_junction",
            "def": "The boundary between two exons in a processed transcript. [SO:ke]"
        },
        "SO:0000334": {
            "name": "nc_conserved_region",
            "def": "Non-coding region of sequence similarity by descent from a common ancestor. [SO:ke]"
        },
        "SO:0000335": {
            "name": "mRNA_with_minus_2_frameshift",
            "def": "A mRNA with a minus 2 frameshift. [SO:ke]"
        },
        "SO:0000336": {
            "name": "pseudogene",
            "def": "A sequence that closely resembles a known functional gene, at another locus within a genome, that is non-functional as a consequence of (usually several) mutations that prevent either its transcription or translation (or both). In general, pseudogenes result from either reverse transcription of a transcript of their \\normal\\ paralog (SO:0000043) (in which case the pseudogene typically lacks introns and includes a poly(A) tail) or from recombination (SO:0000044) (in which case the pseudogene is typically a tandem duplication of its \\normal\\ paralog). [http://www.ucl.ac.uk/~ucbhjow/b241/glossary.html]"
        },
        "SO:0000337": {
            "name": "RNAi_reagent",
            "def": "A double stranded RNA duplex, at least 20bp long, used experimentally to inhibit gene function by RNA interference. [SO:rd]"
        },
        "SO:0000338": {
            "name": "MITE",
            "def": "A highly repetitive and short (100-500 base pair) transposable element with terminal inverted repeats (TIR) and target site duplication (TSD). MITEs do not encode proteins. [http://www.pnas.org/cgi/content/full/97/18/10083]"
        },
        "SO:0000339": {
            "name": "recombination_hotspot",
            "def": "A region in a genome which promotes recombination. [SO:rd]"
        },
        "SO:0000340": {
            "name": "chromosome",
            "def": "Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication. [SO:ma]"
        },
        "SO:0000341": {
            "name": "chromosome_band",
            "def": "A cytologically distinguishable feature of a chromosome, often made visible by staining, and usually alternating light and dark. [SO:ma]"
        },
        "SO:0000342": {
            "name": "site_specific_recombination_target_region"
        },
        "SO:0000343": {
            "name": "match",
            "def": "A region of sequence, aligned to another sequence with some statistical significance, using an algorithm such as BLAST or SIM4. [SO:ke]"
        },
        "SO:0000344": {
            "name": "splice_enhancer",
            "def": "Region of a transcript that regulates splicing. [SO:ke]"
        },
        "SO:0000345": {
            "name": "EST",
            "def": "A tag produced from a single sequencing read from a cDNA clone or PCR product; typically a few hundred base pairs long. [SO:ke]"
        },
        "SO:0000346": {
            "name": "loxP_site"
        },
        "SO:0000347": {
            "name": "nucleotide_match",
            "def": "A match against a nucleotide sequence. [SO:ke]"
        },
        "SO:0000348": {
            "name": "nucleic_acid",
            "def": "An attribute describing a sequence consisting of nucleobases bound to repeating units. The forms found in nature are deoxyribonucleic acid (DNA), where the repeating units are 2-deoxy-D-ribose rings connected to a phosphate backbone, and ribonucleic acid (RNA), where the repeating units are D-ribose rings connected to a phosphate backbone. [CHEBI:33696, RSC:cb]"
        },
        "SO:0000349": {
            "name": "protein_match",
            "def": "A match against a protein sequence. [SO:ke]"
        },
        "SO:0000350": {
            "name": "FRT_site",
            "def": "An inversion site found on the Saccharomyces cerevisiae 2 micron plasmid. [SO:ma]"
        },
        "SO:0000351": {
            "name": "synthetic_sequence",
            "def": "An attribute to decide a sequence of nucleotides, nucleotide analogs, or amino acids that has been designed by an experimenter and which may, or may not, correspond with any natural sequence. [SO:ma]"
        },
        "SO:0000352": {
            "name": "DNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a 2-deoxy-D-ribose ring connected to a phosphate backbone. [RSC:cb]"
        },
        "SO:0000353": {
            "name": "sequence_assembly",
            "def": "A sequence of nucleotides that has been algorithmically derived from an alignment of two or more different sequences. [SO:ma]"
        },
        "SO:0000354": {
            "name": "group_1_intron_homing_endonuclease_target_region",
            "def": "A region of intronic nucleotide sequence targeted by a nuclease enzyme. [SO:ke]"
        },
        "SO:0000355": {
            "name": "haplotype_block",
            "def": "A region of the genome which is co-inherited as the result of the lack of historic recombination within it. [SO:ma]"
        },
        "SO:0000356": {
            "name": "RNA",
            "def": "An attribute describing a sequence consisting of nucleobases bound to a repeating unit made of a D-ribose ring connected to a phosphate backbone. [RSC:cb]"
        },
        "SO:0000357": {
            "name": "flanked",
            "def": "An attribute describing a region that is bounded either side by a particular kind of region. [SO:ke]"
        },
        "SO:0000359": {
            "name": "floxed",
            "def": "An attribute describing sequence that is flanked by Lox-P sites. [SO:ke]"
        },
        "SO:0000360": {
            "name": "codon",
            "def": "A set of (usually) three nucleotide bases in a DNA or RNA sequence, which together code for a unique amino acid or the termination of translation and are contained within the CDS. [http://www.everythingbio.com/glos/definition.php?word=codon, SO:ke]"
        },
        "SO:0000361": {
            "name": "FRT_flanked",
            "def": "An attribute to describe sequence that is flanked by the FLP recombinase recognition site, FRT. [SO:ke]"
        },
        "SO:0000362": {
            "name": "invalidated_by_chimeric_cDNA",
            "def": "A cDNA clone constructed from more than one mRNA. Usually an experimental artifact. [SO:ma]"
        },
        "SO:0000363": {
            "name": "floxed_gene",
            "def": "A transgene that is floxed. [SO:xp]"
        },
        "SO:0000364": {
            "name": "transposable_element_flanking_region",
            "def": "The region of sequence surrounding a transposable element. [SO:ke]"
        },
        "SO:0000365": {
            "name": "integron",
            "def": "A region encoding an integrase which acts at a site adjacent to it (attI_site) to insert DNA which must include but is not limited to an attC_site. [SO:as]"
        },
        "SO:0000366": {
            "name": "insertion_site",
            "def": "The junction where an insertion occurred. [SO:ke]"
        },
        "SO:0000367": {
            "name": "attI_site",
            "def": "A region within an integron, adjacent to an integrase, at which site specific recombination involving an attC_site takes place. [SO:as]"
        },
        "SO:0000368": {
            "name": "transposable_element_insertion_site",
            "def": "The junction in a genome where a transposable_element has inserted. [SO:ke]"
        },
        "SO:0000369": {
            "name": "integrase_coding_region"
        },
        "SO:0000370": {
            "name": "small_regulatory_ncRNA",
            "def": "A non-coding RNA, usually with a specific secondary structure, that acts to regulate gene expression. [SO:ma]"
        },
        "SO:0000371": {
            "name": "conjugative_transposon",
            "def": "A transposon that encodes function required for conjugation. [http://www.sci.sdsu.edu/~smaloy/Glossary/C.html]"
        },
        "SO:0000372": {
            "name": "enzymatic_RNA",
            "def": "An RNA sequence that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0000373": {
            "name": "recombinationally_inverted_gene",
            "def": "A recombinationally rearranged gene by inversion. [SO:xp]"
        },
        "SO:0000374": {
            "name": "ribozyme",
            "def": "An RNA with catalytic activity. [SO:ma]"
        },
        "SO:0000375": {
            "name": "rRNA_5_8S",
            "def": "5_8S ribosomal RNA (5. 8S rRNA) is a component of the large subunit of the eukaryotic ribosome. It is transcribed by RNA polymerase I as part of the 45S precursor that also contains 18S and 28S rRNA. Functionally, it is thought that 5.8S rRNA may be involved in ribosome translocation. It is also known to form covalent linkage to the p53 tumour suppressor protein. 5_8S rRNA is also found in archaea. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00002]"
        },
        "SO:0000376": {
            "name": "RNA_6S",
            "def": "A small (184-nt in E. coli) RNA that forms a hairpin type structure. 6S RNA associates with RNA polymerase in a highly specific manner. 6S RNA represses expression from a sigma70-dependent promoter during stationary phase. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00013]"
        },
        "SO:0000377": {
            "name": "CsrB_RsmB_RNA",
            "def": "An enterobacterial RNA that binds the CsrA protein. The CsrB RNAs contain a conserved motif CAGGXXG that is found in up to 18 copies and has been suggested to bind CsrA. The Csr regulatory system has a strong negative regulatory effect on glycogen biosynthesis, glyconeogenesis and glycogen catabolism and a positive regulatory effect on glycolysis. In other bacteria such as Erwinia caratovara the RsmA protein has been shown to regulate the production of virulence determinants, such extracellular enzymes. RsmA binds to RsmB regulatory RNA which is also a member of this family. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00018]"
        },
        "SO:0000378": {
            "name": "DsrA_RNA",
            "def": "DsrA RNA regulates both transcription, by overcoming transcriptional silencing by the nucleoid-associated H-NS protein, and translation, by promoting efficient translation of the stress sigma factor, RpoS. These two activities of DsrA can be separated by mutation: the first of three stem-loops of the 85 nucleotide RNA is necessary for RpoS translation but not for anti-H-NS action, while the second stem-loop is essential for antisilencing and less critical for RpoS translation. The third stem-loop, which behaves as a transcription terminator, can be substituted by the trp transcription terminator without loss of either DsrA function. The sequence of the first stem-loop of DsrA is complementary with the upstream leader portion of RpoS messenger RNA, suggesting that pairing of DsrA with the RpoS message might be important for translational regulation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00014]"
        },
        "SO:0000379": {
            "name": "GcvB_RNA",
            "def": "A small untranslated RNA involved in expression of the dipeptide and oligopeptide transport systems in Escherichia coli. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00022]"
        },
        "SO:0000380": {
            "name": "hammerhead_ribozyme",
            "def": "A small catalytic RNA motif that catalyzes self-cleavage reaction. Its name comes from its secondary structure which resembles a carpenter's hammer. The hammerhead ribozyme is involved in the replication of some viroid and some satellite RNAs. [PMID:2436805]"
        },
        "SO:0000381": {
            "name": "group_IIA_intron"
        },
        "SO:0000382": {
            "name": "group_IIB_intron"
        },
        "SO:0000383": {
            "name": "MicF_RNA",
            "def": "A non-translated 93 nt antisense RNA that binds its target ompF mRNA and regulates ompF expression by inhibiting translation and inducing degradation of the message. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00033]"
        },
        "SO:0000384": {
            "name": "OxyS_RNA",
            "def": "A small untranslated RNA which is induced in response to oxidative stress in Escherichia coli. Acts as a global regulator to activate or repress the expression of as many as 40 genes, including the fhlA-encoded transcriptional activator and the rpoS-encoded sigma(s) subunit of RNA polymerase. OxyS is bound by the Hfq protein, that increases the OxyS RNA interaction with its target messages. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00035]"
        },
        "SO:0000385": {
            "name": "RNase_MRP_RNA",
            "def": "The RNA molecule essential for the catalytic activity of RNase MRP, an enzymatically active ribonucleoprotein with two distinct roles in eukaryotes. In mitochondria it plays a direct role in the initiation of mitochondrial DNA replication. In the nucleus it is involved in precursor rRNA processing, where it cleaves the internal transcribed spacer 1 between 18S and 5.8S rRNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00030]"
        },
        "SO:0000386": {
            "name": "RNase_P_RNA",
            "def": "The RNA component of Ribonuclease P (RNase P), a ubiquitous endoribonuclease, found in archaea, bacteria and eukarya as well as chloroplasts and mitochondria. Its best characterized activity is the generation of mature 5 prime ends of tRNAs by cleaving the 5 prime leader elements of precursor-tRNAs. Cellular RNase Ps are ribonucleoproteins. RNA from bacterial RNase Ps retains its catalytic activity in the absence of the protein subunit, i.e. it is a ribozyme. Isolated eukaryotic and archaeal RNase P RNA has not been shown to retain its catalytic function, but is still essential for the catalytic activity of the holoenzyme. Although the archaeal and eukaryotic holoenzymes have a much greater protein content than the bacterial ones, the RNA cores from all the three lineages are homologous. Helices corresponding to P1, P2, P3, P4, and P10/11 are common to all cellular RNase P RNAs. Yet, there is considerable sequence variation, particularly among the eukaryotic RNAs. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00010]"
        },
        "SO:0000387": {
            "name": "RprA_RNA",
            "def": "Translational regulation of the stationary phase sigma factor RpoS is mediated by the formation of a double-stranded RNA stem-loop structure in the upstream region of the rpoS messenger RNA, occluding the translation initiation site. Clones carrying rprA (RpoS regulator RNA) increased the translation of RpoS. The rprA gene encodes a 106 nucleotide regulatory RNA. As with DsrA Rfam:RF00014, RprA is predicted to form three stem-loops. Thus, at least two small RNAs, DsrA and RprA, participate in the positive regulation of RpoS translation. Unlike DsrA, RprA does not have an extensive region of complementarity to the RpoS leader, leaving its mechanism of action unclear. RprA is non-essential. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00034]"
        },
        "SO:0000388": {
            "name": "RRE_RNA",
            "def": "The Rev response element (RRE) is encoded within the HIV-env gene. Rev is an essential regulatory protein of HIV that binds an internal loop of the RRE leading, encouraging further Rev-RRE binding. This RNP complex is critical for mRNA export and hence for expression of the HIV structural proteins. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00036]"
        },
        "SO:0000389": {
            "name": "spot_42_RNA",
            "def": "A 109-nucleotide RNA of E. coli that seems to have a regulatory role on the galactose operon. Changes in Spot 42 levels are implicated in affecting DNA polymerase I levels. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00021]"
        },
        "SO:0000390": {
            "name": "telomerase_RNA",
            "def": "The RNA component of telomerase, a reverse transcriptase that synthesizes telomeric DNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00025]"
        },
        "SO:0000391": {
            "name": "U1_snRNA",
            "def": "U1 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Its 5' end forms complementary base pairs with the 5' splice junction, thus defining the 5' donor site of an intron. There are significant differences in sequence and secondary structure between metazoan and yeast U1 snRNAs, the latter being much longer (568 nucleotides as compared to 164 nucleotides in human). Nevertheless, secondary structure predictions suggest that all U1 snRNAs share a 'common core' consisting of helices I, II, the proximal region of III, and IV. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00003]"
        },
        "SO:0000392": {
            "name": "U2_snRNA",
            "def": "U2 is a small nuclear RNA (snRNA) component of the spliceosome (involved in pre-mRNA splicing). Complementary binding between U2 snRNA (in an area lying towards the 5' end but 3' to hairpin I) and the branchpoint sequence (BPS) of the intron results in the bulging out of an unpaired adenine, on the BPS, which initiates a nucleophilic attack at the intronic 5' splice site, thus starting the first of two transesterification reactions that mediate splicing. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00004]"
        },
        "SO:0000393": {
            "name": "U4_snRNA",
            "def": "U4 small nuclear RNA (U4 snRNA) is a component of the major U2-dependent spliceosome. It forms a duplex with U6, and with each splicing round, it is displaced from U6 (and the spliceosome) in an ATP-dependent manner, allowing U6 to refold and create the active site for splicing catalysis. A recycling process involving protein Prp24 re-anneals U4 and U6. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
        },
        "SO:0000394": {
            "name": "U4atac_snRNA",
            "def": "An snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U6atac_snRNA (SO:0000397). [PMID:=12409455]"
        },
        "SO:0000395": {
            "name": "U5_snRNA",
            "def": "U5 RNA is a component of both types of known spliceosome. The precise function of this molecule is unknown, though it is known that the 5' loop is required for splice site selection and p220 binding, and that both the 3' stem-loop and the Sm site are important for Sm protein binding and cap methylation. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00020]"
        },
        "SO:0000396": {
            "name": "U6_snRNA",
            "def": "U6 snRNA is a component of the spliceosome which is involved in splicing pre-mRNA. The putative secondary structure consensus base pairing is confined to a short 5' stem loop, but U6 snRNA is thought to form extensive base-pair interactions with U4 snRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00015]"
        },
        "SO:0000397": {
            "name": "U6atac_snRNA",
            "def": "U6atac_snRNA is an snRNA required for the splicing of the minor U12-dependent class of eukaryotic nuclear introns. It forms a base paired complex with U4atac_snRNA (SO:0000394). [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=retrieve&db=pubmed&list_uids=12409455&dopt=Abstract]"
        },
        "SO:0000398": {
            "name": "U11_snRNA",
            "def": "U11 snRNA plays a role in splicing of the minor U12-dependent class of eukaryotic nuclear introns, similar to U1 snRNA in the major class spliceosome it base pairs to the conserved 5' splice site sequence. [PMID:9622129]"
        },
        "SO:0000399": {
            "name": "U12_snRNA",
            "def": "The U12 small nuclear (snRNA), together with U4atac/U6atac, U5, and U11 snRNAs and associated proteins, forms a spliceosome that cleaves a divergent class of low-abundance pre-mRNA introns. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00007]"
        },
        "SO:0000400": {
            "name": "sequence_attribute",
            "def": "An attribute describes a quality of sequence. [SO:ke]"
        },
        "SO:0000401": {
            "name": "gene_attribute"
        },
        "SO:0000402": {
            "name": "enhancer_attribute"
        },
        "SO:0000403": {
            "name": "U14_snoRNA",
            "def": "U14 small nucleolar RNA (U14 snoRNA) is required for early cleavages of eukaryotic precursor rRNAs. In yeasts, this molecule possess a stem-loop region (known as the Y-domain) which is essential for function. A similar structure, but with a different consensus sequence, is found in plants, but is absent in vertebrates. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00016, PMID:2551119]"
        },
        "SO:0000404": {
            "name": "vault_RNA",
            "def": "A family of RNAs are found as part of the enigmatic vault ribonucleoprotein complex. The complex consists of a major vault protein (MVP), two minor vault proteins (VPARP and TEP1), and several small untranslated RNA molecules. It has been suggested that the vault complex is involved in drug resistance. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00006]"
        },
        "SO:0000405": {
            "name": "Y_RNA",
            "def": "Y RNAs are components of the Ro ribonucleoprotein particle (Ro RNP), in association with Ro60 and La proteins. The Y RNAs and Ro60 and La proteins are well conserved, but the function of the Ro RNP is not known. In humans the RNA component can be one of four small RNAs: hY1, hY3, hY4 and hY5. These small RNAs are predicted to fold into a conserved secondary structure containing three stem structures. The largest of the four, hY1, contains an additional hairpin. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00019]"
        },
        "SO:0000406": {
            "name": "twintron",
            "def": "An intron within an intron. Twintrons are group II or III introns, into which another group II or III intron has been transposed. [PMID:1899376, PMID:7823908]"
        },
        "SO:0000407": {
            "name": "rRNA_18S",
            "def": "A large polynucleotide in eukaryotes, which functions as the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0000408": {
            "name": "site",
            "def": "The interbase position where something (eg an aberration) occurred. [SO:ke]"
        },
        "SO:0000409": {
            "name": "binding_site",
            "def": "A biological_region of sequence that, in the molecule, interacts selectively and non-covalently with other molecules. A region on the surface of a molecule that may interact with another molecule. When applied to polypeptides: Amino acids involved in binding or interactions. It can also apply to an amino acid bond which is represented by the positions of the two flanking amino acids. [EBIBS:GAR, SO:ke]"
        },
        "SO:0000410": {
            "name": "protein_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with polypeptide molecules. [SO:ke]"
        },
        "SO:0000411": {
            "name": "rescue_region",
            "def": "A region that rescues. [SO:xp]"
        },
        "SO:0000412": {
            "name": "restriction_fragment",
            "def": "A region of polynucleotide sequence produced by digestion with a restriction endonuclease. [SO:ke]"
        },
        "SO:0000413": {
            "name": "sequence_difference",
            "def": "A region where the sequence differs from that of a specified sequence. [SO:ke]"
        },
        "SO:0000414": {
            "name": "invalidated_by_genomic_contamination",
            "def": "An attribute to describe a feature that is invalidated due to genomic contamination. [SO:ke]"
        },
        "SO:0000415": {
            "name": "invalidated_by_genomic_polyA_primed_cDNA",
            "def": "An attribute to describe a feature that is invalidated due to polyA priming. [SO:ke]"
        },
        "SO:0000416": {
            "name": "invalidated_by_partial_processing",
            "def": "An attribute to describe a feature that is invalidated due to partial processing. [SO:ke]"
        },
        "SO:0000417": {
            "name": "polypeptide_domain",
            "def": "A structurally or functionally defined protein region. In proteins with multiple domains, the combination of the domains determines the function of the protein. A region which has been shown to recur throughout evolution. [EBIBS:GAR]"
        },
        "SO:0000418": {
            "name": "signal_peptide",
            "def": "The signal_peptide is a short region of the peptide located at the N-terminus that directs the protein to be secreted or part of membrane components. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000419": {
            "name": "mature_protein_region",
            "def": "The polypeptide sequence that remains when the cleaved peptide regions have been cleaved from the immature peptide. [EBIBS:GAR, http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html, SO:cb]"
        },
        "SO:0000420": {
            "name": "five_prime_terminal_inverted_repeat"
        },
        "SO:0000421": {
            "name": "three_prime_terminal_inverted_repeat"
        },
        "SO:0000422": {
            "name": "U5_LTR_region"
        },
        "SO:0000423": {
            "name": "R_LTR_region"
        },
        "SO:0000424": {
            "name": "U3_LTR_region"
        },
        "SO:0000425": {
            "name": "five_prime_LTR"
        },
        "SO:0000426": {
            "name": "three_prime_LTR"
        },
        "SO:0000427": {
            "name": "R_five_prime_LTR_region"
        },
        "SO:0000428": {
            "name": "U5_five_prime_LTR_region"
        },
        "SO:0000429": {
            "name": "U3_five_prime_LTR_region"
        },
        "SO:0000430": {
            "name": "R_three_prime_LTR_region"
        },
        "SO:0000431": {
            "name": "U3_three_prime_LTR_region"
        },
        "SO:0000432": {
            "name": "U5_three_prime_LTR_region"
        },
        "SO:0000433": {
            "name": "non_LTR_retrotransposon_polymeric_tract",
            "def": "A polymeric tract, such as poly(dA), within a non_LTR_retrotransposon. [SO:ke]"
        },
        "SO:0000434": {
            "name": "target_site_duplication",
            "def": "A sequence of the target DNA that is duplicated when a transposable element or phage inserts; usually found at each end the insertion. [http://www.koko.gov.my/CocoaBioTech/Glossaryt.html]"
        },
        "SO:0000435": {
            "name": "RR_tract",
            "def": "A polypurine tract within an LTR_retrotransposon. [SO:ke]"
        },
        "SO:0000436": {
            "name": "ARS",
            "def": "A sequence that can autonomously replicate, as a plasmid, when transformed into a bacterial host. [SO:ma]"
        },
        "SO:0000437": {
            "name": "assortment_derived_duplication"
        },
        "SO:0000438": {
            "name": "gene_not_polyadenylated"
        },
        "SO:0000439": {
            "name": "inverted_ring_chromosome"
        },
        "SO:0000440": {
            "name": "vector_replicon",
            "def": "A replicon that has been modified to act as a vector for foreign sequence. [SO:ma]"
        },
        "SO:0000441": {
            "name": "ss_oligo",
            "def": "A single stranded oligonucleotide. [SO:ke]"
        },
        "SO:0000442": {
            "name": "ds_oligo",
            "def": "A double stranded oligonucleotide. [SO:ke]"
        },
        "SO:0000443": {
            "name": "polymer_attribute",
            "def": "An attribute to describe the kind of biological sequence. [SO:ke]"
        },
        "SO:0000444": {
            "name": "three_prime_noncoding_exon",
            "def": "Non-coding exon in the 3' UTR. [SO:ke]"
        },
        "SO:0000445": {
            "name": "five_prime_noncoding_exon",
            "def": "Non-coding exon in the 5' UTR. [SO:ke]"
        },
        "SO:0000446": {
            "name": "UTR_intron",
            "def": "Intron located in the untranslated region. [SO:ke]"
        },
        "SO:0000447": {
            "name": "five_prime_UTR_intron",
            "def": "An intron located in the 5' UTR. [SO:ke]"
        },
        "SO:0000448": {
            "name": "three_prime_UTR_intron",
            "def": "An intron located in the 3' UTR. [SO:ke]"
        },
        "SO:0000449": {
            "name": "random_sequence",
            "def": "A sequence of nucleotides or amino acids which, by design, has a \\random\\ order of components, given a predetermined input frequency of these components. [SO:ma]"
        },
        "SO:0000450": {
            "name": "interband",
            "def": "A light region between two darkly staining bands in a polytene chromosome. [SO:ma]"
        },
        "SO:0000451": {
            "name": "gene_with_polyadenylated_mRNA",
            "def": "A gene that encodes a polyadenylated mRNA. [SO:xp]"
        },
        "SO:0000452": {
            "name": "transgene_attribute"
        },
        "SO:0000453": {
            "name": "chromosomal_transposition",
            "def": "A chromosome structure variant whereby a region of a chromosome has been transferred to another position. Among interchromosomal rearrangements, the term transposition is reserved for that class in which the telomeres of the chromosomes involved are coupled (that is to say, form the two ends of a single DNA molecule) as in wild-type. [FB:reference_manual, SO:ke]"
        },
        "SO:0000454": {
            "name": "rasiRNA",
            "def": "A 17-28-nt, small interfering RNA derived from transcripts of repetitive elements. [http://www.developmentalcell.com/content/article/abstract?uid=PIIS1534580703002284]"
        },
        "SO:0000455": {
            "name": "gene_with_mRNA_with_frameshift",
            "def": "A gene that encodes an mRNA with a frameshift. [SO:xp]"
        },
        "SO:0000456": {
            "name": "recombinationally_rearranged_gene",
            "def": "A gene that is recombinationally rearranged. [SO:ke]"
        },
        "SO:0000457": {
            "name": "interchromosomal_duplication",
            "def": "A chromosome duplication involving an insertion from another chromosome. [SO:ke]"
        },
        "SO:0000458": {
            "name": "D_gene_segment",
            "def": "Germline genomic DNA including D-region with 5' UTR and 3' UTR, also designated as D-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000459": {
            "name": "gene_with_trans_spliced_transcript",
            "def": "A gene with a transcript that is trans-spliced. [SO:xp]"
        },
        "SO:0000460": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_segment"
        },
        "SO:0000461": {
            "name": "inversion_derived_bipartite_deficiency",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at each end of the inversion. [FB:km]"
        },
        "SO:0000462": {
            "name": "pseudogenic_region",
            "def": "A non-functional descendant of a functional entity. [SO:cjm]"
        },
        "SO:0000463": {
            "name": "encodes_alternately_spliced_transcripts",
            "def": "A gene that encodes more than one transcript. [SO:ke]"
        },
        "SO:0000464": {
            "name": "decayed_exon",
            "def": "A non-functional descendant of an exon. [SO:ke]"
        },
        "SO:0000465": {
            "name": "inversion_derived_deficiency_plus_duplication",
            "def": "A chromosome deletion whereby a chromosome is generated by recombination between two inversions; there is a deficiency at one end of the inversion and a duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000466": {
            "name": "V_gene_segment",
            "def": "Germline genomic DNA including L-part1, V-intron and V-exon, with the 5' UTR and 3' UTR. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000467": {
            "name": "post_translationally_regulated_by_protein_stability",
            "def": "An attribute describing a gene sequence where the resulting protein is regulated by the stability of the resulting protein. [SO:ke]"
        },
        "SO:0000468": {
            "name": "golden_path_fragment",
            "def": "One of the pieces of sequence that make up a golden path. [SO:rd]"
        },
        "SO:0000469": {
            "name": "post_translationally_regulated_by_protein_modification",
            "def": "An attribute describing a gene sequence where the resulting protein is modified to regulate it. [SO:ke]"
        },
        "SO:0000470": {
            "name": "J_gene_segment",
            "def": "Germline genomic DNA of an immunoglobulin/T-cell receptor gene including J-region with 5' UTR (SO:0000204) and 3' UTR (SO:0000205), also designated as J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000471": {
            "name": "autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation. [SO:ke]"
        },
        "SO:0000472": {
            "name": "tiling_path",
            "def": "A set of regions which overlap with minimal polymorphism to form a linear sequence. [SO:cjm]"
        },
        "SO:0000473": {
            "name": "negatively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation where it decreases transcription. [SO:ke]"
        },
        "SO:0000474": {
            "name": "tiling_path_fragment",
            "def": "A piece of sequence that makes up a tiling_path (SO:0000472). [SO:ke]"
        },
        "SO:0000475": {
            "name": "positively_autoregulated",
            "def": "The gene product is involved in its own transcriptional regulation, where it increases transcription. [SO:ke]"
        },
        "SO:0000476": {
            "name": "contig_read",
            "def": "A DNA sequencer read which is part of a contig. [SO:ke]"
        },
        "SO:0000477": {
            "name": "polycistronic_gene",
            "def": "A gene that is polycistronic. [SO:ke]"
        },
        "SO:0000478": {
            "name": "C_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including C-region (and introns if present) with 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000479": {
            "name": "trans_spliced_transcript",
            "def": "A transcript that is trans-spliced. [SO:xp]"
        },
        "SO:0000480": {
            "name": "tiling_path_clone",
            "def": "A clone which is part of a tiling path. A tiling path is a set of sequencing substrates, typically clones, which have been selected in order to efficiently cover a region of the genome in preparation for sequencing and assembly. [SO:ke]"
        },
        "SO:0000481": {
            "name": "terminal_inverted_repeat",
            "def": "An inverted repeat (SO:0000294) occurring at the termini of a DNA transposon. [SO:ke]"
        },
        "SO:0000482": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_gene_cluster"
        },
        "SO:0000483": {
            "name": "nc_primary_transcript",
            "def": "A primary transcript that is never translated into a protein. [SO:ke]"
        },
        "SO:0000484": {
            "name": "three_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 3' exon that is not coding. [SO:ke]"
        },
        "SO:0000485": {
            "name": "DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000486": {
            "name": "five_prime_coding_exon_noncoding_region",
            "def": "The sequence of the 5' exon preceding the start codon. [SO:ke]"
        },
        "SO:0000487": {
            "name": "VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000488": {
            "name": "VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000489": {
            "name": "VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000490": {
            "name": "VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000491": {
            "name": "VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000492": {
            "name": "D_gene_recombination_feature"
        },
        "SO:0000493": {
            "name": "three_prime_D_heptamer",
            "def": "7 nucleotide recombination site like CACAGTG, part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000494": {
            "name": "three_prime_D_nonamer",
            "def": "A 9 nucleotide recombination site (e.g. ACAAAAACC), part of a 3' D-recombination signal sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000495": {
            "name": "three_prime_D_spacer",
            "def": "A 12 or 23 nucleotide spacer between the 3'D-HEPTAMER and 3'D-NONAMER of a 3'D-RS. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000496": {
            "name": "five_prime_D_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACTGTG), part of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000497": {
            "name": "five_prime_D_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a five_prime_D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000498": {
            "name": "five_prime_D_spacer",
            "def": "12 or 23 nucleotide spacer between the 5' D-heptamer (SO:0000496) and 5' D-nonamer (SO:0000497) of a 5' D-recombination signal sequence (SO:0000556) of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000499": {
            "name": "virtual_sequence",
            "def": "A continuous piece of sequence similar to the 'virtual contig' concept of the Ensembl database. [SO:ke]"
        },
        "SO:0000500": {
            "name": "Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. This is less energetically favourable than watson crick base pairing. Hoogsteen GC base pairs only have two hydrogen bonds. [PMID:12177293]"
        },
        "SO:0000501": {
            "name": "reverse_Hoogsteen_base_pair",
            "def": "A type of non-canonical base-pairing. [SO:ke]"
        },
        "SO:0000502": {
            "name": "transcribed_region",
            "def": "A region of sequence that is transcribed. This region may cover the transcript of a gene, it may emcompas the sequence covered by all of the transcripts of a alternately spliced gene, or it may cover the region transcribed by a polycistronic transcript. A gene may have 1 or more transcribed regions and a transcribed_region may belong to one or more genes. [SO:ke]"
        },
        "SO:0000503": {
            "name": "alternately_spliced_gene_encodeing_one_transcript"
        },
        "SO:0000504": {
            "name": "D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000505": {
            "name": "D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000506": {
            "name": "D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000507": {
            "name": "pseudogenic_exon",
            "def": "A non functional descendant of an exon, part of a pseudogene. [SO:ke]"
        },
        "SO:0000508": {
            "name": "D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one D-gene, one DJ-gene, and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000509": {
            "name": "D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000510": {
            "name": "VD_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including L-part1, V-intron and V-D-exon, with the 5' UTR (SO:0000204) and 3' UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000511": {
            "name": "J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000512": {
            "name": "inversion_derived_deficiency_plus_aneuploid",
            "def": "A chromosomal deletion whereby a chromosome generated by recombination between two inversions; has a deficiency at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000513": {
            "name": "J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000514": {
            "name": "J_nonamer",
            "def": "9 nucleotide recombination site (e.g. GGTTTTTGT), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000515": {
            "name": "J_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000516": {
            "name": "pseudogenic_transcript",
            "def": "A non functional descendant of a transcript, part of a pseudogene. [SO:ke]"
        },
        "SO:0000517": {
            "name": "J_spacer",
            "def": "12 or 23 nucleotide spacer between the J-nonamer and the J-heptamer of a J-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000518": {
            "name": "V_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000519": {
            "name": "V_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000520": {
            "name": "V_VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000521": {
            "name": "V_VDJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VDJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000522": {
            "name": "V_VDJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000523": {
            "name": "V_VJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000524": {
            "name": "V_VJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene and one VJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000525": {
            "name": "V_VJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000526": {
            "name": "V_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one V-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000527": {
            "name": "V_D_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000528": {
            "name": "V_D_DJ_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000529": {
            "name": "V_D_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000530": {
            "name": "V_D_DJ_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one D-gene, one DJ-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000531": {
            "name": "V_D_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000532": {
            "name": "V_D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000533": {
            "name": "V_heptamer",
            "def": "7 nucleotide recombination site (e.g. CACAGTG), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000534": {
            "name": "V_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000535": {
            "name": "V_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one V-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000536": {
            "name": "V_nonamer",
            "def": "9 nucleotide recombination site (e.g. ACAAAAACC), part of V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000537": {
            "name": "V_spacer",
            "def": "12 or 23 nucleotide spacer between the V-heptamer and the V-nonamer of a V-gene recombination feature of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000538": {
            "name": "V_gene_recombination_feature",
            "def": "Recombination signal including V-heptamer, V-spacer and V-nonamer in 3' of V-region of a V-gene or V-sequence of an immunoglobulin/T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000539": {
            "name": "DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000540": {
            "name": "DJ_J_C_cluster",
            "def": "Genomic DNA in rearranged configuration including at least one D-J-GENE, one J-GENE and one C-GENE. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000541": {
            "name": "VDJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one VDJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000542": {
            "name": "V_DJ_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000543": {
            "name": "alternately_spliced_gene_encoding_greater_than_one_transcript"
        },
        "SO:0000544": {
            "name": "helitron",
            "def": "A rolling circle transposon. Autonomous helitrons encode a 5'-to-3' DNA helicase and nuclease/ligase similar to those encoded by known rolling-circle replicons. [http://www.pnas.org/cgi/content/full/100/11/6569]"
        },
        "SO:0000545": {
            "name": "recoding_pseudoknot",
            "def": "The pseudoknots involved in recoding are unique in that, as they play their role as a structure, they are immediately unfolded and their now linear sequence serves as a template for decoding. [http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=33937]"
        },
        "SO:0000546": {
            "name": "designed_sequence"
        },
        "SO:0000547": {
            "name": "inversion_derived_bipartite_duplication",
            "def": "A chromosome generated by recombination between two inversions; there is a duplication at each end of the inversion. [FB:km]"
        },
        "SO:0000548": {
            "name": "gene_with_edited_transcript",
            "def": "A gene that encodes a transcript that is edited. [SO:xp]"
        },
        "SO:0000549": {
            "name": "inversion_derived_duplication_plus_aneuploid",
            "def": "A chromosome generated by recombination between two inversions; has a duplication at one end and presumed to have a deficiency or duplication at the other end of the inversion. [FB:km]"
        },
        "SO:0000550": {
            "name": "aneuploid_chromosome",
            "def": "A chromosome structural variation whereby either a chromosome exists in addition to the normal chromosome complement or is lacking. [SO:ke]"
        },
        "SO:0000551": {
            "name": "polyA_signal_sequence",
            "def": "The recognition sequence necessary for endonuclease cleavage of an RNA transcript that is followed by polyadenylation; consensus=AATAAA. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000552": {
            "name": "Shine_Dalgarno_sequence",
            "def": "A region in the 5' UTR that pairs with the 16S rRNA during formation of the preinitiation complex. [SO:jh]"
        },
        "SO:0000553": {
            "name": "polyA_site",
            "def": "The site on an RNA transcript to which will be added adenine residues by post-transcriptional polyadenylation. The boundary between the UTR and the polyA sequence. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000554": {
            "name": "assortment_derived_deficiency_plus_duplication"
        },
        "SO:0000555": {
            "name": "five_prime_clip",
            "def": "5' most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000556": {
            "name": "five_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 5' D-nonamer (SO:0000497), 5' D-spacer (SO:0000498), and 5' D-heptamer (SO:0000396) in 5' of the D-region of a D-gene, or in 5' of the D-region of DJ-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000557": {
            "name": "three_prime_clip",
            "def": "3'-most region of a precursor transcript that is clipped off during processing. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000558": {
            "name": "C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene including more than one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000559": {
            "name": "D_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including more than one D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000560": {
            "name": "D_J_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in germline configuration including at least one D-gene and one J-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000561": {
            "name": "heptamer_of_recombination_feature_of_vertebrate_immune_system_gene",
            "def": "Seven nucleotide recombination site (e.g. CACAGTG), part of V-gene, D-gene or J-gene recombination feature of an immunoglobulin or T-cell receptor gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000562": {
            "name": "nonamer_of_recombination_feature_of_vertebrate_immune_system_gene"
        },
        "SO:0000563": {
            "name": "vertebrate_immune_system_gene_recombination_spacer"
        },
        "SO:0000564": {
            "name": "V_DJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one DJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000565": {
            "name": "V_VDJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VDJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000566": {
            "name": "V_VJ_J_C_cluster",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in rearranged configuration including at least one V-gene, one VJ-gene, one J-gene and one C-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000567": {
            "name": "inversion_derived_aneuploid_chromosome",
            "def": "A chromosome may be generated by recombination between two inversions; presumed to have a deficiency or duplication at each end of the inversion. [FB:km]"
        },
        "SO:0000568": {
            "name": "bidirectional_promoter",
            "def": "An unregulated promoter that allows continuous expression. [SO:ke]"
        },
        "SO:0000569": {
            "name": "retrotransposed",
            "def": "An attribute of a feature that occurred as the product of a reverse transcriptase mediated event. [SO:ke]"
        },
        "SO:0000570": {
            "name": "three_prime_D_recombination_signal_sequence",
            "def": "Recombination signal of an immunoglobulin/T-cell receptor gene, including the 3' D-heptamer (SO:0000493), 3' D-spacer, and 3' D-nonamer (SO:0000494) in 3' of the D-region of a D-gene. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000571": {
            "name": "miRNA_encoding"
        },
        "SO:0000572": {
            "name": "DJ_gene_segment",
            "def": "Genomic DNA of immunoglobulin/T-cell receptor gene in partially rearranged genomic DNA including D-J-region with 5' UTR and 3' UTR, also designated as D-J-segment. [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000573": {
            "name": "rRNA_encoding"
        },
        "SO:0000574": {
            "name": "VDJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-D-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000575": {
            "name": "scRNA_encoding"
        },
        "SO:0000576": {
            "name": "VJ_gene_segment",
            "def": "Rearranged genomic DNA of immunoglobulin/T-cell receptor gene including L-part1, V-intron and V-J-exon, with the 5'UTR (SO:0000204) and 3'UTR (SO:0000205). [http://www.imgt.org/cgi-bin/IMGTlect.jv?query=7#]"
        },
        "SO:0000577": {
            "name": "centromere",
            "def": "A region of chromosome where the spindle fibers attach during mitosis and meiosis. [SO:ke]"
        },
        "SO:0000578": {
            "name": "snoRNA_encoding"
        },
        "SO:0000579": {
            "name": "edited_transcript_feature",
            "def": "A locatable feature on a transcript that is edited. [SO:ma]"
        },
        "SO:0000580": {
            "name": "methylation_guide_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a methylation guide small nucleolar RNA. [SO:ke]"
        },
        "SO:0000581": {
            "name": "cap",
            "def": "A structure consisting of a 7-methylguanosine in 5'-5' triphosphate linkage with the first nucleotide of an mRNA. It is added post-transcriptionally, and is not encoded in the DNA. [http://seqcore.brcf.med.umich.edu/doc/educ/dnapr/mbglossary/mbgloss.html]"
        },
        "SO:0000582": {
            "name": "rRNA_cleavage_snoRNA_primary_transcript",
            "def": "A primary transcript encoding an rRNA cleavage snoRNA. [SO:ke]"
        },
        "SO:0000583": {
            "name": "pre_edited_region",
            "def": "The region of a transcript that will be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000584": {
            "name": "tmRNA",
            "def": "A tmRNA liberates a mRNA from a stalled ribosome. To accomplish this part of the tmRNA is used as a reading frame that ends in a translation stop signal. The broken mRNA is replaced in the ribosome by the tmRNA and translation of the tmRNA leads to addition of a proteolysis tag to the incomplete protein enabling recognition by a protease. Recently a number of permuted tmRNAs genes have been found encoded in two parts. TmRNAs have been identified in eubacteria and some chloroplasts but are absent from archeal and Eukaryote nuclear genomes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00023]"
        },
        "SO:0000585": {
            "name": "C_D_box_snoRNA_encoding"
        },
        "SO:0000586": {
            "name": "tmRNA_primary_transcript",
            "def": "A primary transcript encoding a tmRNA (SO:0000584). [SO:ke]"
        },
        "SO:0000587": {
            "name": "group_I_intron",
            "def": "Group I catalytic introns are large self-splicing ribozymes. They catalyze their own excision from mRNA, tRNA and rRNA precursors in a wide range of organisms. The core secondary structure consists of 9 paired regions (P1-P9). These fold to essentially two domains, the P4-P6 domain (formed from the stacking of P5, P4, P6 and P6a helices) and the P3-P9 domain (formed from the P8, P3, P7 and P9 helices). Group I catalytic introns often have long ORFs inserted in loop regions. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00028]"
        },
        "SO:0000588": {
            "name": "autocatalytically_spliced_intron",
            "def": "A self spliced intron. [SO:ke]"
        },
        "SO:0000589": {
            "name": "SRP_RNA_primary_transcript",
            "def": "A primary transcript encoding a signal recognition particle RNA. [SO:ke]"
        },
        "SO:0000590": {
            "name": "SRP_RNA",
            "def": "The signal recognition particle (SRP) is a universally conserved ribonucleoprotein. It is involved in the co-translational targeting of proteins to membranes. The eukaryotic SRP consists of a 300-nucleotide 7S RNA and six proteins: SRPs 72, 68, 54, 19, 14, and 9. Archaeal SRP consists of a 7S RNA and homologues of the eukaryotic SRP19 and SRP54 proteins. In most eubacteria, the SRP consists of a 4.5S RNA and the Ffh protein (a homologue of the eukaryotic SRP54 protein). Eukaryotic and archaeal 7S RNAs have very similar secondary structures, with eight helical elements. These fold into the Alu and S domains, separated by a long linker region. Eubacterial SRP is generally a simpler structure, with the M domain of Ffh bound to a region of the 4.5S RNA that corresponds to helix 8 of the eukaryotic and archaeal SRP S domain. Some Gram-positive bacteria (e.g. Bacillus subtilis), however, have a larger SRP RNA that also has an Alu domain. The Alu domain is thought to mediate the peptide chain elongation retardation function of the SRP. The universally conserved helix which interacts with the SRP54/Ffh M domain mediates signal sequence recognition. In eukaryotes and archaea, the SRP19-helix 6 complex is thought to be involved in SRP assembly and stabilizes helix 8 for SRP54 binding. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00017]"
        },
        "SO:0000591": {
            "name": "pseudoknot",
            "def": "A tertiary structure in RNA where nucleotides in a loop form base pairs with a region of RNA downstream of the loop. [RSC:cb]"
        },
        "SO:0000592": {
            "name": "H_pseudoknot",
            "def": "A pseudoknot which contains two stems and at least two loops. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=10334330&dopt=Abstract]"
        },
        "SO:0000593": {
            "name": "C_D_box_snoRNA",
            "def": "Most box C/D snoRNAs also contain long (>10 nt) sequences complementary to rRNA. Boxes C and D, as well as boxes C' and D', are usually located in close proximity, and form a structure known as the box C/D motif. This motif is important for snoRNA stability, processing, nucleolar targeting and function. A small number of box C/D snoRNAs are involved in rRNA processing; most, however, are known or predicted to serve as guide RNAs in ribose methylation of rRNA. Targeting involves direct base pairing of the snoRNA at the rRNA site to be modified and selection of a rRNA nucleotide a fixed distance from box D or D'. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
        },
        "SO:0000594": {
            "name": "H_ACA_box_snoRNA",
            "def": "Members of the box H/ACA family contain an ACA triplet, exactly 3 nt upstream from the 3' end and an H-box in a hinge region that links two structurally similar functional domains of the molecule. Both boxes are important for snoRNA biosynthesis and function. A few box H/ACA snoRNAs are involved in rRNA processing; most others are known or predicted to participate in selection of uridine nucleosides in rRNA to be converted to pseudouridines. Site selection is mediated by direct base pairing of the snoRNA with rRNA through one or both targeting domains. [http://www.bio.umass.edu/biochem/rna-sequence/Yeast_snoRNA_Database/snoRNA_DataBase.html]"
        },
        "SO:0000595": {
            "name": "C_D_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box C/D family. [SO:ke]"
        },
        "SO:0000596": {
            "name": "H_ACA_box_snoRNA_primary_transcript",
            "def": "A primary transcript encoding a small nucleolar RNA of the box H/ACA family. [SO:ke]"
        },
        "SO:0000597": {
            "name": "transcript_edited_by_U_insertion/deletion",
            "def": "The insertion and deletion of uridine (U) residues, usually within coding regions of mRNA transcripts of cryptogenes in the mitochondrial genome of kinetoplastid protozoa. [http://www.rna.ucla.edu/index.html]"
        },
        "SO:0000598": {
            "name": "edited_by_C_insertion_and_dinucleotide_insertion"
        },
        "SO:0000599": {
            "name": "edited_by_C_to_U_substitution"
        },
        "SO:0000600": {
            "name": "edited_by_A_to_I_substitution"
        },
        "SO:0000601": {
            "name": "edited_by_G_addition"
        },
        "SO:0000602": {
            "name": "guide_RNA",
            "def": "A short 3'-uridylated RNA that can form a duplex (except for its post-transcriptionally added oligo_U tail (SO:0000609)) with a stretch of mature edited mRNA. [http://www.rna.ucla.edu/index.html]"
        },
        "SO:0000603": {
            "name": "group_II_intron",
            "def": "Group II introns are found in rRNA, tRNA and mRNA of organelles in fungi, plants and protists, and also in mRNA in bacteria. They are large self-splicing ribozymes and have 6 structural domains (usually designated dI to dVI). A subset of group II introns also encode essential splicing proteins in intronic ORFs. The length of these introns can therefore be up to 3kb. Splicing occurs in almost identical fashion to nuclear pre-mRNA splicing with two transesterification steps. The 2' hydroxyl of a bulged adenosine in domain VI attacks the 5' splice site, followed by nucleophilic attack on the 3' splice site by the 3' OH of the upstream exon. Protein machinery is required for splicing in vivo, and long range intron to intron and intron-exon interactions are important for splice site positioning. Group II introns are further sub-classified into groups IIA and IIB which differ in splice site consensus, distance of bulged A from 3' splice site, some tertiary interactions, and intronic ORF phylogeny. [http://www.sanger.ac.uk/Software/Rfam/browse/index.shtml]"
        },
        "SO:0000604": {
            "name": "editing_block",
            "def": "Edited mRNA sequence mediated by a single guide RNA (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000605": {
            "name": "intergenic_region",
            "def": "A region containing or overlapping no genes that is bounded on either side by a gene, or bounded by a gene and the end of the chromosome. [SO:cjm]"
        },
        "SO:0000606": {
            "name": "editing_domain",
            "def": "Edited mRNA sequence mediated by two or more overlapping guide RNAs (SO:0000602). [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000607": {
            "name": "unedited_region",
            "def": "The region of an edited transcript that will not be edited. [http://dna.kdna.ucla.edu/rna/index.aspx]"
        },
        "SO:0000608": {
            "name": "H_ACA_box_snoRNA_encoding"
        },
        "SO:0000609": {
            "name": "oligo_U_tail",
            "def": "The string of non-encoded U's at the 3' end of a guide RNA (SO:0000602). [http://www.rna.ucla.edu/]"
        },
        "SO:0000610": {
            "name": "polyA_sequence",
            "def": "Sequence of about 100 nucleotides of A added to the 3' end of most eukaryotic mRNAs. [SO:ke]"
        },
        "SO:0000611": {
            "name": "branch_site",
            "def": "A pyrimidine rich sequence near the 3' end of an intron to which the 5'end becomes covalently bound during nuclear splicing. The resulting structure resembles a lariat. [SO:ke]"
        },
        "SO:0000612": {
            "name": "polypyrimidine_tract",
            "def": "The polypyrimidine tract is one of the cis-acting sequence elements directing intron removal in pre-mRNA splicing. [http://nar.oupjournals.org/cgi/content/full/25/4/888]"
        },
        "SO:0000613": {
            "name": "bacterial_RNApol_promoter",
            "def": "A DNA sequence to which bacterial RNA polymerase binds, to begin transcription. [SO:ke]"
        },
        "SO:0000614": {
            "name": "bacterial_terminator",
            "def": "A terminator signal for bacterial transcription. [SO:ke]"
        },
        "SO:0000615": {
            "name": "terminator_of_type_2_RNApol_III_promoter",
            "def": "A terminator signal for RNA polymerase III transcription. [SO:ke]"
        },
        "SO:0000616": {
            "name": "transcription_end_site",
            "def": "The base where transcription ends. [SO:ke]"
        },
        "SO:0000617": {
            "name": "RNApol_III_promoter_type_1"
        },
        "SO:0000618": {
            "name": "RNApol_III_promoter_type_2"
        },
        "SO:0000619": {
            "name": "A_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence TGGCnnAGTGG. [SO:ke]"
        },
        "SO:0000620": {
            "name": "B_box",
            "def": "A variably distant linear promoter region recognized by TFIIIC, with consensus sequence AGGTTCCAnnCC. [SO:ke]"
        },
        "SO:0000621": {
            "name": "RNApol_III_promoter_type_3"
        },
        "SO:0000622": {
            "name": "C_box",
            "def": "An RNA polymerase III type 1 promoter with consensus sequence CAnnCCn. [SO:ke]"
        },
        "SO:0000623": {
            "name": "snRNA_encoding"
        },
        "SO:0000624": {
            "name": "telomere",
            "def": "A specific structure at the end of a linear chromosome, required for the integrity and maintenance of the end. [SO:ma]"
        },
        "SO:0000625": {
            "name": "silencer",
            "def": "A regulatory region which upon binding of transcription factors, suppress the transcription of the gene or genes they control. [SO:ke]"
        },
        "SO:0000626": {
            "name": "chromosomal_regulatory_element"
        },
        "SO:0000627": {
            "name": "insulator",
            "def": "A transcriptional cis regulatory region that when located between a CM and a gene's promoter prevents the CRM from modulating that genes expression. [SO:regcreative]"
        },
        "SO:0000628": {
            "name": "chromosomal_structural_element"
        },
        "SO:0000629": {
            "name": "five_prime_open_reading_frame"
        },
        "SO:0000630": {
            "name": "upstream_AUG_codon",
            "def": "A start codon upstream of the ORF. [SO:ke]"
        },
        "SO:0000631": {
            "name": "polycistronic_primary_transcript",
            "def": "A primary transcript encoding for more than one gene product. [SO:ke]"
        },
        "SO:0000632": {
            "name": "monocistronic_primary_transcript",
            "def": "A primary transcript encoding for one gene product. [SO:ke]"
        },
        "SO:0000633": {
            "name": "monocistronic_mRNA",
            "def": "An mRNA with either a single protein product, or for which the regions encoding all its protein products overlap. [SO:rd]"
        },
        "SO:0000634": {
            "name": "polycistronic_mRNA",
            "def": "An mRNA that encodes multiple proteins from at least two non-overlapping regions. [SO:rd]"
        },
        "SO:0000635": {
            "name": "mini_exon_donor_RNA",
            "def": "A primary transcript that donates the spliced leader to other mRNA. [SO:ke]"
        },
        "SO:0000636": {
            "name": "spliced_leader_RNA"
        },
        "SO:0000637": {
            "name": "engineered_plasmid",
            "def": "A plasmid that is engineered. [SO:xp]"
        },
        "SO:0000638": {
            "name": "transcribed_spacer_region",
            "def": "Part of an rRNA transcription unit that is transcribed but discarded during maturation, not giving rise to any part of rRNA. [http://oregonstate.edu/instruction/bb492/general/glossary.html]"
        },
        "SO:0000639": {
            "name": "internal_transcribed_spacer_region",
            "def": "Non-coding regions of DNA sequence that separate genes coding for the 28S, 5.8S, and 18S ribosomal RNAs. [SO:ke]"
        },
        "SO:0000640": {
            "name": "external_transcribed_spacer_region",
            "def": "Non-coding regions of DNA that precede the sequence that codes for the ribosomal RNA. [SO:ke]"
        },
        "SO:0000641": {
            "name": "tetranucleotide_repeat_microsatellite_feature"
        },
        "SO:0000642": {
            "name": "SRP_RNA_encoding"
        },
        "SO:0000643": {
            "name": "minisatellite",
            "def": "A repeat region containing tandemly repeated sequences having a unit length of 10 to 40 bp. [http://www.informatics.jax.org/silver/glossary.shtml]"
        },
        "SO:0000644": {
            "name": "antisense_RNA",
            "def": "Antisense RNA is RNA that is transcribed from the coding, rather than the template, strand of DNA. It is therefore complementary to mRNA. [SO:ke]"
        },
        "SO:0000645": {
            "name": "antisense_primary_transcript",
            "def": "The reverse complement of the primary transcript. [SO:ke]"
        },
        "SO:0000646": {
            "name": "siRNA",
            "def": "A small RNA molecule that is the product of a longer exogenous or endogenous dsRNA, which is either a bimolecular duplex or very long hairpin, processed (via the Dicer pathway) such that numerous siRNAs accumulate from both strands of the dsRNA. SRNAs trigger the cleavage of their target molecules. [PMID:12592000]"
        },
        "SO:0000647": {
            "name": "miRNA_primary_transcript",
            "def": "A primary transcript encoding a micro RNA. [SO:ke]"
        },
        "SO:0000650": {
            "name": "small_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0000651": {
            "name": "large_subunit_rRNA",
            "def": "Ribosomal RNA transcript that structures the large subunit of the ribosome. [SO:ke]"
        },
        "SO:0000652": {
            "name": "rRNA_5S",
            "def": "5S ribosomal RNA (5S rRNA) is a component of the large ribosomal subunit in both prokaryotes and eukaryotes. In eukaryotes, it is synthesised by RNA polymerase III (the other eukaryotic rRNAs are cleaved from a 45S precursor synthesised by RNA polymerase I). In Xenopus oocytes, it has been shown that fingers 4-7 of the nine-zinc finger transcription factor TFIIIA can bind to the central region of 5S RNA. Thus, in addition to positively regulating 5S rRNA transcription, TFIIIA also stabilizes 5S rRNA until it is required for transcription. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00001]"
        },
        "SO:0000653": {
            "name": "rRNA_28S",
            "def": "A component of the large ribosomal subunit. [SO:ke]"
        },
        "SO:0000654": {
            "name": "maxicircle_gene",
            "def": "A mitochondrial gene located in a maxicircle. [SO:xp]"
        },
        "SO:0000655": {
            "name": "ncRNA",
            "def": "An RNA transcript that does not encode for a protein rather the RNA molecule is the gene product. [SO:ke]"
        },
        "SO:0000656": {
            "name": "stRNA_encoding"
        },
        "SO:0000657": {
            "name": "repeat_region",
            "def": "A region of sequence containing one or more repeat units. [SO:ke]"
        },
        "SO:0000658": {
            "name": "dispersed_repeat",
            "def": "A repeat that is located at dispersed sites in the genome. [SO:ke]"
        },
        "SO:0000659": {
            "name": "tmRNA_encoding"
        },
        "SO:0000660": {
            "name": "DNA_invertase_target_sequence"
        },
        "SO:0000661": {
            "name": "intron_attribute"
        },
        "SO:0000662": {
            "name": "spliceosomal_intron",
            "def": "An intron which is spliced by the spliceosome. [SO:ke]"
        },
        "SO:0000663": {
            "name": "tRNA_encoding"
        },
        "SO:0000664": {
            "name": "introgressed_chromosome_region"
        },
        "SO:0000665": {
            "name": "monocistronic_transcript",
            "def": "A transcript that is monocistronic. [SO:xp]"
        },
        "SO:0000666": {
            "name": "mobile_intron",
            "def": "An intron (mitochondrial, chloroplast, nuclear or prokaryotic) that encodes a double strand sequence specific endonuclease allowing for mobility. [SO:ke]"
        },
        "SO:0000667": {
            "name": "insertion",
            "def": "The sequence of one or more nucleotides added between two adjacent nucleotides in the sequence. [SO:ke]"
        },
        "SO:0000668": {
            "name": "EST_match",
            "def": "A match against an EST sequence. [SO:ke]"
        },
        "SO:0000669": {
            "name": "sequence_rearrangement_feature"
        },
        "SO:0000670": {
            "name": "chromosome_breakage_sequence",
            "def": "A sequence within the micronuclear DNA of ciliates at which chromosome breakage and telomere addition occurs during nuclear differentiation. [SO:ma]"
        },
        "SO:0000671": {
            "name": "internal_eliminated_sequence",
            "def": "A sequence eliminated from the genome of ciliates during nuclear differentiation. [SO:ma]"
        },
        "SO:0000672": {
            "name": "macronucleus_destined_segment",
            "def": "A sequence that is conserved, although rearranged relative to the micronucleus, in the macronucleus of a ciliate genome. [SO:ma]"
        },
        "SO:0000673": {
            "name": "transcript",
            "def": "An RNA synthesized on a DNA or RNA template by an RNA polymerase. [SO:ma]"
        },
        "SO:0000674": {
            "name": "non_canonical_splice_site",
            "def": "A splice site where the donor and acceptor sites differ from the canonical form. [SO:ke]"
        },
        "SO:0000675": {
            "name": "canonical_splice_site",
            "def": "The major class of splice site with dinucleotides GT and AG for donor and acceptor sites, respectively. [SO:ke]"
        },
        "SO:0000676": {
            "name": "canonical_three_prime_splice_site",
            "def": "The canonical 3' splice site has the sequence \\AG\\. [SO:ke]"
        },
        "SO:0000677": {
            "name": "canonical_five_prime_splice_site",
            "def": "The canonical 5' splice site has the sequence \\GT\\. [SO:ke]"
        },
        "SO:0000678": {
            "name": "non_canonical_three_prime_splice_site",
            "def": "A 3' splice site that does not have the sequence \\AG\\. [SO:ke]"
        },
        "SO:0000679": {
            "name": "non_canonical_five_prime_splice_site",
            "def": "A 5' splice site which does not have the sequence \\GT\\. [SO:ke]"
        },
        "SO:0000680": {
            "name": "non_canonical_start_codon",
            "def": "A start codon that is not the usual AUG sequence. [SO:ke]"
        },
        "SO:0000681": {
            "name": "aberrant_processed_transcript",
            "def": "A transcript that has been processed \\incorrectly\\, for example by the failure of splicing of one or more exons. [SO:ke]"
        },
        "SO:0000682": {
            "name": "splicing_feature"
        },
        "SO:0000683": {
            "name": "exonic_splice_enhancer",
            "def": "Exonic splicing enhancers (ESEs) facilitate exon definition by assisting in the recruitment of splicing factors to the adjacent intron. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12403462&dopt=Abstract]"
        },
        "SO:0000684": {
            "name": "nuclease_sensitive_site",
            "def": "A region of nucleotide sequence targeted by a nuclease enzyme. [SO:ma]"
        },
        "SO:0000685": {
            "name": "DNAseI_hypersensitive_site"
        },
        "SO:0000686": {
            "name": "translocation_element",
            "def": "A chromosomal translocation whereby the chromosomes carrying non-homologous centromeres may be recovered independently. These chromosomes are described as translocation elements. This occurs for some translocations, particularly but not exclusively, reciprocal translocations. [SO:ma]"
        },
        "SO:0000687": {
            "name": "deletion_junction",
            "def": "The space between two bases in a sequence which marks the position where a deletion has occurred. [SO:ke]"
        },
        "SO:0000688": {
            "name": "golden_path",
            "def": "A set of subregions selected from sequence contigs which when concatenated form a nonredundant linear sequence. [SO:ls]"
        },
        "SO:0000689": {
            "name": "cDNA_match",
            "def": "A match against cDNA sequence. [SO:ke]"
        },
        "SO:0000690": {
            "name": "gene_with_polycistronic_transcript",
            "def": "A gene that encodes a polycistronic transcript. [SO:xp]"
        },
        "SO:0000691": {
            "name": "cleaved_initiator_methionine",
            "def": "The initiator methionine that has been cleaved from a mature polypeptide sequence. [EBIBS:GAR]"
        },
        "SO:0000692": {
            "name": "gene_with_dicistronic_transcript",
            "def": "A gene that encodes a dicistronic transcript. [SO:xp]"
        },
        "SO:0000693": {
            "name": "gene_with_recoded_mRNA",
            "def": "A gene that encodes an mRNA that is recoded. [SO:xp]"
        },
        "SO:0000694": {
            "name": "SNP",
            "def": "SNPs are single base pair positions in genomic DNA at which different sequence alternatives exist in normal individuals in some population(s), wherein the least frequent variant has an abundance of 1% or greater. [SO:cb]"
        },
        "SO:0000695": {
            "name": "reagent",
            "def": "A sequence used in experiment. [SO:ke]"
        },
        "SO:0000696": {
            "name": "oligo",
            "def": "A short oligonucleotide sequence, of length on the order of 10's of bases; either single or double stranded. [SO:ma]"
        },
        "SO:0000697": {
            "name": "gene_with_stop_codon_read_through",
            "def": "A gene that encodes a transcript with stop codon readthrough. [SO:xp]"
        },
        "SO:0000698": {
            "name": "gene_with_stop_codon_redefined_as_pyrrolysine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as pyrrolysine. [SO:xp]"
        },
        "SO:0000699": {
            "name": "junction",
            "def": "A sequence_feature with an extent of zero. [SO:ke]"
        },
        "SO:0000700": {
            "name": "remark",
            "def": "A comment about the sequence. [SO:ke]"
        },
        "SO:0000701": {
            "name": "possible_base_call_error",
            "def": "A region of sequence where the validity of the base calling is questionable. [SO:ke]"
        },
        "SO:0000702": {
            "name": "possible_assembly_error",
            "def": "A region of sequence where there may have been an error in the assembly. [SO:ke]"
        },
        "SO:0000703": {
            "name": "experimental_result_region",
            "def": "A region of sequence implicated in an experimental result. [SO:ke]"
        },
        "SO:0000704": {
            "name": "gene",
            "def": "A region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. [SO:immuno_workshop]"
        },
        "SO:0000705": {
            "name": "tandem_repeat",
            "def": "Two or more adjacent copies of a region (of length greater than 1). [SO:ke]"
        },
        "SO:0000706": {
            "name": "trans_splice_acceptor_site",
            "def": "The 3' splice site of the acceptor primary transcript. [SO:ke]"
        },
        "SO:0000707": {
            "name": "trans_splice_donor_site",
            "def": "The 5' five prime splice site region of the donor RNA. [SO:ke]"
        },
        "SO:0000708": {
            "name": "SL1_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL1 RNA leader sequence to the 5' end of most mRNAs. [SO:nlw]"
        },
        "SO:0000709": {
            "name": "SL2_acceptor_site",
            "def": "A trans_splicing_acceptor_site which appends the 22nt SL2 RNA leader sequence to the 5' end of mRNAs. SL2 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0000710": {
            "name": "gene_with_stop_codon_redefined_as_selenocysteine",
            "def": "A gene encoding an mRNA that has the stop codon redefined as selenocysteine. [SO:xp]"
        },
        "SO:0000711": {
            "name": "gene_with_mRNA_recoded_by_translational_bypass",
            "def": "A gene with mRNA recoded by translational bypass. [SO:xp]"
        },
        "SO:0000712": {
            "name": "gene_with_transcript_with_translational_frameshift",
            "def": "A gene encoding a transcript that has a translational frameshift. [SO:xp]"
        },
        "SO:0000713": {
            "name": "DNA_motif",
            "def": "A motif that is active in the DNA form of the sequence. [SO:ke]"
        },
        "SO:0000714": {
            "name": "nucleotide_motif",
            "def": "A region of nucleotide sequence corresponding to a known motif. [SO:ke]"
        },
        "SO:0000715": {
            "name": "RNA_motif",
            "def": "A motif that is active in RNA sequence. [SO:ke]"
        },
        "SO:0000716": {
            "name": "dicistronic_mRNA",
            "def": "An mRNA that has the quality dicistronic. [SO:ke]"
        },
        "SO:0000717": {
            "name": "reading_frame",
            "def": "A nucleic acid sequence that when read as sequential triplets, has the potential of encoding a sequential string of amino acids. It need not contain the start or stop codon. [SGD:rb]"
        },
        "SO:0000718": {
            "name": "blocked_reading_frame",
            "def": "A reading_frame that is interrupted by one or more stop codons; usually identified through inter-genomic sequence comparisons. [SGD:rb]"
        },
        "SO:0000719": {
            "name": "ultracontig",
            "def": "An ordered and oriented set of scaffolds based on somewhat weaker sets of inferential evidence such as one set of mate pair reads together with supporting evidence from ESTs or location of markers from SNP or microsatellite maps, or cytogenetic localization of contained markers. [FB:WG]"
        },
        "SO:0000720": {
            "name": "foreign_transposable_element",
            "def": "A transposable element that is foreign. [SO:ke]"
        },
        "SO:0000721": {
            "name": "gene_with_dicistronic_primary_transcript",
            "def": "A gene that encodes a dicistronic primary transcript. [SO:xp]"
        },
        "SO:0000722": {
            "name": "gene_with_dicistronic_mRNA",
            "def": "A gene that encodes a polycistronic mRNA. [SO:xp]"
        },
        "SO:0000723": {
            "name": "iDNA",
            "def": "Genomic sequence removed from the genome, as a normal event, by a process of recombination. [SO:ma]"
        },
        "SO:0000724": {
            "name": "oriT",
            "def": "A region of a DNA molecule where transfer is initiated during the process of conjugation or mobilization. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000725": {
            "name": "transit_peptide",
            "def": "The transit_peptide is a short region at the N-terminus of the peptide that directs the protein to an organelle (chloroplast, mitochondrion, microbody or cyanelle). [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0000726": {
            "name": "repeat_unit",
            "def": "The simplest repeated component of a repeat region. A single repeat. [SO:ke]"
        },
        "SO:0000727": {
            "name": "CRM",
            "def": "A regulatory region where transcription factor binding sites clustered to regulate various aspects of transcription activities. (CRMs can be located a few kb to hundred kb upstream of the basal promoter, in the coding sequence, within introns, or in the downstream 3'UTR sequences, as well as on different chromosome). A single gene can be regulated by multiple CRMs to give precise control of its spatial and temporal expression. CRMs function as nodes in large, intertwined regulatory network. [PMID:19660565, SO:SG]"
        },
        "SO:0000728": {
            "name": "intein",
            "def": "A region of a peptide that is able to excise itself and rejoin the remaining portions with a peptide bond. [SO:ke]"
        },
        "SO:0000729": {
            "name": "intein_containing",
            "def": "An attribute of protein-coding genes where the initial protein product contains an intein. [SO:ke]"
        },
        "SO:0000730": {
            "name": "gap",
            "def": "A gap in the sequence of known length. The unknown bases are filled in with N's. [SO:ke]"
        },
        "SO:0000731": {
            "name": "fragmentary",
            "def": "An attribute to describe a feature that is incomplete. [SO:ke]"
        },
        "SO:0000732": {
            "name": "predicted",
            "def": "An attribute describing an unverified region. [SO:ke]"
        },
        "SO:0000733": {
            "name": "feature_attribute",
            "def": "An attribute describing a located_sequence_feature. [SO:ke]"
        },
        "SO:0000734": {
            "name": "exemplar_mRNA",
            "def": "An exemplar is a representative cDNA sequence for each gene. The exemplar approach is a method that usually involves some initial clustering into gene groups and the subsequent selection of a representative from each gene group. [http://mged.sourceforge.net/ontologies/MGEDontology.php]"
        },
        "SO:0000735": {
            "name": "sequence_location"
        },
        "SO:0000736": {
            "name": "organelle_sequence"
        },
        "SO:0000737": {
            "name": "mitochondrial_sequence"
        },
        "SO:0000738": {
            "name": "nuclear_sequence"
        },
        "SO:0000739": {
            "name": "nucleomorphic_sequence"
        },
        "SO:0000740": {
            "name": "plastid_sequence"
        },
        "SO:0000741": {
            "name": "kinetoplast",
            "def": "A kinetoplast is an interlocked network of thousands of minicircles and tens of maxicircles, located near the base of the flagellum of some protozoan species. [PMID:8395055]"
        },
        "SO:0000742": {
            "name": "maxicircle",
            "def": "A maxicircle is a replicon, part of a kinetoplast, that contains open reading frames and replicates via a rolling circle method. [PMID:8395055]"
        },
        "SO:0000743": {
            "name": "apicoplast_sequence"
        },
        "SO:0000744": {
            "name": "chromoplast_sequence"
        },
        "SO:0000745": {
            "name": "chloroplast_sequence"
        },
        "SO:0000746": {
            "name": "cyanelle_sequence"
        },
        "SO:0000747": {
            "name": "leucoplast_sequence"
        },
        "SO:0000748": {
            "name": "proplastid_sequence"
        },
        "SO:0000749": {
            "name": "plasmid_location"
        },
        "SO:0000750": {
            "name": "amplification_origin",
            "def": "An origin_of_replication that is used for the amplification of a chromosomal nucleic acid sequence. [SO:ma]"
        },
        "SO:0000751": {
            "name": "proviral_location"
        },
        "SO:0000752": {
            "name": "gene_group_regulatory_region"
        },
        "SO:0000753": {
            "name": "clone_insert",
            "def": "The region of sequence that has been inserted and is being propagated by the clone. [SO:ke]"
        },
        "SO:0000754": {
            "name": "lambda_vector",
            "def": "The lambda bacteriophage is the vector for the linear lambda clone. The genes involved in the lysogenic pathway are removed from the from the viral DNA. Up to 25 kb of foreign DNA can then be inserted into the lambda genome. [ISBN:0-1767-2380-8]"
        },
        "SO:0000755": {
            "name": "plasmid_vector"
        },
        "SO:0000756": {
            "name": "cDNA",
            "def": "DNA synthesized by reverse transcriptase using RNA as a template. [SO:ma]"
        },
        "SO:0000757": {
            "name": "single_stranded_cDNA"
        },
        "SO:0000758": {
            "name": "double_stranded_cDNA"
        },
        "SO:0000759": {
            "name": "plasmid_clone"
        },
        "SO:0000760": {
            "name": "YAC_clone"
        },
        "SO:0000761": {
            "name": "phagemid_clone"
        },
        "SO:0000762": {
            "name": "PAC_clone"
        },
        "SO:0000763": {
            "name": "fosmid_clone"
        },
        "SO:0000764": {
            "name": "BAC_clone"
        },
        "SO:0000765": {
            "name": "cosmid_clone"
        },
        "SO:0000766": {
            "name": "pyrrolysyl_tRNA",
            "def": "A tRNA sequence that has a pyrrolysine anticodon, and a 3' pyrrolysine binding region. [SO:ke]"
        },
        "SO:0000767": {
            "name": "clone_insert_start"
        },
        "SO:0000768": {
            "name": "episome",
            "def": "A plasmid that may integrate with a chromosome. [SO:ma]"
        },
        "SO:0000769": {
            "name": "tmRNA_coding_piece",
            "def": "The region of a two-piece tmRNA that bears the reading frame encoding the proteolysis tag. The tmRNA gene undergoes circular permutation in some groups of bacteria. Processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw, issn:1362-4962]"
        },
        "SO:0000770": {
            "name": "tmRNA_acceptor_piece",
            "def": "The acceptor region of a two-piece tmRNA that when mature is charged at its 3' end with alanine. The tmRNA gene undergoes circular permutation in some groups of bacteria; processing of the transcripts from such a gene leaves the mature tmRNA in two pieces, base-paired together. [doi:10.1093/nar/gkh795, Indiana:kw]"
        },
        "SO:0000771": {
            "name": "QTL",
            "def": "A quantitative trait locus (QTL) is a polymorphic locus which contains alleles that differentially affect the expression of a continuously distributed phenotypic trait. Usually it is a marker described by statistical association to quantitative variation in the particular phenotypic trait that is thought to be controlled by the cumulative action of alleles at multiple loci. [http://rgd.mcw.edu/tu/qtls/]"
        },
        "SO:0000772": {
            "name": "genomic_island",
            "def": "A genomic island is an integrated mobile genetic element, characterized by size (over 10 Kb). It that has features that suggest a foreign origin. These can include nucleotide distribution (oligonucleotides signature, CG content etc.) that differs from the bulk of the chromosome and/or genes suggesting DNA mobility. [Phigo:at, SO:ke]"
        },
        "SO:0000773": {
            "name": "pathogenic_island",
            "def": "Mobile genetic elements that contribute to rapid changes in virulence potential. They are present on the genomes of pathogenic strains but absent from the genomes of non pathogenic members of the same or related species. [SO:ke]"
        },
        "SO:0000774": {
            "name": "metabolic_island",
            "def": "A transmissible element containing genes involved in metabolism, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
        },
        "SO:0000775": {
            "name": "adaptive_island",
            "def": "An adaptive island is a genomic island that provides an adaptive advantage to the host. [SO:ke]"
        },
        "SO:0000776": {
            "name": "symbiosis_island",
            "def": "A transmissible element containing genes involved in symbiosis, analogous to the pathogenicity islands of gram negative bacteria. [SO:ke]"
        },
        "SO:0000777": {
            "name": "pseudogenic_rRNA",
            "def": "A non functional descendant of an rRNA. [SO:ke]"
        },
        "SO:0000778": {
            "name": "pseudogenic_tRNA",
            "def": "A non functional descendent of a tRNA. [SO:ke]"
        },
        "SO:0000779": {
            "name": "engineered_episome",
            "def": "An episome that is engineered. [SO:xp]"
        },
        "SO:0000780": {
            "name": "transposable_element_attribute"
        },
        "SO:0000781": {
            "name": "transgenic",
            "def": "Attribute describing sequence that has been integrated with foreign sequence. [SO:ke]"
        },
        "SO:0000782": {
            "name": "natural",
            "def": "An attribute describing a feature that occurs in nature. [SO:ke]"
        },
        "SO:0000783": {
            "name": "engineered",
            "def": "An attribute to describe a region that was modified in vitro. [SO:ke]"
        },
        "SO:0000784": {
            "name": "foreign",
            "def": "An attribute to describe a region from another species. [SO:ke]"
        },
        "SO:0000785": {
            "name": "cloned_region"
        },
        "SO:0000786": {
            "name": "reagent_attribute"
        },
        "SO:0000787": {
            "name": "clone_attribute"
        },
        "SO:0000788": {
            "name": "cloned"
        },
        "SO:0000789": {
            "name": "validated",
            "def": "An attribute to describe a feature that has been proven. [SO:ke]"
        },
        "SO:0000790": {
            "name": "invalidated",
            "def": "An attribute describing a feature that is invalidated. [SO:ke]"
        },
        "SO:0000791": {
            "name": "cloned_genomic"
        },
        "SO:0000792": {
            "name": "cloned_cDNA"
        },
        "SO:0000793": {
            "name": "engineered_DNA"
        },
        "SO:0000794": {
            "name": "engineered_rescue_region",
            "def": "A rescue region that is engineered. [SO:xp]"
        },
        "SO:0000795": {
            "name": "rescue_mini_gene",
            "def": "A mini_gene that rescues. [SO:xp]"
        },
        "SO:0000796": {
            "name": "transgenic_transposable_element",
            "def": "TE that has been modified in vitro, including insertion of DNA derived from a source other than the originating TE. [FB:mc]"
        },
        "SO:0000797": {
            "name": "natural_transposable_element",
            "def": "TE that exists (or existed) in nature. [FB:mc]"
        },
        "SO:0000798": {
            "name": "engineered_transposable_element",
            "def": "TE that has been modified by manipulations in vitro. [FB:mc]"
        },
        "SO:0000799": {
            "name": "engineered_foreign_transposable_element",
            "def": "A transposable_element that is engineered and foreign. [FB:mc]"
        },
        "SO:0000800": {
            "name": "assortment_derived_duplication",
            "def": "A multi-chromosome duplication aberration generated by reassortment of other aberration components. [FB:gm]"
        },
        "SO:0000801": {
            "name": "assortment_derived_deficiency_plus_duplication",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency and a duplication. [FB:gm]"
        },
        "SO:0000802": {
            "name": "assortment_derived_deficiency",
            "def": "A multi-chromosome deficiency aberration generated by reassortment of other aberration components. [FB:gm]"
        },
        "SO:0000803": {
            "name": "assortment_derived_aneuploid",
            "def": "A multi-chromosome aberration generated by reassortment of other aberration components; presumed to have a deficiency or a duplication. [FB:gm]"
        },
        "SO:0000804": {
            "name": "engineered_region",
            "def": "A region that is engineered. [SO:xp]"
        },
        "SO:0000805": {
            "name": "engineered_foreign_region",
            "def": "A region that is engineered and foreign. [SO:xp]"
        },
        "SO:0000806": {
            "name": "fusion"
        },
        "SO:0000807": {
            "name": "engineered_tag",
            "def": "A tag that is engineered. [SO:xp]"
        },
        "SO:0000808": {
            "name": "validated_cDNA_clone",
            "def": "A cDNA clone that has been validated. [SO:xp]"
        },
        "SO:0000809": {
            "name": "invalidated_cDNA_clone",
            "def": "A cDNA clone that is invalid. [SO:xp]"
        },
        "SO:0000810": {
            "name": "chimeric_cDNA_clone",
            "def": "A cDNA clone invalidated because it is chimeric. [SO:xp]"
        },
        "SO:0000811": {
            "name": "genomically_contaminated_cDNA_clone",
            "def": "A cDNA clone invalidated by genomic contamination. [SO:xp]"
        },
        "SO:0000812": {
            "name": "polyA_primed_cDNA_clone",
            "def": "A cDNA clone invalidated by polyA priming. [SO:xp]"
        },
        "SO:0000813": {
            "name": "partially_processed_cDNA_clone",
            "def": "A cDNA invalidated clone by partial processing. [SO:xp]"
        },
        "SO:0000814": {
            "name": "rescue",
            "def": "An attribute describing a region's ability, when introduced to a mutant organism, to re-establish (rescue) a phenotype. [SO:ke]"
        },
        "SO:0000815": {
            "name": "mini_gene",
            "def": "By definition, minigenes are short open-reading frames (ORF), usually encoding approximately 9 to 20 amino acids, which are expressed in vivo (as distinct from being synthesized as peptide or protein ex vivo and subsequently injected). The in vivo synthesis confers a distinct advantage: the expressed sequences can enter both antigen presentation pathways, MHC I (inducing CD8+ T- cells, which are usually cytotoxic T-lymphocytes (CTL)) and MHC II (inducing CD4+ T-cells, usually 'T-helpers' (Th)); and can encounter B-cells, inducing antibody responses. Three main vector approaches have been used to deliver minigenes: viral vectors, bacterial vectors and plasmid DNA. [PMID:15992143]"
        },
        "SO:0000816": {
            "name": "rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
        },
        "SO:0000817": {
            "name": "wild_type",
            "def": "An attribute describing sequence with the genotype found in nature and/or standard laboratory stock. [SO:ke]"
        },
        "SO:0000818": {
            "name": "wild_type_rescue_gene",
            "def": "A gene that rescues. [SO:xp]"
        },
        "SO:0000819": {
            "name": "mitochondrial_chromosome",
            "def": "A chromosome originating in a mitochondria. [SO:xp]"
        },
        "SO:0000820": {
            "name": "chloroplast_chromosome",
            "def": "A chromosome originating in a chloroplast. [SO:xp]"
        },
        "SO:0000821": {
            "name": "chromoplast_chromosome",
            "def": "A chromosome originating in a chromoplast. [SO:xp]"
        },
        "SO:0000822": {
            "name": "cyanelle_chromosome",
            "def": "A chromosome originating in a cyanelle. [SO:xp]"
        },
        "SO:0000823": {
            "name": "leucoplast_chromosome",
            "def": "A chromosome with origin in a leucoplast. [SO:xp]"
        },
        "SO:0000824": {
            "name": "macronuclear_chromosome",
            "def": "A chromosome originating in a macronucleus. [SO:xp]"
        },
        "SO:0000825": {
            "name": "micronuclear_chromosome",
            "def": "A chromosome originating in a micronucleus. [SO:xp]"
        },
        "SO:0000828": {
            "name": "nuclear_chromosome",
            "def": "A chromosome originating in a nucleus. [SO:xp]"
        },
        "SO:0000829": {
            "name": "nucleomorphic_chromosome",
            "def": "A chromosome originating in a nucleomorph. [SO:xp]"
        },
        "SO:0000830": {
            "name": "chromosome_part",
            "def": "A region of a chromosome. [SO:ke]"
        },
        "SO:0000831": {
            "name": "gene_member_region",
            "def": "A region of a gene. [SO:ke]"
        },
        "SO:0000832": {
            "name": "promoter_region",
            "def": "A region of sequence which is part of a promoter. [SO:ke]"
        },
        "SO:0000833": {
            "name": "transcript_region",
            "def": "A region of a transcript. [SO:ke]"
        },
        "SO:0000834": {
            "name": "mature_transcript_region",
            "def": "A region of a mature transcript. [SO:ke]"
        },
        "SO:0000835": {
            "name": "primary_transcript_region",
            "def": "A part of a primary transcript. [SO:ke]"
        },
        "SO:0000836": {
            "name": "mRNA_region",
            "def": "A region of an mRNA. [SO:cb]"
        },
        "SO:0000837": {
            "name": "UTR_region",
            "def": "A region of UTR. [SO:ke]"
        },
        "SO:0000838": {
            "name": "rRNA_primary_transcript_region",
            "def": "A region of an rRNA primary transcript. [SO:ke]"
        },
        "SO:0000839": {
            "name": "polypeptide_region",
            "def": "Biological sequence region that can be assigned to a specific subsequence of a polypeptide. [SO:GAR, SO:ke]"
        },
        "SO:0000840": {
            "name": "repeat_component",
            "def": "A region of a repeated sequence. [SO:ke]"
        },
        "SO:0000841": {
            "name": "spliceosomal_intron_region",
            "def": "A region within an intron. [SO:ke]"
        },
        "SO:0000842": {
            "name": "gene_component_region"
        },
        "SO:0000843": {
            "name": "bacterial_RNApol_promoter_region",
            "def": "A region which is part of a bacterial RNA polymerase promoter. [SO:ke]"
        },
        "SO:0000844": {
            "name": "RNApol_II_promoter_region",
            "def": "A region of sequence which is a promoter for RNA polymerase II. [SO:ke]"
        },
        "SO:0000845": {
            "name": "RNApol_III_promoter_type_1_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 1. [SO:ke]"
        },
        "SO:0000846": {
            "name": "RNApol_III_promoter_type_2_region",
            "def": "A region of sequence which is a promoter for RNA polymerase III type 2. [SO:ke]"
        },
        "SO:0000847": {
            "name": "tmRNA_region",
            "def": "A region of a tmRNA. [SO:cb]"
        },
        "SO:0000848": {
            "name": "LTR_component"
        },
        "SO:0000849": {
            "name": "three_prime_LTR_component"
        },
        "SO:0000850": {
            "name": "five_prime_LTR_component"
        },
        "SO:0000851": {
            "name": "CDS_region",
            "def": "A region of a CDS. [SO:cb]"
        },
        "SO:0000852": {
            "name": "exon_region",
            "def": "A region of an exon. [RSC:cb]"
        },
        "SO:0000853": {
            "name": "homologous_region",
            "def": "A region that is homologous to another region. [SO:ke]"
        },
        "SO:0000854": {
            "name": "paralogous_region",
            "def": "A homologous_region that is paralogous to another region. [SO:ke]"
        },
        "SO:0000855": {
            "name": "orthologous_region",
            "def": "A homologous_region that is orthologous to another region. [SO:ke]"
        },
        "SO:0000856": {
            "name": "conserved"
        },
        "SO:0000857": {
            "name": "homologous",
            "def": "Similarity due to common ancestry. [SO:ke]"
        },
        "SO:0000858": {
            "name": "orthologous",
            "def": "An attribute describing a kind of homology where divergence occurred after a speciation event. [SO:ke]"
        },
        "SO:0000859": {
            "name": "paralogous",
            "def": "An attribute describing a kind of homology where divergence occurred after a duplication event. [SO:ke]"
        },
        "SO:0000860": {
            "name": "syntenic",
            "def": "Attribute describing sequence regions occurring in same order on chromosome of different species. [SO:ke]"
        },
        "SO:0000861": {
            "name": "capped_primary_transcript",
            "def": "A primary transcript that is capped. [SO:xp]"
        },
        "SO:0000862": {
            "name": "capped_mRNA",
            "def": "An mRNA that is capped. [SO:xp]"
        },
        "SO:0000863": {
            "name": "mRNA_attribute",
            "def": "An attribute describing an mRNA feature. [SO:ke]"
        },
        "SO:0000864": {
            "name": "exemplar",
            "def": "An attribute describing a sequence is representative of a class of similar sequences. [SO:ke]"
        },
        "SO:0000865": {
            "name": "frameshift",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is not divisible by 3. [SO:ke]"
        },
        "SO:0000866": {
            "name": "minus_1_frameshift",
            "def": "A frameshift caused by deleting one base. [SO:ke]"
        },
        "SO:0000867": {
            "name": "minus_2_frameshift",
            "def": "A frameshift caused by deleting two bases. [SO:ke]"
        },
        "SO:0000868": {
            "name": "plus_1_frameshift",
            "def": "A frameshift caused by inserting one base. [SO:ke]"
        },
        "SO:0000869": {
            "name": "plus_2_framshift",
            "def": "A frameshift caused by inserting two bases. [SO:ke]"
        },
        "SO:0000870": {
            "name": "trans_spliced",
            "def": "An attribute describing transcript sequence that is created by splicing exons from diferent genes. [SO:ke]"
        },
        "SO:0000871": {
            "name": "polyadenylated_mRNA",
            "def": "An mRNA that is polyadenylated. [SO:xp]"
        },
        "SO:0000872": {
            "name": "trans_spliced_mRNA",
            "def": "An mRNA that is trans-spliced. [SO:xp]"
        },
        "SO:0000873": {
            "name": "edited_transcript",
            "def": "A transcript that is edited. [SO:ke]"
        },
        "SO:0000874": {
            "name": "edited_transcript_by_A_to_I_substitution",
            "def": "A transcript that has been edited by A to I substitution. [SO:ke]"
        },
        "SO:0000875": {
            "name": "bound_by_protein",
            "def": "An attribute describing a sequence that is bound by a protein. [SO:ke]"
        },
        "SO:0000876": {
            "name": "bound_by_nucleic_acid",
            "def": "An attribute describing a sequence that is bound by a nucleic acid. [SO:ke]"
        },
        "SO:0000877": {
            "name": "alternatively_spliced",
            "def": "An attribute describing a situation where a gene may encode for more than 1 transcript. [SO:ke]"
        },
        "SO:0000878": {
            "name": "monocistronic",
            "def": "An attribute describing a sequence that contains the code for one gene product. [SO:ke]"
        },
        "SO:0000879": {
            "name": "dicistronic",
            "def": "An attribute describing a sequence that contains the code for two gene products. [SO:ke]"
        },
        "SO:0000880": {
            "name": "polycistronic",
            "def": "An attribute describing a sequence that contains the code for more than one gene product. [SO:ke]"
        },
        "SO:0000881": {
            "name": "recoded",
            "def": "An attribute describing an mRNA sequence that has been reprogrammed at translation, causing localized alterations. [SO:ke]"
        },
        "SO:0000882": {
            "name": "codon_redefined",
            "def": "An attribute describing the alteration of codon meaning. [SO:ke]"
        },
        "SO:0000883": {
            "name": "stop_codon_read_through",
            "def": "A stop codon redefined to be a new amino acid. [SO:ke]"
        },
        "SO:0000884": {
            "name": "stop_codon_redefined_as_pyrrolysine",
            "def": "A stop codon redefined to be the new amino acid, pyrrolysine. [SO:ke]"
        },
        "SO:0000885": {
            "name": "stop_codon_redefined_as_selenocysteine",
            "def": "A stop codon redefined to be the new amino acid, selenocysteine. [SO:ke]"
        },
        "SO:0000886": {
            "name": "recoded_by_translational_bypass",
            "def": "Recoded mRNA where a block of nucleotides is not translated. [SO:ke]"
        },
        "SO:0000887": {
            "name": "translationally_frameshifted",
            "def": "Recoding by frameshifting a particular site. [SO:ke]"
        },
        "SO:0000888": {
            "name": "maternally_imprinted_gene",
            "def": "A gene that is maternally_imprinted. [SO:xp]"
        },
        "SO:0000889": {
            "name": "paternally_imprinted_gene",
            "def": "A gene that is paternally imprinted. [SO:xp]"
        },
        "SO:0000890": {
            "name": "post_translationally_regulated_gene",
            "def": "A gene that is post translationally regulated. [SO:xp]"
        },
        "SO:0000891": {
            "name": "negatively_autoregulated_gene",
            "def": "A gene that is negatively autoreguated. [SO:xp]"
        },
        "SO:0000892": {
            "name": "positively_autoregulated_gene",
            "def": "A gene that is positively autoregulated. [SO:xp]"
        },
        "SO:0000893": {
            "name": "silenced",
            "def": "An attribute describing an epigenetic process where a gene is inactivated at transcriptional or translational level. [SO:ke]"
        },
        "SO:0000894": {
            "name": "silenced_by_DNA_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA modifications, resulting in repression of transcription. [SO:ke]"
        },
        "SO:0000895": {
            "name": "silenced_by_DNA_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by DNA methylation, resulting in repression of transcription. [SO:ke]"
        },
        "SO:0000896": {
            "name": "translationally_regulated_gene",
            "def": "A gene that is translationally regulated. [SO:xp]"
        },
        "SO:0000897": {
            "name": "allelically_excluded_gene",
            "def": "A gene that is allelically_excluded. [SO:xp]"
        },
        "SO:0000898": {
            "name": "epigenetically_modified_gene",
            "def": "A gene that is epigenetically modified. [SO:ke]"
        },
        "SO:0000899": {
            "name": "nuclear_mitochondrial",
            "def": "An attribute describing a nuclear pseudogene of a mitochndrial gene. [SO:ke]"
        },
        "SO:0000900": {
            "name": "processed",
            "def": "An attribute describing a pseudogene where by an mRNA was retrotransposed. The mRNA sequence is transcribed back into the genome, lacking introns and promotors, but often including a polyA tail. [SO:ke]"
        },
        "SO:0000901": {
            "name": "unequally_crossed_over",
            "def": "An attribute describing a pseudogene that was created by tandem duplication and unequal crossing over during recombination. [SO:ke]"
        },
        "SO:0000902": {
            "name": "transgene",
            "def": "A transgene is a gene that has been transferred naturally or by any of a number of genetic engineering techniques from one organism to another. [SO:xp]"
        },
        "SO:0000903": {
            "name": "endogenous_retroviral_sequence"
        },
        "SO:0000904": {
            "name": "rearranged_at_DNA_level",
            "def": "An attribute to describe the sequence of a feature, where the DNA is rearranged. [SO:ke]"
        },
        "SO:0000905": {
            "name": "status",
            "def": "An attribute describing the status of a feature, based on the available evidence. [SO:ke]"
        },
        "SO:0000906": {
            "name": "independently_known",
            "def": "Attribute to describe a feature that is independently known - not predicted. [SO:ke]"
        },
        "SO:0000907": {
            "name": "supported_by_sequence_similarity",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity techniques. [SO:ke]"
        },
        "SO:0000908": {
            "name": "supported_by_domain_match",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity of a known domain. [SO:ke]"
        },
        "SO:0000909": {
            "name": "supported_by_EST_or_cDNA",
            "def": "An attribute to describe a feature that has been predicted using sequence similarity to EST or cDNA data. [SO:ke]"
        },
        "SO:0000910": {
            "name": "orphan"
        },
        "SO:0000911": {
            "name": "predicted_by_ab_initio_computation",
            "def": "An attribute describing a feature that is predicted by a computer program that did not rely on sequence similarity. [SO:ke]"
        },
        "SO:0000912": {
            "name": "asx_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Aspartate or Asparagine (Asx), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0000913": {
            "name": "cloned_cDNA_insert",
            "def": "A clone insert made from cDNA. [SO:xp]"
        },
        "SO:0000914": {
            "name": "cloned_genomic_insert",
            "def": "A clone insert made from genomic DNA. [SO:xp]"
        },
        "SO:0000915": {
            "name": "engineered_insert",
            "def": "A clone insert that is engineered. [SO:xp]"
        },
        "SO:0000916": {
            "name": "edit_operation"
        },
        "SO:0000917": {
            "name": "insert_U",
            "def": "An edit to insert a U. [SO:ke]"
        },
        "SO:0000918": {
            "name": "delete_U",
            "def": "An edit to delete a uridine. [SO:ke]"
        },
        "SO:0000919": {
            "name": "substitute_A_to_I",
            "def": "An edit to substitute an I for an A. [SO:ke]"
        },
        "SO:0000920": {
            "name": "insert_C",
            "def": "An edit to insert a cytidine. [SO:ke]"
        },
        "SO:0000921": {
            "name": "insert_dinucleotide",
            "def": "An edit to insert a dinucleotide. [SO:ke]"
        },
        "SO:0000922": {
            "name": "substitute_C_to_U",
            "def": "An edit to substitute an U for a C. [SO:ke]"
        },
        "SO:0000923": {
            "name": "insert_G",
            "def": "An edit to insert a G. [SO:ke]"
        },
        "SO:0000924": {
            "name": "insert_GC",
            "def": "An edit to insert a GC dinucleotide. [SO:ke]"
        },
        "SO:0000925": {
            "name": "insert_GU",
            "def": "An edit to insert a GU dinucleotide. [SO:ke]"
        },
        "SO:0000926": {
            "name": "insert_CU",
            "def": "An edit to insert a CU dinucleotide. [SO:ke]"
        },
        "SO:0000927": {
            "name": "insert_AU",
            "def": "An edit to insert a AU dinucleotide. [SO:ke]"
        },
        "SO:0000928": {
            "name": "insert_AA",
            "def": "An edit to insert a AA dinucleotide. [SO:ke]"
        },
        "SO:0000929": {
            "name": "edited_mRNA",
            "def": "An mRNA that is edited. [SO:xp]"
        },
        "SO:0000930": {
            "name": "guide_RNA_region",
            "def": "A region of guide RNA. [SO:ma]"
        },
        "SO:0000931": {
            "name": "anchor_region",
            "def": "A region of a guide_RNA that base-pairs to a target mRNA. [SO:jk]"
        },
        "SO:0000932": {
            "name": "pre_edited_mRNA"
        },
        "SO:0000933": {
            "name": "intermediate",
            "def": "An attribute to describe a feature between stages of processing. [SO:ke]"
        },
        "SO:0000934": {
            "name": "miRNA_target_site",
            "def": "A miRNA target site is a binding site where the molecule is a micro RNA. [FB:cds]"
        },
        "SO:0000935": {
            "name": "edited_CDS",
            "def": "A CDS that is edited. [SO:xp]"
        },
        "SO:0000936": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_segment"
        },
        "SO:0000937": {
            "name": "vertebrate_immune_system_feature"
        },
        "SO:0000938": {
            "name": "vertebrate_immunoglobulin_T_cell_receptor_rearranged_gene_cluster"
        },
        "SO:0000939": {
            "name": "vertebrate_immune_system_gene_recombination_signal_feature"
        },
        "SO:0000940": {
            "name": "recombinationally_rearranged"
        },
        "SO:0000941": {
            "name": "recombinationally_rearranged_vertebrate_immune_system_gene",
            "def": "A recombinationally rearranged gene of the vertebrate immune system. [SO:xp]"
        },
        "SO:0000942": {
            "name": "attP_site",
            "def": "An integration/excision site of a phage chromosome at which a recombinase acts to insert the phage DNA at a cognate integration/excision site on a bacterial chromosome. [SO:as]"
        },
        "SO:0000943": {
            "name": "attB_site",
            "def": "An integration/excision site of a bacterial chromosome at which a recombinase acts to insert foreign DNA containing a cognate integration/excision site. [SO:as]"
        },
        "SO:0000944": {
            "name": "attL_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attB_site and the 3' portion of attP_site. [SO:as]"
        },
        "SO:0000945": {
            "name": "attR_site",
            "def": "A region that results from recombination between attP_site and attB_site, composed of the 5' portion of attP_site and the 3' portion of attB_site. [SO:as]"
        },
        "SO:0000946": {
            "name": "integration_excision_site",
            "def": "A region specifically recognised by a recombinase, which inserts or removes another region marked by a distinct cognate integration/excision site. [SO:as]"
        },
        "SO:0000947": {
            "name": "resolution_site",
            "def": "A region specifically recognized by a recombinase, which separates a physically contiguous circle of DNA into two physically separate circles. [SO:as]"
        },
        "SO:0000948": {
            "name": "inversion_site",
            "def": "A region specifically recognised by a recombinase, which inverts the region flanked by a pair of sites. [SO:ma]"
        },
        "SO:0000949": {
            "name": "dif_site",
            "def": "A site at which replicated bacterial circular chromosomes are decatenated by site specific resolvase. [SO:as]"
        },
        "SO:0000950": {
            "name": "attC_site",
            "def": "An attC site is a sequence required for the integration of a DNA of an integron. [SO:as]"
        },
        "SO:0000951": {
            "name": "eukaryotic_terminator"
        },
        "SO:0000952": {
            "name": "oriV",
            "def": "An origin of vegetative replication in plasmids and phages. [SO:as]"
        },
        "SO:0000953": {
            "name": "oriC",
            "def": "An origin of bacterial chromosome replication. [SO:as]"
        },
        "SO:0000954": {
            "name": "DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, DNA molecule. [SO:ma]"
        },
        "SO:0000955": {
            "name": "double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded DNA molecule. [SO:ma]"
        },
        "SO:0000956": {
            "name": "single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded DNA molecule. [SO:ma]"
        },
        "SO:0000957": {
            "name": "linear_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear DNA molecule. [SO:ma]"
        },
        "SO:0000958": {
            "name": "circular_double_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000959": {
            "name": "linear_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear DNA molecule. [SO:ma]"
        },
        "SO:0000960": {
            "name": "circular_single_stranded_DNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000961": {
            "name": "RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, RNA molecule. [SO:ma]"
        },
        "SO:0000962": {
            "name": "single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded RNA molecule. [SO:ma]"
        },
        "SO:0000963": {
            "name": "linear_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, linear RNA molecule. [SO:ma]"
        },
        "SO:0000964": {
            "name": "linear_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, linear RNA molecule. [SO:ma]"
        },
        "SO:0000965": {
            "name": "double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded RNA molecule. [SO:ma]"
        },
        "SO:0000966": {
            "name": "circular_single_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, single-stranded, circular DNA molecule. [SO:ma]"
        },
        "SO:0000967": {
            "name": "circular_double_stranded_RNA_chromosome",
            "def": "Structural unit composed of a self-replicating, double-stranded, circular RNA molecule. [SO:ma]"
        },
        "SO:0000968": {
            "name": "sequence_replication_mode"
        },
        "SO:0000969": {
            "name": "rolling_circle"
        },
        "SO:0000970": {
            "name": "theta_replication"
        },
        "SO:0000971": {
            "name": "DNA_replication_mode"
        },
        "SO:0000972": {
            "name": "RNA_replication_mode"
        },
        "SO:0000973": {
            "name": "insertion_sequence",
            "def": "A terminal_inverted_repeat_element that is bacterial and only encodes the functions required for its transposition between these inverted repeats. [SO:as]"
        },
        "SO:0000975": {
            "name": "minicircle_gene"
        },
        "SO:0000976": {
            "name": "cryptic",
            "def": "A feature_attribute describing a feature that is not manifest under normal conditions. [SO:ke]"
        },
        "SO:0000977": {
            "name": "anchor_binding_site"
        },
        "SO:0000978": {
            "name": "template_region",
            "def": "A region of a guide_RNA that specifies the insertions and deletions of bases in the editing of a target mRNA. [SO:jk]"
        },
        "SO:0000979": {
            "name": "gRNA_encoding",
            "def": "A non-protein_coding gene that encodes a guide_RNA. [SO:ma]"
        },
        "SO:0000980": {
            "name": "minicircle",
            "def": "A minicircle is a replicon, part of a kinetoplast, that encodes for guide RNAs. [PMID:8395055]"
        },
        "SO:0000981": {
            "name": "rho_dependent_bacterial_terminator"
        },
        "SO:0000982": {
            "name": "rho_independent_bacterial_terminator"
        },
        "SO:0000983": {
            "name": "strand_attribute"
        },
        "SO:0000984": {
            "name": "single"
        },
        "SO:0000985": {
            "name": "double"
        },
        "SO:0000986": {
            "name": "topology_attribute"
        },
        "SO:0000987": {
            "name": "linear",
            "def": "A quality of a nucleotide polymer that has a 3'-terminal residue and a 5'-terminal residue. [SO:cb]"
        },
        "SO:0000988": {
            "name": "circular",
            "def": "A quality of a nucleotide polymer that has no terminal nucleotide residues. [SO:cb]"
        },
        "SO:0000989": {
            "name": "class_II_RNA",
            "def": "Small non-coding RNA (59-60 nt long) containing 5' and 3' ends that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
        },
        "SO:0000990": {
            "name": "class_I_RNA",
            "def": "Small non-coding RNA (55-65 nt long) containing highly conserved 5' and 3' ends (16 and 8 nt, respectively) that are predicted to come together to form a stem structure. Identified in the social amoeba Dictyostelium discoideum and localized in the cytoplasm. [PMID:15333696]"
        },
        "SO:0000991": {
            "name": "genomic_DNA"
        },
        "SO:0000992": {
            "name": "BAC_cloned_genomic_insert"
        },
        "SO:0000993": {
            "name": "consensus"
        },
        "SO:0000994": {
            "name": "consensus_region"
        },
        "SO:0000995": {
            "name": "consensus_mRNA"
        },
        "SO:0000996": {
            "name": "predicted_gene"
        },
        "SO:0000997": {
            "name": "gene_fragment"
        },
        "SO:0000998": {
            "name": "recursive_splice_site",
            "def": "A recursive splice site is a splice site which subdivides a large intron. Recursive splicing is a mechanism that splices large introns by sub dividing the intron at non exonic elements and alternate exons. [http://www.genetics.org/cgi/content/full/170/2/661]"
        },
        "SO:0000999": {
            "name": "BAC_end",
            "def": "A region of sequence from the end of a BAC clone that may provide a highly specific marker. [SO:ke]"
        },
        "SO:0001000": {
            "name": "rRNA_16S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the small subunit of the ribosome. [SO:ke]"
        },
        "SO:0001001": {
            "name": "rRNA_23S",
            "def": "A large polynucleotide in Bacteria and Archaea, which functions as the large subunit of the ribosome. [SO:ke]"
        },
        "SO:0001002": {
            "name": "rRNA_25S",
            "def": "A large polynucleotide which functions as part of the large subunit of the ribosome in some eukaryotes. [RSC:cb]"
        },
        "SO:0001003": {
            "name": "solo_LTR",
            "def": "A recombination product between the 2 LTR of the same element. [SO:ke]"
        },
        "SO:0001004": {
            "name": "low_complexity"
        },
        "SO:0001005": {
            "name": "low_complexity_region"
        },
        "SO:0001006": {
            "name": "prophage",
            "def": "A phage genome after it has established in the host genome in a latent/immune state either as a plasmid or as an integrated \\island\\. [GOC:jl]"
        },
        "SO:0001007": {
            "name": "cryptic_prophage",
            "def": "A remnant of an integrated prophage in the host genome or an \\island\\ in the host genome that includes phage like-genes. [GOC:jl]"
        },
        "SO:0001008": {
            "name": "tetraloop",
            "def": "A base-paired stem with loop of 4 non-hydrogen bonded nucleotides. [SO:ke]"
        },
        "SO:0001009": {
            "name": "DNA_constraint_sequence",
            "def": "A double-stranded DNA used to control macromolecular structure and function. [http:/www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=search&db=pubmed&term=SILVERMAN+SK[au\\]&dispmax=50]"
        },
        "SO:0001010": {
            "name": "i_motif",
            "def": "A cytosine rich domain whereby strands associate both inter- and intramolecularly at moderately acidic pH. [PMID:9753739]"
        },
        "SO:0001011": {
            "name": "PNA_oligo",
            "def": "Peptide nucleic acid, is a chemical not known to occur naturally but is artificially synthesized and used in some biological research and medical treatments. The PNA backbone is composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [SO:ke]"
        },
        "SO:0001012": {
            "name": "DNAzyme",
            "def": "A DNA sequence with catalytic activity. [SO:cb]"
        },
        "SO:0001013": {
            "name": "MNP",
            "def": "A multiple nucleotide polymorphism with alleles of common length > 1, for example AAA/TTT. [http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs=rs2067431]"
        },
        "SO:0001014": {
            "name": "intron_domain"
        },
        "SO:0001015": {
            "name": "wobble_base_pair",
            "def": "A type of non-canonical base pairing, most commonly between G and U, which is important for the secondary structure of RNAs. It has similar thermodynamic stability to the Watson-Crick pairing. Wobble base pairs only have two hydrogen bonds. Other wobble base pair possibilities are I-A, I-U and I-C. [PMID:11256617]"
        },
        "SO:0001016": {
            "name": "internal_guide_sequence",
            "def": "A purine-rich sequence in the group I introns which determines the locations of the splice sites in group I intron splicing and has catalytic activity. [SO:cb]"
        },
        "SO:0001017": {
            "name": "silent_mutation",
            "def": "A sequence variant that does not affect protein function. Silent mutations may occur in genic ( CDS, UTR, intron etc) and intergenic regions. Silent mutations may have affects on processes such as splicing and regulation. [SO:ke]"
        },
        "SO:0001018": {
            "name": "epitope",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with antibodies, B cells or T cells. [http://en.wikipedia.org/wiki/Epitope, SO:cb]"
        },
        "SO:0001019": {
            "name": "copy_number_variation",
            "def": "A variation that increases or decreases the copy number of a given region. [SO:ke]"
        },
        "SO:0001020": {
            "name": "sequence_variant_affecting_copy_number"
        },
        "SO:0001021": {
            "name": "chromosome_breakpoint"
        },
        "SO:0001022": {
            "name": "inversion_breakpoint",
            "def": "The point within a chromosome where an inversion begins or ends. [SO:cb]"
        },
        "SO:0001023": {
            "name": "allele",
            "def": "An allele is one of a set of coexisting sequence variants of a gene. [SO:immuno_workshop]"
        },
        "SO:0001024": {
            "name": "haplotype",
            "def": "A haplotype is one of a set of coexisting sequence variants of a haplotype block. [SO:immuno_workshop]"
        },
        "SO:0001025": {
            "name": "polymorphic_sequence_variant",
            "def": "A sequence variant that is segregating in one or more natural populations of a species. [SO:immuno_workshop]"
        },
        "SO:0001026": {
            "name": "genome",
            "def": "A genome is the sum of genetic material within a cell or virion. [SO:immuno_workshop]"
        },
        "SO:0001027": {
            "name": "genotype",
            "def": "A genotype is a variant genome, complete or incomplete. [SO:immuno_workshop]"
        },
        "SO:0001028": {
            "name": "diplotype",
            "def": "A diplotype is a pair of haplotypes from a given individual. It is a genotype where the phase is known. [SO:immuno_workshop]"
        },
        "SO:0001029": {
            "name": "direction_attribute"
        },
        "SO:0001030": {
            "name": "forward",
            "def": "Forward is an attribute of the feature, where the feature is in the 5' to 3' direction. [SO:ke]"
        },
        "SO:0001031": {
            "name": "reverse",
            "def": "Reverse is an attribute of the feature, where the feature is in the 3' to 5' direction. Again could be applied to primer. [SO:ke]"
        },
        "SO:0001032": {
            "name": "mitochondrial_DNA"
        },
        "SO:0001033": {
            "name": "chloroplast_DNA"
        },
        "SO:0001034": {
            "name": "miRtron",
            "def": "A de-branched intron which mimics the structure of pre-miRNA and enters the miRNA processing pathway without Drosha mediated cleavage. [PMID:17589500, SO:ma]"
        },
        "SO:0001035": {
            "name": "piRNA",
            "def": "A small non coding RNA, part of a silencing system that prevents the spreading of selfish genetic elements. [SO:ke]"
        },
        "SO:0001036": {
            "name": "arginyl_tRNA",
            "def": "A tRNA sequence that has an arginine anticodon, and a 3' arginine binding region. [SO:ke]"
        },
        "SO:0001037": {
            "name": "mobile_genetic_element",
            "def": "A nucleotide region with either intra-genome or intracellular mobility, of varying length, which often carry the information necessary for transfer and recombination with the host genome. [PMID:14681355]"
        },
        "SO:0001038": {
            "name": "extrachromosomal_mobile_genetic_element",
            "def": "An MGE that is not integrated into the host chromosome. [SO:ke]"
        },
        "SO:0001039": {
            "name": "integrated_mobile_genetic_element",
            "def": "An MGE that is integrated into the host chromosome. [SO:ke]"
        },
        "SO:0001040": {
            "name": "integrated_plasmid",
            "def": "A plasmid sequence that is integrated within the host chromosome. [SO:ke]"
        },
        "SO:0001041": {
            "name": "viral_sequence",
            "def": "The region of nucleotide sequence of a virus, a submicroscopic particle that replicates by infecting a host cell. [SO:ke]"
        },
        "SO:0001042": {
            "name": "phage_sequence",
            "def": "The nucleotide sequence of a virus that infects bacteria. [SO:ke]"
        },
        "SO:0001043": {
            "name": "attCtn_site",
            "def": "An attachment site located on a conjugative transposon and used for site-specific integration of a conjugative transposon. [Phigo:at]"
        },
        "SO:0001044": {
            "name": "nuclear_mt_pseudogene",
            "def": "A nuclear pseudogene of either coding or non-coding mitochondria derived sequence. [SO:xp]"
        },
        "SO:0001045": {
            "name": "cointegrated_plasmid",
            "def": "A MGE region consisting of two fused plasmids resulting from a replicative transposition event. [phigo:at]"
        },
        "SO:0001046": {
            "name": "IRLinv_site",
            "def": "Component of the inversion site located at the left of a region susceptible to site-specific inversion. [Phigo:at]"
        },
        "SO:0001047": {
            "name": "IRRinv_site",
            "def": "Component of the inversion site located at the right of a region susceptible to site-specific inversion. [Phigo:at]"
        },
        "SO:0001048": {
            "name": "inversion_site_part",
            "def": "A region located within an inversion site. [SO:ke]"
        },
        "SO:0001049": {
            "name": "defective_conjugative_transposon",
            "def": "An island that contains genes for integration/excision and the gene and site for the initiation of intercellular transfer by conjugation. It can be complemented for transfer by a conjugative transposon. [Phigo:ariane]"
        },
        "SO:0001050": {
            "name": "repeat_fragment",
            "def": "A portion of a repeat, interrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001051": {
            "name": "nested_region"
        },
        "SO:0001052": {
            "name": "nested_repeat"
        },
        "SO:0001053": {
            "name": "nested_transposon"
        },
        "SO:0001054": {
            "name": "transposon_fragment",
            "def": "A portion of a transposon, interrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001055": {
            "name": "transcriptional_cis_regulatory_region",
            "def": "A regulatory_region that modulates the transcription of a gene or genes. [PMID:9679020, SO:regcreative]"
        },
        "SO:0001056": {
            "name": "splicing_regulatory_region",
            "def": "A regulatory_region that modulates splicing. [SO:ke]"
        },
        "SO:0001057": {
            "name": "enhanceosome"
        },
        "SO:0001058": {
            "name": "promoter_targeting_sequence",
            "def": "A transcriptional_cis_regulatory_region that restricts the activity of a CRM to a single promoter and which functions only when both itself and an insulator are located between the CRM and the promoter. [SO:regcreative]"
        },
        "SO:0001059": {
            "name": "sequence_alteration",
            "def": "A sequence_alteration is a sequence_feature whose extent is the deviation from another sequence. [SO:ke]"
        },
        "SO:0001060": {
            "name": "sequence_variant",
            "def": "A sequence_variant is a non exact copy of a sequence_feature or genome exhibiting one or more sequence_alteration. [SO:ke]"
        },
        "SO:0001061": {
            "name": "propeptide_cleavage_site",
            "def": "The propeptide_cleavage_site is the arginine/lysine boundary on a propeptide where cleavage occurs. [EBIBS:GAR]"
        },
        "SO:0001062": {
            "name": "propeptide",
            "def": "Part of a peptide chain which is cleaved off during the formation of the mature protein. [EBIBS:GAR]"
        },
        "SO:0001063": {
            "name": "immature_peptide_region",
            "def": "An immature_peptide_region is the extent of the peptide after it has been translated and before any processing occurs. [EBIBS:GAR]"
        },
        "SO:0001064": {
            "name": "active_peptide",
            "def": "Active peptides are proteins which are biologically active, released from a precursor molecule. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001066": {
            "name": "compositionally_biased_region_of_peptide",
            "def": "Polypeptide region that is rich in a particular amino acid or homopolymeric and greater than three residues in length. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001067": {
            "name": "polypeptide_motif",
            "def": "A sequence motif is a short (up to 20 amino acids) region of biological interest. Such motifs, although they are too short to constitute functional domains, share sequence similarities and are conserved in different proteins. They display a common function (protein-binding, subcellular location etc.). [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001068": {
            "name": "polypeptide_repeat",
            "def": "A polypeptide_repeat is a single copy of an internal sequence repetition. [EBIBS:GAR]"
        },
        "SO:0001070": {
            "name": "polypeptide_structural_region",
            "def": "Region of polypeptide with a given structural property. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001071": {
            "name": "membrane_structure",
            "def": "Arrangement of the polypeptide with respect to the lipid bilayer. [EBIBS:GAR]"
        },
        "SO:0001072": {
            "name": "extramembrane_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001073": {
            "name": "cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized inside the cytoplasm. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001074": {
            "name": "non_cytoplasmic_polypeptide_region",
            "def": "Polypeptide region that is localized outside of a lipid bilayer and outside of the cytoplasm. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001075": {
            "name": "intramembrane_polypeptide_region",
            "def": "Polypeptide region present in the lipid bilayer. [EBIBS:GAR]"
        },
        "SO:0001076": {
            "name": "membrane_peptide_loop",
            "def": "Polypeptide region localized within the lipid bilayer where both ends traverse the same membrane. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001077": {
            "name": "transmembrane_polypeptide_region",
            "def": "Polypeptide region traversing the lipid bilayer. [EBIBS:GAR, UniProt:curator_manual]"
        },
        "SO:0001078": {
            "name": "polypeptide_secondary_structure",
            "def": "A region of peptide with secondary structure has hydrogen bonding along the peptide chain that causes a defined conformation of the chain. [EBIBS:GAR]"
        },
        "SO:0001079": {
            "name": "polypeptide_structural_motif",
            "def": "Motif is a three-dimensional structural element within the chain, which appears also in a variety of other molecules. Unlike a domain, a motif does not need to form a stable globular unit. [EBIBS:GAR]"
        },
        "SO:0001080": {
            "name": "coiled_coil",
            "def": "A coiled coil is a structural motif in proteins, in which alpha-helices are coiled together like the strands of a rope. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001081": {
            "name": "helix_turn_helix",
            "def": "A motif comprising two helices separated by a turn. [EBIBS:GAR]"
        },
        "SO:0001082": {
            "name": "polypeptide_sequencing_information",
            "def": "Incompatibility in the sequence due to some experimental problem. [EBIBS:GAR]"
        },
        "SO:0001083": {
            "name": "non_adjacent_residues",
            "def": "Indicates that two consecutive residues in a fragment sequence are not consecutive in the full-length protein and that there are a number of unsequenced residues between them. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001084": {
            "name": "non_terminal_residue",
            "def": "The residue at an extremity of the sequence is not the terminal residue. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001085": {
            "name": "sequence_conflict",
            "def": "Different sources report differing sequences. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001086": {
            "name": "sequence_uncertainty",
            "def": "Describes the positions in a sequence where the authors are unsure about the sequence assignment. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001087": {
            "name": "cross_link",
            "def": "Posttranslationally formed amino acid bonds. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001088": {
            "name": "disulfide_bond",
            "def": "The covalent bond between sulfur atoms that binds two peptide chains or different parts of one peptide chain and is a structural determinant in many protein molecules. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001089": {
            "name": "post_translationally_modified_region",
            "def": "A region where a transformation occurs in a protein after it has been synthesized. This which may regulate, stabilize, crosslink or introduce new chemical functionalities in the protein. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001090": {
            "name": "covalent_binding_site",
            "def": "Binding involving a covalent bond. [EBIBS:GAR]"
        },
        "SO:0001091": {
            "name": "non_covalent_binding_site",
            "def": "Binding site for any chemical group (co-enzyme, prosthetic group, etc.). [EBIBS:GAR]"
        },
        "SO:0001092": {
            "name": "polypeptide_metal_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with metal ions. [EBIBS:GAR, SO:cb, UniProt:curation_manual]"
        },
        "SO:0001093": {
            "name": "protein_protein_contact",
            "def": "A binding site that, in the protein molecule, interacts selectively and non-covalently with polypeptide residues. [EBIBS:GAR, UniProt:Curation_manual]"
        },
        "SO:0001094": {
            "name": "polypeptide_calcium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with calcium ions. [EBIBS:GAR]"
        },
        "SO:0001095": {
            "name": "polypeptide_cobalt_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with cobalt ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001096": {
            "name": "polypeptide_copper_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with copper ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001097": {
            "name": "polypeptide_iron_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with iron ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001098": {
            "name": "polypeptide_magnesium_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with magnesium ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001099": {
            "name": "polypeptide_manganese_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with manganese ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001100": {
            "name": "polypeptide_molybdenum_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with molybdenum ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001101": {
            "name": "polypeptide_nickel_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with nickel ions. [EBIBS:GAR]"
        },
        "SO:0001102": {
            "name": "polypeptide_tungsten_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with tungsten ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001103": {
            "name": "polypeptide_zinc_ion_contact_site",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with zinc ions. [EBIBS:GAR, SO:cb]"
        },
        "SO:0001104": {
            "name": "catalytic_residue",
            "def": "Amino acid involved in the activity of an enzyme. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001105": {
            "name": "polypeptide_ligand_contact",
            "def": "Residues which interact with a ligand. [EBIBS:GAR]"
        },
        "SO:0001106": {
            "name": "asx_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: Residue(i) is Aspartate or Asparagine (Asx), side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3), main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001107": {
            "name": "beta_bulge",
            "def": "A motif of three residues within a beta-sheet in which the main chains of two consecutive residues are H-bonded to that of the third, and in which the dihedral angles are as follows: Residue(i): -140 degrees < phi(l) -20 degrees , -90 degrees < psi(l) < 40 degrees. Residue (i+1): -180 degrees < phi < -25 degrees or +120 degrees < phi < +180 degrees, +40 degrees < psi < +180 degrees or -180 degrees < psi < -120 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001108": {
            "name": "beta_bulge_loop",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds. Beta bulge loops often occur at the loop ends of beta-hairpins. [EBIBS:GAR, Http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001109": {
            "name": "beta_bulge_loop_five",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+4), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+3), these loops have an RL nest at residues i+2 and i+3. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001110": {
            "name": "beta_bulge_loop_six",
            "def": "A motif of three residues within a beta-sheet consisting of two H-bonds in which: the main-chain NH of residue(i) is H-bonded to the main-chain CO of residue(i+5), the main-chain CO of residue i is H-bonded to the main-chain NH of residue(i+4), these loops have an RL nest at residues i+3 and i+4. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001111": {
            "name": "beta_strand",
            "def": "A beta strand describes a single length of polypeptide chain that forms part of a beta sheet. A single continuous stretch of amino acids adopting an extended conformation of hydrogen bonds between the N-O and the C=O of another part of the peptide. This forms a secondary protein structure in which two or more extended polypeptide regions are hydrogen-bonded to one another in a planar array. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001112": {
            "name": "antiparallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (one running N-terminal to C-terminal and one running C-terminal to N-terminal). Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i) and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they form two mutual backbone hydrogen bonds to each other's flanking peptide groups; this is known as a close pair of hydrogen bonds. The peptide backbone dihedral angles (phi, psi) are about (-140 degrees, 135 degrees) in antiparallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001113": {
            "name": "parallel_beta_strand",
            "def": "A peptide region which hydrogen bonded to another region of peptide running in the oposite direction (both running N-terminal to C-terminal). This orientation is slightly less stable because it introduces nonplanarity in the inter-strand hydrogen bonding pattern. Hydrogen bonding occurs between every other C=O from one strand to every other N-H on the adjacent strand. In this case, if two atoms C-alpha (i)and C-alpha (j) are adjacent in two hydrogen-bonded beta strands, then they do not hydrogen bond to each other; rather, one residue forms hydrogen bonds to the residues that flank the other (but not vice versa). For example, residue i may form hydrogen bonds to residues j - 1 and j + 1; this is known as a wide pair of hydrogen bonds. By contrast, residue j may hydrogen-bond to different residues altogether, or to none at all. The dihedral angles (phi, psi) are about (-120 degrees, 115 degrees) in parallel sheets. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001114": {
            "name": "peptide_helix",
            "def": "A helix is a secondary_structure conformation where the peptide backbone forms a coil. [EBIBS:GAR]"
        },
        "SO:0001115": {
            "name": "left_handed_peptide_helix",
            "def": "A left handed helix is a region of peptide where the coiled conformation turns in an anticlockwise, left handed screw. [EBIBS:GAR]"
        },
        "SO:0001116": {
            "name": "right_handed_peptide_helix",
            "def": "A right handed helix is a region of peptide where the coiled conformation turns in a clockwise, right handed screw. [EBIBS:GAR]"
        },
        "SO:0001117": {
            "name": "alpha_helix",
            "def": "The helix has 3.6 residues per turn which corresponds to a translation of 1.5 angstroms (= 0.15 nm) along the helical axis. Every backbone N-H group donates a hydrogen bond to the backbone C=O group of the amino acid four residues earlier. [EBIBS:GAR]"
        },
        "SO:0001118": {
            "name": "pi_helix",
            "def": "The pi helix has 4.1 residues per turn and a translation of 1.15  (=0.115 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid five residues earlier. [EBIBS:GAR]"
        },
        "SO:0001119": {
            "name": "three_ten_helix",
            "def": "The 3-10 helix has 3 residues per turn with a translation of 2.0 angstroms (=0.2 nm) along the helical axis. The N-H group of an amino acid forms a hydrogen bond with the C=O group of the amino acid three residues earlier. [EBIBS:GAR]"
        },
        "SO:0001120": {
            "name": "polypeptide_nest_motif",
            "def": "A motif of two consecutive residues with dihedral angles. Nest should not have Proline as any residue. Nests frequently occur as parts of other motifs such as Schellman loops. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001121": {
            "name": "polypeptide_nest_left_right_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001122": {
            "name": "polypeptide_nest_right_left_motif",
            "def": "A motif of two consecutive residues with dihedral angles: Residue(i): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001123": {
            "name": "schellmann_loop",
            "def": "A motif of six or seven consecutive residues that contains two H-bonds. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001124": {
            "name": "schellmann_loop_seven",
            "def": "Wild type: A motif of seven consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+6), the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+5). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001125": {
            "name": "schellmann_loop_six",
            "def": "Common Type: A motif of six consecutive residues that contains two H-bonds in which: the main-chain CO of residue(i) is H-bonded to the main-chain NH of residue(i+5) the main-chain CO of residue(i+1) is H-bonded to the main-chain NH of residue(i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001126": {
            "name": "serine_threonine_motif",
            "def": "A motif of five consecutive residues and two hydrogen bonds in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2) or (i+3) , the main-chain CO group of residue(i) is H-bonded to the main-chain NH of residue(i+3) or (i+4). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001127": {
            "name": "serine_threonine_staple_motif",
            "def": "A motif of four or five consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain OH of residue(i) is H-bonded to the main-chain CO of residue(i3) or (i4), Phi angles of residues(i1), (i2) and (i3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001128": {
            "name": "polypeptide_turn_motif",
            "def": "A reversal in the direction of the backbone of a protein that is stabilized by hydrogen bond between backbone NH and CO groups, involving no more than 4 amino acid residues. [EBIBS:GAR, uniprot:feature_type]"
        },
        "SO:0001129": {
            "name": "asx_turn_left_handed_type_one",
            "def": "Left handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001130": {
            "name": "asx_turn_left_handed_type_two",
            "def": "Left handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001131": {
            "name": "asx_turn_right_handed_type_two",
            "def": "Right handed type II (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, +80 degrees < psi +120 degrees < +180 degrees. Residue(i+1): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001132": {
            "name": "asx_turn_right_handed_type_one",
            "def": "Right handed type I (dihedral angles):- Residue(i): -140 degrees < chi (1) -120 degrees < -20 degrees, -90 degrees < psi +120 degrees < +40 degrees. Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001133": {
            "name": "beta_turn",
            "def": "A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles of the second and third residues, which are the basis for sub-categorization. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001134": {
            "name": "beta_turn_left_handed_type_one",
            "def": "Left handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles:- Residue(i+1): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. Residue(i+2): -140 degrees > phi > -20 degrees, -90 degrees > psi > +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001135": {
            "name": "beta_turn_left_handed_type_two",
            "def": "Left handed type II: A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees > phi > -20 degrees, +80 degrees > psi > +180 degrees. Residue(i+2): +20 degrees > phi > +140 degrees, -40 degrees > psi > +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001136": {
            "name": "beta_turn_right_handed_type_one",
            "def": "Right handed type I:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. Residue(i+2): -140 degrees < phi < -20 degrees, -90 degrees < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001137": {
            "name": "beta_turn_right_handed_type_two",
            "def": "Right handed type II:A motif of four consecutive residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth. It is characterized by the dihedral angles: Residue(i+1): -140 degrees < phi < -20 degrees, +80 degrees < psi < +180 degrees. Residue(i+2): +20 degrees < phi < +140 degrees, -40 degrees < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001138": {
            "name": "gamma_turn",
            "def": "Gamma turns, defined for 3 residues i,( i+1),( i+2) if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001139": {
            "name": "gamma_turn_classic",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=75.0 - psi(i+1)=-64.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001140": {
            "name": "gamma_turn_inverse",
            "def": "Gamma turns, defined for 3 residues i, i+1, i+2 if a hydrogen bond exists between residues i and i+2 and the phi and psi angles of residue i+1 fall within 40 degrees: phi(i+1)=-79.0 - psi(i+1)=69.0. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001141": {
            "name": "serine_threonine_turn",
            "def": "A motif of three consecutive residues and one H-bond in which: residue(i) is Serine (S) or Threonine (T), the side-chain O of residue(i) is H-bonded to the main-chain NH of residue(i+2). [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001142": {
            "name": "st_turn_left_handed_type_one",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001143": {
            "name": "st_turn_left_handed_type_two",
            "def": "The peptide twists in an anticlockwise, left handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001144": {
            "name": "st_turn_right_handed_type_one",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, -90 degrees psi +120 degrees < +40 degrees, residue(i+1): -140 degrees < phi < -20 degrees, -90 < psi < +40 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001145": {
            "name": "st_turn_right_handed_type_two",
            "def": "The peptide twists in an clockwise, right handed manner. The dihedral angles for this turn are: Residue(i): -140 degrees < chi(1) -120 degrees < -20 degrees, +80 degrees psi +120 degrees < +180 degrees, residue(i+1): +20 degrees < phi < +140 degrees, -40 < psi < +90 degrees. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0001146": {
            "name": "polypeptide_variation_site",
            "def": "A site of sequence variation (alteration). Alternative sequence due to naturally occurring events such as polymorphisms and alternative splicing or experimental methods such as site directed mutagenesis. [EBIBS:GAR, SO:ke]"
        },
        "SO:0001147": {
            "name": "natural_variant_site",
            "def": "Describes the natural sequence variants due to polymorphisms, disease-associated mutations, RNA editing and variations between strains, isolates or cultivars. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001148": {
            "name": "mutated_variant_site",
            "def": "Site which has been experimentally altered. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001149": {
            "name": "alternate_sequence_site",
            "def": "Description of sequence variants produced by alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting. [EBIBS:GAR, UniProt:curation_manual]"
        },
        "SO:0001150": {
            "name": "beta_turn_type_six",
            "def": "A motif of four consecutive peptide resides of type VIa or type VIb and where the i+2 residue is cis-proline. [SO:cb]"
        },
        "SO:0001151": {
            "name": "beta_turn_type_six_a",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -90 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001152": {
            "name": "beta_turn_type_six_a_one"
        },
        "SO:0001153": {
            "name": "beta_turn_type_six_a_two"
        },
        "SO:0001154": {
            "name": "beta_turn_type_six_b",
            "def": "A motif of four consecutive peptide residues, of which the i+2 residue is proline, and that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -120 degrees, psi ~ 120 degrees. Residue(i+2): phi ~ -60 degrees, psi ~ 0 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001155": {
            "name": "beta_turn_type_eight",
            "def": "A motif of four consecutive peptide residues that may contain one H-bond, which, if present, is between the main-chain CO of the first residue and the main-chain NH of the fourth and is characterized by the dihedral angles: Residue(i+1): phi ~ -60 degrees, psi ~ -30 degrees. Residue(i+2): phi ~ -120 degrees, psi ~ 120 degrees. [PMID:2371257, SO:cb]"
        },
        "SO:0001156": {
            "name": "DRE_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -10 and -60 relative to the TSS. Consensus sequence is WATCGATW. [PMID:12537576]"
        },
        "SO:0001157": {
            "name": "DMv4_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, located immediately upstream of some TATA box elements with respect to the TSS (+1). Consensus sequence is YGGTCACACTR. Marked spatial preference within core promoter; tend to occur near the TSS, although not as tightly as INR (SO:0000014). [PMID:16827941:12537576]"
        },
        "SO:0001158": {
            "name": "E_box_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and +1 relative to the TSS. Consensus sequence is AWCAGCTGWT. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015). [PMID:12537576:16827941]"
        },
        "SO:0001159": {
            "name": "DMv5_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -50 and -10 relative to the TSS. Consensus sequence is KTYRGTATWTTT. Tends to co-occur with DMv4 (SO:0001157) . Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
        },
        "SO:0001160": {
            "name": "DMv3_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -30 and +15 relative to the TSS. Consensus sequence is KNNCAKCNCTRNY. Tends to co-occur with DMv2 (SO:0001161). Tends to not occur with DPE motif (SO:0000015) or MTE (0001162). [PMID:12537576:16827941]"
        },
        "SO:0001161": {
            "name": "DMv2_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between -60 and -45 relative to the TSS. Consensus sequence is MKSYGGCARCGSYSS. Tends to co-occur with DMv3 (SO:0001160). Tends to not occur with DPE motif (SO:0000015) or MTE (SO:0001162). [PMID:12537576:16827941]"
        },
        "SO:0001162": {
            "name": "MTE",
            "def": "A sequence element characteristic of some RNA polymerase II promoters, usually located between +20 and +30 relative to the TSS. Consensus sequence is CSARCSSAACGS. Tends to co-occur with INR motif (SO:0000014). Tends to not occur with DPE motif (SO:0000015) or DMv5 (SO:0001159). [PMID:12537576:15231738, PMID:16858867]"
        },
        "SO:0001163": {
            "name": "INR1_motif",
            "def": "A promoter motif with consensus sequence TCATTCG. [PMID:16827941]"
        },
        "SO:0001164": {
            "name": "DPE1_motif",
            "def": "A promoter motif with consensus sequence CGGACGT. [PMID:16827941]"
        },
        "SO:0001165": {
            "name": "DMv1_motif",
            "def": "A promoter motif with consensus sequence CARCCCT. [PMID:16827941]"
        },
        "SO:0001166": {
            "name": "GAGA_motif",
            "def": "A non directional promoter motif with consensus sequence GAGAGCG. [PMID:16827941]"
        },
        "SO:0001167": {
            "name": "NDM2_motif",
            "def": "A non directional promoter motif with consensus CGMYGYCR. [PMID:16827941]"
        },
        "SO:0001168": {
            "name": "NDM3_motif",
            "def": "A non directional promoter motif with consensus sequence GAAAGCT. [PMID:16827941]"
        },
        "SO:0001169": {
            "name": "ds_RNA_viral_sequence",
            "def": "A ds_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded RNA. [SO:ke]"
        },
        "SO:0001170": {
            "name": "polinton",
            "def": "A kind of DNA transposon that populates the genomes of protists, fungi, and animals, characterized by a unique set of proteins necessary for their transposition, including a protein-primed DNA polymerase B, retroviral integrase, cysteine protease, and ATPase. Polintons are characterized by 6-bp target site duplications, terminal-inverted repeats that are several hundred nucleotides long, and 5'-AG and TC-3' termini. Polintons exist as autonomous and nonautonomous elements. [PMID:16537396]"
        },
        "SO:0001171": {
            "name": "rRNA_21S",
            "def": "A component of the large ribosomal subunit in mitochondrial rRNA. [RSC:cb]"
        },
        "SO:0001172": {
            "name": "tRNA_region",
            "def": "A region of a tRNA. [RSC:cb]"
        },
        "SO:0001173": {
            "name": "anticodon_loop",
            "def": "A sequence of seven nucleotide bases in tRNA which contains the anticodon. It has the sequence 5'-pyrimidine-purine-anticodon-modified purine-any base-3. [ISBN:0716719207]"
        },
        "SO:0001174": {
            "name": "anticodon",
            "def": "A sequence of three nucleotide bases in tRNA which recognizes a codon in mRNA. [RSC:cb]"
        },
        "SO:0001175": {
            "name": "CCA_tail",
            "def": "Base sequence at the 3' end of a tRNA. The 3'-hydroxyl group on the terminal adenosine is the attachment point for the amino acid. [ISBN:0716719207]"
        },
        "SO:0001176": {
            "name": "DHU_loop",
            "def": "Non-base-paired sequence of nucleotide bases in tRNA. It contains several dihydrouracil residues. [ISBN:071671920]"
        },
        "SO:0001177": {
            "name": "T_loop",
            "def": "Non-base-paired sequence of three nucleotide bases in tRNA. It has sequence T-Psi-C. [ISBN:0716719207]"
        },
        "SO:0001178": {
            "name": "pyrrolysine_tRNA_primary_transcript",
            "def": "A primary transcript encoding pyrrolysyl tRNA (SO:0000766). [RSC:cb]"
        },
        "SO:0001179": {
            "name": "U3_snoRNA",
            "def": "U3 snoRNA is a member of the box C/D class of small nucleolar RNAs. The U3 snoRNA secondary structure is characterised by a small 5' domain (with boxes A and A'), and a larger 3' domain (with boxes B, C, C', and D), the two domains being linked by a single-stranded hinge. Boxes B and C form the B/C motif, which appears to be exclusive to U3 snoRNAs, and boxes C' and D form the C'/D motif. The latter is functionally similar to the C/D motifs found in other snoRNAs. The 5' domain and the hinge region act as a pre-rRNA-binding domain. The 3' domain has conserved protein-binding sites. Both the box B/C and box C'/D motifs are sufficient for nuclear retention of U3 snoRNA. The box C'/D motif is also necessary for nucleolar localization, stability and hypermethylation of U3 snoRNA. Both box B/C and C'/D motifs are involved in specific protein interactions and are necessary for the rRNA processing functions of U3 snoRNA. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00012]"
        },
        "SO:0001180": {
            "name": "AU_rich_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is rich in AUUUA pentamers. Messenger RNAs bearing multiple AU-rich elements are often unstable. [PMID:7892223]"
        },
        "SO:0001181": {
            "name": "Bruno_response_element",
            "def": "A cis-acting element found in the 3' UTR of some mRNA which is bound by the Drosophila Bruno protein and its homologs. [PMID:10893231]"
        },
        "SO:0001182": {
            "name": "iron_responsive_element",
            "def": "A regulatory sequence found in the 5' and 3' UTRs of many mRNAs which encode iron-binding proteins. It has a hairpin structure and is recognized by trans-acting proteins known as iron-regulatory proteins. [PMID:3198610, PMID:8710843]"
        },
        "SO:0001183": {
            "name": "morpholino_backbone",
            "def": "An attribute describing a sequence composed of nucleobases bound to a morpholino backbone. A morpholino backbone consists of morpholine (CHEBI:34856) rings connected by phosphorodiamidate linkages. [RSC:cb]"
        },
        "SO:0001184": {
            "name": "PNA",
            "def": "An attribute describing a sequence composed of peptide nucleic acid (CHEBI:48021), a chemical consisting of nucleobases bound to a backbone composed of repeating N-(2-aminoethyl)-glycine units linked by peptide bonds. The purine and pyrimidine bases are linked to the backbone by methylene carbonyl bonds. [RSC:cb]"
        },
        "SO:0001185": {
            "name": "enzymatic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity with or without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0001186": {
            "name": "ribozymic",
            "def": "An attribute describing the sequence of a transcript that has catalytic activity even without an associated ribonucleoprotein. [RSC:cb]"
        },
        "SO:0001187": {
            "name": "pseudouridylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of pseudouridylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
        },
        "SO:0001188": {
            "name": "LNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of 'locked' deoxyribose rings connected to a phosphate backbone. The deoxyribose unit's conformation is 'locked' by a 2'-C,4'-C-oxymethylene link. [CHEBI:48010]"
        },
        "SO:0001189": {
            "name": "LNA_oligo",
            "def": "An oligo composed of LNA residues. [RSC:cb]"
        },
        "SO:0001190": {
            "name": "TNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of threose rings connected to a phosphate backbone. [CHEBI:48019]"
        },
        "SO:0001191": {
            "name": "TNA_oligo",
            "def": "An oligo composed of TNA residues. [RSC:cb]"
        },
        "SO:0001192": {
            "name": "GNA",
            "def": "An attribute describing a sequence consisting of nucleobases attached to a repeating unit made of an acyclic three-carbon propylene glycol connected to a phosphate backbone. It has two enantiomeric forms, (R)-GNA and (S)-GNA. [CHEBI:48015]"
        },
        "SO:0001193": {
            "name": "GNA_oligo",
            "def": "An oligo composed of GNA residues. [RSC:cb]"
        },
        "SO:0001194": {
            "name": "R_GNA",
            "def": "An attribute describing a GNA sequence in the (R)-GNA enantiomer. [CHEBI:48016]"
        },
        "SO:0001195": {
            "name": "R_GNA_oligo",
            "def": "An oligo composed of (R)-GNA residues. [RSC:cb]"
        },
        "SO:0001196": {
            "name": "S_GNA",
            "def": "An attribute describing a GNA sequence in the (S)-GNA enantiomer. [CHEBI:48017]"
        },
        "SO:0001197": {
            "name": "S_GNA_oligo",
            "def": "An oligo composed of (S)-GNA residues. [RSC:cb]"
        },
        "SO:0001198": {
            "name": "ds_DNA_viral_sequence",
            "def": "A ds_DNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as double stranded DNA. [SO:ke]"
        },
        "SO:0001199": {
            "name": "ss_RNA_viral_sequence",
            "def": "A ss_RNA_viral_sequence is a viral_sequence that is the sequence of a virus that exists as single stranded RNA. [SO:ke]"
        },
        "SO:0001200": {
            "name": "negative_sense_ssRNA_viral_sequence",
            "def": "A negative_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that is complementary to mRNA and must be converted to positive sense RNA by RNA polymerase before translation. [SO:ke]"
        },
        "SO:0001201": {
            "name": "positive_sense_ssRNA_viral_sequence",
            "def": "A positive_sense_RNA_viral_sequence is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus that can be immediately translated by the host. [SO:ke]"
        },
        "SO:0001202": {
            "name": "ambisense_ssRNA_viral_sequence",
            "def": "A ambisense_RNA_virus is a ss_RNA_viral_sequence that is the sequence of a single stranded RNA virus with both messenger and anti messenger polarity. [SO:ke]"
        },
        "SO:0001203": {
            "name": "RNA_polymerase_promoter",
            "def": "A region (DNA) to which RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001204": {
            "name": "Phage_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which Bacteriophage RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001205": {
            "name": "SP6_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the SP6 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001206": {
            "name": "T3_RNA_Polymerase_Promoter",
            "def": "A DNA sequence to which the T3 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001207": {
            "name": "T7_RNA_Polymerase_Promoter",
            "def": "A region (DNA) to which the T7 RNA polymerase binds, to begin transcription. [xenbase:jb]"
        },
        "SO:0001208": {
            "name": "five_prime_EST",
            "def": "An EST read from the 5' end of a transcript that usually codes for a protein. These regions tend to be conserved across species and do not change much within a gene family. [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
        },
        "SO:0001209": {
            "name": "three_prime_EST",
            "def": "An EST read from the 3' end of a transcript. They are more likely to fall within non-coding, or untranslated regions(UTRs). [http://www.ncbi.nlm.nih.gov/About/primer/est.html]"
        },
        "SO:0001210": {
            "name": "translational_frameshift",
            "def": "The region of mRNA (not divisible by 3 bases) that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001211": {
            "name": "plus_1_translational_frameshift",
            "def": "The region of mRNA 1 base long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001212": {
            "name": "plus_2_translational_frameshift",
            "def": "The region of mRNA 2 bases long that is skipped during the process of translational frameshifting (GO:0006452), causing the reading frame to be different. [SO:ke]"
        },
        "SO:0001213": {
            "name": "group_III_intron",
            "def": "Group III introns are introns found in the mRNA of the plastids of euglenoid protists. They are spliced by a two step transesterification with bulged adenosine as initiating nucleophile. [PMID:11377794]"
        },
        "SO:0001214": {
            "name": "noncoding_region_of_exon",
            "def": "The maximal intersection of exon and UTR. [SO:ke]"
        },
        "SO:0001215": {
            "name": "coding_region_of_exon",
            "def": "The region of an exon that encodes for protein sequence. [SO:ke]"
        },
        "SO:0001216": {
            "name": "endonuclease_spliced_intron",
            "def": "An intron that spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
        },
        "SO:0001217": {
            "name": "protein_coding_gene"
        },
        "SO:0001218": {
            "name": "transgenic_insertion",
            "def": "An insertion that derives from another organism, via the use of recombinant DNA technology. [SO:bm]"
        },
        "SO:0001219": {
            "name": "retrogene"
        },
        "SO:0001220": {
            "name": "silenced_by_RNA_interference",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by RNA interference. [RSC:cb]"
        },
        "SO:0001221": {
            "name": "silenced_by_histone_modification",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone modification. [RSC:cb]"
        },
        "SO:0001222": {
            "name": "silenced_by_histone_methylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone methylation. [RSC:cb]"
        },
        "SO:0001223": {
            "name": "silenced_by_histone_deacetylation",
            "def": "An attribute describing an epigenetic process where a gene is inactivated by histone deacetylation. [RSC:cb]"
        },
        "SO:0001224": {
            "name": "gene_silenced_by_RNA_interference",
            "def": "A gene that is silenced by RNA interference. [SO:xp]"
        },
        "SO:0001225": {
            "name": "gene_silenced_by_histone_modification",
            "def": "A gene that is silenced by histone modification. [SO:xp]"
        },
        "SO:0001226": {
            "name": "gene_silenced_by_histone_methylation",
            "def": "A gene that is silenced by histone methylation. [SO:xp]"
        },
        "SO:0001227": {
            "name": "gene_silenced_by_histone_deacetylation",
            "def": "A gene that is silenced by histone deacetylation. [SO:xp]"
        },
        "SO:0001228": {
            "name": "dihydrouridine",
            "def": "A modified RNA base in which the 5,6-dihydrouracil is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001229": {
            "name": "pseudouridine",
            "def": "A modified RNA base in which the 5- position of the uracil is bound to the ribose ring instead of the 4- position. [RSC:cb]"
        },
        "SO:0001230": {
            "name": "inosine",
            "def": "A modified RNA base in which hypoxanthine is bound to the ribose ring. [http://library.med.utah.edu/RNAmods/, RSC:cb]"
        },
        "SO:0001231": {
            "name": "seven_methylguanine",
            "def": "A modified RNA base in which guanine is methylated at the 7- position. [RSC:cb]"
        },
        "SO:0001232": {
            "name": "ribothymidine",
            "def": "A modified RNA base in which thymine is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001233": {
            "name": "methylinosine",
            "def": "A modified RNA base in which methylhypoxanthine is bound to the ribose ring. [RSC:cb]"
        },
        "SO:0001234": {
            "name": "mobile",
            "def": "An attribute describing a feature that has either intra-genome or intracellular mobility. [RSC:cb]"
        },
        "SO:0001235": {
            "name": "replicon",
            "def": "A region containing at least one unique origin of replication and a unique termination site. [ISBN:0716719207]"
        },
        "SO:0001236": {
            "name": "base",
            "def": "A base is a sequence feature that corresponds to a single unit of a nucleotide polymer. [SO:ke]"
        },
        "SO:0001237": {
            "name": "amino_acid",
            "def": "A sequence feature that corresponds to a single amino acid residue in a polypeptide. [RSC:cb]"
        },
        "SO:0001238": {
            "name": "major_TSS"
        },
        "SO:0001239": {
            "name": "minor_TSS"
        },
        "SO:0001240": {
            "name": "TSS_region",
            "def": "The region of a gene from the 5' most TSS to the 3' TSS. [BBOP:nw]"
        },
        "SO:0001241": {
            "name": "encodes_alternate_transcription_start_sites"
        },
        "SO:0001243": {
            "name": "miRNA_primary_transcript_region",
            "def": "A part of an miRNA primary_transcript. [SO:ke]"
        },
        "SO:0001244": {
            "name": "pre_miRNA",
            "def": "The 60-70 nucleotide region remain after Drosha processing of the primary transcript, that folds back upon itself to form a hairpin structure. [SO:ke]"
        },
        "SO:0001245": {
            "name": "miRNA_stem",
            "def": "The stem of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
        },
        "SO:0001246": {
            "name": "miRNA_loop",
            "def": "The loop of the hairpin loop formed by folding of the pre-miRNA. [SO:ke]"
        },
        "SO:0001247": {
            "name": "synthetic_oligo",
            "def": "An oligo composed of synthetic nucleotides. [SO:ke]"
        },
        "SO:0001248": {
            "name": "assembly",
            "def": "A region of the genome of known length that is composed by ordering and aligning two or more different regions. [SO:ke]"
        },
        "SO:0001249": {
            "name": "fragment_assembly",
            "def": "A fragment assembly is a genome assembly that orders overlapping fragments of the genome based on landmark sequences. The base pair distance between the landmarks is known allowing additivity of lengths. [SO:ke]"
        },
        "SO:0001250": {
            "name": "fingerprint_map",
            "def": "A fingerprint_map is a physical map composed of restriction fragments. [SO:ke]"
        },
        "SO:0001251": {
            "name": "STS_map",
            "def": "An STS map is a physical map organized by the unique STS landmarks. [SO:ke]"
        },
        "SO:0001252": {
            "name": "RH_map",
            "def": "A radiation hybrid map is a physical map. [SO:ke]"
        },
        "SO:0001253": {
            "name": "sonicate_fragment",
            "def": "A DNA fragment generated by sonication. Sonication is a technique used to sheer DNA into smaller fragments. [SO:ke]"
        },
        "SO:0001254": {
            "name": "polyploid",
            "def": "A kind of chromosome variation where the chromosome complement is an exact multiple of the haploid number and is greater than the diploid number. [SO:ke]"
        },
        "SO:0001255": {
            "name": "autopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from the same organism. [SO:ke]"
        },
        "SO:0001256": {
            "name": "allopolyploid",
            "def": "A polyploid where the multiple chromosome set was derived from a different organism. [SO:ke]"
        },
        "SO:0001257": {
            "name": "homing_endonuclease_binding_site",
            "def": "The binding site (recognition site) of a homing endonuclease. The binding site is typically large. [SO:ke]"
        },
        "SO:0001258": {
            "name": "octamer_motif",
            "def": "A sequence element characteristic of some RNA polymerase II promoters with sequence ATTGCAT that binds Pou-domain transcription factors. [GOC:dh, PMID:3095662]"
        },
        "SO:0001259": {
            "name": "apicoplast_chromosome",
            "def": "A chromosome originating in an apicoplast. [SO:xp]"
        },
        "SO:0001260": {
            "name": "sequence_collection",
            "def": "A collection of discontinuous sequences. [SO:ke]"
        },
        "SO:0001261": {
            "name": "overlapping_feature_set",
            "def": "A continuous region of sequence composed of the overlapping of multiple sequence_features, which ultimately provides evidence for another sequence_feature. [SO:ke]"
        },
        "SO:0001262": {
            "name": "overlapping_EST_set",
            "def": "A continous experimental result region extending the length of multiple overlapping EST's. [SO:ke]"
        },
        "SO:0001263": {
            "name": "ncRNA_gene"
        },
        "SO:0001264": {
            "name": "gRNA_gene"
        },
        "SO:0001265": {
            "name": "miRNA_gene"
        },
        "SO:0001266": {
            "name": "scRNA_gene"
        },
        "SO:0001267": {
            "name": "snoRNA_gene"
        },
        "SO:0001268": {
            "name": "snRNA_gene"
        },
        "SO:0001269": {
            "name": "SRP_RNA_gene"
        },
        "SO:0001271": {
            "name": "tmRNA_gene"
        },
        "SO:0001272": {
            "name": "tRNA_gene"
        },
        "SO:0001273": {
            "name": "modified_adenosine",
            "def": "A modified adenine is an adenine base feature that has been altered. [SO:ke]"
        },
        "SO:0001274": {
            "name": "modified_inosine",
            "def": "A modified inosine is an inosine base feature that has been altered. [SO:ke]"
        },
        "SO:0001275": {
            "name": "modified_cytidine",
            "def": "A modified cytidine is a cytidine base feature which has been altered. [SO:ke]"
        },
        "SO:0001276": {
            "name": "modified_guanosine"
        },
        "SO:0001277": {
            "name": "modified_uridine"
        },
        "SO:0001278": {
            "name": "one_methylinosine",
            "def": "1-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001279": {
            "name": "one_two_prime_O_dimethylinosine",
            "def": "1,2'-O-dimethylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001280": {
            "name": "two_prime_O_methylinosine",
            "def": "2'-O-methylinosine is a modified inosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001281": {
            "name": "three_methylcytidine",
            "def": "3-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001282": {
            "name": "five_methylcytidine",
            "def": "5-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001283": {
            "name": "two_prime_O_methylcytidine",
            "def": "2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001284": {
            "name": "two_thiocytidine",
            "def": "2-thiocytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001285": {
            "name": "N4_acetylcytidine",
            "def": "N4-acetylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001286": {
            "name": "five_formylcytidine",
            "def": "5-formylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001287": {
            "name": "five_two_prime_O_dimethylcytidine",
            "def": "5,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001288": {
            "name": "N4_acetyl_2_prime_O_methylcytidine",
            "def": "N4-acetyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001289": {
            "name": "lysidine",
            "def": "Lysidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001290": {
            "name": "N4_methylcytidine",
            "def": "N4-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001291": {
            "name": "N4_2_prime_O_dimethylcytidine",
            "def": "N4,2'-O-dimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001292": {
            "name": "five_hydroxymethylcytidine",
            "def": "5-hydroxymethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001293": {
            "name": "five_formyl_two_prime_O_methylcytidine",
            "def": "5-formyl-2'-O-methylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001294": {
            "name": "N4_N4_2_prime_O_trimethylcytidine",
            "def": "N4_N4_2_prime_O_trimethylcytidine is a modified cytidine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001295": {
            "name": "one_methyladenosine",
            "def": "1_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001296": {
            "name": "two_methyladenosine",
            "def": "2_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001297": {
            "name": "N6_methyladenosine",
            "def": "N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001298": {
            "name": "two_prime_O_methyladenosine",
            "def": "2prime_O_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001299": {
            "name": "two_methylthio_N6_methyladenosine",
            "def": "2_methylthio_N6_methyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001300": {
            "name": "N6_isopentenyladenosine",
            "def": "N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001301": {
            "name": "two_methylthio_N6_isopentenyladenosine",
            "def": "2_methylthio_N6_isopentenyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001302": {
            "name": "N6_cis_hydroxyisopentenyl_adenosine",
            "def": "N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001303": {
            "name": "two_methylthio_N6_cis_hydroxyisopentenyl_adenosine",
            "def": "2_methylthio_N6_cis_hydroxyisopentenyl_adenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001304": {
            "name": "N6_glycinylcarbamoyladenosine",
            "def": "N6_glycinylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001305": {
            "name": "N6_threonylcarbamoyladenosine",
            "def": "N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001306": {
            "name": "two_methylthio_N6_threonyl_carbamoyladenosine",
            "def": "2_methylthio_N6_threonyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001307": {
            "name": "N6_methyl_N6_threonylcarbamoyladenosine",
            "def": "N6_methyl_N6_threonylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001308": {
            "name": "N6_hydroxynorvalylcarbamoyladenosine",
            "def": "N6_hydroxynorvalylcarbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001309": {
            "name": "two_methylthio_N6_hydroxynorvalyl_carbamoyladenosine",
            "def": "2_methylthio_N6_hydroxynorvalyl_carbamoyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001310": {
            "name": "two_prime_O_ribosyladenosine_phosphate",
            "def": "2prime_O_ribosyladenosine_phosphate is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001311": {
            "name": "N6_N6_dimethyladenosine",
            "def": "N6_N6_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001312": {
            "name": "N6_2_prime_O_dimethyladenosine",
            "def": "N6_2prime_O_dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001313": {
            "name": "N6_N6_2_prime_O_trimethyladenosine",
            "def": "N6_N6_2prime_O_trimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001314": {
            "name": "one_two_prime_O_dimethyladenosine",
            "def": "1,2'-O-dimethyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001315": {
            "name": "N6_acetyladenosine",
            "def": "N6_acetyladenosine is a modified adenosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001316": {
            "name": "seven_deazaguanosine",
            "def": "7-deazaguanosine is a modified guanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001317": {
            "name": "queuosine",
            "def": "Queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001318": {
            "name": "epoxyqueuosine",
            "def": "Epoxyqueuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001319": {
            "name": "galactosyl_queuosine",
            "def": "Galactosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001320": {
            "name": "mannosyl_queuosine",
            "def": "Mannosyl_queuosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001321": {
            "name": "seven_cyano_seven_deazaguanosine",
            "def": "7_cyano_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001322": {
            "name": "seven_aminomethyl_seven_deazaguanosine",
            "def": "7_aminomethyl_7_deazaguanosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001323": {
            "name": "archaeosine",
            "def": "Archaeosine is a modified 7-deazoguanosine. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001324": {
            "name": "one_methylguanosine",
            "def": "1_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001325": {
            "name": "N2_methylguanosine",
            "def": "N2_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001326": {
            "name": "seven_methylguanosine",
            "def": "7_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001327": {
            "name": "two_prime_O_methylguanosine",
            "def": "2prime_O_methylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001328": {
            "name": "N2_N2_dimethylguanosine",
            "def": "N2_N2_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001329": {
            "name": "N2_2_prime_O_dimethylguanosine",
            "def": "N2_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001330": {
            "name": "N2_N2_2_prime_O_trimethylguanosine",
            "def": "N2_N2_2prime_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001331": {
            "name": "two_prime_O_ribosylguanosine_phosphate",
            "def": "2prime_O_ribosylguanosine_phosphate is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001332": {
            "name": "wybutosine",
            "def": "Wybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001333": {
            "name": "peroxywybutosine",
            "def": "Peroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001334": {
            "name": "hydroxywybutosine",
            "def": "Hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001335": {
            "name": "undermodified_hydroxywybutosine",
            "def": "Undermodified_hydroxywybutosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001336": {
            "name": "wyosine",
            "def": "Wyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001337": {
            "name": "methylwyosine",
            "def": "Methylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001338": {
            "name": "N2_7_dimethylguanosine",
            "def": "N2_7_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001339": {
            "name": "N2_N2_7_trimethylguanosine",
            "def": "N2_N2_7_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001340": {
            "name": "one_two_prime_O_dimethylguanosine",
            "def": "1_2prime_O_dimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001341": {
            "name": "four_demethylwyosine",
            "def": "4_demethylwyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001342": {
            "name": "isowyosine",
            "def": "Isowyosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001343": {
            "name": "N2_7_2prirme_O_trimethylguanosine",
            "def": "N2_7_2prirme_O_trimethylguanosine is a modified guanosine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001344": {
            "name": "five_methyluridine",
            "def": "5_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001345": {
            "name": "two_prime_O_methyluridine",
            "def": "2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001346": {
            "name": "five_two_prime_O_dimethyluridine",
            "def": "5_2_prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001347": {
            "name": "one_methylpseudouridine",
            "def": "1_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001348": {
            "name": "two_prime_O_methylpseudouridine",
            "def": "2prime_O_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001349": {
            "name": "two_thiouridine",
            "def": "2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001350": {
            "name": "four_thiouridine",
            "def": "4_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001351": {
            "name": "five_methyl_2_thiouridine",
            "def": "5_methyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001352": {
            "name": "two_thio_two_prime_O_methyluridine",
            "def": "2_thio_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001353": {
            "name": "three_three_amino_three_carboxypropyl_uridine",
            "def": "3_3_amino_3_carboxypropyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001354": {
            "name": "five_hydroxyuridine",
            "def": "5_hydroxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001355": {
            "name": "five_methoxyuridine",
            "def": "5_methoxyuridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001356": {
            "name": "uridine_five_oxyacetic_acid",
            "def": "Uridine_5_oxyacetic_acid is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001357": {
            "name": "uridine_five_oxyacetic_acid_methyl_ester",
            "def": "Uridine_5_oxyacetic_acid_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001358": {
            "name": "five_carboxyhydroxymethyl_uridine",
            "def": "5_carboxyhydroxymethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001359": {
            "name": "five_carboxyhydroxymethyl_uridine_methyl_ester",
            "def": "5_carboxyhydroxymethyl_uridine_methyl_ester is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001360": {
            "name": "five_methoxycarbonylmethyluridine",
            "def": "Five_methoxycarbonylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001361": {
            "name": "five_methoxycarbonylmethyl_two_prime_O_methyluridine",
            "def": "Five_methoxycarbonylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001362": {
            "name": "five_methoxycarbonylmethyl_two_thiouridine",
            "def": "5_methoxycarbonylmethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001363": {
            "name": "five_aminomethyl_two_thiouridine",
            "def": "5_aminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001364": {
            "name": "five_methylaminomethyluridine",
            "def": "5_methylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001365": {
            "name": "five_methylaminomethyl_two_thiouridine",
            "def": "5_methylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001366": {
            "name": "five_methylaminomethyl_two_selenouridine",
            "def": "5_methylaminomethyl_2_selenouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001367": {
            "name": "five_carbamoylmethyluridine",
            "def": "5_carbamoylmethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001368": {
            "name": "five_carbamoylmethyl_two_prime_O_methyluridine",
            "def": "5_carbamoylmethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001369": {
            "name": "five_carboxymethylaminomethyluridine",
            "def": "5_carboxymethylaminomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001370": {
            "name": "five_carboxymethylaminomethyl_two_prime_O_methyluridine",
            "def": "5_carboxymethylaminomethyl_2_prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001371": {
            "name": "five_carboxymethylaminomethyl_two_thiouridine",
            "def": "5_carboxymethylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001372": {
            "name": "three_methyluridine",
            "def": "3_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001373": {
            "name": "one_methyl_three_three_amino_three_carboxypropyl_pseudouridine",
            "def": "1_methyl_3_3_amino_3_carboxypropyl_pseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001374": {
            "name": "five_carboxymethyluridine",
            "def": "5_carboxymethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001375": {
            "name": "three_two_prime_O_dimethyluridine",
            "def": "3_2prime_O_dimethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001376": {
            "name": "five_methyldihydrouridine",
            "def": "5_methyldihydrouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001377": {
            "name": "three_methylpseudouridine",
            "def": "3_methylpseudouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001378": {
            "name": "five_taurinomethyluridine",
            "def": "5_taurinomethyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001379": {
            "name": "five_taurinomethyl_two_thiouridine",
            "def": "5_taurinomethyl_2_thiouridineis a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001380": {
            "name": "five_isopentenylaminomethyl_uridine",
            "def": "5_isopentenylaminomethyl_uridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001381": {
            "name": "five_isopentenylaminomethyl_two_thiouridine",
            "def": "5_isopentenylaminomethyl_2_thiouridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001382": {
            "name": "five_isopentenylaminomethyl_two_prime_O_methyluridine",
            "def": "5_isopentenylaminomethyl_2prime_O_methyluridine is a modified uridine base feature. [http://library.med.utah.edu/RNAmods/]"
        },
        "SO:0001383": {
            "name": "histone_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues of a histone. [SO:ke]"
        },
        "SO:0001384": {
            "name": "CDS_fragment"
        },
        "SO:0001385": {
            "name": "modified_amino_acid_feature",
            "def": "A post translationally modified amino acid feature. [SO:ke]"
        },
        "SO:0001386": {
            "name": "modified_glycine",
            "def": "A post translationally modified glycine amino acid feature. [SO:ke]"
        },
        "SO:0001387": {
            "name": "modified_L_alanine",
            "def": "A post translationally modified alanine amino acid feature. [SO:ke]"
        },
        "SO:0001388": {
            "name": "modified_L_asparagine",
            "def": "A post translationally modified asparagine amino acid feature. [SO:ke]"
        },
        "SO:0001389": {
            "name": "modified_L_aspartic_acid",
            "def": "A post translationally modified aspartic acid amino acid feature. [SO:ke]"
        },
        "SO:0001390": {
            "name": "modified_L_cysteine",
            "def": "A post translationally modified cysteine amino acid feature. [SO:ke]"
        },
        "SO:0001391": {
            "name": "modified_L_glutamic_acid"
        },
        "SO:0001392": {
            "name": "modified_L_threonine",
            "def": "A post translationally modified threonine amino acid feature. [SO:ke]"
        },
        "SO:0001393": {
            "name": "modified_L_tryptophan",
            "def": "A post translationally modified tryptophan amino acid feature. [SO:ke]"
        },
        "SO:0001394": {
            "name": "modified_L_glutamine",
            "def": "A post translationally modified glutamine amino acid feature. [SO:ke]"
        },
        "SO:0001395": {
            "name": "modified_L_methionine",
            "def": "A post translationally modified methionine amino acid feature. [SO:ke]"
        },
        "SO:0001396": {
            "name": "modified_L_isoleucine",
            "def": "A post translationally modified isoleucine amino acid feature. [SO:ke]"
        },
        "SO:0001397": {
            "name": "modified_L_phenylalanine",
            "def": "A post translationally modified phenylalanine amino acid feature. [SO:ke]"
        },
        "SO:0001398": {
            "name": "modified_L_histidine",
            "def": "A post translationally modified histidine amino acid feature. [SO:ke]"
        },
        "SO:0001399": {
            "name": "modified_L_serine",
            "def": "A post translationally modified serine amino acid feature. [SO:ke]"
        },
        "SO:0001400": {
            "name": "modified_L_lysine",
            "def": "A post translationally modified lysine amino acid feature. [SO:ke]"
        },
        "SO:0001401": {
            "name": "modified_L_leucine",
            "def": "A post translationally modified leucine amino acid feature. [SO:ke]"
        },
        "SO:0001402": {
            "name": "modified_L_selenocysteine",
            "def": "A post translationally modified selenocysteine amino acid feature. [SO:ke]"
        },
        "SO:0001403": {
            "name": "modified_L_valine",
            "def": "A post translationally modified valine amino acid feature. [SO:ke]"
        },
        "SO:0001404": {
            "name": "modified_L_proline",
            "def": "A post translationally modified proline amino acid feature. [SO:ke]"
        },
        "SO:0001405": {
            "name": "modified_L_tyrosine",
            "def": "A post translationally modified tyrosine amino acid feature. [SO:ke]"
        },
        "SO:0001406": {
            "name": "modified_L_arginine",
            "def": "A post translationally modified arginine amino acid feature. [SO:ke]"
        },
        "SO:0001407": {
            "name": "peptidyl",
            "def": "An attribute describing the nature of a proteinaceous polymer, where by the amino acid units are joined by peptide bonds. [SO:ke]"
        },
        "SO:0001408": {
            "name": "cleaved_for_gpi_anchor_region",
            "def": "The C-terminal residues of a polypeptide which are exchanged for a GPI-anchor. [EBI:rh]"
        },
        "SO:0001409": {
            "name": "biomaterial_region",
            "def": "A region which is intended for use in an experiment. [SO:cb]"
        },
        "SO:0001410": {
            "name": "experimental_feature",
            "def": "A region which is the result of some arbitrary experimental procedure. The procedure may be carried out with biological material or inside a computer. [SO:cb]"
        },
        "SO:0001411": {
            "name": "biological_region",
            "def": "A region defined by its disposition to be involved in a biological process. [SO:cb]"
        },
        "SO:0001412": {
            "name": "topologically_defined_region",
            "def": "A region that is defined according to its relations with other regions within the same sequence. [SO:cb]"
        },
        "SO:0001413": {
            "name": "translocation_breakpoint",
            "def": "The point within a chromosome where a translocation begins or ends. [SO:cb]"
        },
        "SO:0001414": {
            "name": "insertion_breakpoint",
            "def": "The point within a chromosome where a insertion begins or ends. [SO:cb]"
        },
        "SO:0001415": {
            "name": "deletion_breakpoint",
            "def": "The point within a chromosome where a deletion begins or ends. [SO:cb]"
        },
        "SO:0001416": {
            "name": "five_prime_flanking_region",
            "def": "A flanking region located five prime of a specific region. [SO:chado]"
        },
        "SO:0001417": {
            "name": "three_prime_flanking_region",
            "def": "A flanking region located three prime of a specific region. [SO:chado]"
        },
        "SO:0001418": {
            "name": "transcribed_fragment",
            "def": "An experimental region, defined by a tiling array experiment to be transcribed at some level. [SO:ke]"
        },
        "SO:0001419": {
            "name": "cis_splice_site",
            "def": "Intronic 2 bp region bordering exon. A splice_site that adjacent_to exon and overlaps intron. [SO:cjm, SO:ke]"
        },
        "SO:0001420": {
            "name": "trans_splice_site",
            "def": "Primary transcript region bordering trans-splice junction. [SO:ke]"
        },
        "SO:0001421": {
            "name": "splice_junction",
            "def": "The boundary between an intron and an exon. [SO:ke]"
        },
        "SO:0001422": {
            "name": "conformational_switch",
            "def": "A region of a polypeptide, involved in the transition from one conformational state to another. [SO:ke]"
        },
        "SO:0001423": {
            "name": "dye_terminator_read",
            "def": "A read produced by the dye terminator method of sequencing. [SO:ke]"
        },
        "SO:0001424": {
            "name": "pyrosequenced_read",
            "def": "A read produced by pyrosequencing technology. [SO:ke]"
        },
        "SO:0001425": {
            "name": "ligation_based_read",
            "def": "A read produced by ligation based sequencing technologies. [SO:ke]"
        },
        "SO:0001426": {
            "name": "polymerase_synthesis_read",
            "def": "A read produced by the polymerase based sequence by synthesis method. [SO:ke]"
        },
        "SO:0001427": {
            "name": "cis_regulatory_frameshift_element",
            "def": "A structural region in an RNA molecule which promotes ribosomal frameshifting of cis coding sequence. [RFAM:jd]"
        },
        "SO:0001428": {
            "name": "expressed_sequence_assembly",
            "def": "A sequence assembly derived from expressed sequences. [SO:ke]"
        },
        "SO:0001429": {
            "name": "DNA_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with DNA. [SO:ke]"
        },
        "SO:0001431": {
            "name": "cryptic_gene",
            "def": "A gene that is not transcribed under normal conditions and is not critical to normal cellular functioning. [SO:ke]"
        },
        "SO:0001432": {
            "name": "sequence_variant_affecting_polyadenylation"
        },
        "SO:0001433": {
            "name": "three_prime_RACE_clone",
            "def": "A three prime RACE (Rapid Amplification of cDNA Ends) clone is a cDNA clone copied from the 3' end of an mRNA (using a poly-dT primer to capture the polyA tail and a gene-specific or randomly primed 5' primer), and spliced into a vector for propagation in a suitable host. [modENCODE:nlw]"
        },
        "SO:0001434": {
            "name": "cassette_pseudogene",
            "def": "A cassette pseudogene is a kind of gene in an inactive form which may recombine at a telomeric locus to form a functional copy. [SO:ke]"
        },
        "SO:0001435": {
            "name": "alanine"
        },
        "SO:0001436": {
            "name": "valine"
        },
        "SO:0001437": {
            "name": "leucine"
        },
        "SO:0001438": {
            "name": "isoleucine"
        },
        "SO:0001439": {
            "name": "proline"
        },
        "SO:0001440": {
            "name": "tryptophan"
        },
        "SO:0001441": {
            "name": "phenylalanine"
        },
        "SO:0001442": {
            "name": "methionine"
        },
        "SO:0001443": {
            "name": "glycine"
        },
        "SO:0001444": {
            "name": "serine"
        },
        "SO:0001445": {
            "name": "threonine"
        },
        "SO:0001446": {
            "name": "tyrosine"
        },
        "SO:0001447": {
            "name": "cysteine"
        },
        "SO:0001448": {
            "name": "glutamine"
        },
        "SO:0001449": {
            "name": "asparagine"
        },
        "SO:0001450": {
            "name": "lysine"
        },
        "SO:0001451": {
            "name": "arginine"
        },
        "SO:0001452": {
            "name": "histidine"
        },
        "SO:0001453": {
            "name": "aspartic_acid"
        },
        "SO:0001454": {
            "name": "glutamic_acid"
        },
        "SO:0001455": {
            "name": "selenocysteine"
        },
        "SO:0001456": {
            "name": "pyrrolysine"
        },
        "SO:0001457": {
            "name": "transcribed_cluster",
            "def": "A region defined by a set of transcribed sequences from the same gene or expressed pseudogene. [SO:ke]"
        },
        "SO:0001458": {
            "name": "unigene_cluster",
            "def": "A kind of transcribed_cluster defined by a set of transcribed sequences from the a unique gene. [SO:ke]"
        },
        "SO:0001459": {
            "name": "CRISPR",
            "def": "Clustered Palindromic Repeats interspersed with bacteriophage derived spacer sequences. [RFAM:jd]"
        },
        "SO:0001460": {
            "name": "insulator_binding_site",
            "def": "A binding site that, in an insulator region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001461": {
            "name": "enhancer_binding_site",
            "def": "A binding site that, in the enhancer region of a nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001462": {
            "name": "contig_collection",
            "def": "A collection of contigs. [SO:ke]"
        },
        "SO:0001463": {
            "name": "lincRNA",
            "def": "A multiexonic non-coding RNA transcribed by RNA polymerase II. [PMID:19182780, SO:ke]"
        },
        "SO:0001464": {
            "name": "UST",
            "def": "An EST spanning part or all of the untranslated regions of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001465": {
            "name": "three_prime_UST",
            "def": "A UST located in the 3'UTR of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001466": {
            "name": "five_prime_UST",
            "def": "An UST located in the 5'UTR of a protein-coding transcript. [SO:nlw]"
        },
        "SO:0001467": {
            "name": "RST",
            "def": "A tag produced from a single sequencing read from a RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001468": {
            "name": "three_prime_RST",
            "def": "A tag produced from a single sequencing read from a 3'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001469": {
            "name": "five_prime_RST",
            "def": "A tag produced from a single sequencing read from a 5'-RACE product; typically a few hundred base pairs long. [SO:nlw]"
        },
        "SO:0001470": {
            "name": "UST_match",
            "def": "A match against an UST sequence. [SO:nlw]"
        },
        "SO:0001471": {
            "name": "RST_match",
            "def": "A match against an RST sequence. [SO:nlw]"
        },
        "SO:0001472": {
            "name": "primer_match",
            "def": "A nucleotide match to a primer sequence. [SO:nlw]"
        },
        "SO:0001473": {
            "name": "miRNA_antiguide",
            "def": "A region of the pri miRNA that base pairs with the guide to form the hairpin. [SO:ke]"
        },
        "SO:0001474": {
            "name": "trans_splice_junction",
            "def": "The boundary between the spliced leader and the first exon of the mRNA. [SO:ke]"
        },
        "SO:0001475": {
            "name": "outron",
            "def": "A region of a primary transcript, that is removed via trans splicing. [PMID:16401417, SO:ke]"
        },
        "SO:0001476": {
            "name": "natural_plasmid",
            "def": "A plasmid that occurs naturally. [SO:xp]"
        },
        "SO:0001477": {
            "name": "gene_trap_construct",
            "def": "A gene trap construct is a type of engineered plasmid which is designed to integrate into a genome and produce a fusion transcript between exons of the gene into which it inserts and a reporter element in the construct. Gene traps contain a splice acceptor, do not contain promoter elements for the reporter, and are mutagenic. Gene traps may be bicistronic with the second cassette containing a promoter driving an a selectable marker. [ZFIN:dh]"
        },
        "SO:0001478": {
            "name": "promoter_trap_construct",
            "def": "A promoter trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when inserted in close proximity to a promoter element. Promoter traps typically do not contain promoter elements and are mutagenic. [ZFIN:dh]"
        },
        "SO:0001479": {
            "name": "enhancer_trap_construct",
            "def": "An enhancer trap construct is a type of engineered plasmid which is designed to integrate into a genome and express a reporter when the expression from a basic minimal promoter is enhanced by genomic enhancer elements. Enhancer traps contain promoter elements and are not usually mutagenic. [ZFIN:dh]"
        },
        "SO:0001480": {
            "name": "PAC_end",
            "def": "A region of sequence from the end of a PAC clone that may provide a highly specific marker. [ZFIN:mh]"
        },
        "SO:0001481": {
            "name": "RAPD",
            "def": "RAPD is a 'PCR product' where a sequence variant is identified through the use of PCR with random primers. [ZFIN:mh]"
        },
        "SO:0001482": {
            "name": "shadow_enhancer"
        },
        "SO:0001483": {
            "name": "SNV",
            "def": "SNVs are single nucleotide positions in genomic DNA at which different sequence alternatives exist. [SO:bm]"
        },
        "SO:0001484": {
            "name": "X_element_combinatorial_repeat",
            "def": "An X element combinatorial repeat is a repeat region located between the X element and the telomere or adjacent Y' element. [http://www.yeastgenome.org/help/glossary.html]"
        },
        "SO:0001485": {
            "name": "Y_prime_element",
            "def": "A Y' element is a repeat region (SO:0000657) located adjacent to telomeric repeats or X element combinatorial repeats, either as a single copy or tandem repeat of two to four copies. [http:http://www.yeastgenome.org/help/glossary.html]"
        },
        "SO:0001486": {
            "name": "standard_draft",
            "def": "The status of a whole genome sequence, where the data is minimally filtered or un-filtered, from any number of sequencing platforms, and is assembled into contigs. Genome sequence of this quality may harbour regions of poor quality and can be relatively incomplete. [DOI:10.1126]"
        },
        "SO:0001487": {
            "name": "high_quality_draft",
            "def": "The status of a whole genome sequence, where overall coverage represents at least 90 percent of the genome. [DOI:10.1126]"
        },
        "SO:0001488": {
            "name": "improved_high_quality_draft",
            "def": "The status of a whole genome sequence, where additional work has been performed, using either manual or automated methods, such as gap resolution. [DOI:10.1126]"
        },
        "SO:0001489": {
            "name": "annotation_directed_improved_draft",
            "def": "The status of a whole genome sequence,where annotation, and verification of coding regions has occurred. [DOI:10.1126]"
        },
        "SO:0001490": {
            "name": "noncontiguous_finished",
            "def": "The status of a whole genome sequence, where the assembly is high quality, closure approaches have been successful for most gaps, misassemblies and low quality regions. [DOI:10.1126]"
        },
        "SO:0001491": {
            "name": "finished_genome",
            "def": "The status of a whole genome sequence, with less than 1 error per 100,000 base pairs. [DOI:10.1126]"
        },
        "SO:0001492": {
            "name": "intronic_regulatory_region",
            "def": "A regulatory region that is part of an intron. [SO:ke]"
        },
        "SO:0001493": {
            "name": "centromere_DNA_Element_I",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region composed of 8-11bp which enables binding by the centromere binding factor 1(Cbf1p). [PMID:11222754]"
        },
        "SO:0001494": {
            "name": "centromere_DNA_Element_II",
            "def": "A centromere DNA Element II (CDEII) is part a conserved region of the centromere, consisting of a consensus region that is AT-rich and ~ 75-100 bp in length. [PMID:11222754]"
        },
        "SO:0001495": {
            "name": "centromere_DNA_Element_III",
            "def": "A centromere DNA Element I (CDEI) is a conserved region, part of the centromere, consisting of a consensus region that consists of a 25-bp which enables binding by the centromere DNA binding factor 3 (CBF3) complex. [PMID:11222754]"
        },
        "SO:0001496": {
            "name": "telomeric_repeat",
            "def": "The telomeric repeat is a repeat region, part of the chromosome, which in yeast, is a G-rich terminal sequence of the form (TG(1-3))n or more precisely ((TG)(1-6)TG(2-3))n. [PMID:8720065]"
        },
        "SO:0001497": {
            "name": "X_element",
            "def": "The X element is a conserved region, of the telomere, of ~475 bp that contains an ARS sequence and in most cases an Abf1p binding site. [http://www.yeastgenome.org/help/glossary.html#xelemcoresequence, PMID:7785338, PMID:8005434]"
        },
        "SO:0001498": {
            "name": "YAC_end",
            "def": "A region of sequence from the end of a YAC clone that may provide a highly specific marker. [SO:ke]"
        },
        "SO:0001499": {
            "name": "whole_genome_sequence_status",
            "def": "The status of whole genome sequence. [DOI:10.1126]"
        },
        "SO:0001500": {
            "name": "heritable_phenotypic_marker",
            "def": "A biological_region characterized as a single heritable trait in a phenotype screen. The heritable phenotype may be mapped to a chromosome but generally has not been characterized to a specific gene locus. [JAX:hdene]"
        },
        "SO:0001501": {
            "name": "peptide_collection",
            "def": "A collection of peptide sequences. [BBOP:nlw]"
        },
        "SO:0001502": {
            "name": "high_identity_region",
            "def": "An experimental feature with high sequence identity to another sequence. [SO:ke]"
        },
        "SO:0001503": {
            "name": "processed_transcript",
            "def": "A transcript for which no open reading frame has been identified and for which no other function has been determined. [MGI:hdeen]"
        },
        "SO:0001504": {
            "name": "assortment_derived_variation",
            "def": "A chromosome variation derived from an event during meiosis. [SO:ke]"
        },
        "SO:0001505": {
            "name": "reference_genome",
            "def": "A collection of sequences (often chromosomes) taken as the standard for a given organism and genome assembly. [SO:ke]"
        },
        "SO:0001506": {
            "name": "variant_genome",
            "def": "A collection of sequences (often chromosomes) of an individual. [SO:ke]"
        },
        "SO:0001507": {
            "name": "variant_collection",
            "def": "A collection of one or more sequences of an individual. [SO:ke]"
        },
        "SO:0001508": {
            "name": "alteration_attribute"
        },
        "SO:0001509": {
            "name": "chromosomal_variation_attribute"
        },
        "SO:0001510": {
            "name": "intrachromosomal"
        },
        "SO:0001511": {
            "name": "interchromosomal"
        },
        "SO:0001512": {
            "name": "insertion_attribute",
            "def": "A quality of a chromosomal insertion,. [SO:ke]"
        },
        "SO:0001513": {
            "name": "tandem"
        },
        "SO:0001514": {
            "name": "direct",
            "def": "A quality of an insertion where the insert is not in a cytologically inverted orientation. [SO:ke]"
        },
        "SO:0001515": {
            "name": "inverted",
            "def": "A quality of an insertion where the insert is in a cytologically inverted orientation. [SO:ke]"
        },
        "SO:0001516": {
            "name": "free",
            "def": "The quality of a duplication where the new region exists independently of the original. [SO:ke]"
        },
        "SO:0001517": {
            "name": "inversion_attribute"
        },
        "SO:0001518": {
            "name": "pericentric"
        },
        "SO:0001519": {
            "name": "paracentric"
        },
        "SO:0001520": {
            "name": "translocaton_attribute"
        },
        "SO:0001521": {
            "name": "reciprocal"
        },
        "SO:0001522": {
            "name": "insertional"
        },
        "SO:0001523": {
            "name": "duplication_attribute"
        },
        "SO:0001524": {
            "name": "chromosomally_aberrant_genome"
        },
        "SO:0001525": {
            "name": "assembly_error_correction",
            "def": "A region of sequence where the final nucleotide assignment differs from the original assembly due to an improvement that replaces a mistake. [SO:ke]"
        },
        "SO:0001526": {
            "name": "base_call_error_correction",
            "def": "A region of sequence where the final nucleotide assignment is different from that given by the base caller due to an improvement that replaces a mistake. [SO:ke]"
        },
        "SO:0001527": {
            "name": "peptide_localization_signal",
            "def": "A region of peptide sequence used to target the polypeptide molecule to a specific organelle. [SO:ke]"
        },
        "SO:0001528": {
            "name": "nuclear_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nucleus. [SO:ke]"
        },
        "SO:0001529": {
            "name": "endosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the endosome. [SO:ke]"
        },
        "SO:0001530": {
            "name": "lysosomal_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the lysosome. [SO:ke]"
        },
        "SO:0001531": {
            "name": "nuclear_export_signal",
            "def": "A polypeptide region that targets a polypeptide to he cytoplasm. [SO:ke]"
        },
        "SO:0001532": {
            "name": "recombination_signal_sequence",
            "def": "A region recognized by a recombinase. [SO:ke]"
        },
        "SO:0001533": {
            "name": "cryptic_splice_site",
            "def": "A splice site that is in part of the transcript not normally spliced. They occur via mutation or transcriptional error. [SO:ke]"
        },
        "SO:0001534": {
            "name": "nuclear_rim_localization_signal",
            "def": "A polypeptide region that targets a polypeptide to the nuclear rim. [SO:ke]"
        },
        "SO:0001535": {
            "name": "p_element",
            "def": "A P_element is a DNA transposon responsible for hybrid dysgenesis. [SO:ke]"
        },
        "SO:0001536": {
            "name": "functional_variant",
            "def": "A sequence variant in which the function of a gene product is altered with respect to a reference. [SO:ke]"
        },
        "SO:0001537": {
            "name": "structural_variant",
            "def": "A sequence variant that changes one or more sequence features. [SO:ke]"
        },
        "SO:0001538": {
            "name": "transcript_function_variant",
            "def": "A sequence variant which alters the functioning of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001539": {
            "name": "translational_product_function_variant",
            "def": "A sequence variant that affects the functioning of a translational product with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001540": {
            "name": "level_of_transcript_variant",
            "def": "A sequence variant which alters the level of a transcript. [SO:ke]"
        },
        "SO:0001541": {
            "name": "decreased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001542": {
            "name": "increased_transcript_level_variant",
            "def": "A sequence variant that increases the level of mature, spliced and processed RNA with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001543": {
            "name": "transcript_processing_variant",
            "def": "A sequence variant that affects the post transcriptional processing of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001544": {
            "name": "editing_variant",
            "def": "A transcript processing variant whereby the process of editing is disrupted with respect to the reference. [SO:ke]"
        },
        "SO:0001545": {
            "name": "polyadenylation_variant",
            "def": "A sequence variant that changes polyadenylation with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001546": {
            "name": "transcript_stability_variant",
            "def": "A variant that changes the stability of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001547": {
            "name": "decreased_transcript_stability_variant",
            "def": "A sequence variant that decreases transcript stability with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001548": {
            "name": "increased_transcript_stability_variant",
            "def": "A sequence variant that increases transcript stability with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001549": {
            "name": "transcription_variant",
            "def": "A variant that changes alters the transcription of a transcript with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001550": {
            "name": "rate_of_transcription_variant",
            "def": "A sequence variant that changes the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001551": {
            "name": "increased_transcription_rate_variant",
            "def": "A sequence variant that increases the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001552": {
            "name": "decreased_transcription_rate_variant",
            "def": "A sequence variant that decreases the rate of transcription with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001553": {
            "name": "translational_product_level_variant",
            "def": "A functional variant that changes the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001554": {
            "name": "polypeptide_function_variant",
            "def": "A sequence variant which changes polypeptide functioning with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001555": {
            "name": "decreased_translational_product_level",
            "def": "A sequence variant which decreases the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001556": {
            "name": "increased_translational_product_level",
            "def": "A sequence variant which increases the translational product level with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001557": {
            "name": "polypeptide_gain_of_function_variant",
            "def": "A sequence variant which causes gain of polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001558": {
            "name": "polypeptide_localization_variant",
            "def": "A sequence variant which changes the localization of a polypeptide with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001559": {
            "name": "polypeptide_loss_of_function_variant",
            "def": "A sequence variant that causes the loss of a polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001560": {
            "name": "inactive_ligand_binding_site",
            "def": "A sequence variant that causes the inactivation of a ligand binding site with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001561": {
            "name": "polypeptide_partial_loss_of_function",
            "def": "A sequence variant that causes some but not all loss of polypeptide function with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001562": {
            "name": "polypeptide_post_translational_processing_variant",
            "def": "A sequence variant that causes a change in post translational processing of the peptide with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001563": {
            "name": "copy_number_change",
            "def": "A sequence variant where copies of a feature (CNV) are either increased or decreased. [SO:ke]"
        },
        "SO:0001564": {
            "name": "gene_variant",
            "def": "A sequence variant where the structure of the gene is changed. [SO:ke]"
        },
        "SO:0001565": {
            "name": "gene_fusion",
            "def": "A sequence variant whereby a two genes have become joined. [SO:ke]"
        },
        "SO:0001566": {
            "name": "regulatory_region_variant",
            "def": "A sequence variant located within a regulatory region. [SO:ke]"
        },
        "SO:0001567": {
            "name": "stop_retained_variant",
            "def": "A sequence variant where at least one base in the terminator codon is changed, but the terminator remains. [SO:ke]"
        },
        "SO:0001568": {
            "name": "splicing_variant",
            "def": "A sequence variant that changes the process of splicing. [SO:ke]"
        },
        "SO:0001569": {
            "name": "cryptic_splice_site_variant",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:0001570": {
            "name": "cryptic_splice_acceptor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new acceptor. [SO:ke]"
        },
        "SO:0001571": {
            "name": "cryptic_splice_donor",
            "def": "A sequence variant whereby a new splice site is created due to the activation of a new donor. [SO:ke]"
        },
        "SO:0001572": {
            "name": "exon_loss_variant",
            "def": "A sequence variant whereby an exon is lost from the transcript. [SO:ke]"
        },
        "SO:0001573": {
            "name": "intron_gain_variant",
            "def": "A sequence variant whereby an intron is gained by the processed transcript; usually a result of an alteration of the donor or acceptor. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:0001574": {
            "name": "splice_acceptor_variant",
            "def": "A splice variant that changes the 2 base region at the 3' end of an intron. [SO:ke]"
        },
        "SO:0001575": {
            "name": "splice_donor_variant",
            "def": "A splice variant that changes the 2 base pair region at the 5' end of an intron. [SO:ke]"
        },
        "SO:0001576": {
            "name": "transcript_variant",
            "def": "A sequence variant that changes the structure of the transcript. [SO:ke]"
        },
        "SO:0001577": {
            "name": "complex_transcript_variant",
            "def": "A transcript variant with a complex INDEL- Insertion or deletion that spans an exon/intron border or a coding sequence/UTR border. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001578": {
            "name": "stop_lost",
            "def": "A sequence variant where at least one base of the terminator codon (stop) is changed, resulting in an elongated transcript. [SO:ke]"
        },
        "SO:0001579": {
            "name": "transcript_sequence_variant"
        },
        "SO:0001580": {
            "name": "coding_sequence_variant",
            "def": "A sequence variant that changes the coding sequence. [SO:ke]"
        },
        "SO:0001582": {
            "name": "initiator_codon_variant",
            "def": "A codon variant that changes at least one base of the first codon of a transcript. [SO:ke]"
        },
        "SO:0001583": {
            "name": "missense_variant",
            "def": "A sequence variant, that changes one or more bases, resulting in a different amino acid sequence but where the length is preserved. [EBI:fc, EBI:gr, SO:ke]"
        },
        "SO:0001585": {
            "name": "conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for a different but similar amino acid. These variants may or may not be deleterious. [SO:ke]"
        },
        "SO:0001586": {
            "name": "non_conservative_missense_variant",
            "def": "A sequence variant whereby at least one base of a codon is changed resulting in a codon that encodes for an amino acid with different biochemical properties. [SO:ke]"
        },
        "SO:0001587": {
            "name": "stop_gained",
            "def": "A sequence variant whereby at least one base of a codon is changed, resulting in a premature stop codon, leading to a shortened transcript. [SO:ke]"
        },
        "SO:0001589": {
            "name": "frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
        },
        "SO:0001590": {
            "name": "terminator_codon_variant",
            "def": "A sequence variant whereby at least one of the bases in the terminator codon is changed. [SO:ke]"
        },
        "SO:0001591": {
            "name": "frame_restoring_variant",
            "def": "A sequence variant that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
        },
        "SO:0001592": {
            "name": "minus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base ahead. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
        },
        "SO:0001593": {
            "name": "minus_2_frameshift_variant"
        },
        "SO:0001594": {
            "name": "plus_1_frameshift_variant",
            "def": "A sequence variant which causes a disruption of the translational reading frame, by shifting one base backward. [http://arjournals.annualreviews.org/doi/pdf/10.1146/annurev.ge.08.120174.001535]"
        },
        "SO:0001595": {
            "name": "plus_2_frameshift_variant"
        },
        "SO:0001596": {
            "name": "transcript_secondary_structure_variant",
            "def": "A sequence variant within a transcript that changes the secondary structure of the RNA product. [SO:ke]"
        },
        "SO:0001597": {
            "name": "compensatory_transcript_secondary_structure_variant",
            "def": "A secondary structure variant that compensate for the change made by a previous variant. [SO:ke]"
        },
        "SO:0001598": {
            "name": "translational_product_structure_variant",
            "def": "A sequence variant within the transcript that changes the structure of the translational product. [SO:ke]"
        },
        "SO:0001599": {
            "name": "3D_polypeptide_structure_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
        },
        "SO:0001600": {
            "name": "complex_3D_structural_variant",
            "def": "A sequence variant that changes the resulting polypeptide structure. [SO:ke]"
        },
        "SO:0001601": {
            "name": "conformational_change_variant",
            "def": "A sequence variant in the CDS region that causes a conformational change in the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001602": {
            "name": "complex_change_of_translational_product_variant"
        },
        "SO:0001603": {
            "name": "polypeptide_sequence_variant",
            "def": "A sequence variant with in the CDS that causes a change in the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001604": {
            "name": "amino_acid_deletion",
            "def": "A sequence variant within a CDS resulting in the loss of an amino acid from the resulting polypeptide. [SO:ke]"
        },
        "SO:0001605": {
            "name": "amino_acid_insertion",
            "def": "A sequence variant within a CDS resulting in the gain of an amino acid to the resulting polypeptide. [SO:ke]"
        },
        "SO:0001606": {
            "name": "amino_acid_substitution",
            "def": "A sequence variant of a codon resulting in the substitution of one amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001607": {
            "name": "conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a similar amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001608": {
            "name": "non_conservative_amino_acid_substitution",
            "def": "A sequence variant of a codon causing the substitution of a non conservative amino acid for another in the resulting polypeptide. [SO:ke]"
        },
        "SO:0001609": {
            "name": "elongated_polypeptide",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence. [SO:ke]"
        },
        "SO:0001610": {
            "name": "elongated_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001611": {
            "name": "elongated_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001612": {
            "name": "elongated_in_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001613": {
            "name": "elongated_out_of_frame_polypeptide_C_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the C terminus. [SO:ke]"
        },
        "SO:0001614": {
            "name": "elongated_in_frame_polypeptide_N_terminal_elongation",
            "def": "A sequence variant with in the CDS that causes in frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001615": {
            "name": "elongated_out_of_frame_polypeptide_N_terminal",
            "def": "A sequence variant with in the CDS that causes out of frame elongation of the resulting polypeptide sequence at the N terminus. [SO:ke]"
        },
        "SO:0001616": {
            "name": "polypeptide_fusion",
            "def": "A sequence variant that causes a fusion of two polypeptide sequences. [SO:ke]"
        },
        "SO:0001617": {
            "name": "polypeptide_truncation",
            "def": "A sequence variant of the CD that causes a truncation of the resulting polypeptide. [SO:ke]"
        },
        "SO:0001618": {
            "name": "inactive_catalytic_site",
            "def": "A sequence variant that causes the inactivation of a catalytic site with respect to a reference sequence. [SO:ke]"
        },
        "SO:0001619": {
            "name": "non_coding_transcript_variant",
            "def": "A transcript variant of a non coding RNA gene. [SO:ke]"
        },
        "SO:0001620": {
            "name": "mature_miRNA_variant",
            "def": "A transcript variant located with the sequence of the mature miRNA. [SO:ke]"
        },
        "SO:0001621": {
            "name": "NMD_transcript_variant",
            "def": "A variant in a transcript that is the target of NMD. [SO:ke]"
        },
        "SO:0001622": {
            "name": "UTR_variant",
            "def": "A transcript variant that is located within the UTR. [SO:ke]"
        },
        "SO:0001623": {
            "name": "5_prime_UTR_variant",
            "def": "A UTR variant of the 5' UTR. [SO:ke]"
        },
        "SO:0001624": {
            "name": "3_prime_UTR_variant",
            "def": "A UTR variant of the 3' UTR. [SO:ke]"
        },
        "SO:0001626": {
            "name": "incomplete_terminal_codon_variant",
            "def": "A sequence variant where at least one base of the final codon of an incompletely annotated transcript is changed. [SO:ke]"
        },
        "SO:0001627": {
            "name": "intron_variant",
            "def": "A transcript variant occurring within an intron. [SO:ke]"
        },
        "SO:0001628": {
            "name": "intergenic_variant",
            "def": "A sequence variant located in the intergenic region, between genes. [SO:ke]"
        },
        "SO:0001629": {
            "name": "splice_site_variant",
            "def": "A sequence variant that changes the first two or last two bases of an intron, or the 5th base from the start of the intron in the orientation of the transcript. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001630": {
            "name": "splice_region_variant",
            "def": "A sequence variant in which a change has occurred within the region of the splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [http://ensembl.org/info/docs/variation/index.html]"
        },
        "SO:0001631": {
            "name": "upstream_gene_variant",
            "def": "A sequence variant located 5' of a gene. [SO:ke]"
        },
        "SO:0001632": {
            "name": "downstream_gene_variant",
            "def": "A sequence variant located 3' of a gene. [SO:ke]"
        },
        "SO:0001633": {
            "name": "5KB_downstream_variant",
            "def": "A sequence variant located within 5 KB of the end of a gene. [SO:ke]"
        },
        "SO:0001634": {
            "name": "500B_downstream_variant",
            "def": "A sequence variant located within a half KB of the end of a gene. [SO:ke]"
        },
        "SO:0001635": {
            "name": "5KB_upstream_variant",
            "def": "A sequence variant located within 5KB 5' of a gene. [SO:ke]"
        },
        "SO:0001636": {
            "name": "2KB_upstream_variant",
            "def": "A sequence variant located within 2KB 5' of a gene. [SO:ke]"
        },
        "SO:0001637": {
            "name": "rRNA_gene",
            "def": "A gene that encodes for ribosomal RNA. [SO:ke]"
        },
        "SO:0001638": {
            "name": "piRNA_gene",
            "def": "A gene that encodes for an piwi associated RNA. [SO:ke]"
        },
        "SO:0001639": {
            "name": "RNase_P_RNA_gene",
            "def": "A gene that encodes an RNase P RNA. [SO:ke]"
        },
        "SO:0001640": {
            "name": "RNase_MRP_RNA_gene",
            "def": "A gene that encodes a RNase_MRP_RNA. [SO:ke]"
        },
        "SO:0001641": {
            "name": "lincRNA_gene",
            "def": "A gene that encodes large intervening non-coding RNA. [SO:ke]"
        },
        "SO:0001642": {
            "name": "mathematically_defined_repeat",
            "def": "A mathematically defined repeat (MDR) is a experimental feature that is determined by querying overlapping oligomers of length k against a database of shotgun sequence data and identifying regions in the query sequence that exceed a statistically determined threshold of repetitiveness. [SO:jestill]"
        },
        "SO:0001643": {
            "name": "telomerase_RNA_gene",
            "def": "A telomerase RNA gene is a non coding RNA gene the RNA product of which is a component of telomerase. [SO:ke]"
        },
        "SO:0001644": {
            "name": "targeting_vector",
            "def": "An engineered vector that is able to take part in homologous recombination in a host with the intent of introducing site specific genomic modifications. [MGD:tm, PMID:10354467]"
        },
        "SO:0001645": {
            "name": "genetic_marker",
            "def": "A measurable sequence feature that varies within a population. [SO:db]"
        },
        "SO:0001646": {
            "name": "DArT_marker",
            "def": "A genetic marker, discovered using Diversity Arrays Technology (DArT) technology. [SO:ke]"
        },
        "SO:0001647": {
            "name": "kozak_sequence",
            "def": "A kind of ribosome entry site, specific to Eukaryotic organisms that overlaps part of both 5' UTR and CDS sequence. [SO:ke]"
        },
        "SO:0001648": {
            "name": "nested_transposon",
            "def": "A transposon that is disrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001649": {
            "name": "nested_repeat",
            "def": "A repeat that is disrupted by the insertion of another element. [SO:ke]"
        },
        "SO:0001650": {
            "name": "inframe_variant",
            "def": "A sequence variant which does not cause a disruption of the translational reading frame. [SO:ke]"
        },
        "SO:0001653": {
            "name": "retinoic_acid_responsive_element",
            "def": "A transcription factor binding site of variable direct repeats of the sequence PuGGTCA spaced by five nucleotides (DR5) found in the promoters of retinoic acid-responsive genes, to which retinoic acid receptors bind. [PMID:11327309, PMID:19917671]"
        },
        "SO:0001654": {
            "name": "nucleotide_to_protein_binding_site",
            "def": "A binding site that, in the nucleotide molecule, interacts selectively and non-covalently with polypeptide residues. [SO:ke]"
        },
        "SO:0001655": {
            "name": "nucleotide_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with nucleotide residues. [SO:cb]"
        },
        "SO:0001656": {
            "name": "metal_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with metal ions. [SO:cb]"
        },
        "SO:0001657": {
            "name": "ligand_binding_site",
            "def": "A binding site that, in the molecule, interacts selectively and non-covalently with a small molecule such as a drug, or hormone. [SO:ke]"
        },
        "SO:0001658": {
            "name": "nested_tandem_repeat",
            "def": "An NTR is a nested repeat of two distinct tandem motifs interspersed with each other. [SO:AF]"
        },
        "SO:0001659": {
            "name": "promoter_element"
        },
        "SO:0001660": {
            "name": "core_promoter_element"
        },
        "SO:0001661": {
            "name": "RNA_polymerase_II_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase II. [PMID:16858867]"
        },
        "SO:0001662": {
            "name": "RNA_polymerase_III_TATA_box",
            "def": "A TATA box core promoter of a gene transcribed by RNA polymerase III. [SO:ke]"
        },
        "SO:0001663": {
            "name": "BREd_motif",
            "def": "A core TRNA polymerase II promoter element with consensus (G/A)T(T/G/A)(T/A)(G/T)(T/G)(T/G). [PMID:16858867]"
        },
        "SO:0001664": {
            "name": "DCE",
            "def": "A discontinuous core element of RNA polymerase II transcribed genes, situated downstream of the TSS. It is composed of three sub elements: SI, SII and SIII. [PMID:16858867]"
        },
        "SO:0001665": {
            "name": "DCE_SI",
            "def": "A sub element of the DCE core promoter element, with consensus sequence CTTC. [PMID:16858867, SO:ke]"
        },
        "SO:0001666": {
            "name": "DCE_SII",
            "def": "A sub element of the DCE core promoter element with consensus sequence CTGT. [PMID:16858867, SO:ke]"
        },
        "SO:0001667": {
            "name": "DCE_SIII",
            "def": "A sub element of the DCE core promoter element with consensus sequence AGC. [PMID:16858867, SO:ke]"
        },
        "SO:0001668": {
            "name": "proximal_promoter_element",
            "def": "DNA segment that ranges from about -250 to -40 relative to +1 of RNA transcription start site, where sequence specific DNA-binding transcription factors binds, such as Sp1, CTF (CCAAT-binding transcription factor), and CBF (CCAAT-box binding factor). [PMID:12515390, PMID:9679020, SO:ml]"
        },
        "SO:0001669": {
            "name": "RNApol_II_core_promoter",
            "def": "The minimal portion of the promoter required to properly initiate transcription in RNA polymerase II transcribed genes. [PMID:16858867]"
        },
        "SO:0001670": {
            "name": "distal_promoter_element"
        },
        "SO:0001671": {
            "name": "bacterial_RNApol_promoter_sigma_70"
        },
        "SO:0001672": {
            "name": "bacterial_RNApol_promoter_sigma54"
        },
        "SO:0001673": {
            "name": "minus_12_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
        },
        "SO:0001674": {
            "name": "minus_24_signal",
            "def": "A conserved region about 12-bp upstream of the start point of bacterial transcription units, involved with sigma factor 54. [PMID:18331472]"
        },
        "SO:0001675": {
            "name": "A_box_type_1",
            "def": "An A box within an RNA polymerase III type 1 promoter. [SO:ke]"
        },
        "SO:0001676": {
            "name": "A_box_type_2",
            "def": "An A box within an RNA polymerase III type 2 promoter. [SO:ke]"
        },
        "SO:0001677": {
            "name": "intermediate_element",
            "def": "A core promoter region of RNA polymerase III type 1 promoters. [PMID:12381659]"
        },
        "SO:0001678": {
            "name": "regulatory_promoter_element",
            "def": "A promoter element that is not part of the core promoter, but provides the promoter with a specific regulatory region. [PMID:12381659]"
        },
        "SO:0001679": {
            "name": "transcription_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of transcription. [SO:ke]"
        },
        "SO:0001680": {
            "name": "translation_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of translation. [SO:ke]"
        },
        "SO:0001681": {
            "name": "recombination_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of recombination. [SO:ke]"
        },
        "SO:0001682": {
            "name": "replication_regulatory_region",
            "def": "A regulatory region that is involved in the control of the process of nucleotide replication. [SO:ke]"
        },
        "SO:0001683": {
            "name": "sequence_motif",
            "def": "A sequence motif is a nucleotide or amino-acid sequence pattern that may have biological significance. [http://en.wikipedia.org/wiki/Sequence_motif]"
        },
        "SO:0001684": {
            "name": "experimental_feature_attribute",
            "def": "An attribute of an experimentally derived feature. [SO:ke]"
        },
        "SO:0001685": {
            "name": "score",
            "def": "The score of an experimentally derived feature such as a p-value. [SO:ke]"
        },
        "SO:0001686": {
            "name": "quality_value",
            "def": "An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score. [SO:ke]"
        },
        "SO:0001687": {
            "name": "restriction_enzyme_recognition_site",
            "def": "The nucleotide region (usually a palindrome) that is recognized by a restriction enzyme. This may or may not be equal to the restriction enzyme binding site. [SO:ke]"
        },
        "SO:0001688": {
            "name": "restriction_enzyme_cleavage_junction",
            "def": "The boundary at which a restriction enzyme breaks the nucleotide sequence. [SO:ke]"
        },
        "SO:0001689": {
            "name": "five_prime_restriction_enzyme_junction",
            "def": "The restriction enzyme cleavage junction on the 5' strand of the nucleotide sequence. [SO:ke]"
        },
        "SO:0001690": {
            "name": "three_prime_restriction_enzyme_junction"
        },
        "SO:0001691": {
            "name": "blunt_end_restriction_enzyme_cleavage_site"
        },
        "SO:0001692": {
            "name": "sticky_end_restriction_enzyme_cleavage_site"
        },
        "SO:0001693": {
            "name": "blunt_end_restriction_enzyme_cleavage_junction",
            "def": "A restriction enzyme cleavage site where both strands are cut at the same position. [SO:ke]"
        },
        "SO:0001694": {
            "name": "single_strand_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme cleavage site whereby only one strand is cut. [SO:ke]"
        },
        "SO:0001695": {
            "name": "restriction_enzyme_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended. [SO:ke]"
        },
        "SO:0001696": {
            "name": "experimentally_defined_binding_region",
            "def": "A region that has been implicated in binding although the exact coordinates of binding may be unknown. [SO:ke]"
        },
        "SO:0001697": {
            "name": "ChIP_seq_region",
            "def": "A region of sequence identified by CHiP seq technology to contain a protein binding site. [SO:ke]"
        },
        "SO:0001698": {
            "name": "ASPE_primer",
            "def": "\\A primer containing an SNV at the 3' end for accurate genotyping. [http://www.ncbi.nlm.nih.gov/pubmed/11252801]"
        },
        "SO:0001699": {
            "name": "dCAPS_primer",
            "def": "A primer with one or more mismatches to the DNA template corresponding to a position within a restriction enzyme recognition site. [http://www.ncbi.nlm.nih.gov/pubmed/9628033]"
        },
        "SO:0001700": {
            "name": "histone_modification",
            "def": "Histone modification is a post translationally modified region whereby residues of the histone protein are modified by methylation, acetylation, phosphorylation, ubiquitination, sumoylation, citrullination, or ADP-ribosylation. [http:en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001701": {
            "name": "histone_methylation_site",
            "def": "A histone modification site where the modification is the methylation of the residue. [SO:ke]"
        },
        "SO:0001702": {
            "name": "histone_acetylation_site",
            "def": "A histone modification where the modification is the acylation of the residue. [SO:ke]"
        },
        "SO:0001703": {
            "name": "H3K9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001704": {
            "name": "H3K14_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001705": {
            "name": "H3K4_monomethylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001706": {
            "name": "H3K4_trimethylation",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001707": {
            "name": "H3K9_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001708": {
            "name": "H3K27_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001709": {
            "name": "H3K27_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001710": {
            "name": "H3K79_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is mono- methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001711": {
            "name": "H3K79_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is di-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001712": {
            "name": "H3K79_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001713": {
            "name": "H4K20_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H4histone protein is mono-methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001714": {
            "name": "H2BK5_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2B protein is methylated. [http://en.wikipedia.org/wiki/Histone]"
        },
        "SO:0001715": {
            "name": "ISRE",
            "def": "An ISRE is a transcriptional cis regulatory region, containing the consensus region: YAGTTTC(A/T)YTTTYCC, responsible for increased transcription via interferon binding. [http://genesdev.cshlp.org/content/2/4/383.abstrac]"
        },
        "SO:0001716": {
            "name": "histone_ubiqitination_site",
            "def": "A histone modification site where ubiquitin may be added. [SO:ke]"
        },
        "SO:0001717": {
            "name": "H2B_ubiquitination_site",
            "def": "A histone modification site on H2B where ubiquitin may be added. [SO:ke]"
        },
        "SO:0001718": {
            "name": "H3K18_acetylation_site",
            "def": "A kind of histone modification site, whereby the 14th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001719": {
            "name": "H3K23_acylation_site",
            "def": "A kind of histone modification, whereby the 23rd residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001720": {
            "name": "epigenetically_modified_region",
            "def": "A biological region implicated in inherited changes caused by mechanisms other than changes in the underlying DNA sequence. [http://en.wikipedia.org/wiki/Epigenetics, SO:ke]"
        },
        "SO:0001721": {
            "name": "H3K27_acylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acylated. [SO:ke]"
        },
        "SO:0001722": {
            "name": "H3K36_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
        },
        "SO:0001723": {
            "name": "H3K36_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is dimethylated. [SO:ke]"
        },
        "SO:0001724": {
            "name": "H3K36_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is tri-methylated. [SO:ke]"
        },
        "SO:0001725": {
            "name": "H3K4_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
        },
        "SO:0001726": {
            "name": "H3K27_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is di-methylated. [SO:ke]"
        },
        "SO:0001727": {
            "name": "H3K9_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is mono-methylated. [SO:ke]"
        },
        "SO:0001728": {
            "name": "H3K9_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein may be dimethylated. [SO:ke]"
        },
        "SO:0001729": {
            "name": "H4K16_acylation_site",
            "def": "A kind of histone modification site, whereby the 16th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
        },
        "SO:0001730": {
            "name": "H4K5_acylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:ke]"
        },
        "SO:0001731": {
            "name": "H4K8_acylation_site",
            "def": "A kind of histone modification site, whereby the 8th residue (a lysine), from the start of the H4 histone protein is acylated. [SO:KE]"
        },
        "SO:0001732": {
            "name": "H3K27_methylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001733": {
            "name": "H3K36_methylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001734": {
            "name": "H3K4_methylation_site",
            "def": "A kind of histone modification, whereby the 4th residue (a lysine), from the start of the H3 protein is methylated. [SO:ke]"
        },
        "SO:0001735": {
            "name": "H3K79_methylation_site",
            "def": "A kind of histone modification site, whereby the 79th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001736": {
            "name": "H3K9_methylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H3 histone protein is methylated. [SO:ke]"
        },
        "SO:0001737": {
            "name": "histone_acylation_region",
            "def": "A histone modification, whereby the histone protein is acylated at multiple sites in a region. [SO:ke]"
        },
        "SO:0001738": {
            "name": "H4K_acylation_region",
            "def": "A region of the H4 histone whereby multiple lysines are acylated. [SO:ke]"
        },
        "SO:0001739": {
            "name": "gene_with_non_canonical_start_codon",
            "def": "A gene with a start codon other than AUG. [SO:xp]"
        },
        "SO:0001740": {
            "name": "gene_with_start_codon_CUG",
            "def": "A gene with a translational start codon of CUG. [SO:mc]"
        },
        "SO:0001741": {
            "name": "pseudogenic_gene_segment",
            "def": "A gene segment which when incorporated by somatic recombination in the final gene transcript results in a nonfunctional product. [SO:hd]"
        },
        "SO:0001742": {
            "name": "copy_number_gain",
            "def": "A sequence alteration whereby the copy number of a given regions is greater than the reference sequence. [SO:ke]"
        },
        "SO:0001743": {
            "name": "copy_number_loss",
            "def": "A sequence alteration whereby the copy number of a given region is less than the reference sequence. [SO:ke]"
        },
        "SO:0001744": {
            "name": "UPD",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from one parent and no copies of the same chromosome or region from the other parent. [SO:BM]"
        },
        "SO:0001745": {
            "name": "maternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the mother and no copies of the same chromosome or region from the father. [SO:bm]"
        },
        "SO:0001746": {
            "name": "paternal_uniparental_disomy",
            "def": "Uniparental disomy is a sequence_alteration where a diploid individual receives two copies for all or part of a chromosome from the father and no copies of the same chromosome or region from the mother. [SO:bm]"
        },
        "SO:0001747": {
            "name": "open_chromatin_region",
            "def": "A DNA sequence that in the normal state of the chromosome corresponds to an unfolded, un-complexed stretch of double-stranded DNA. [SO:cb]"
        },
        "SO:0001748": {
            "name": "SL3_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL3 RNA leader sequence to the 5' end of an mRNA. SL3 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001749": {
            "name": "SL4_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL4 RNA leader sequence to the 5' end of an mRNA. SL4 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001750": {
            "name": "SL5_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL5 RNA leader sequence to the 5' end of an mRNA. SL5 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001751": {
            "name": "SL6_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL6 RNA leader sequence to the 5' end of an mRNA. SL6 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001752": {
            "name": "SL7_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL7 RNA leader sequence to the 5' end of an mRNA. SL7 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001753": {
            "name": "SL8_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL8 RNA leader sequence to the 5' end of an mRNA. SL8 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001754": {
            "name": "SL9_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL9 RNA leader sequence to the 5' end of an mRNA. SL9 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001755": {
            "name": "SL10_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL10 RNA leader sequence to the 5' end of an mRNA. SL10 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001756": {
            "name": "SL11_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL11 RNA leader sequence to the 5' end of an mRNA. SL11 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001757": {
            "name": "SL12_acceptor_site",
            "def": "A SL2_acceptor_site which appends the SL12 RNA leader sequence to the 5' end of an mRNA. SL12 acceptor sites occur in genes in internal segments of polycistronic transcripts. [SO:nlw]"
        },
        "SO:0001758": {
            "name": "duplicated_pseudogene",
            "def": "A pseudogene that arose via gene duplication. Generally duplicated pseudogenes have the same structure as the original gene, including intron-exon structure and some regulatory sequence. [http://en.wikipedia.org/wiki/Pseudogene]"
        },
        "SO:0001759": {
            "name": "unitary_pseudogene",
            "def": "A pseudogene, deactivated from original state by mutation, fixed in a population. [http://en.wikipedia.org/wiki/Pseudogene, SO:ke]"
        },
        "SO:0001760": {
            "name": "non_processed_pseudogene",
            "def": "A pseudogene that arose from a means other than retrotransposition. [SO:ke]"
        },
        "SO:0001761": {
            "name": "variant_quality",
            "def": "A dependent entity that inheres in a bearer, a sequence variant. [PMID:17597783, SO:ke]"
        },
        "SO:0001762": {
            "name": "variant_origin",
            "def": "A quality inhering in a variant by virtue of its origin. [PMID:17597783, SO:ke]"
        },
        "SO:0001763": {
            "name": "variant_frequency",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [PMID:17597783, SO:ke]"
        },
        "SO:0001764": {
            "name": "unique_variant",
            "def": "A physical quality which inheres to the variant by virtue of the number instances of the variant within a population. [SO:ke]"
        },
        "SO:0001765": {
            "name": "rare_variant"
        },
        "SO:0001766": {
            "name": "polymorphic_variant"
        },
        "SO:0001767": {
            "name": "common_variant"
        },
        "SO:0001768": {
            "name": "fixed_variant"
        },
        "SO:0001769": {
            "name": "variant_phenotype",
            "def": "A quality inhering in a variant by virtue of its phenotype. [PMID:17597783, SO:ke]"
        },
        "SO:0001770": {
            "name": "benign_variant"
        },
        "SO:0001771": {
            "name": "disease_associated_variant"
        },
        "SO:0001772": {
            "name": "disease_causing_variant"
        },
        "SO:0001773": {
            "name": "lethal_variant"
        },
        "SO:0001774": {
            "name": "quantitative_variant"
        },
        "SO:0001775": {
            "name": "maternal_variant"
        },
        "SO:0001776": {
            "name": "paternal_variant"
        },
        "SO:0001777": {
            "name": "somatic_variant"
        },
        "SO:0001778": {
            "name": "germline_variant"
        },
        "SO:0001779": {
            "name": "pedigree_specific_variant"
        },
        "SO:0001780": {
            "name": "population_specific_variant"
        },
        "SO:0001781": {
            "name": "de_novo_variant"
        },
        "SO:0001782": {
            "name": "TF_binding_site_variant",
            "def": "A sequence variant located within a transcription factor binding site. [EBI:fc]"
        },
        "SO:0001784": {
            "name": "complex_structural_alteration",
            "def": "A structural sequence alteration or rearrangement encompassing one or more genome fragments, with 4 or more breakpoints. [FB:reference_manual, NCBI:th, SO:ke]"
        },
        "SO:0001785": {
            "name": "structural_alteration"
        },
        "SO:0001786": {
            "name": "loss_of_heterozygosity",
            "def": "A functional variant whereby the sequence alteration causes a loss of function of one allele of a gene. [SO:ke]"
        },
        "SO:0001787": {
            "name": "splice_donor_5th_base_variant",
            "def": "A sequence variant that causes a change at the 5th base pair after the start of the intron in the orientation of the transcript. [EBI:gr]"
        },
        "SO:0001788": {
            "name": "U_box",
            "def": "An U-box is a conserved T-rich region upstream of a retroviral polypurine tract that is involved in PPT primer creation during reverse transcription. [PMID:10556309, PMID:11577982, PMID:9649446]"
        },
        "SO:0001789": {
            "name": "mating_type_region",
            "def": "A specialized region in the genomes of some yeast and fungi, the genes of which regulate mating type. [SO:ke]"
        },
        "SO:0001790": {
            "name": "paired_end_fragment",
            "def": "An assembly region that has been sequenced from both ends resulting in a read_pair (mate_pair). [SO:ke]"
        },
        "SO:0001791": {
            "name": "exon_variant",
            "def": "A sequence variant that changes exon sequence. [SO:ke]"
        },
        "SO:0001792": {
            "name": "non_coding_transcript_exon_variant",
            "def": "A sequence variant that changes non-coding exon sequence in a non-coding transcript. [EBI:fc, SO:ke]"
        },
        "SO:0001793": {
            "name": "clone_end",
            "def": "A read from an end of the clone sequence. [SO:ke]"
        },
        "SO:0001794": {
            "name": "point_centromere",
            "def": "A point centromere is a relatively small centromere (about 125 bp DNA) in discrete sequence, found in some yeast including S. cerevisiae. [PMID:7502067, SO:vw]"
        },
        "SO:0001795": {
            "name": "regional_centromere",
            "def": "A regional centromere is a large modular centromere found in fission yeast and higher eukaryotes. It consist of a central core region flanked by inverted inner and outer repeat regions. [PMID:7502067, SO:vw]"
        },
        "SO:0001796": {
            "name": "regional_centromere_central_core",
            "def": "A conserved region within the central region of a modular centromere, where the kinetochore is formed. [SO:vw]"
        },
        "SO:0001797": {
            "name": "centromeric_repeat",
            "def": "A repeat region found within the modular centromere. [SO:ke]"
        },
        "SO:0001798": {
            "name": "regional_centromere_inner_repeat_region",
            "def": "The inner inverted repeat region of a modular centromere and part of the central core surrounding a non-conserved central region. This region is adjacent to the central core, on each chromosome arm. [SO:vw]"
        },
        "SO:0001799": {
            "name": "regional_centromere_outer_repeat_region",
            "def": "The heterochromatic outer repeat region of a modular centromere. These repeats exist in tandem arrays on both chromosome arms. [SO:vw]"
        },
        "SO:0001800": {
            "name": "tasiRNA",
            "def": "The sequence of a 21 nucleotide double stranded, polyadenylated non coding RNA, transcribed from the TAS gene. [PMID:16145017]"
        },
        "SO:0001801": {
            "name": "tasiRNA_primary_transcript",
            "def": "A primary transcript encoding a tasiRNA. [PMID:16145017]"
        },
        "SO:0001802": {
            "name": "increased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is increased with respect to the reference. [SO:ke]"
        },
        "SO:0001803": {
            "name": "decreased_polyadenylation_variant",
            "def": "A transcript processing variant whereby polyadenylation of the encoded transcript is decreased with respect to the reference. [SO:ke]"
        },
        "SO:0001804": {
            "name": "DDB_box",
            "def": "A conserved polypeptide motif that mediates protein-protein interaction and defines adaptor proteins for DDB1/cullin 4 ubiquitin ligases. [PMID:18794354, PMID:19818632]"
        },
        "SO:0001805": {
            "name": "destruction_box",
            "def": "A conserved polypeptide motif that can be recognized by both Fizzy/Cdc20- and FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is RXXLXXXXN. [PMID:12208841, PMID:1842691]"
        },
        "SO:0001806": {
            "name": "ER_retention_signal",
            "def": "A C-terminal tetrapeptide motif that mediates retention of a protein in (or retrieval to) the endoplasmic reticulum. In mammals the sequence is KDEL, and in fungi HDEL or DDEL. [doi:10.1093/jxb/50.331.157, PMID:2077689]"
        },
        "SO:0001807": {
            "name": "KEN_box",
            "def": "A conserved polypeptide motif that can be recognized by FZR/Cdh1-activated anaphase-promoting complex/cyclosome (APC/C) and targets a protein for ubiquitination and subsequent degradation by the APC/C. The consensus sequence is KENXXXN. [PMID:10733526, PMID:1220884, PMID:18426916]"
        },
        "SO:0001808": {
            "name": "mitochondrial_targeting_signal",
            "def": "A polypeptide region that targets a polypeptide to the mitochondrion. [PomBase:mah]"
        },
        "SO:0001809": {
            "name": "signal_anchor",
            "def": "A signal sequence that is not cleaved from the polypeptide. Anchors a Type II membrane protein to the membrane. [http://www.cbs.dtu.dk/services/SignalP/background/biobackground.php]"
        },
        "SO:0001810": {
            "name": "PIP_box",
            "def": "A polypeptide region that mediates binding to PCNA. The consensus sequence is QXX(hh)XX(aa), where (h) denotes residues with moderately hydrophobic side chains and (a) denotes residues with highly hydrophobic aromatic side chains. [PMID:9631646]"
        },
        "SO:0001811": {
            "name": "phosphorylation_site",
            "def": "A post-translationally modified region in which residues of the protein are modified by phosphorylation. [PomBase:mah]"
        },
        "SO:0001812": {
            "name": "transmembrane_helix",
            "def": "A region that traverses the lipid bilayer and adopts a helical secondary structure. [PomBase:mah]"
        },
        "SO:0001813": {
            "name": "vacuolar_sorting_signal",
            "def": "A polypeptide region that targets a polypeptide to the vacuole. [PomBase:mah]"
        },
        "SO:0001814": {
            "name": "coding_variant_quality"
        },
        "SO:0001815": {
            "name": "synonymous"
        },
        "SO:0001816": {
            "name": "non_synonymous"
        },
        "SO:0001817": {
            "name": "inframe",
            "def": "An attribute describing a sequence that contains a mutation involving the deletion or insertion of one or more bases, where this number is divisible by 3. [SO:ke]"
        },
        "SO:0001818": {
            "name": "protein_altering_variant",
            "def": "A sequence_variant which is predicted to change the protein encoded in the coding sequence. [EBI:gr]"
        },
        "SO:0001819": {
            "name": "synonymous_variant",
            "def": "A sequence variant where there is no resulting change to the encoded amino acid. [SO:ke]"
        },
        "SO:0001820": {
            "name": "inframe_indel",
            "def": "A coding sequence variant where the change does not alter the frame of the transcript. [SO:ke]"
        },
        "SO:0001821": {
            "name": "inframe_insertion",
            "def": "An inframe non synonymous variant that inserts bases into in the coding sequence. [EBI:gr]"
        },
        "SO:0001822": {
            "name": "inframe_deletion",
            "def": "An inframe non synonymous variant that deletes bases from the coding sequence. [EBI:gr]"
        },
        "SO:0001823": {
            "name": "conservative_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence between existing codons. [EBI:gr]"
        },
        "SO:0001824": {
            "name": "disruptive_inframe_insertion",
            "def": "An inframe increase in cds length that inserts one or more codons into the coding sequence within an existing codon. [EBI:gr]"
        },
        "SO:0001825": {
            "name": "conservative_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes one or more entire codons from the coding sequence but does not change any remaining codons. [EBI:gr]"
        },
        "SO:0001826": {
            "name": "disruptive_inframe_deletion",
            "def": "An inframe decrease in cds length that deletes bases from the coding sequence starting within an existing codon. [EBI:gr]"
        },
        "SO:0001827": {
            "name": "mRNA_read",
            "def": "A sequencer read of an mRNA substrate. [SO:ke]"
        },
        "SO:0001828": {
            "name": "genomic_DNA_read",
            "def": "A sequencer read of a genomic DNA substrate. [SO:ke]"
        },
        "SO:0001829": {
            "name": "mRNA_contig",
            "def": "A contig composed of mRNA_reads. [SO:ke]"
        },
        "SO:0001830": {
            "name": "AFLP_fragment",
            "def": "A PCR product obtained by applying the AFLP technique, based on a restriction enzyme digestion of genomic DNA and an amplification of the resulting fragments. [GMOD:ea]"
        },
        "SO:0001831": {
            "name": "protein_hmm_match",
            "def": "A match to a protein HMM such as pfam. [SO:ke]"
        },
        "SO:0001832": {
            "name": "immunoglobulin_region",
            "def": "A region of immunoglobulin sequence, either constant or variable. [SO:ke]"
        },
        "SO:0001833": {
            "name": "V_region",
            "def": "The variable region of an immunoglobulin polypeptide sequence. [SO:ke]"
        },
        "SO:0001834": {
            "name": "C_region",
            "def": "The constant region of an immunoglobulin polypeptide sequence. [SO:ke]"
        },
        "SO:0001835": {
            "name": "N_region",
            "def": "Extra nucleotides inserted between rearranged immunoglobulin segments. [SO:ke]"
        },
        "SO:0001836": {
            "name": "S_region",
            "def": "The switch region of immunoglobulin heavy chains; it is involved in the rearrangement of heavy chain DNA leading to the expression of a different immunoglobulin classes from the same B-cell. [SO:ke]"
        },
        "SO:0001837": {
            "name": "mobile_element_insertion",
            "def": "A kind of insertion where the inserted sequence is a mobile element. [EBI:dvga]"
        },
        "SO:0001838": {
            "name": "novel_sequence_insertion",
            "def": "An insertion the sequence of which cannot be mapped to the reference genome. [NCBI:th]"
        },
        "SO:0001839": {
            "name": "CSL_response_element",
            "def": "A promoter element with consensus sequence GTGRGAA, bound by CSL (CBF1/RBP-JK/Suppressor of Hairless/LAG-1) transcription factors. [PMID:19101542]"
        },
        "SO:0001840": {
            "name": "GATA_box",
            "def": "A GATA transcription factor element containing the consensus sequence WGATAR (in which W indicates A/T and R indicates A/G). [PMID:8321208]"
        },
        "SO:0001841": {
            "name": "polymorphic_pseudogene",
            "def": "Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains the gene is translated. [JAX:hd]"
        },
        "SO:0001842": {
            "name": "AP_1_binding_site",
            "def": "A promoter element with consensus sequence TGACTCA, bound by AP-1 and related transcription factors. [PMID:1899230, PMID:3034432, PMID:3125983]"
        },
        "SO:0001843": {
            "name": "CRE",
            "def": "A promoter element with consensus sequence TGACGTCA; bound by the ATF/CREB family of transcription factors. [PMID:11483355, PMID:11483993]"
        },
        "SO:0001844": {
            "name": "CuRE",
            "def": "A promoter element bound by copper ion-sensing transcription factors such as S. cerevisiae Mac1p or S. pombe Cuf1; the consensus sequence is HTHNNGCTGD (more specifically TTTGCKCR in budding yeast). [PMID:10593913, PMID:9188496, PMID:9211922]"
        },
        "SO:0001845": {
            "name": "DRE",
            "def": "A promoter element with consensus sequence CGWGGWNGMM, bound by transcription factors related to RecA and found in promoters of genes expressed following several types of DNA damage or inhibition of DNA synthesis. [PMID:11073995, PMID:8668127]"
        },
        "SO:0001846": {
            "name": "FLEX_element",
            "def": "A promoter element that has consensus sequence GTAAACAAACAAAM and contains a heptameric core GTAAACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:10747048, PMID:14871934]"
        },
        "SO:0001847": {
            "name": "forkhead_motif",
            "def": "A promoter element with consensus sequence TTTRTTTACA, bound by transcription factors with a forkhead DNA-binding domain. [PMID:15195092]"
        },
        "SO:0001848": {
            "name": "homol_D_box",
            "def": "A core promoter element that has the consensus sequence CAGTCACA (or its inverted form TGTGACTG), and plays the role of a TATA box in promoters that do not contain a canonical TATA sequence. [PMID:7501449, PMID:8458332]"
        },
        "SO:0001849": {
            "name": "homol_E_box",
            "def": "A core promoter element that has the consensus sequence ACCCTACCCT (or its inverted form AGGGTAGGGT), and is found near the homol D box in some promoters that use a homol D box instead of a canonical TATA sequence. [PMID:7501449]"
        },
        "SO:0001850": {
            "name": "HSE",
            "def": "A promoter element that consists of at least three copies of the pentanucleotide NGAAN, bound by the heat shock transcription factor HSF. [PMID:17347150, PMID:8689565]"
        },
        "SO:0001851": {
            "name": "iron_repressed_GATA_element",
            "def": "A GATA promoter element with consensus sequence WGATAA, found in promoters of genes repressed in the presence of iron. [PMID:11956219, PMID:17211681]"
        },
        "SO:0001852": {
            "name": "mating_type_M_box",
            "def": "A promoter element with consensus sequence ACAAT, found in promoters of mating type M-specific genes in fission yeast and bound by the transcription factor Mat1-Mc. [PMID:9233811]"
        },
        "SO:0001853": {
            "name": "androgen_response_element",
            "def": "A non-palindromic sequence found in the promoters of genes whose expression is regulated in response to androgen. [PMID:21796522]"
        },
        "SO:0001854": {
            "name": "smFISH_probe",
            "def": "A smFISH is a probe that binds RNA in a single molecule in situ hybridization experiment. [PMID:18806792]"
        },
        "SO:0001855": {
            "name": "MCB",
            "def": "A promoter element with consensus sequence ACGCGT, bound by the transcription factor complex MBF (MCB-binding factor) and found in promoters of genes expressed during the G1/S transition of the cell cycle. [PMID:16285853]"
        },
        "SO:0001856": {
            "name": "CCAAT_motif",
            "def": "A promoter element with consensus sequence CCAAT, bound by a protein complex that represses transcription in response to low iron levels. [PMID:16963626]"
        },
        "SO:0001857": {
            "name": "Ace2_UAS",
            "def": "A promoter element with consensus sequence CCAGCC, bound by the fungal transcription factor Ace2. [PMID:16678171]"
        },
        "SO:0001858": {
            "name": "TR_box",
            "def": "A promoter element with consensus sequence TTCTTTGTTY, bound an HMG-box transcription factor such as S. pombe Ste11, and found in promoters of genes up-regulated early in meiosis. [PMID:1657709]"
        },
        "SO:0001859": {
            "name": "STREP_motif",
            "def": "A promoter element with consensus sequence CCCCTC, bound by the PKA-responsive zinc finger transcription factor Rst2. [PMID:11739717]"
        },
        "SO:0001860": {
            "name": "rDNA_intergenic_spacer_element",
            "def": "A DNA motif that contains a core consensus sequence AGGTAAGGGTAATGCAC, is found in the intergenic regions of rDNA repeats, and is bound by an RNA polymerase I transcription termination factor (e.g. S. pombe Reb1). [PMID:9016645]"
        },
        "SO:0001861": {
            "name": "sterol_regulatory_element",
            "def": "A 10-bp promoter element bound by sterol regulatory element binding proteins (SREBPs), found in promoters of genes involved in sterol metabolism. Many variants of the sequence ATCACCCCAC function as SREs. [GO:mah, PMID:11111080, PMID:16537923]"
        },
        "SO:0001862": {
            "name": "GT_dinucleotide_repeat",
            "def": "A dinucleotide repeat region composed of GT repeating elements. [SO:ke]"
        },
        "SO:0001863": {
            "name": "GTT_trinucleotide_repeat",
            "def": "A trinucleotide repeat region composed of GTT repeating elements. [SO:ke]"
        },
        "SO:0001864": {
            "name": "Sap1_recognition_motif",
            "def": "A DNA motif to which the S. pombe Sap1 protein binds. The consensus sequence is 5'-TARGCAGNTNYAACGMG-3'; it is found at the mating type locus, where it is important for mating type switching, and at replication fork barriers in rDNA repeats. [PMID:16166653, PMID:7651412]"
        },
        "SO:0001865": {
            "name": "CDRE_motif",
            "def": "An RNA polymerase II promoter element found in the promoters of genes regulated by calcineurin. The consensus sequence is GNGGCKCA. [PMID:16928959]"
        },
        "SO:0001866": {
            "name": "BAC_read_contig",
            "def": "A contig of BAC reads. [GMOD:ea]"
        },
        "SO:0001867": {
            "name": "candidate_gene",
            "def": "A gene suspected of being involved in the expression of a trait. [GMOD:ea]"
        },
        "SO:0001868": {
            "name": "positional_candidate_gene",
            "def": "A candidate gene whose association with a trait is based on the gene's location on a chromosome. [GMOD:ea]"
        },
        "SO:0001869": {
            "name": "functional_candidate_gene",
            "def": "A candidate gene whose function has something in common biologically with the trait under investigation. [GMOD:ea]"
        },
        "SO:0001870": {
            "name": "enhancerRNA",
            "def": "A short ncRNA that is transcribed from an enhancer. May have a regulatory function. [doi:10.1038/465173a, SO:cjm]"
        },
        "SO:0001871": {
            "name": "PCB",
            "def": "A promoter element with consensus sequence GNAACR, bound by the transcription factor complex PBF (PCB-binding factor) and found in promoters of genes expressed during the M/G1 transition of the cell cycle. [GO:mah, PMID:12411492]"
        },
        "SO:0001872": {
            "name": "rearrangement_region",
            "def": "A region of a chromosome, where the chromosome has undergone a large structural rearrangement that altered the genome organization. There is no longer synteny to the reference genome. [NCBI:th, PMID:18564416]"
        },
        "SO:0001873": {
            "name": "interchromosomal_breakpoint",
            "def": "A rearrangement breakpoint between two different chromosomes. [NCBI:th]"
        },
        "SO:0001874": {
            "name": "intrachromosomal_breakpoint",
            "def": "A rearrangement breakpoint within the same chromosome. [NCBI:th]"
        },
        "SO:0001875": {
            "name": "unassigned_supercontig",
            "def": "A supercontig that is not been assigned to any ultracontig during a genome assembly project. [GMOD:ea]"
        },
        "SO:0001876": {
            "name": "partial_genomic_sequence_assembly",
            "def": "A partial DNA sequence assembly of a chromosome or full genome, which contains gaps that are filled with N's. [GMOD:ea]"
        },
        "SO:0001877": {
            "name": "lnc_RNA",
            "def": "A non-coding RNA over 200nucleotides in length. [HGNC:mw]"
        },
        "SO:0001878": {
            "name": "feature_variant",
            "def": "A sequence variant that falls entirely or partially within a genomic feature. [EBI:fc, SO:ke]"
        },
        "SO:0001879": {
            "name": "feature_ablation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the deletion, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001880": {
            "name": "feature_amplification",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, an amplification of sequence, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001881": {
            "name": "feature_translocation",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where the structural change, a translocation, is greater than the extent of the underlying genomic features. [SO:ke]"
        },
        "SO:0001882": {
            "name": "feature_fusion",
            "def": "A sequence variant, caused by an alteration of the genomic sequence, where a deletion fuses genomic features. [SO:ke]"
        },
        "SO:0001883": {
            "name": "transcript_translocation",
            "def": "A feature translocation where the region contains a transcript. [SO:ke]"
        },
        "SO:0001884": {
            "name": "regulatory_region_translocation",
            "def": "A feature translocation where the region contains a regulatory region. [SO:ke]"
        },
        "SO:0001885": {
            "name": "TFBS_translocation",
            "def": "A feature translocation where the region contains a transcription factor binding site. [SO:ke]"
        },
        "SO:0001886": {
            "name": "transcript_fusion",
            "def": "A feature fusion where the deletion brings together transcript regions. [SO:ke]"
        },
        "SO:0001887": {
            "name": "regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together regulatory regions. [SO:ke]"
        },
        "SO:0001888": {
            "name": "TFBS_fusion",
            "def": "A fusion where the deletion brings together transcription factor binding sites. [SO:ke]"
        },
        "SO:0001889": {
            "name": "transcript_amplification",
            "def": "A feature amplification of a region containing a transcript. [SO:ke]"
        },
        "SO:0001890": {
            "name": "transcript_regulatory_region_fusion",
            "def": "A feature fusion where the deletion brings together a regulatory region and a transcript region. [SO:ke]"
        },
        "SO:0001891": {
            "name": "regulatory_region_amplification",
            "def": "A feature amplification of a region containing a regulatory region. [SO:ke]"
        },
        "SO:0001892": {
            "name": "TFBS_amplification",
            "def": "A feature amplification of a region containing a transcription factor binding site. [SO:ke]"
        },
        "SO:0001893": {
            "name": "transcript_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcript feature. [SO:ke]"
        },
        "SO:0001894": {
            "name": "regulatory_region_ablation",
            "def": "A feature ablation whereby the deleted region includes a regulatory region. [SO:ke]"
        },
        "SO:0001895": {
            "name": "TFBS_ablation",
            "def": "A feature ablation whereby the deleted region includes a transcription factor binding site. [SO:ke]"
        },
        "SO:0001896": {
            "name": "transposable_element_CDS",
            "def": "A CDS that is part of a transposable element. [SO:ke]"
        },
        "SO:0001897": {
            "name": "transposable_element_pseudogene",
            "def": "A pseudogene contained within a transposable element. [SO:ke]"
        },
        "SO:0001898": {
            "name": "dg_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
        },
        "SO:0001899": {
            "name": "dh_repeat",
            "def": "A repeat region which is part of the regional centromere outer repeat region. [PMID:16407326, SO:vw]"
        },
        "SO:0001900": {
            "name": "M26_binding_site",
            "def": "A promoter element that contains a core sequence TGACGT, bound by a protein complex that regulates transcription of genes encoding PKA pathway components. [PMID:15448137]"
        },
        "SO:0001901": {
            "name": "AACCCT_box",
            "def": "A conserved 17-bp sequence (5'-ATCA(C/A)AACCCTAACCCT-3') commonly present upstream of the start site of histone transcription units functioning as a transcription factor binding site. [PMID:17452352, PMID:4092687]"
        },
        "SO:0001902": {
            "name": "splice_region",
            "def": "A region surrounding a cis_splice site, either within 1-3 bases of the exon or 3-8 bases of the intron. [SO:bm]"
        },
        "SO:0001903": {
            "name": "intronic_lncRNA",
            "def": "A lnc_RNA totally contained within an intron. [PMID:19071207, SO:ke]"
        },
        "SO:0001904": {
            "name": "antisense_lncRNA",
            "def": "Non-coding RNA transcribed from the opposite DNA strand compared with other transcripts and overlap in part with sense RNA. [PMID:19638999]"
        },
        "SO:0001905": {
            "name": "regional_centromere_outer_repeat_transcript",
            "def": "A transcript that is transcribed from the outer repeat region of a regional centromere. [PomBase:mah]"
        },
        "SO:0001906": {
            "name": "feature_truncation",
            "def": "A sequence variant that causes the reduction of a genomic feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001907": {
            "name": "feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001908": {
            "name": "internal_feature_elongation",
            "def": "A sequence variant that causes the extension of a genomic feature from within the feature rather than from the terminus of the feature, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0001909": {
            "name": "frameshift_elongation",
            "def": "A frameshift variant that causes the translational reading frame to be extended relative to the reference feature. [SO:ke]"
        },
        "SO:0001910": {
            "name": "frameshift_truncation",
            "def": "A frameshift variant that causes the translational reading frame to be shortened relative to the reference feature. [SO:ke]"
        },
        "SO:0001911": {
            "name": "copy_number_increase",
            "def": "A sequence variant where copies of a feature are increased relative to the reference. [SO:ke]"
        },
        "SO:0001912": {
            "name": "copy_number_decrease",
            "def": "A sequence variant where copies of a feature are decreased relative to the reference. [SO:ke]"
        },
        "SO:0001913": {
            "name": "bacterial_RNApol_promoter_sigma_ecf",
            "def": "A bacterial promoter with sigma ecf factor binding dependency. This is a type of bacterial promoters that requires a sigma ECF factor to bind to identified -10 and -35 sequence regions in order to mediate binding of the RNA polymerase to the promoter region as part of transcription initiation. [Invitrogen:kc]"
        },
        "SO:0001914": {
            "name": "rDNA_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:14645529]"
        },
        "SO:0001915": {
            "name": "transcription_start_cluster",
            "def": "A region defined by a cluster of experimentally determined transcription starting sites. [PMID:19624849, PMID:21372179, SO:andrewgibson]"
        },
        "SO:0001916": {
            "name": "CAGE_tag",
            "def": "A CAGE tag is a sequence tag hat corresponds to 5' ends of mRNA at cap sites, produced by cap analysis gene expression and used to identify transcriptional start sites. [SO:andrewgibson]"
        },
        "SO:0001917": {
            "name": "CAGE_cluster",
            "def": "A kind of transcription_initiation_cluster defined by the clustering of CAGE tags on a sequence region. [PMID:16645617, SO:andrewgibson]"
        },
        "SO:0001918": {
            "name": "5_methylcytosine",
            "def": "A cytosine methylated at the 5 carbon. [SO:rtapella]"
        },
        "SO:0001919": {
            "name": "4_methylcytosine",
            "def": "A cytosine methylated at the 4 nitrogen. [SO:rtapella]"
        },
        "SO:0001920": {
            "name": "N6_methyladenine",
            "def": "An adenine methylated at the 6 nitrogen. [SO:rtapella]"
        },
        "SO:0001921": {
            "name": "mitochondrial_contig",
            "def": "A contig of mitochondria derived sequences. [GMOD:ea]"
        },
        "SO:0001922": {
            "name": "mitochondrial_supercontig",
            "def": "A scaffold composed of mitochondrial contigs. [GMOD:ea]"
        },
        "SO:0001923": {
            "name": "TERRA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts contain G rich telomeric RNA repeats and RNA tracts corresponding to adjacent subtelomeric sequences. They are 100-9000 bases long. [PMID:22139915]"
        },
        "SO:0001924": {
            "name": "ARRET",
            "def": "A non coding RNA transcript, complementary to subtelomeric tract of TERRA transcript but devoid of the repeats. [PMID:2139915]"
        },
        "SO:0001925": {
            "name": "ARIA",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts consist of C rich repeats. [PMID:22139915]"
        },
        "SO:0001926": {
            "name": "anti_ARRET",
            "def": "A non-coding RNA transcript, derived from the transcription of the telomere. These  transcripts are antisense of ARRET transcripts. [PMID:22139915]"
        },
        "SO:0001927": {
            "name": "telomeric_transcript",
            "def": "A non-coding transcript derived from the transcript of the telomere. [PMID:22139915]"
        },
        "SO:0001928": {
            "name": "distal_duplication",
            "def": "A duplication of the distal region of a chromosome. [SO:bm]"
        },
        "SO:0001929": {
            "name": "mitochondrial_DNA_read",
            "def": "A sequencer read of a mitochondrial DNA sample. [GMOD:ea]"
        },
        "SO:0001930": {
            "name": "chloroplast_DNA_read",
            "def": "A sequencer read of a chloroplast DNA sample. [GMOD:ea]"
        },
        "SO:0001931": {
            "name": "consensus_gDNA",
            "def": "Genomic DNA sequence produced from some base calling or alignment algorithm which uses aligned or assembled multiple gDNA sequences as input. [GMOD:ea]"
        },
        "SO:0001932": {
            "name": "restriction_enzyme_five_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 5' end. [SO:ke]"
        },
        "SO:0001933": {
            "name": "restriction_enzyme_three_prime_single_strand_overhang",
            "def": "A terminal region of DNA sequence where the end of the region is not blunt ended and the exposed single strand terminates at the 3' end. [SO:ke]"
        },
        "SO:0001934": {
            "name": "monomeric_repeat",
            "def": "A repeat_region containing repeat_units of 1 bp that is repeated multiple times in tandem. [SO:ke]"
        },
        "SO:0001935": {
            "name": "H3K20_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H3 protein is tri-methylated. [EBI:nj]"
        },
        "SO:0001936": {
            "name": "H3K36_acetylation_site",
            "def": "A kind of histone modification site, whereby the 36th residue (a lysine), from the start of the H3 histone protein is acylated. [EBI:nj]"
        },
        "SO:0001937": {
            "name": "H2BK12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H2B protein is methylated. [EBI:nj]"
        },
        "SO:0001938": {
            "name": "H2AK5_acetylation_site",
            "def": "A kind of histone modification site, whereby the 5th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001939": {
            "name": "H4K12_acetylation_site",
            "def": "A kind of histone modification site, whereby the 12th residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001940": {
            "name": "H2BK120_acetylation_site",
            "def": "A kind of histone modification site, whereby the 120th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001941": {
            "name": "H4K91_acetylation_site",
            "def": "A kind of histone modification site, whereby the 91st residue (a lysine), from the start of the H4 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001942": {
            "name": "H2BK20_acetylation_site",
            "def": "A kind of histone modification site, whereby the 20th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001943": {
            "name": "H3K4ac_acetylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001944": {
            "name": "H2AK9_acetylation_site",
            "def": "A kind of histone modification site, whereby the 9th residue (a lysine), from the start of the H2A histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001945": {
            "name": "H3K56_acetylation_site",
            "def": "A kind of histone modification site, whereby the 56th residue (a lysine), from the start of the H3 histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001946": {
            "name": "H2BK15_acetylation_site",
            "def": "A kind of histone modification site, whereby the 15th residue (a lysine), from the start of the H2B histone protein is acetylated. [EBI:nj]"
        },
        "SO:0001947": {
            "name": "H3R2_monomethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is mono-methylated. [EBI:nj]"
        },
        "SO:0001948": {
            "name": "H3R2_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 2nd residue (an arginine), from the start of the H3 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001949": {
            "name": "H4R3_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 3nd residue (an arginine), from the start of the H4 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001950": {
            "name": "H4K4_trimethylation_site",
            "def": "A kind of histone modification site, whereby the 4th residue (a lysine), from the start of the H4 protein is tri-methylated. [EBI:nj]"
        },
        "SO:0001951": {
            "name": "H3K23_dimethylation_site",
            "def": "A kind of histone modification site, whereby the 23rd residue (a lysine), from the start of the H3 protein is di-methylated. [EBI:nj]"
        },
        "SO:0001952": {
            "name": "promoter_flanking_region",
            "def": "A region immediately adjacent to a promoter which may or may not contain transcription factor binding sites. [EBI:nj]"
        },
        "SO:0001953": {
            "name": "restriction_enzyme_assembly_scar",
            "def": "A region of DNA sequence formed from the ligation of two sticky ends where the palindrome is broken and no longer comprises the recognition site and thus cannot be re-cut by the restriction enzymes used to create the sticky ends. [SO:ke]"
        },
        "SO:0001954": {
            "name": "restriction_enzyme_region",
            "def": "A region related to restriction enzyme function. [SO:ke]"
        },
        "SO:0001955": {
            "name": "protein_stability_element",
            "def": "A polypeptide region that proves structure in a protein that affects the stability of the protein. [SO:ke]"
        },
        "SO:0001956": {
            "name": "protease_site",
            "def": "A polypeptide_region that  codes for a protease cleavage site. [SO:ke]"
        },
        "SO:0001957": {
            "name": "RNA_stability_element",
            "def": "RNA secondary structure that affects the stability of an RNA molecule. [SO:ke]"
        },
        "SO:0001958": {
            "name": "lariat_intron",
            "def": "A kind of intron whereby the excision is driven by lariat formation. [SO:ke]"
        },
        "SO:0001959": {
            "name": "TCT_motif",
            "def": "A cis-regulatory element, conserved sequence YYC+1TTTYY, and spans -2 to +6 relative to +1 TSS. It is present in most ribosomal protein genes in Drosophila and mammals but not in the yeast Saccharomyces cerevisiae. Resembles the initiator (TCAKTY in Drosophila) but functionally distinct from initiator. [PMID:20801935, SO:myl]"
        },
        "SO:0001960": {
            "name": "5_hydroxymethylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a hydroxymethyl group at the 5 carbon. [SO:ke]"
        },
        "SO:0001961": {
            "name": "5_formylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a formyl group at the 5 carbon. [SO:ke]"
        },
        "SO:0001962": {
            "name": "modified_adenine",
            "def": "A modified adenine DNA base feature. [SO:ke]"
        },
        "SO:0001963": {
            "name": "modified_cytosine",
            "def": "A modified cytosine DNA base feature. [SO:ke]"
        },
        "SO:0001964": {
            "name": "modified_guanine",
            "def": "A modified guanine DNA base feature. [SO:ke]"
        },
        "SO:0001965": {
            "name": "8_oxoguanine",
            "def": "A modified DNA guanine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
        },
        "SO:0001966": {
            "name": "5_carboxylcytosine",
            "def": "A modified DNA cytosine base feature, modified by a carboxy group at the 5 carbon. [SO:ke]"
        },
        "SO:0001967": {
            "name": "8_oxoadenine",
            "def": "A modified DNA adenine base,at the 8 carbon, often the product of DNA damage. [SO:ke]"
        },
        "SO:0001968": {
            "name": "coding_transcript_variant",
            "def": "A transcript variant of a protein coding gene. [SO:ke]"
        },
        "SO:0001969": {
            "name": "coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a coding transcript. [SO:ke]"
        },
        "SO:0001970": {
            "name": "non_coding_transcript_intron_variant",
            "def": "A transcript variant occurring within an intron of a non coding transcript. [SO:ke]"
        },
        "SO:0001971": {
            "name": "zinc_finger_binding_site"
        },
        "SO:0001972": {
            "name": "histone_4_acylation_site",
            "def": "A histone 4 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
        },
        "SO:0001973": {
            "name": "histone_3_acetylation_site",
            "def": "A histone 3 modification where the modification is the acylation of the residue. [EBI:nj, SO:ke]"
        },
        "SO:0001974": {
            "name": "CTCF_binding_site",
            "def": "A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG, bound by CCCTF-binding factor. [EBI:nj]"
        },
        "SO:0001975": {
            "name": "five_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 5 prime overhangs. [SO:ke]"
        },
        "SO:0001976": {
            "name": "three_prime_sticky_end_restriction_enzyme_cleavage_site",
            "def": "A restriction enzyme recognition site that, when cleaved, results in 3 prime overhangs. [SO:ke]"
        },
        "SO:0001977": {
            "name": "ribonuclease_site",
            "def": "A region of a transcript encoding the cleavage site for a ribonuclease enzyme. [SO:ke]"
        },
        "SO:0001978": {
            "name": "signature",
            "def": "A region of  sequence where developer information is encoded. [SO:ke]"
        },
        "SO:0001979": {
            "name": "RNA_stability_element",
            "def": "A motif that affects the stability of RNA. [PMID:22495308, SO:ke]"
        },
        "SO:0001980": {
            "name": "G_box",
            "def": "A regulatory promoter element identified in mutation experiments, with consensus sequence: CACGTG. Present in promoters, intergenic regions, coding regions, and introns. They are involved in gene expression responses to light and interact with G-box binding factor and I-box binding factor 1a. [PMID:19249238, PMID:8571452, SO:ml]"
        },
        "SO:0001981": {
            "name": "L_box",
            "def": "An orientation dependent  regulatory promoter element, with consensus sequence of TTGCACAN4TTGCACA, found in plants. [PMID:17381552, PMID:2902624, SO:ml]"
        },
        "SO:0001982": {
            "name": "I-box",
            "def": "A plant regulatory promoter motif,  composed of a highly conserved hexamer GATAAG (I-box core). [PMID:2347304, PMID:2902624, SO:ml]"
        },
        "SO:0001983": {
            "name": "5_prime_UTR_premature_start_codon_variant",
            "def": "A 5' UTR variant where a premature start codon is introduced, moved or lost. [SANGER:am]"
        },
        "SO:0001984": {
            "name": "silent_mating_type_cassette_array",
            "def": "A gene cassette array that corresponds to a silenced version of a mating type region. [PomBase:mah]"
        },
        "SO:0001985": {
            "name": "Okazaki_fragment",
            "def": "Any of the DNA segments produced by discontinuous synthesis of the lagging strand during DNA replication. [ISBN:0805350152]"
        },
        "SO:0001986": {
            "name": "upstream_transcript_variant",
            "def": "A feature variant, where the alteration occurs upstream of the transcript TSS. [EBI:gr]"
        },
        "SO:0001987": {
            "name": "downstream_transcript_variant"
        },
        "SO:0001988": {
            "name": "5_prime_UTR_premature_start_codon_gain_variant",
            "def": "A 5' UTR variant where a premature start codon is gained. [Sanger:am]"
        },
        "SO:0001989": {
            "name": "5_prime_UTR_premature_start_codon_loss_variant",
            "def": "A 5' UTR variant where a premature start codon is lost. [SANGER:am]"
        },
        "SO:0001990": {
            "name": "five_prime_UTR_premature_start_codon_location_variant",
            "def": "A 5' UTR variant where a premature start codon is moved. [SANGER:am]"
        },
        "SO:0001991": {
            "name": "consensus_AFLP_fragment",
            "def": "A consensus AFLP fragment is an AFLP sequence produced from any alignment algorithm which uses assembled multiple AFLP sequences as input. [GMOD:ea]"
        },
        "SO:0001992": {
            "name": "nonsynonymous_variant",
            "def": "A non-synonymous variant is an inframe, protein altering variant, resulting in a codon change. [SO:ke]"
        },
        "SO:0001993": {
            "name": "extended_cis_splice_site",
            "def": "Intronic positions associated with cis-splicing. Contains the first and second positions immediately before the exon and the first, second and fifth positions immediately after. [SANGER:am]"
        },
        "SO:0001994": {
            "name": "intron_base_5",
            "def": "Fifth intronic position after the intron exon boundary, close to the 5' edge of the intron. [SANGER:am]"
        },
        "SO:0001995": {
            "name": "extended_intronic_splice_region_variant",
            "def": "A sequence variant occurring in the intron, within 10 bases of exon. [sanger:am]"
        },
        "SO:0001996": {
            "name": "extended_intronic_splice_region",
            "def": "Region of intronic sequence within 10 bases of an exon. [SANGER:am]"
        },
        "SO:0001997": {
            "name": "subtelomere",
            "def": "A heterochromatic region of the chromosome,  adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes and it is transcribed. [POMBE:al]"
        },
        "SO:0001998": {
            "name": "sgRNA",
            "def": "A small RNA oligo, typically about 20 bases, that guides the cas nuclease to a target DNA sequence in the CRISPR/cas mutagenesis method. [PMID:23934893]"
        },
        "SO:0001999": {
            "name": "mating_type_region_motif",
            "def": "DNA motif that is a component of a mating type region. [SO:ke]"
        },
        "SO:0002001": {
            "name": "Y_region",
            "def": "A segment of non-homology between a and alpha mating alleles, found at all three mating loci (HML, MAT, and HMR), has two forms (Ya and Yalpha). [SGD:jd]"
        },
        "SO:0002002": {
            "name": "Z1_region",
            "def": "A mating type region motif, one of two segments of homology found at all three mating loci (HML, MAT, and HMR). [SGD:jd]"
        },
        "SO:0002003": {
            "name": "Z2_region",
            "def": "A mating type region motif, the rightmost segment of homology in the HML and MAT mating loci (not present in HMR). [SGD:jd]"
        },
        "SO:0002004": {
            "name": "ARS_consensus_sequence",
            "def": "The ACS is an 11-bp sequence of the form 5'-WTTTAYRTTTW-3' which is at the core of every yeast ARS, and is necessary but not sufficient for recognition and binding by the origin recognition complex (ORC). Functional ARSs require an ACS, as well as other cis elements in the 5' (C domain) and 3' (B domain) flanking sequences of the ACS. [SGD:jd]"
        },
        "SO:0002005": {
            "name": "DSR_motif",
            "def": "The determinant of selective removal (DSR) motif consists of repeats of U(U/C)AAAC. The motif targets meiotic transcripts for removal during mitosis via the exosome. [PMID:22645662]"
        },
        "SO:0002006": {
            "name": "zinc_repressed_element",
            "def": "A promoter element that has the consensus sequence GNMGATC, and is found in promoters of genes repressed in the presence of zinc. [PMID:24003116, POMBE:mh]"
        },
        "SO:0002007": {
            "name": "MNV",
            "def": "An MNV is a multiple nucleotide variant (substitution) in which the inserted sequence is the same length as the replaced sequence. [NCBI:th]"
        },
        "SO:0002008": {
            "name": "rare_amino_acid_variant",
            "def": "A sequence variant whereby at least one base of a codon encoding a rare amino acid is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002009": {
            "name": "selenocysteine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding selenocysteine  is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002010": {
            "name": "pyrrolysine_loss",
            "def": "A sequence variant whereby at least one base of a codon encoding pyrrolysine is changed, resulting in a different encoded amino acid. [SO:ke]"
        },
        "SO:0002011": {
            "name": "intragenic_variant",
            "def": "A variant that occurs within a gene but falls outside of all transcript features. This occurs when alternate transcripts of a gene do not share overlapping  sequence. [SO:ke]"
        },
        "SO:0002012": {
            "name": "start_lost",
            "def": "A codon variant that changes at least one base of the canonical start codon. [SO:ke]"
        },
        "SO:0002013": {
            "name": "5_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 5'UTR  with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002014": {
            "name": "5_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 5' UTR, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002015": {
            "name": "3_prime_UTR_truncation",
            "def": "A sequence variant that causes the reduction of a the 3' UTR  with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002016": {
            "name": "3_prime_UTR_elongation",
            "def": "A sequence variant that causes the extension of 3' UTR, with regard to the reference sequence. [SO:ke]"
        },
        "SO:0002017": {
            "name": "conserved_intergenic_variant",
            "def": "A sequence variant located in a conserved intergenic region, between genes. [SO:ke]"
        },
        "SO:0002018": {
            "name": "conserved_intron_variant",
            "def": "A transcript variant occurring within a conserved region of an intron. [SO:ke]"
        },
        "SO:0002019": {
            "name": "start_retained_variant",
            "def": "A sequence variant where at least one base in the start codon is changed, but the start remains. [SO:ke]"
        },
        "SO:0002020": {
            "name": "boundary_element",
            "def": "Boundary elements are DNA motifs that prevent heterochromatin from spreading into neighboring euchromatic regions. [PMID:24013502]"
        },
        "SO:0002021": {
            "name": "mating_type_region_replication_fork_barrier",
            "def": "A DNA motif that is found in eukaryotic rDNA repeats, and is a site of replication fork pausing. [PMID:17614787]"
        },
        "SO:0002022": {
            "name": "priRNA",
            "def": "A small RNA molecule, 22-23 nt in size, that is the product of a longer RNA. The production of priRNAs is independent of dicer and involves binding of RNA by argonaute and trimming by triman. In fission yeast, priRNAs trigger the establishment of heterochromatin. PriRNAs are primarily generated from centromeric transcripts (dg and dh repeats), but may also be produced from degradation products of primary transcripts. [PMID:20178743, PMID:24095277, PomBase:al]"
        },
        "SO:0002023": {
            "name": "multiplexing_sequence_identifier",
            "def": "A nucleic tag which is used in a ligation step of library preparation process to allow pooling of samples while maintaining ability to identify individual source material and creation of a multiplexed library. [OBO:prs, PMID:22574170]"
        },
        "SO:0002024": {
            "name": "W_region",
            "def": "The leftmost segment of homology in the HML and MAT mating loci,  but not present in HMR. [SGD:jd]"
        },
        "SO:0002025": {
            "name": "cis_acting_homologous_chromosome_pairing_region",
            "def": "A genome region where chromosome pairing occurs preferentially during homologous chromosome pairing during early meiotic prophase of Meiosis I. [PMID:22582262, PMID:23117617, PMID:24173580, PomBase:vw]"
        },
        "SO:0002026": {
            "name": "intein_encoding_region",
            "def": "The nucleotide sequence which encodes the intein portion of the precursor gene. [PMID:8165123]"
        },
        "SO:0002027": {
            "name": "uORF",
            "def": "A short open reading frame that is found in the 5' untranslated region of an mRNA and plays a role in translational regulation. [PMID:12890013, PMID:16153175, POMBASE:mah]"
        },
        "SO:0002028": {
            "name": "sORF",
            "def": "An open reading frame that encodes a peptide of less than 100 amino acids. [PMID:23970561, PMID:24705786, POMBASE:mah]"
        },
        "SO:0002029": {
            "name": "tnaORF",
            "def": "A translated ORF encoded entirely within the antisense strand of a known protein coding gene. [POMBASE:vw]"
        },
        "SO:0002030": {
            "name": "X_region",
            "def": "One of two segments of homology found at all three mating loci (HML, MAT and HMR). [SGD:jd]"
        },
        "SO:0002031": {
            "name": "shRNA",
            "def": "A short hairpin RNA (shRNA) is an RNA transcript that makes a tight hairpin turn that can be used to silence target gene expression via RNA interference. [PMID:6699500, SO:ke]"
        },
        "SO:0002032": {
            "name": "moR",
            "def": "A non-coding transcript encoded by sequences adjacent to the ends of the 5' and 3' miR-encoding sequences that abut the loop in precursor miRNA. [SO:ke]"
        },
        "SO:0002033": {
            "name": "loR",
            "def": "A short, non coding transcript of loop-derived sequences encoded in precursor miRNA. [SO:ke]"
        },
        "SO:0002034": {
            "name": "miR_encoding_snoRNA_primary_transcript",
            "def": "A snoRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002035": {
            "name": "lncRNA_primary_transcript",
            "def": "A primary transcript encoding a  lncRNA. [SO:ke]"
        },
        "SO:0002036": {
            "name": "miR_encoding_lncRNA_primary_transcript",
            "def": "A lncRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002037": {
            "name": "miR_encoding_tRNA_primary_transcript",
            "def": "A tRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002038": {
            "name": "shRNA_primary_transcript",
            "def": "A primary transcript encoding an shRNA. [SO:ke]"
        },
        "SO:0002039": {
            "name": "miR_encoding_shRNA_primary_transcript",
            "def": "A shRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002040": {
            "name": "vaultRNA_primary_transcript",
            "def": "A primary transcript encoding a  vaultRNA. [SO:ke]"
        },
        "SO:0002041": {
            "name": "miR_encoding_vaultRNA_primary_transcript",
            "def": "A vaultRNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002042": {
            "name": "Y_RNA_primary_transcript",
            "def": "A primary transcript encoding a  Y-RNA. [SO:ke]"
        },
        "SO:0002043": {
            "name": "miR_encoding_Y_RNA_primary_transcript",
            "def": "A Y-RNA primary transcript that also encodes pre-miR sequence that is processed to form functionally active miRNA. [SO:ke]"
        },
        "SO:0002044": {
            "name": "TCS_element",
            "def": "A TCS element is a (yeast) transcription factor binding site, bound by the TEA DNA binding domain (DBD) of transcription factors. The consensus site is CATTCC or CATTCT. [PMID:1489142, PMID:20118212, SO:ke]"
        },
        "SO:0002045": {
            "name": "pheromone_response_element",
            "def": "A PRE is a (yeast) TFBS with consensus site [TGAAAC(A/G)]. [PMID:1489142, SO:ke]"
        },
        "SO:0002046": {
            "name": "FRE",
            "def": "A FRE is an enhancer element necessary and sufficient to confer filamentation associated expression in S. cerevisiae. [PMID:1489142, SO:ke]"
        },
        "SO:0002047": {
            "name": "transcription_pause_site",
            "def": "Transcription pause sites are regions of a gene where RNA polymerase may pause during transcription. The functional role of pausing may be to facilitate factor recruitment, RNA folding, and synchronization with translation. Consensus transcription pause site have been observed in E. coli. [PMID:24789973, SO:ke]"
        },
        "SO:0002048": {
            "name": "disabled_reading_frame",
            "def": "A reading frame that could encode a full-length protein but which contains obvious mid-sequence disablements (frameshifts or premature stop codons). [SGD:se]"
        },
        "SO:0002049": {
            "name": "H3K27_acetylation_site",
            "def": "A kind of histone modification site, whereby the 27th residue (a lysine), from the start of the H3 histone protein is acetylated. [SO:rs]"
        },
        "SO:0002050": {
            "name": "constitutive_promoter",
            "def": "A promoter that allows for continual transcription of gene. [SO:ke]"
        },
        "SO:0002051": {
            "name": "inducible_promoter",
            "def": "A promoter whereby activity is induced by the presence or absence of biotic or abiotic factors. [SO:ke]"
        },
        "SO:0002052": {
            "name": "dominant_negative_variant",
            "def": "A variant where the mutated gene product adversely affects the other (wild type) gene product. [SO:ke]"
        },
        "SO:0002053": {
            "name": "gain_of_function_variant",
            "def": "A sequence variant whereby new or enhanced function is conferred on the gene product. [SO:ke]"
        },
        "SO:0002054": {
            "name": "loss_of_function_variant",
            "def": "A sequence variant whereby the gene product has diminished or abolished function. [SO:ke]"
        },
        "SO:0002055": {
            "name": "null_mutation",
            "def": "A variant whereby the gene product is not functional or the gene product is not produced. [SO:ke]"
        },
        "SO:0002056": {
            "name": "intronic_splicing_silencer",
            "def": "An intronic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
        },
        "SO:0002057": {
            "name": "intronic_splicing_enhancer"
        },
        "SO:0002058": {
            "name": "exonic_splicing_silencer",
            "def": "An exonic  splicing regulatory element that functions to recruit trans acting splicing factors suppress the transcription of the gene or genes they control. [PMID:23241926, SO:ke]"
        },
        "SO:0002059": {
            "name": "recombination_enhancer",
            "def": "A regulatory_region that promotes or induces the process of recombination. [PMID:8861911, SGD:se]"
        },
        "SO:0002060": {
            "name": "interchomosomal_translocation",
            "def": "A translocation where the regions involved are from different chromosomes. [NCBI:th]"
        },
        "SO:0002061": {
            "name": "intrachomosomal_translocation",
            "def": "A translocation where the regions involved are from the same chromosome. [NCBI:th]"
        },
        "SO:0002062": {
            "name": "complex_chromosomal_rearrangement",
            "def": "A contiguous cluster of translocations, usually the result of a single catastrophic event such as chromothripsis or chromoanasynthesis. [NCBI:th]"
        },
        "SO:0002063": {
            "name": "alu_insertion",
            "def": "An insertion of sequence from the Alu family of mobile elements. [NCBI:th]"
        },
        "SO:0002064": {
            "name": "LINE1_insertion",
            "def": "An insertion from the Line1 family of mobile elements. [NCBI:th]"
        },
        "SO:0002065": {
            "name": "SVA_insertion",
            "def": "An insertion of sequence from the SVA family of mobile elements. [NCBI:th]"
        },
        "SO:0005836": {
            "name": "regulatory_region",
            "def": "A region of sequence that is involved in the control of a biological process. [SO:ke]"
        },
        "SO:0005837": {
            "name": "U14_snoRNA_primary_transcript",
            "def": "The primary transcript of an evolutionarily conserved eukaryotic low molecular weight RNA capable of intermolecular hybridization with both homologous and heterologous 18S rRNA. [PMID:2251119]"
        },
        "SO:0005841": {
            "name": "methylation_guide_snoRNA",
            "def": "A snoRNA that specifies the site of 2'-O-ribose methylation in an RNA molecule by base pairing with a short sequence around the target residue. [GOC:mah, PMID:12457565]"
        },
        "SO:0005843": {
            "name": "rRNA_cleavage_RNA",
            "def": "An ncRNA that is part of a ribonucleoprotein that cleaves the primary pre-rRNA transcript in the process of producing mature rRNA molecules. [GOC:kgc]"
        },
        "SO:0005845": {
            "name": "exon_of_single_exon_gene",
            "def": "An exon that is the only exon in a gene. [RSC:cb]"
        },
        "SO:0005847": {
            "name": "cassette_array_member"
        },
        "SO:0005848": {
            "name": "gene_cassette_member"
        },
        "SO:0005849": {
            "name": "gene_subarray_member"
        },
        "SO:0005850": {
            "name": "primer_binding_site",
            "def": "Non-covalent primer binding site for initiation of replication, transcription, or reverse transcription. [http://www.ebi.ac.uk/embl/Documentation/FT_definitions/feature_table.html]"
        },
        "SO:0005851": {
            "name": "gene_array",
            "def": "An array includes two or more genes, or two or more gene subarrays, contiguously arranged where the individual genes, or subarrays, are either identical in sequence, or essentially so. [SO:ma]"
        },
        "SO:0005852": {
            "name": "gene_subarray",
            "def": "A subarray is, by defintition, a member of a gene array (SO:0005851); the members of a subarray may differ substantially in sequence, but are closely related in function. [SO:ma]"
        },
        "SO:0005853": {
            "name": "gene_cassette",
            "def": "A gene that can be substituted for a related gene at a different site in the genome. [SGD:se]"
        },
        "SO:0005854": {
            "name": "gene_cassette_array",
            "def": "An array of non-functional genes whose members, when captured by recombination form functional genes. [SO:ma]"
        },
        "SO:0005855": {
            "name": "gene_group",
            "def": "A collection of related genes. [SO:ma]"
        },
        "SO:0005856": {
            "name": "selenocysteine_tRNA_primary_transcript",
            "def": "A primary transcript encoding seryl tRNA (SO:000269). [SO:ke]"
        },
        "SO:0005857": {
            "name": "selenocysteinyl_tRNA",
            "def": "A tRNA sequence that has a selenocysteine anticodon, and a 3' selenocysteine binding region. [SO:ke]"
        },
        "SO:0005858": {
            "name": "syntenic_region",
            "def": "A region in which two or more pairs of homologous markers occur on the same chromosome in two or more species. [http://www.informatics.jax.org/silverbook/glossary.shtml]"
        },
        "SO:0100001": {
            "name": "biochemical_region_of_peptide",
            "def": "A region of a peptide that is involved in a biochemical function. [EBIBS:GAR]"
        },
        "SO:0100002": {
            "name": "molecular_contact_region",
            "def": "A region that is involved a contact with another molecule. [EBIBS:GAR]"
        },
        "SO:0100003": {
            "name": "intrinsically_unstructured_polypeptide_region",
            "def": "A region of polypeptide chain with high conformational flexibility. [EBIBS:GAR]"
        },
        "SO:0100004": {
            "name": "catmat_left_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100005": {
            "name": "catmat_left_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170.  The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100006": {
            "name": "catmat_right_handed_three",
            "def": "A motif of 3 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -75 bounds -100 to -50, res i+1: psi 140 bounds 110 to 170. An extra restriction of the length of the O to O distance would be useful, that it be less than 5 Angstrom. More precisely these two oxygens are the main chain carbonyl oxygen atoms of residues i-1 and i+1. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100007": {
            "name": "catmat_right_handed_four",
            "def": "A motif of 4 consecutive residues with dihedral angles as follows: res i: phi -90 bounds -120 to -60, res i: psi -10 bounds -50 to 30, res i+1: phi -90 bounds -120 to -60, res i+1: psi -10 bounds -50 to 30, res i+2: phi -75 bounds -100 to -50, res i+2: psi 140 bounds 110 to 170. The extra restriction of the length of the O to O distance is similar, that it be less than 5 Angstrom. In this case these two Oxygen atoms are the main chain carbonyl oxygen atoms of residues i-1 and i+2. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100008": {
            "name": "alpha_beta_motif",
            "def": "A motif of five consecutive residues and two H-bonds in which: H-bond between CO of residue(i) and NH of residue(i+4), H-bond between CO of residue(i) and NH of residue(i+3),Phi angles of residues(i+1), (i+2) and (i+3) are negative. [EBIBS:GAR, http://www.ebi.ac.uk/msd-srv/msdmotif/]"
        },
        "SO:0100009": {
            "name": "lipoprotein_signal_peptide",
            "def": "A peptide that acts as a signal for both membrane translocation and lipid attachment in prokaryotes. [EBIBS:GAR]"
        },
        "SO:0100010": {
            "name": "no_output",
            "def": "An experimental region wherean analysis has been run and not produced any annotation. [EBIBS:GAR]"
        },
        "SO:0100011": {
            "name": "cleaved_peptide_region",
            "def": "The cleaved_peptide_region is the region of a peptide sequence that is cleaved during maturation. [EBIBS:GAR]"
        },
        "SO:0100012": {
            "name": "peptide_coil",
            "def": "Irregular, unstructured regions of a protein's backbone, as distinct from the regular region (namely alpha helix and beta strand - characterised by specific patterns of main-chain hydrogen bonds). [EBIBS:GAR]"
        },
        "SO:0100013": {
            "name": "hydrophobic_region_of_peptide",
            "def": "Hydrophobic regions are regions with a low affinity for water. [EBIBS:GAR]"
        },
        "SO:0100014": {
            "name": "n_terminal_region",
            "def": "The amino-terminal positively-charged region of a signal peptide (approx 1-5 aa). [EBIBS:GAR]"
        },
        "SO:0100015": {
            "name": "c_terminal_region",
            "def": "The more polar, carboxy-terminal region of the signal peptide (approx 3-7 aa). [EBIBS:GAR]"
        },
        "SO:0100016": {
            "name": "central_hydrophobic_region_of_signal_peptide",
            "def": "The central, hydrophobic region of the signal peptide (approx 7-15 aa). [EBIBS:GAR]"
        },
        "SO:0100017": {
            "name": "polypeptide_conserved_motif",
            "def": "A conserved motif is a short (up to 20 amino acids) region of biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
        },
        "SO:0100018": {
            "name": "polypeptide_binding_motif",
            "def": "A polypeptide binding motif is a short (up to 20 amino acids) polypeptide region of biological interest that contains one or more amino acids experimentally shown to bind to a ligand. [EBIBS:GAR]"
        },
        "SO:0100019": {
            "name": "polypeptide_catalytic_motif",
            "def": "A polypeptide catalytic motif is a short (up to 20 amino acids) polypeptide region that contains one or more active site residues. [EBIBS:GAR]"
        },
        "SO:0100020": {
            "name": "polypeptide_DNA_contact",
            "def": "A binding site that, in the polypeptide molecule, interacts selectively and non-covalently with DNA. [EBIBS:GAR, SO:ke]"
        },
        "SO:0100021": {
            "name": "polypeptide_conserved_region",
            "def": "A subsection of sequence with biological interest that is conserved in different proteins. They may or may not have functional or structural significance within the proteins in which they are found. [EBIBS:GAR]"
        },
        "SO:1000002": {
            "name": "substitution",
            "def": "A sequence alteration where the length of the change in the variant is the same as that of the reference. [SO:ke]"
        },
        "SO:1000005": {
            "name": "complex_substitution",
            "def": "When no simple or well defined DNA mutation event describes the observed DNA change, the keyword \\complex\\ should be used. Usually there are multiple equally plausible explanations for the change. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000008": {
            "name": "point_mutation",
            "def": "A single nucleotide change which has occurred at the same position of a corresponding nucleotide in a reference sequence. [SO:immuno_workshop]"
        },
        "SO:1000009": {
            "name": "transition",
            "def": "Change of a pyrimidine nucleotide, C or T, into an other pyrimidine nucleotide, or change of a purine nucleotide, A or G, into an other purine nucleotide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000010": {
            "name": "pyrimidine_transition",
            "def": "A substitution of a pyrimidine, C or T, for another pyrimidine. [SO:ke]"
        },
        "SO:1000011": {
            "name": "C_to_T_transition",
            "def": "A transition of a cytidine to a thymine. [SO:ke]"
        },
        "SO:1000012": {
            "name": "C_to_T_transition_at_pCpG_site",
            "def": "The transition of cytidine to thymine occurring at a pCpG site as a consequence of the spontaneous deamination of 5'-methylcytidine. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000013": {
            "name": "T_to_C_transition"
        },
        "SO:1000014": {
            "name": "purine_transition",
            "def": "A substitution of a purine, A or G, for another purine. [SO:ke]"
        },
        "SO:1000015": {
            "name": "A_to_G_transition",
            "def": "A transition of an adenine to a guanine. [SO:ke]"
        },
        "SO:1000016": {
            "name": "G_to_A_transition",
            "def": "A transition of a guanine to an adenine. [SO:ke]"
        },
        "SO:1000017": {
            "name": "transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G, or vice versa. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000018": {
            "name": "pyrimidine_to_purine_transversion",
            "def": "Change of a pyrimidine nucleotide, C or T, into a purine nucleotide, A or G. [SO:ke]"
        },
        "SO:1000019": {
            "name": "C_to_A_transversion",
            "def": "A transversion from cytidine to adenine. [SO:ke]"
        },
        "SO:1000020": {
            "name": "C_to_G_transversion"
        },
        "SO:1000021": {
            "name": "T_to_A_transversion",
            "def": "A transversion from T to A. [SO:ke]"
        },
        "SO:1000022": {
            "name": "T_to_G_transversion",
            "def": "A transversion from T to G. [SO:ke]"
        },
        "SO:1000023": {
            "name": "purine_to_pyrimidine_transversion",
            "def": "Change of a purine nucleotide, A or G , into a pyrimidine nucleotide C or T. [SO:ke]"
        },
        "SO:1000024": {
            "name": "A_to_C_transversion",
            "def": "A transversion from adenine to cytidine. [SO:ke]"
        },
        "SO:1000025": {
            "name": "A_to_T_transversion",
            "def": "A transversion from adenine to thymine. [SO:ke]"
        },
        "SO:1000026": {
            "name": "G_to_C_transversion",
            "def": "A transversion from guanine to cytidine. [SO:ke]"
        },
        "SO:1000027": {
            "name": "G_to_T_transversion",
            "def": "A transversion from guanine to thymine. [SO:ke]"
        },
        "SO:1000028": {
            "name": "intrachromosomal_mutation",
            "def": "A chromosomal structure variation within a single chromosome. [SO:ke]"
        },
        "SO:1000029": {
            "name": "chromosomal_deletion",
            "def": "An incomplete chromosome. [SO:ke]"
        },
        "SO:1000030": {
            "name": "chromosomal_inversion",
            "def": "An interchromosomal mutation where a region of the chromosome is inverted with respect to wild type. [SO:ke]"
        },
        "SO:1000031": {
            "name": "interchromosomal_mutation",
            "def": "A chromosomal structure variation whereby more than one chromosome is involved. [SO:ke]"
        },
        "SO:1000032": {
            "name": "indel",
            "def": "A sequence alteration which included an insertion and a deletion, affecting 2 or more bases. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, http:http://www.hgvs.org/mutnomen/recs-DNA.html#indel]"
        },
        "SO:1000035": {
            "name": "duplication",
            "def": "An insertion which derives from, or is identical in sequence to, nucleotides present at a known location in the genome. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html, NCBI:th]"
        },
        "SO:1000036": {
            "name": "inversion",
            "def": "A continuous nucleotide sequence is inverted in the same position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000037": {
            "name": "chromosomal_duplication",
            "def": "An extra chromosome. [SO:ke]"
        },
        "SO:1000038": {
            "name": "intrachromosomal_duplication",
            "def": "A duplication that occurred within a chromosome. [SO:ke]"
        },
        "SO:1000039": {
            "name": "direct_tandem_duplication",
            "def": "A tandem duplication where the individual regions are in the same orientation. [SO:ke]"
        },
        "SO:1000040": {
            "name": "inverted_tandem_duplication",
            "def": "A tandem duplication where the individual regions are not in the same orientation. [SO:ke]"
        },
        "SO:1000041": {
            "name": "intrachromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred within a chromosome. [SO:ke]"
        },
        "SO:1000042": {
            "name": "compound_chromosome",
            "def": "A chromosome structure variant where a monocentric element is caused by the fusion of two chromosome arms. [SO:ke]"
        },
        "SO:1000043": {
            "name": "Robertsonian_fusion",
            "def": "A non reciprocal translocation whereby the participating chromosomes break at their centromeres and the long arms fuse to form a single chromosome with a single centromere. [http://en.wikipedia.org/wiki/Robertsonian_translocation]"
        },
        "SO:1000044": {
            "name": "chromosomal_translocation",
            "def": "An interchromosomal mutation. Rearrangements that alter the pairing of telomeres are classified as translocations. [FB:reference_manual]"
        },
        "SO:1000045": {
            "name": "ring_chromosome",
            "def": "A ring chromosome is a chromosome whose arms have fused together to form a ring, often with the loss of the ends of the chromosome. [http://en.wikipedia.org/wiki/Ring_chromosome]"
        },
        "SO:1000046": {
            "name": "pericentric_inversion",
            "def": "A chromosomal inversion that includes the centromere. [FB:reference_manual]"
        },
        "SO:1000047": {
            "name": "paracentric_inversion",
            "def": "A chromosomal inversion that does not include the centromere. [FB:reference_manual]"
        },
        "SO:1000048": {
            "name": "reciprocal_chromosomal_translocation",
            "def": "A chromosomal translocation with two breaks; two chromosome segments have simply been exchanged. [FB:reference_manual]"
        },
        "SO:1000049": {
            "name": "sequence_variation_affecting_transcript",
            "def": "Any change in mature, spliced and processed, RNA that results from a change in the corresponding DNA sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000050": {
            "name": "sequence_variant_causing_no_change_in_transcript",
            "def": "No effect on the state of the RNA. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000054": {
            "name": "sequence_variation_affecting_coding_sequence",
            "def": "Any of the amino acid coding triplets of a gene are affected by the DNA mutation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000055": {
            "name": "sequence_variant_causing_initiator_codon_change_in_transcript",
            "def": "The DNA mutation changes, usually destroys, the first coding triplet of a gene. Usually prevents translation although another initiator codon may be used. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000056": {
            "name": "sequence_variant_causing_amino_acid_coding_codon_change_in_transcript",
            "def": "The DNA mutation affects the amino acid coding sequence of a gene; this region includes both the initiator and terminator codons. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000057": {
            "name": "sequence_variant_causing_synonymous_codon_change_in_transcript",
            "def": "The changed codon has the same translation product as the original codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000058": {
            "name": "sequence_variant_causing_non_synonymous_codon_change_in_transcript",
            "def": "A DNA point mutation that causes a substitution of an amino acid by an other. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000059": {
            "name": "sequence_variant_causing_missense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon leads to a new codon coding for a new amino acid. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000060": {
            "name": "sequence_variant_causing_conservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change does not change the gross properties (size, charge, hydrophobicity) of the amino acid at that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000061": {
            "name": "sequence_variant_causing_nonconservative_missense_codon_change_in_transcript",
            "def": "The amino acid change following from the codon change changes the gross properties (size, charge, hydrophobicity) of the amino acid in that position. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000062": {
            "name": "sequence_variant_causing_nonsense_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet creates a terminator codon. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000063": {
            "name": "sequence_variant_causing_terminator_codon_change_in_transcript",
            "def": "The nucleotide change in the codon triplet changes the stop codon, causing an elongated transcript sequence. [SO:ke]"
        },
        "SO:1000064": {
            "name": "sequence_variation_affecting_reading_frame",
            "def": "An umbrella term for terms describing an effect of a sequence variation on the frame of translation. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000065": {
            "name": "frameshift_sequence_variation",
            "def": "A mutation causing a disruption of the translational reading frame, because the number of nucleotides inserted or deleted is not a multiple of three. [SO:ke]"
        },
        "SO:1000066": {
            "name": "sequence_variant_causing_plus_1_frameshift_mutation",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of a nucleotide. [SO:ke]"
        },
        "SO:1000067": {
            "name": "sequence_variant_causing_minus_1_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of a nucleotide. [SO:ke]"
        },
        "SO:1000068": {
            "name": "sequence_variant_causing_plus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the insertion of two nucleotides. [SO:ke]"
        },
        "SO:1000069": {
            "name": "sequence_variant_causing_minus_2_frameshift",
            "def": "A mutation causing a disruption of the translational reading frame, due to the deletion of two nucleotides. [SO:ke]"
        },
        "SO:1000070": {
            "name": "sequence_variant_affecting_transcript_processing",
            "def": "Sequence variant affects the way in which the primary transcriptional product is processed to form the mature transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000071": {
            "name": "sequence_variant_affecting_splicing",
            "def": "A sequence_variant_effect where the way in which the primary transcriptional product is processed to form the mature transcript, specifically by the removal (splicing) of intron sequences is changed. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000072": {
            "name": "sequence_variant_affecting_splice_donor",
            "def": "A sequence_variant_effect that changes the splice donor sequence. [SO:ke]"
        },
        "SO:1000073": {
            "name": "sequence_variant_affecting_splice_acceptor",
            "def": "A sequence_variant_effect that changes the splice acceptor sequence. [SO:ke]"
        },
        "SO:1000074": {
            "name": "sequence_variant_causing_cryptic_splice_activation",
            "def": "A sequence variant causing a new (functional) splice site. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000075": {
            "name": "sequence_variant_affecting_editing",
            "def": "Sequence variant affects the editing of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000076": {
            "name": "sequence_variant_affecting_transcription",
            "def": "Mutation affects the process of transcription, its initiation, progression or termination. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000078": {
            "name": "sequence_variant_decreasing_rate_of_transcription",
            "def": "A sequence variation that decreases the rate a which transcription of the sequence occurs. [SO:ke]"
        },
        "SO:1000079": {
            "name": "sequence_variation_affecting_transcript_sequence"
        },
        "SO:1000080": {
            "name": "sequence_variant_increasing_rate_of_transcription"
        },
        "SO:1000081": {
            "name": "sequence_variant_affecting_rate_of_transcription",
            "def": "A mutation that alters the rate a which transcription of the sequence occurs. [SO:ke]"
        },
        "SO:1000082": {
            "name": "sequence variant_affecting_transcript_stability",
            "def": "Sequence variant affects the stability of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000083": {
            "name": "sequence_variant_increasing_transcript_stability",
            "def": "Sequence variant increases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000084": {
            "name": "sequence_variant_decreasing_transcript_stability",
            "def": "Sequence variant decreases the stability (half-life) of the transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000085": {
            "name": "sequence_variation_affecting_level_of_transcript",
            "def": "A sequence variation that causes a change in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000086": {
            "name": "sequence_variation_decreasing_level_of_transcript",
            "def": "A sequence variation that causes a decrease in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000087": {
            "name": "sequence_variation_increasing_level_of_transcript",
            "def": "A sequence_variation that causes an increase in the level of mature, spliced and processed RNA, resulting from a change in the corresponding DNA sequence. [SO:ke]"
        },
        "SO:1000088": {
            "name": "sequence_variant_affecting_translational_product",
            "def": "A sequence variant causing a change in primary translation product of a transcript. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000089": {
            "name": "sequence_variant_causing_no_change_of_translational_product",
            "def": "The sequence variant at RNA level does not lead to any change in polypeptide. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000092": {
            "name": "sequence_variant_causing_complex_change_of_translational_product",
            "def": "Any sequence variant effect that is known at nucleotide level but cannot be explained by using other key terms. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000093": {
            "name": "sequence_variant_causing_amino_acid_substitution",
            "def": "The replacement of a single amino acid by another. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000094": {
            "name": "sequence_variant_causing_conservative_amino_acid_substitution"
        },
        "SO:1000095": {
            "name": "sequence_variant_causing_nonconservative_amino_acid_substitution"
        },
        "SO:1000096": {
            "name": "sequence_variant_causing_amino_acid_insertion",
            "def": "The insertion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000097": {
            "name": "sequence_variant_causing_amino_acid_deletion",
            "def": "The deletion of one or more amino acids from the polypeptide, without affecting the surrounding sequence. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000098": {
            "name": "sequence_variant_causing_polypeptide_truncation",
            "def": "The translational product is truncated at its C-terminus, usually a result of a nonsense codon change in transcript (SO:1000062). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000099": {
            "name": "sequence_variant_causing_polypeptide_elongation",
            "def": "The extension of the translational product at either (or both) the N-terminus and/or the C-terminus. [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000100": {
            "name": "mutation_causing_polypeptide_N_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000101": {
            "name": "mutation_causing_polypeptide_C_terminal_elongation",
            "def": ". [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000102": {
            "name": "sequence_variant_affecting_level_of_translational_product"
        },
        "SO:1000103": {
            "name": "sequence_variant_decreasing_level_of_translation_product"
        },
        "SO:1000104": {
            "name": "sequence_variant_increasing_level_of_translation_product"
        },
        "SO:1000105": {
            "name": "sequence_variant_affecting_polypeptide_amino_acid_sequence"
        },
        "SO:1000106": {
            "name": "mutation_causing_inframe_polypeptide_N_terminal_elongation"
        },
        "SO:1000107": {
            "name": "mutation_causing_out_of_frame_polypeptide_N_terminal_elongation"
        },
        "SO:1000108": {
            "name": "mutaton_causing_inframe_polypeptide_C_terminal_elongation"
        },
        "SO:1000109": {
            "name": "mutation_causing_out_of_frame_polypeptide_C_terminal_elongation"
        },
        "SO:1000110": {
            "name": "frame_restoring_sequence_variant",
            "def": "A mutation that reverts the sequence of a previous frameshift mutation back to the initial frame. [SO:ke]"
        },
        "SO:1000111": {
            "name": "sequence_variant_affecting_3D_structure_of_polypeptide",
            "def": "A mutation that changes the amino acid sequence of the peptide in such a way that it changes the 3D structure of the molecule. [SO:ke]"
        },
        "SO:1000112": {
            "name": "sequence_variant_causing_no_3D_structural_change"
        },
        "SO:1000115": {
            "name": "sequence_variant_causing_complex_3D_structural_change"
        },
        "SO:1000116": {
            "name": "sequence_variant_causing_conformational_change"
        },
        "SO:1000117": {
            "name": "sequence_variant_affecting_polypeptide_function"
        },
        "SO:1000118": {
            "name": "sequence_variant_causing_loss_of_function_of_polypeptide"
        },
        "SO:1000119": {
            "name": "sequence_variant_causing_inactive_ligand_binding_site"
        },
        "SO:1000120": {
            "name": "sequence_variant_causing_inactive_catalytic_site"
        },
        "SO:1000121": {
            "name": "sequence_variant_causing_polypeptide_localization_change"
        },
        "SO:1000122": {
            "name": "sequence_variant_causing_polypeptide_post_translational_processing_change"
        },
        "SO:1000123": {
            "name": "polypeptide_post_translational_processing_affected"
        },
        "SO:1000124": {
            "name": "sequence_variant_causing_partial_loss_of_function_of_polypeptide"
        },
        "SO:1000125": {
            "name": "sequence_variant_causing_gain_of_function_of_polypeptide"
        },
        "SO:1000126": {
            "name": "sequence_variant_affecting_transcript_secondary_structure",
            "def": "A sequence variant that affects the secondary structure (folding) of the RNA transcript molecule. [SO:ke]"
        },
        "SO:1000127": {
            "name": "sequence_variant_causing_compensatory_transcript_secondary_structure_mutation"
        },
        "SO:1000132": {
            "name": "sequence_variant_effect",
            "def": "The effect of a change in nucleotide sequence. [SO:ke]"
        },
        "SO:1000134": {
            "name": "sequence_variant_causing_polypeptide_fusion"
        },
        "SO:1000136": {
            "name": "autosynaptic_chromosome",
            "def": "An autosynaptic chromosome is the aneuploid product of recombination between a pericentric inversion and a cytologically wild-type chromosome. [PMID:6804304]"
        },
        "SO:1000138": {
            "name": "homo_compound_chromosome",
            "def": "A compound chromosome whereby two copies of the same chromosomal arm attached to a common centromere. The chromosome is diploid for the arm involved. [SO:ke]"
        },
        "SO:1000140": {
            "name": "hetero_compound_chromosome",
            "def": "A compound chromosome whereby two arms from different chromosomes are connected through the centromere of one of them. [FB:reference_manual, SO:ke]"
        },
        "SO:1000141": {
            "name": "chromosome_fission",
            "def": "A chromosome that occurred by the division of a larger chromosome. [SO:ke]"
        },
        "SO:1000142": {
            "name": "dexstrosynaptic_chromosome",
            "def": "An autosynaptic chromosome carrying the two right (D = dextro) telomeres. [FB:manual]"
        },
        "SO:1000143": {
            "name": "laevosynaptic_chromosome",
            "def": "LS is an autosynaptic chromosome carrying the two left (L = levo) telomeres. [FB:manual]"
        },
        "SO:1000144": {
            "name": "free_duplication",
            "def": "A chromosome structure variation whereby the duplicated sequences are carried as a free centric element. [FB:reference_manual]"
        },
        "SO:1000145": {
            "name": "free_ring_duplication",
            "def": "A ring chromosome which is a copy of another chromosome. [SO:ke]"
        },
        "SO:1000147": {
            "name": "deficient_translocation",
            "def": "A chromosomal deletion whereby a translocation occurs in which one of the four broken ends loses a segment before re-joining. [FB:reference_manual]"
        },
        "SO:1000148": {
            "name": "inversion_cum_translocation",
            "def": "A chromosomal translocation whereby the first two breaks are in the same chromosome, and the region between them is rejoined in inverted order to the other side of the first break, such that both sides of break one are present on the same chromosome. The remaining free ends are joined as a translocation with those resulting from the third break. [FB:reference_manual]"
        },
        "SO:1000149": {
            "name": "bipartite_duplication",
            "def": "An interchromosomal mutation whereby the (large) region between the first two breaks listed is lost, and the two flanking segments (one of them centric) are joined as a translocation to the free ends resulting from the third break. [FB:reference_manual]"
        },
        "SO:1000150": {
            "name": "cyclic_translocation",
            "def": "A chromosomal translocation whereby three breaks occurred in three different chromosomes. The centric segment resulting from the first break listed is joined to the acentric segment resulting from the second, rather than the third. [FB:reference_manual]"
        },
        "SO:1000151": {
            "name": "bipartite_inversion",
            "def": "A chromosomal inversion caused by three breaks in the same chromosome; both central segments are inverted in place (i.e., they are not transposed). [FB:reference_manual]"
        },
        "SO:1000152": {
            "name": "uninverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000153": {
            "name": "inverted_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
        },
        "SO:1000154": {
            "name": "insertional_duplication",
            "def": "A chromosome duplication involving the insertion of a duplicated region (as opposed to a free duplication). [SO:ke]"
        },
        "SO:1000155": {
            "name": "interchromosomal_transposition",
            "def": "A chromosome structure variation whereby a transposition occurred between chromosomes. [SO:ke]"
        },
        "SO:1000156": {
            "name": "inverted_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segment. [FB:reference_manual]"
        },
        "SO:1000157": {
            "name": "uninverted_interchromosomal_transposition",
            "def": "An interchromosomal transition where the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000158": {
            "name": "inverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically inverted orientation with respect to its flanking segments. [FB:reference_manual]"
        },
        "SO:1000159": {
            "name": "uninverted_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the insertion is in cytologically the same orientation as its flanking segments. [FB:reference_manual]"
        },
        "SO:1000160": {
            "name": "unoriented_insertional_duplication",
            "def": "An insertional duplication where a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000161": {
            "name": "unoriented_interchromosomal_transposition",
            "def": "An interchromosomal transposition whereby a copy of the segment between the first two breaks listed is inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000162": {
            "name": "unoriented_intrachromosomal_transposition",
            "def": "An intrachromosomal transposition whereby the segment between the first two breaks listed is removed and inserted at the third break; the orientation of the insertion with respect to its flanking segments is not recorded. [FB:reference_manual]"
        },
        "SO:1000170": {
            "name": "uncharacterized_chromosomal_mutation"
        },
        "SO:1000171": {
            "name": "deficient_inversion",
            "def": "A chromosomal deletion whereby three breaks occur in the same chromosome; one central region is lost, and the other is inverted. [FB:reference_manual, SO:ke]"
        },
        "SO:1000173": {
            "name": "tandem_duplication",
            "def": "A duplication consisting of 2 identical adjacent regions. [SO:ke]"
        },
        "SO:1000175": {
            "name": "partially_characterized_chromosomal_mutation"
        },
        "SO:1000180": {
            "name": "sequence_variant_affecting_gene_structure",
            "def": "A sequence_variant_effect that changes the gene structure. [SO:ke]"
        },
        "SO:1000181": {
            "name": "sequence_variant_causing_gene_fusion",
            "def": "A sequence_variant_effect that changes the gene structure by causing a fusion to another gene. [SO:ke]"
        },
        "SO:1000182": {
            "name": "chromosome_number_variation",
            "def": "A kind of chromosome variation where the chromosome complement is not an exact multiple of the haploid number. [SO:ke]"
        },
        "SO:1000183": {
            "name": "chromosome_structure_variation"
        },
        "SO:1000184": {
            "name": "sequence_variant_causes_exon_loss",
            "def": "A sequence variant affecting splicing and causes an exon loss. [SO:ke]"
        },
        "SO:1000185": {
            "name": "sequence_variant_causes_intron_gain",
            "def": "A sequence variant effect, causing an intron to be gained by the processed transcript; usually a result of a donor acceptor mutation (SO:1000072). [EBI:www.ebi.ac.uk/mutations/recommendations/mutevent.html]"
        },
        "SO:1000186": {
            "name": "sequence_variant_causing_cryptic_splice_donor_activation"
        },
        "SO:1001186": {
            "name": "sequence_variant_causing_cryptic_splice_acceptor_activation"
        },
        "SO:1001187": {
            "name": "alternatively_spliced_transcript",
            "def": "A transcript that is alternatively spliced. [SO:xp]"
        },
        "SO:1001188": {
            "name": "encodes_1_polypeptide",
            "def": "A gene that is alternately spliced, but encodes only one polypeptide. [SO:ke]"
        },
        "SO:1001189": {
            "name": "encodes_greater_than_1_polypeptide",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide. [SO:ke]"
        },
        "SO:1001190": {
            "name": "encodes_different_polypeptides_different_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different stop codons. [SO:ke]"
        },
        "SO:1001191": {
            "name": "encodes_overlapping_peptides_different_start",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start codons. [SO:ke]"
        },
        "SO:1001192": {
            "name": "encodes_disjoint_polypeptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that do not have overlapping peptide sequences. [SO:ke]"
        },
        "SO:1001193": {
            "name": "encodes_overlapping_polypeptides_different_start_and_stop",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences, but use different start and stop codons. [SO:ke]"
        },
        "SO:1001194": {
            "name": "alternatively_spliced_gene_encoding_greater_than_1_polypeptide_coding_regions_overlapping"
        },
        "SO:1001195": {
            "name": "encodes_overlapping_peptides",
            "def": "A gene that is alternately spliced, and encodes more than one polypeptide, that have overlapping peptide sequences. [SO:ke]"
        },
        "SO:1001196": {
            "name": "cryptogene",
            "def": "A maxicircle gene so extensively edited that it cannot be matched to its edited mRNA sequence. [SO:ma]"
        },
        "SO:1001197": {
            "name": "dicistronic_primary_transcript",
            "def": "A primary transcript that has the quality dicistronic. [SO:xp]"
        },
        "SO:1001217": {
            "name": "member_of_regulon"
        },
        "SO:1001244": {
            "name": "alternatively_spliced_transcript_encoding_greater_than_1_polypeptide_different_start_codon_different_stop_codon_coding_regions_non_overlapping"
        },
        "SO:1001246": {
            "name": "CDS_independently_known",
            "def": "A CDS with the evidence status of being independently known. [SO:xp]"
        },
        "SO:1001247": {
            "name": "orphan_CDS",
            "def": "A CDS whose predicted amino acid sequence is unsupported by any experimental evidence or by any match with any other known sequence. [SO:ma]"
        },
        "SO:1001249": {
            "name": "CDS_supported_by_domain_match_data",
            "def": "A CDS that is supported by domain similarity. [SO:xp]"
        },
        "SO:1001251": {
            "name": "CDS_supported_by_sequence_similarity_data",
            "def": "A CDS that is supported by sequence similarity data. [SO:xp]"
        },
        "SO:1001254": {
            "name": "CDS_predicted",
            "def": "A CDS that is predicted. [SO:ke]"
        },
        "SO:1001255": {
            "name": "status_of_coding_sequence"
        },
        "SO:1001259": {
            "name": "CDS_supported_by_EST_or_cDNA_data",
            "def": "A CDS that is supported by similarity to EST or cDNA data. [SO:xp]"
        },
        "SO:1001260": {
            "name": "internal_Shine_Dalgarno_sequence",
            "def": "A Shine-Dalgarno sequence that stimulates recoding through interactions with the anti-Shine-Dalgarno in the RNA of small ribosomal subunits of translating ribosomes. The signal is only operative in Bacteria. [PMID:12519954, SO:ke]"
        },
        "SO:1001261": {
            "name": "recoded_mRNA",
            "def": "The sequence of a mature mRNA transcript, modified before translation or during translation, usually by special cis-acting signals. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
        },
        "SO:1001262": {
            "name": "minus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of -1. [SO:ke]"
        },
        "SO:1001263": {
            "name": "plus_1_translationally_frameshifted",
            "def": "An attribute describing a translational frameshift of +1. [SO:ke]"
        },
        "SO:1001264": {
            "name": "mRNA_recoded_by_translational_bypass",
            "def": "A recoded_mRNA where translation was suspended at a particular codon and resumed at a particular non-overlapping downstream codon. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8811194&dopt=Abstract]"
        },
        "SO:1001265": {
            "name": "mRNA_recoded_by_codon_redefinition",
            "def": "A recoded_mRNA that was modified by an alteration of codon meaning. [SO:ma]"
        },
        "SO:1001266": {
            "name": "stop_codon_redefinition_as_selenocysteine"
        },
        "SO:1001267": {
            "name": "stop_codon_readthrough"
        },
        "SO:1001268": {
            "name": "recoding_stimulatory_region",
            "def": "A site in an mRNA sequence that stimulates the recoding of a region in the same mRNA. [http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=12519954&dopt=Abstract]"
        },
        "SO:1001269": {
            "name": "four_bp_start_codon",
            "def": "A non-canonical start codon with 4 base pairs. [SO:ke]"
        },
        "SO:1001270": {
            "name": "stop_codon_redefinition_as_pyrrolysine"
        },
        "SO:1001271": {
            "name": "archaeal_intron",
            "def": "An intron characteristic of Archaeal tRNA and rRNA genes, where intron transcript generates a bulge-helix-bulge motif that is recognised by a splicing endoribonuclease. [PMID:9301331, SO:ma]"
        },
        "SO:1001272": {
            "name": "tRNA_intron",
            "def": "An intron found in tRNA that is spliced via endonucleolytic cleavage and ligation rather than transesterification. [SO:ke]"
        },
        "SO:1001273": {
            "name": "CTG_start_codon",
            "def": "A non-canonical start codon of sequence CTG. [SO:ke]"
        },
        "SO:1001274": {
            "name": "SECIS_element",
            "def": "The incorporation of selenocysteine into a protein sequence is directed by an in-frame UGA codon (usually a stop codon) within the coding region of the mRNA. Selenoprotein mRNAs contain a conserved secondary structure in the 3' UTR that is required for the distinction of UGA stop from UGA selenocysteine. The selenocysteine insertion sequence (SECIS) is around 60 nt in length and adopts a hairpin structure which is sufficiently well-defined and conserved to act as a computational screen for selenoprotein genes. [http://www.sanger.ac.uk/cgi-bin/Rfam/getacc?RF00031]"
        },
        "SO:1001275": {
            "name": "retron",
            "def": "Sequence coding for a short, single-stranded, DNA sequence via a retrotransposed RNA intermediate; characteristic of some microbial genomes. [SO:ma]"
        },
        "SO:1001277": {
            "name": "three_prime_recoding_site",
            "def": "The recoding stimulatory signal located downstream of the recoding site. [SO:ke]"
        },
        "SO:1001279": {
            "name": "three_prime_stem_loop_structure",
            "def": "A recoding stimulatory region, the stem-loop secondary structural element is downstream of the redefined region. [PMID:12519954, SO:ke]"
        },
        "SO:1001280": {
            "name": "five_prime_recoding_site",
            "def": "The recoding stimulatory signal located upstream of the recoding site. [SO:ke]"
        },
        "SO:1001281": {
            "name": "flanking_three_prime_quadruplet_recoding_signal",
            "def": "Four base pair sequence immediately downstream of the redefined region. The redefined region is a frameshift site. The quadruplet is 2 overlapping codons. [PMID:12519954, SO:ke]"
        },
        "SO:1001282": {
            "name": "UAG_stop_codon_signal",
            "def": "A stop codon signal for a UAG stop codon redefinition. [SO:ke]"
        },
        "SO:1001283": {
            "name": "UAA_stop_codon_signal",
            "def": "A stop codon signal for a UAA stop codon redefinition. [SO:ke]"
        },
        "SO:1001284": {
            "name": "regulon",
            "def": "A group of genes, whether linked as a cluster or not, that respond to a common regulatory signal. [ISBN:0198506732]"
        },
        "SO:1001285": {
            "name": "UGA_stop_codon_signal",
            "def": "A stop codon signal for a UGA stop codon redefinition. [SO:ke]"
        },
        "SO:1001286": {
            "name": "three_prime_repeat_recoding_signal",
            "def": "A recoding stimulatory signal, downstream sequence important for recoding that contains repetitive elements. [PMID:12519954, SO:ke]"
        },
        "SO:1001287": {
            "name": "distant_three_prime_recoding_signal",
            "def": "A recoding signal that is found many hundreds of nucleotides 3' of a redefined stop codon. [http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=8709208&dopt=Abstract]"
        },
        "SO:1001288": {
            "name": "stop_codon_signal",
            "def": "A recoding stimulatory signal that is a stop codon and has effect on efficiency of recoding. [PMID:12519954, SO:ke]"
        },
        "SO:2000061": {
            "name": "databank_entry",
            "def": "The sequence referred to by an entry in a databank such as GenBank or SwissProt. [SO:ke]"
        },
        "SO:3000000": {
            "name": "gene_segment",
            "def": "A gene component region which acts as a recombinational unit of a gene whose functional form is generated through somatic recombination. [GOC:add]"
        }
    };
})(sequenceOntology = exports.sequenceOntology || (exports.sequenceOntology = {}));


/***/ }),

/***/ "./node_modules/rdfoo/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/rdfoo/dist/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __webpack_require__(/*! ./rdfoo/Graph */ "./node_modules/rdfoo/dist/rdfoo/Graph.js");
exports.Graph = Graph_1.default;
const Facade_1 = __webpack_require__(/*! ./rdfoo/Facade */ "./node_modules/rdfoo/dist/rdfoo/Facade.js");
exports.Facade = Facade_1.default;
const GraphView_1 = __webpack_require__(/*! ./rdfoo/GraphView */ "./node_modules/rdfoo/dist/rdfoo/GraphView.js");
exports.GraphView = GraphView_1.default;
const GraphViewHybrid_1 = __webpack_require__(/*! ./rdfoo/GraphViewHybrid */ "./node_modules/rdfoo/dist/rdfoo/GraphViewHybrid.js");
exports.GraphViewHybrid = GraphViewHybrid_1.default;
const GraphViewBasic_1 = __webpack_require__(/*! ./rdfoo/GraphViewBasic */ "./node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js");
exports.GraphViewBasic = GraphViewBasic_1.default;
const node = __webpack_require__(/*! ./rdfoo/node */ "./node_modules/rdfoo/dist/rdfoo/node.js");
exports.node = node;
const triple = __webpack_require__(/*! ./rdfoo/triple */ "./node_modules/rdfoo/dist/rdfoo/triple.js");
exports.triple = triple;
const serialize_1 = __webpack_require__(/*! ./rdfoo/serialize */ "./node_modules/rdfoo/dist/rdfoo/serialize.js");
exports.serialize = serialize_1.default;
const changeURIPrefix_1 = __webpack_require__(/*! ./rdfoo/changeURIPrefix */ "./node_modules/rdfoo/dist/rdfoo/changeURIPrefix.js");
exports.changeURIPrefix = changeURIPrefix_1.default;
const identifyFiletype_1 = __webpack_require__(/*! ./rdfoo/identifyFiletype */ "./node_modules/rdfoo/dist/rdfoo/identifyFiletype.js");
exports.identifyFiletype = identifyFiletype_1.default;
exports.Filetype = identifyFiletype_1.Filetype;
const parseRDF_1 = __webpack_require__(/*! ./rdfoo/parseRDF */ "./node_modules/rdfoo/dist/rdfoo/parseRDF.js");
exports.parseRDF = parseRDF_1.default;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/Facade.js":
/*!*************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/Facade.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const triple = __webpack_require__(/*! ./triple */ "./node_modules/rdfoo/dist/rdfoo/triple.js");
const node = __webpack_require__(/*! ./node */ "./node_modules/rdfoo/dist/rdfoo/node.js");
class Facade {
    constructor(graph, uri) {
        this.graph = graph;
        this.uri = uri;
    }
    getProperty(predicate) {
        return this.graph.matchOne(this.uri, predicate, null);
    }
    getUriProperty(predicate) {
        return triple.objectUri(this.getProperty(predicate));
    }
    getRequiredUriProperty(predicate) {
        const prop = triple.objectUri(this.getProperty(predicate));
        if (prop === undefined)
            throw new Error('missing property ' + predicate);
        return prop;
    }
    getStringProperty(predicate) {
        return triple.objectString(this.getProperty(predicate));
    }
    getRequiredStringProperty(predicate) {
        const prop = triple.objectString(this.getProperty(predicate));
        if (prop === undefined)
            throw new Error('missing property ' + predicate);
        return prop;
    }
    getIntProperty(predicate) {
        return triple.objectInt(this.getProperty(predicate));
    }
    getBoolProperty(predicate) {
        return triple.objectBool(this.getProperty(predicate));
    }
    getFloatProperty(predicate) {
        return triple.objectFloat(this.getProperty(predicate));
    }
    getProperties(predicate) {
        return this.graph.match(this.uri, predicate, null);
    }
    getUriProperties(predicate) {
        return this.getProperties(predicate).map(triple.objectUri).filter((el) => !!el);
    }
    getStringProperties(predicate) {
        return this.getProperties(predicate).map(triple.objectString).filter((el) => !!el);
    }
    setProperty(predicate, object) {
        this.graph.removeMatches(this.uri, predicate, null);
        this.graph.insert(this.uri, predicate, object);
    }
    insertProperty(predicate, object) {
        this.graph.insert(this.uri, predicate, object);
    }
    insertProperties(properties) {
        this.graph.insertProperties(this.uri, properties);
    }
    deleteProperty(predicate) {
        this.graph.removeMatches(this.uri, predicate, null);
    }
    setUriProperty(predicate, value) {
        if (value === undefined) {
            this.deleteProperty(predicate);
        }
        else {
            this.setProperty(predicate, node.createUriNode(value));
        }
    }
    insertUriProperty(predicate, value) {
        this.insertProperty(predicate, node.createUriNode(value));
    }
    setStringProperty(predicate, value) {
        if (value === undefined) {
            this.deleteProperty(predicate);
        }
        else {
            this.setProperty(predicate, node.createStringNode(value));
        }
    }
    setIntProperty(predicate, value) {
        if (value === undefined) {
            this.deleteProperty(predicate);
        }
        else {
            this.setProperty(predicate, node.createIntNode(value));
        }
    }
    setBoolProperty(predicate, value) {
        if (value === undefined) {
            this.deleteProperty(predicate);
        }
        else {
            this.setProperty(predicate, node.createBoolNode(value));
        }
    }
    setFloatProperty(predicate, value) {
        if (value === undefined) {
            this.deleteProperty(predicate);
        }
        else {
            this.setProperty(predicate, node.createFloatNode(value));
        }
    }
    get objectType() {
        return this.getUriProperty('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
    }
    hasCorrectTypePredicate() {
        return this.objectType === this.facadeType;
    }
    watch(cb) {
        return this.graph.watchSubject(this.uri, cb);
    }
    destroy() {
        this.graph.removeMatches(null, null, this.uri);
        this.graph.removeMatches(this.uri, null, null);
    }
}
exports.default = Facade;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/Graph.js":
/*!************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/Graph.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node = __webpack_require__(/*! ./node */ "./node_modules/rdfoo/dist/rdfoo/node.js");
const power_assert_1 = __webpack_require__(/*! power-assert */ "./node_modules/power-assert/index.js");
const shortid = __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js");
const identifyFiletype_1 = __webpack_require__(/*! ./identifyFiletype */ "./node_modules/rdfoo/dist/rdfoo/identifyFiletype.js");
const parseRDF_1 = __webpack_require__(/*! ./parseRDF */ "./node_modules/rdfoo/dist/rdfoo/parseRDF.js");
const serialize_1 = __webpack_require__(/*! ./serialize */ "./node_modules/rdfoo/dist/rdfoo/serialize.js");
const rdf_serializer_ntriples_1 = __webpack_require__(/*! rdf-serializer-ntriples */ "./node_modules/rdf-serializer-ntriples/index.js");
let RdfGraphArray = __webpack_require__(/*! rdf-graph-array-sboljs */ "./node_modules/rdf-graph-array-sboljs/index.js").Graph;
class Graph {
    constructor(triples) {
        this.graph = triples ? new RdfGraphArray(triples) : new RdfGraphArray([]);
        this._globalWatchers = new Array();
        this._subjWatchers = new Map();
        this.ignoreWatchers = false;
    }
    match(s, p, o) {
        if (s === undefined || p === undefined || o === undefined) {
            console.dir(arguments);
            throw new Error('one of s/p/o were undefined');
        }
        const res = this.graph.match(s, p, o).toArray();
        // console.log('Match { ' + s + ', ' + p + ', ' + o + ' } => ' + res.length)
        return res;
    }
    matchOne(s, p, o) {
        if (s === undefined || p === undefined || o === undefined)
            throw new Error('one of s/p/o were undefined');
        if (!s && !o) {
            console.dir({ s, p, o });
            throw new Error('matchOne with only a predicate?');
        }
        if (!p && !o) {
            console.dir({ s, p, o });
            throw new Error('matchOne with only a subject?');
        }
        if (!s && !p) {
            console.dir({ s, p, o });
            throw new Error('matchOne with only an object?');
        }
        const matches = this.match(s, p, o);
        if (matches.length > 1) {
            console.error('results:');
            console.dir(matches);
            throw new Error('Got more than one result for matchOne { ' + [s, p, o].join(', ') + ' }');
        }
        return matches[0];
    }
    hasMatch(s, p, o) {
        if (s === undefined || p === undefined || o === undefined)
            throw new Error('one of s/p/o were undefined');
        return this.match(s, p, o).length > 0;
    }
    addAll(other) {
        this.graph.addAll(other.graph);
    }
    get subjects() {
        let subjects = [];
        for (let k of Object.keys(this.graph._gspo)) {
            subjects = subjects.concat(Object.keys(this.graph._gspo[k]));
        }
        return subjects;
    }
    fireWatchers(subj) {
        if (this.ignoreWatchers)
            return;
        const watchers = this._subjWatchers.get(subj);
        if (watchers === undefined)
            return;
        watchers.forEach((cb) => {
            cb();
        });
    }
    fireGlobalWatchers() {
        if (this.ignoreWatchers)
            return;
        this._globalWatchers.forEach((cb) => cb());
    }
    insert(...args) {
        if (arguments.length === 3) {
            this.graph.add({
                subject: node.createUriNode(arguments[0]),
                predicate: node.createUriNode(arguments[1]),
                object: arguments[2],
            });
            this.touchSubject(arguments[0]);
        }
        else {
            power_assert_1.default(Array.isArray(arguments[0]));
            const w = new Set();
            arguments[0].forEach((t) => {
                //console.log('Insert { ' + t.subject + ', ' + t.predicate + ', ' + t.object + ' }')
                this.insert(t.subject, t.predicate, t.object);
                w.add(t.subject);
            });
            w.forEach((uri) => {
                this.touchSubject(uri);
            });
        }
    }
    touchSubject(subject) {
        this.fireWatchers(subject);
        this.fireGlobalWatchers();
    }
    insertProperties(subject, properties) {
        var triples = [];
        Object.keys(properties).forEach((property) => {
            power_assert_1.default(('' + property) !== 'undefined');
            var value = properties[property];
            if (Array.isArray(value)) {
                value.forEach((value) => {
                    triples.push({
                        subject: subject,
                        predicate: property,
                        object: value
                    });
                });
            }
            else {
                triples.push({
                    subject: subject,
                    predicate: property,
                    object: value
                });
            }
        });
        this.insert(triples);
    }
    removeMatches(s, p, o) {
        if (s === undefined || p === undefined || o === undefined)
            throw new Error('one of s/p/o were undefined');
        //console.log('Remove matches { ' + s + ', ' + p + ', ' + o + ' }')
        const w = new Set();
        const matches = this.match(s, p, o);
        matches.forEach((t) => {
            w.add(t.subject);
        });
        this.graph.removeMatches(s, p, o);
        w.forEach((uri) => {
            this.touchSubject(uri);
        });
        this.fireGlobalWatchers();
    }
    generateURI(template) {
        var n = 1;
        for (;;) {
            var uri = template.split('$rand$').join(shortid.generate())
                .split('$^n$').join('' + n)
                .split('$n$').join('_' + n)
                .split('$n?$').join(n > 1 ? ('_' + n) : '');
            ++n;
            if (this.hasMatch(uri, null, null))
                continue;
            return uri;
        }
    }
    purgeSubject(subject) {
        //console.log('purge ' + subject)
        this.graph.removeMatches(subject, null, null);
        this.graph.removeMatches(null, null, subject);
    }
    replaceURI(oldURI, newURI) {
        // TODO: do this in-place instead of creating a new graph
        //
        let newGraph = new RdfGraphArray();
        for (let triple of this.graph._graph) {
            newGraph.add({
                subject: replace(triple.subject),
                predicate: replace(triple.predicate),
                object: replace(triple.object)
            });
        }
        this.graph = newGraph;
        function replace(n) {
            if (n.interfaceName !== 'NamedNode')
                return n;
            if (n.nominalValue !== oldURI)
                return n;
            return node.createUriNode(newURI);
        }
    }
    watchSubject(uri, cb) {
        const watchers = this._subjWatchers.get(uri);
        if (watchers === undefined) {
            this._subjWatchers.set(uri, [cb]);
        }
        else {
            watchers.push(cb);
        }
        return {
            unwatch: () => {
                const watchers = this._subjWatchers.get(uri);
                if (watchers !== undefined) {
                    for (var i = 0; i < watchers.length; ++i) {
                        if (watchers[i] === cb) {
                            watchers.splice(i, 1);
                            break;
                        }
                    }
                    if (watchers.length === 0) {
                        this._subjWatchers.delete(uri);
                    }
                }
            }
        };
    }
    watch(cb) {
        this._globalWatchers.push(cb);
        return {
            unwatch: () => {
                for (var i = 0; i < this._globalWatchers.length; ++i) {
                    if (this._globalWatchers[i] === cb) {
                        this._globalWatchers.splice(i, 1);
                        break;
                    }
                }
            }
        };
    }
    static loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let graph = new Graph();
            yield graph.loadString(data, defaultURIPrefix, mimeType);
            return graph;
        });
    }
    loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let filetype = identifyFiletype_1.default(data, mimeType || null);
            if (filetype === null) {
                throw new Error('???');
            }
            yield parseRDF_1.default(this, data, filetype);
        });
    }
    startIgnoringWatchers() {
        this.ignoreWatchers = true;
    }
    stopIgnoringWatchers() {
        this.ignoreWatchers = false;
    }
    toArray() {
        return this.graph.toArray();
    }
    clone() {
        return new Graph(this.graph.toArray());
    }
    serializeXML() {
        return serialize_1.default(this, new Map(), () => false, '');
    }
    serializeN3() {
        let serializer = new (new rdf_serializer_ntriples_1.default()).Impl(this.graph);
        console.dir(serializer);
    }
}
exports.default = Graph;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/GraphView.js":
/*!****************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/GraphView.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GraphView {
    constructor(graph) {
        this.graph = graph;
    }
}
exports.default = GraphView;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js":
/*!*********************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GraphView_1 = __webpack_require__(/*! ./GraphView */ "./node_modules/rdfoo/dist/rdfoo/GraphView.js");
const triple = __webpack_require__(/*! ./triple */ "./node_modules/rdfoo/dist/rdfoo/triple.js");
class GraphViewBasic extends GraphView_1.default {
    constructor(graph) {
        super(graph);
    }
    uriToFacade(uri) {
        return undefined;
    }
    hasType(s, t) {
        return this.graph.match(s, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', t).length > 0;
    }
    instancesOfType(type) {
        return this.graph.match(null, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', type)
            .map(triple.subjectUri);
    }
    getType(uri) {
        const type = triple.objectUri(this.graph.matchOne(uri, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', null));
        return type;
    }
    getTypes(uri) {
        const types = this.graph.match(uri, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', null)
            .map(triple.objectUri);
        return types;
    }
}
exports.default = GraphViewBasic;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/GraphViewHybrid.js":
/*!**********************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/GraphViewHybrid.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GraphViewBasic_1 = __webpack_require__(/*! ./GraphViewBasic */ "./node_modules/rdfoo/dist/rdfoo/GraphViewBasic.js");
class GraphViewHybrid extends GraphViewBasic_1.default {
    constructor(graph) {
        super(graph);
        this.views = [];
    }
    addView(view) {
        this.views.push(view);
    }
    uriToFacade(uri) {
        for (let d of this.views) {
            let f = d.uriToFacade(uri);
            if (f !== undefined) {
                return f;
            }
        }
        return undefined;
    }
}
exports.default = GraphViewHybrid;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/changeURIPrefix.js":
/*!**********************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/changeURIPrefix.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdf = __webpack_require__(/*! rdf-ext */ "./node_modules/rdf-ext/rdf-ext.js");
const RdfGraphArray = __webpack_require__(/*! rdf-graph-array-sboljs */ "./node_modules/rdf-graph-array-sboljs/index.js");
function changeURIPrefix(graph, topLevels, newPrefix) {
    let triples = graph.graph._graph;
    let newGraph = new RdfGraphArray.Graph([]);
    let prefixes = new Set();
    let identityMap = new Map();
    for (let triple of triples) {
        if (triple.predicate.nominalValue === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
            if (topLevels.has(triple.object.nominalValue)) {
                let subjectPrefix = prefix(triple.subject.nominalValue);
                prefixes.add(subjectPrefix);
            }
        }
    }
    for (let triple of triples) {
        let subject = triple.subject;
        let predicate = triple.predicate;
        let object = triple.object;
        let matched = false;
        for (let prefix of prefixes) {
            if (subject.nominalValue.indexOf(prefix) === 0) {
                let newSubject = rdf.createNamedNode(newPrefix + subject.nominalValue.slice(prefix.length));
                identityMap.set(subject.nominalValue, newSubject.nominalValue);
                subject = newSubject;
                matched = true;
                break;
            }
        }
        if (!matched) {
            // can't change prefix, just drop the triple
            continue;
        }
        if (object.interfaceName === 'NamedNode') {
            for (let prefix of prefixes) {
                if (object.nominalValue.indexOf(prefix) === 0) {
                    let newObject = rdf.createNamedNode(newPrefix + object.nominalValue.slice(prefix.length));
                    identityMap.set(object.nominalValue, newObject.nominalValue);
                    object = newObject;
                    break;
                }
            }
        }
        newGraph.add({ subject, predicate, object });
    }
    console.dir(prefixes);
    graph.graph = newGraph;
    return identityMap;
    // TODO currently only works for SBOL compliant URIs
    // 
    function prefix(uri) {
        let n = 0;
        for (let i = uri.length - 1; i > 0; --i) {
            if (uri[i] === '/') {
                ++n;
                if (n === 2) {
                    return uri.slice(0, i + 1);
                }
            }
        }
        throw new Error('cant get prefix');
    }
}
exports.default = changeURIPrefix;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/identifyFiletype.js":
/*!***********************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/identifyFiletype.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Filetype;
(function (Filetype) {
    Filetype[Filetype["FASTA"] = 0] = "FASTA";
    Filetype[Filetype["GenBank"] = 1] = "GenBank";
    Filetype[Filetype["RDFXML"] = 2] = "RDFXML";
    Filetype[Filetype["NTriples"] = 3] = "NTriples";
})(Filetype = exports.Filetype || (exports.Filetype = {}));
function identifyFiletype(content, mimeType) {
    switch (mimeType) {
        case 'application/rdf+xml':
        case 'application/xml':
        case 'text/xml':
            return Filetype.RDFXML;
        case 'text/turtle':
        case 'text/n3':
        case 'text/n-triples':
            return Filetype.NTriples;
    }
    let n = 0;
    while (content[n].trim().length === 0)
        ++n;
    if (content[n] === '>') {
        return Filetype.FASTA;
    }
    if (content[n] === '@') {
        return Filetype.NTriples; // @prefix maybe
    }
    if (content[n] === '#') {
        return Filetype.NTriples; // # Empty TURTLE
    }
    if (content.substr(n, 5) === 'LOCUS') {
        return Filetype.GenBank;
    }
    if (content.substr(n, 5) === '<?xml') {
        return Filetype.RDFXML;
    }
    if (content.substr(n, 5) === '<rdf:') {
        return Filetype.RDFXML;
    }
    let firstLineEnd = content.indexOf('\n', n);
    if (firstLineEnd !== -1) {
        if (content[n] === '<' && content[firstLineEnd - 1] === '.') {
            return Filetype.NTriples;
        }
    }
    return null;
}
exports.default = identifyFiletype;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/node.js":
/*!***********************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/node.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdf = __webpack_require__(/*! rdf-ext */ "./node_modules/rdf-ext/rdf-ext.js");
function createUriNode(uri) {
    if (!(typeof (uri) === 'string')) {
        throw new Error('trying to create URI node for ' + (typeof uri) + ' ' + uri);
    }
    return rdf.createNamedNode(uri);
}
exports.createUriNode = createUriNode;
function isUri(node) {
    return node.interfaceName === 'NamedRdfNode';
}
exports.isUri = isUri;
function toUri(node) {
    if (node === undefined)
        return;
    if (node.interfaceName !== 'NamedRdfNode') {
        //throw new Error('nodeToUri requires a NamedRdfNode, but found ' + node.interfaceName)
    }
    return node.nominalValue;
}
exports.toUri = toUri;
function createIntNode(value) {
    return rdf.createLiteral('' + value);
}
exports.createIntNode = createIntNode;
function toInt(node) {
    if (node === undefined)
        return;
    if (node.interfaceName !== 'Literal') {
        console.error(JSON.stringify(node));
        throw new Error('Integer node must be a literal; instead got ' + node.interfaceName);
    }
    const res = parseInt(node.nominalValue);
    if (isNaN(res)) {
        console.warn('parseInt returned NaN for ' + JSON.stringify(node.nominalValue));
    }
    return res;
}
exports.toInt = toInt;
function createStringNode(value) {
    return rdf.createLiteral('' + value);
}
exports.createStringNode = createStringNode;
function toString(node) {
    if (node === undefined)
        return;
    if (node.interfaceName !== 'Literal') {
        console.error(JSON.stringify(node));
        throw new Error('String node must be a literal; instead got ' + node.interfaceName);
    }
    return node.nominalValue;
}
exports.toString = toString;
function createFloatNode(value) {
    return rdf.createLiteral('' + value);
}
exports.createFloatNode = createFloatNode;
function isFloat(node) {
    return node.interfaceName === 'Literal';
}
exports.isFloat = isFloat;
function toFloat(node) {
    if (node === undefined)
        return;
    if (node.interfaceName !== 'Literal') {
        console.error(JSON.stringify(node));
        throw new Error('Floating point node must be a literal; instead got ' + node.interfaceName);
    }
    return parseFloat(node.nominalValue);
}
exports.toFloat = toFloat;
function createBoolNode(value) {
    return rdf.createLiteral(value ? 'true' : 'false');
}
exports.createBoolNode = createBoolNode;
function toBool(node) {
    if (node === undefined)
        return;
    if (node.interfaceName !== 'Literal') {
        console.error(JSON.stringify(node));
        throw new Error('Boolean node must be a literal; instead got ' + node.interfaceName);
    }
    return node.nominalValue === 'true' ? true : false;
}
exports.toBool = toBool;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/parseRDF.js":
/*!***************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/parseRDF.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const RdfParserXml = __webpack_require__(/*! rdf-parser-rdfxml */ "./node_modules/rdf-parser-rdfxml/index.js");
const RdfParserN3 = __webpack_require__(/*! @rdfoo/rdf-parser-n3 */ "./node_modules/@rdfoo/rdf-parser-n3/index.js");
const identifyFiletype_1 = __webpack_require__(/*! ./identifyFiletype */ "./node_modules/rdfoo/dist/rdfoo/identifyFiletype.js");
function parseRDF(graph, rdf, filetype) {
    return __awaiter(this, void 0, void 0, function* () {
        let parser = null;
        if (filetype === identifyFiletype_1.Filetype.NTriples) {
            parser = new RdfParserN3();
        }
        else if (filetype === identifyFiletype_1.Filetype.RDFXML) {
            parser = new RdfParserXml();
        }
        else {
            throw new Error('Unknown type ' + filetype);
        }
        yield parser.process(rdf, (triple) => {
            graph.graph.add(triple);
        });
    });
}
exports.default = parseRDF;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/serialize.js":
/*!****************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/serialize.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const et = __webpack_require__(/*! elementtree */ "./node_modules/elementtree/lib/elementtree.js");
const triple_1 = __webpack_require__(/*! ./triple */ "./node_modules/rdfoo/dist/rdfoo/triple.js");
let ElementTree = et.ElementTree;
let Element = et.Element;
let SubElement = et.SubElement;
let QName = et.QName;
function serialize(graph, defaultPrefixes, isOwnershipRelation, preferredTypeNamespace) {
    let prefixes = new Map(defaultPrefixes);
    let prefixesUsed = new Map();
    prefixesUsed.set('rdf', true);
    let subjectToElement = new Map();
    let ownedElements = new Set();
    for (let triple of graph.match(null, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', null)) {
        let subject = nodeToURI(triple.subject);
        let type = nodeToURI(triple.object);
        if (subjectToElement.has(subject))
            continue;
        let types = graph.match(subject, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', null)
            .map(triple_1.objectUri)
            .filter(s => s !== undefined)
            .map(s => s);
        for (let type of types) {
            if (type.indexOf(preferredTypeNamespace) === 0) {
                types = [type];
                break;
            }
        }
        let subjectElem = Element(prefixify(types[0]), {
            [prefixify('http://www.w3.org/1999/02/22-rdf-syntax-ns#about')]: subject
        });
        subjectToElement.set(subject, subjectElem);
    }
    for (let triple of graph.graph.toArray()) {
        let s = nodeToURI(triple.subject);
        let subjectElem = subjectToElement.get(s);
        if (!subjectElem) {
            subjectElem = Element('rdf:Description', {
                [prefixify('http://www.w3.org/1999/02/22-rdf-syntax-ns#about')]: s
            });
            subjectToElement.set(s, subjectElem);
        }
        let p = nodeToURI(triple.predicate);
        if (p === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
            continue;
        }
        if (isOwnershipRelation(triple)) {
            let o = nodeToURI(triple.object);
            let ownedElement = subjectToElement.get(o);
            if (ownedElement) {
                let ownershipElement = SubElement(subjectElem, prefixify(p));
                ownershipElement.append(ownedElement);
                ownedElements.add(o);
                continue;
            }
        }
        if (triple.object.interfaceName === 'NamedNode') {
            SubElement(subjectElem, prefixify(p), {
                [prefixify('http://www.w3.org/1999/02/22-rdf-syntax-ns#resource')]: nodeToURI(triple.object)
            });
            continue;
        }
        if (triple.object.interfaceName === 'Literal') {
            let attr = {};
            // TODO language and datatype
            let elem = SubElement(subjectElem, prefixify(p), attr);
            elem.text = triple.object.nominalValue;
            continue;
        }
        throw new Error('Unknown interfaceName ' + triple.object.interfaceName);
    }
    let docAttr = {};
    for (let prefix of prefixes.keys()) {
        if (prefixesUsed.get(prefix) === true)
            docAttr['xmlns:' + prefix] = prefixes.get(prefix);
    }
    let root = Element(prefixify('http://www.w3.org/1999/02/22-rdf-syntax-ns#RDF'), docAttr);
    for (let subject of subjectToElement.keys()) {
        if (!ownedElements.has(subject))
            root.append(subjectToElement.get(subject));
    }
    let doc = new ElementTree(root);
    return doc.write({
        xml_declaration: true,
        indent: 2
    });
    function nodeToURI(node) {
        if (node.interfaceName !== 'NamedNode')
            throw new Error('expected NamedNode but found ' + JSON.stringify(node));
        if (typeof node.nominalValue !== 'string')
            throw new Error('nominalValue not a string?');
        return node.nominalValue;
    }
    function prefixify(iri) {
        for (var prefix of prefixes.keys()) {
            var prefixIRI = prefixes.get(prefix);
            if (iri.indexOf(prefixIRI) === 0) {
                prefixesUsed.set(prefix, true);
                return prefix + ':' + iri.slice(prefixIRI.length);
            }
        }
        var fragmentStart = iri.lastIndexOf('#');
        if (fragmentStart === -1)
            fragmentStart = iri.lastIndexOf('/');
        if (fragmentStart === -1)
            return iri;
        var iriPrefix = iri.substr(0, fragmentStart + 1);
        for (var i = 0;; ++i) {
            var prefixName = 'ns' + i;
            if (prefixes.get(prefixName) === undefined) {
                prefixes.set(prefixName, iriPrefix);
                prefixesUsed.set(prefixName, true);
                return prefixName + ':' + iri.slice(iriPrefix.length);
            }
        }
    }
}
exports.default = serialize;


/***/ }),

/***/ "./node_modules/rdfoo/dist/rdfoo/triple.js":
/*!*************************************************!*\
  !*** ./node_modules/rdfoo/dist/rdfoo/triple.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const node = __webpack_require__(/*! ./node */ "./node_modules/rdfoo/dist/rdfoo/node.js");
function subjectUri(triple) {
    if (triple === undefined)
        return undefined;
    return node.toUri(triple.subject);
}
exports.subjectUri = subjectUri;
function predicateUri(triple) {
    if (triple === undefined)
        return undefined;
    return node.toUri(triple.predicate);
}
exports.predicateUri = predicateUri;
function objectUri(triple) {
    if (triple === undefined)
        return undefined;
    return node.toUri(triple.object);
}
exports.objectUri = objectUri;
function objectInt(triple) {
    if (triple === undefined)
        return undefined;
    return node.toInt(triple.object);
}
exports.objectInt = objectInt;
function objectFloat(triple) {
    if (triple === undefined)
        return undefined;
    return node.toFloat(triple.object);
}
exports.objectFloat = objectFloat;
function objectBool(triple) {
    if (triple === undefined)
        return undefined;
    return node.toBool(triple.object);
}
exports.objectBool = objectBool;
function objectString(triple) {
    if (triple === undefined)
        return undefined;
    return node.toString(triple.object);
}
exports.objectString = objectString;


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "events").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ "util");
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/node.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ "util");

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! stream */ "stream");


/***/ }),

/***/ "./node_modules/readable-stream/readable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(/*! stream */ "stream");
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");
}


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = __webpack_require__(/*! stream */ "stream").Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // character classes and tokens
  var whitespace = '\r\n\t '

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var number = '0124356789'
  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

  // (Letter | "_" | ":")
  var quote = '\'"'
  var attribEnd = whitespace + '>'
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // turn all the string character sets into character class objects.
  whitespace = charClass(whitespace)
  number = charClass(number)
  letter = charClass(letter)

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  quote = charClass(quote)
  attribEnd = charClass(attribEnd)

  function charClass (str) {
    return str.split('').reduce(function (s, c) {
      s[c] = true
      return s
    }, {})
  }

  function isRegExp (c) {
    return Object.prototype.toString.call(c) === '[object RegExp]'
  }

  function is (charclass, c) {
    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
  }

  function not (charclass, c) {
    return !is(charclass, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (not(whitespace, c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    var i = 0
    var c = ''
    while (true) {
      c = chunk.charAt(i++)
      parser.c = c
      if (!c) {
        break
      }
      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }
      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = chunk.charAt(i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (is(whitespace, c)) {
            // wait for it...
          } else if (is(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (is(quote, c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (is(quote, c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (is(quote, c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (is(whitespace, c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && is(whitespace, c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (is(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (not(whitespace, c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (is(whitespace, c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (is(whitespace, c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (is(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (is(whitespace, c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (is(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (is(whitespace, c)) {
            continue
          } else if (is(quote, c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (is(whitespace, c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (not(attribEnd, c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (is(whitespace, c)) {
              continue
            } else if (not(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (is(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (not(whitespace, c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (is(whitespace, c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? undefined : exports)


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOL1GraphView.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOL1GraphView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sbol1 = void 0;
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const S1DnaSequence_1 = __webpack_require__(/*! ./sbol1/S1DnaSequence */ "./node_modules/sbolgraph/dist/sbol1/S1DnaSequence.js");
const S1DnaComponent_1 = __webpack_require__(/*! ./sbol1/S1DnaComponent */ "./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js");
const S1Collection_1 = __webpack_require__(/*! ./sbol1/S1Collection */ "./node_modules/sbolgraph/dist/sbol1/S1Collection.js");
const S1SequenceAnnotation_1 = __webpack_require__(/*! ./sbol1/S1SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol1/S1SequenceAnnotation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const isOwnershipRelation_1 = __webpack_require__(/*! ./isOwnershipRelation */ "./node_modules/sbolgraph/dist/isOwnershipRelation.js");
class SBOL1GraphView extends rdfoo_1.GraphViewBasic {
    constructor(graph) {
        super(graph);
        this.graph = graph;
    }
    get dnaSequences() {
        return this.instancesOfType(bioterms_1.Types.SBOL1.DnaSequence)
            .map((uri) => new S1DnaSequence_1.default(this, uri));
    }
    get dnaComponents() {
        return this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent)
            .map((uri) => new S1DnaComponent_1.default(this, uri));
    }
    get collections() {
        return this.instancesOfType(bioterms_1.Types.SBOL1.Collection)
            .map((uri) => new S1Collection_1.default(this, uri));
    }
    uriToFacade(uri) {
        if (!uri)
            return undefined;
        const types = this.getTypes(uri);
        if (types.indexOf(bioterms_1.Types.SBOL1.DnaSequence) !== -1)
            return new S1DnaSequence_1.default(this, uri);
        if (types.indexOf(bioterms_1.Types.SBOL1.DnaComponent) !== -1)
            return new S1DnaComponent_1.default(this, uri);
        if (types.indexOf(bioterms_1.Types.SBOL1.Collection) !== -1)
            return new S1Collection_1.default(this, uri);
        if (types.indexOf(bioterms_1.Types.SBOL1.SequenceAnnotation) !== -1)
            return new S1SequenceAnnotation_1.default(this, uri);
        return undefined;
    }
    get topLevels() {
        const topLevels = [];
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.DnaSequence));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL1.Collection));
        return topLevels.map((topLevel) => this.uriToFacade(topLevel));
    }
    serializeXML() {
        let defaultPrefixes = [
            ['rdf', bioterms_1.Prefixes.rdf],
            ['dcterms', bioterms_1.Prefixes.dcterms],
            ['prov', bioterms_1.Prefixes.prov],
            ['sbol', bioterms_1.Prefixes.sbol1],
            ['sbol2', bioterms_1.Prefixes.sbol2],
            ['sbol3', bioterms_1.Prefixes.sbol3],
            ['om', bioterms_1.Prefixes.measure],
        ];
        return rdfoo_1.serialize(this.graph, new Map(defaultPrefixes), t => isOwnershipRelation_1.default(this.graph, t), bioterms_1.Prefixes.sbol1);
    }
    get rootDnaComponents() {
        return this.instancesOfType(bioterms_1.Types.SBOL1.DnaComponent).filter((uri) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL1.subComponent, uri);
        }).map((uri) => new S1DnaComponent_1.default(this, uri));
    }
}
exports.default = SBOL1GraphView;
function sbol1(graph) {
    return new SBOL1GraphView(graph);
}
exports.sbol1 = sbol1;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOL2GraphView.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOL2GraphView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sbol2 = void 0;
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ./sbol2/S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S2ComponentInstance_1 = __webpack_require__(/*! ./sbol2/S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
const S2ModuleDefinition_1 = __webpack_require__(/*! ./sbol2/S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
const S2ModuleInstance_1 = __webpack_require__(/*! ./sbol2/S2ModuleInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js");
const S2Identified_1 = __webpack_require__(/*! ./sbol2/S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2FunctionalComponent_1 = __webpack_require__(/*! ./sbol2/S2FunctionalComponent */ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js");
const S2Range_1 = __webpack_require__(/*! ./sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const S2Sequence_1 = __webpack_require__(/*! ./sbol2/S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
const S2Collection_1 = __webpack_require__(/*! ./sbol2/S2Collection */ "./node_modules/sbolgraph/dist/sbol2/S2Collection.js");
const S2Model_1 = __webpack_require__(/*! ./sbol2/S2Model */ "./node_modules/sbolgraph/dist/sbol2/S2Model.js");
const S2Measure_1 = __webpack_require__(/*! ./sbol2/S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");
const S2Interaction_1 = __webpack_require__(/*! ./sbol2/S2Interaction */ "./node_modules/sbolgraph/dist/sbol2/S2Interaction.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ./sbol2/S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2Participation_1 = __webpack_require__(/*! ./sbol2/S2Participation */ "./node_modules/sbolgraph/dist/sbol2/S2Participation.js");
const S2MapsTo_1 = __webpack_require__(/*! ./sbol2/S2MapsTo */ "./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js");
const S2GenericLocation_1 = __webpack_require__(/*! ./sbol2/S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./sbol2/S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2Cut_1 = __webpack_require__(/*! ./sbol2/S2Cut */ "./node_modules/sbolgraph/dist/sbol2/S2Cut.js");
const rdfoo_2 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const rdfoo_3 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const fastaToSBOL2_1 = __webpack_require__(/*! ./conversion/fastaToSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fastaToSBOL2.js");
const genbankToSBOL2_1 = __webpack_require__(/*! ./conversion/genbankToSBOL2 */ "./node_modules/sbolgraph/dist/conversion/genbankToSBOL2.js");
const S2Implementation_1 = __webpack_require__(/*! ./sbol2/S2Implementation */ "./node_modules/sbolgraph/dist/sbol2/S2Implementation.js");
const S2Experiment_1 = __webpack_require__(/*! ./sbol2/S2Experiment */ "./node_modules/sbolgraph/dist/sbol2/S2Experiment.js");
const S2ExperimentalData_1 = __webpack_require__(/*! ./sbol2/S2ExperimentalData */ "./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/sbolgraph/dist/index.js");
const toSBOL2_1 = __webpack_require__(/*! ./conversion/fromSBOL1/toSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL1/toSBOL2.js");
const toSBOL2_2 = __webpack_require__(/*! ./conversion/fromSBOL3/toSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL3/toSBOL2.js");
const enforceURICompliance_1 = __webpack_require__(/*! ./conversion/enforceURICompliance */ "./node_modules/sbolgraph/dist/conversion/enforceURICompliance.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
const isOwnershipRelation_1 = __webpack_require__(/*! ./isOwnershipRelation */ "./node_modules/sbolgraph/dist/isOwnershipRelation.js");
const S2SequenceConstraint_1 = __webpack_require__(/*! ./sbol2/S2SequenceConstraint */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js");
class SBOL2GraphView extends rdfoo_1.GraphViewHybrid {
    constructor(graph) {
        super(graph);
        this._cachedUriPrefixes = null;
        this.addView(new SBOL2(this));
        this.addView(new rdfoo_prov_1.ProvView(graph));
    }
    createComponentDefinition(uriPrefix, id, version) {
        console.dir(arguments);
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ComponentDefinition, uriPrefix, id, undefined, version);
        return new S2ComponentDefinition_1.default(this, identified.uri);
    }
    createModuleDefinition(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ModuleDefinition, uriPrefix, id, undefined, version);
        return new S2ModuleDefinition_1.default(this, identified.uri);
    }
    createCollection(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Collection, uriPrefix, id, undefined, version);
        return new S2Collection_1.default(this, identified.uri);
    }
    createSequence(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Sequence, uriPrefix, id, undefined, version);
        const seq = new S2Sequence_1.default(this, identified.uri);
        seq.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
        seq.elements = '';
        return seq;
    }
    createModel(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Model, uriPrefix, id, undefined, version);
        const model = new S2Model_1.default(this, identified.uri);
        return model;
    }
    createImplementation(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Implementation, uriPrefix, id, undefined, version);
        return new S2Implementation_1.default(this, identified.uri);
    }
    createExperiment(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Experiment, uriPrefix, id, undefined, version);
        return new S2Experiment_1.default(this, identified.uri);
    }
    createExperimentalData(uriPrefix, id, version) {
        if (arguments.length < 3)
            version = '1';
        const identified = S2IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.ExperimentalData, uriPrefix, id, undefined, version);
        return new S2ExperimentalData_1.default(this, identified.uri);
    }
    get sequences() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Sequence)
            .map((uri) => new S2Sequence_1.default(this, uri));
    }
    get componentDefinitions() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition)
            .map((uri) => new S2ComponentDefinition_1.default(this, uri));
    }
    get collections() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Collection)
            .map((uri) => new S2Collection_1.default(this, uri));
    }
    get models() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Model)
            .map((uri) => new S2Model_1.default(this, uri));
    }
    componentDefinition(uri) {
        return new S2ComponentDefinition_1.default(this, uri);
    }
    getComponentDefinition(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL2.ComponentDefinition)
            return null;
        return new S2ComponentDefinition_1.default(this, uri);
    }
    get componentInstances() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Component)
            .map((uri) => new S2ComponentInstance_1.default(this, uri));
    }
    moduleDefinition(uri) {
        return new S2ModuleDefinition_1.default(this, uri);
    }
    get moduleDefinitions() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition)
            .map((uri) => new S2ModuleDefinition_1.default(this, uri));
    }
    getModuleDefinition(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL2.ModuleDefinition)
            return null;
        return new S2ModuleDefinition_1.default(this, uri);
    }
    getActivity(uri) {
        if (this.getType(uri) !== bioterms_1.Types.Prov.Activity)
            return null;
        return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), uri);
    }
    getExperiment(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL2.Experiment)
            return null;
        return new S2Experiment_1.default(this, uri);
    }
    get experiments() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Experiment)
            .map((uri) => new S2Experiment_1.default(this, uri));
    }
    get attachments() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Attachment)
            .map((uri) => new _1.S2Attachment(this, uri));
    }
    getExperimentalData(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL2.ExperimentalData)
            return null;
        return new S2ExperimentalData_1.default(this, uri);
    }
    get experimentalData() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ExperimentalData)
            .map((uri) => new S2ExperimentalData_1.default(this, uri));
    }
    get implementations() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.Implementation)
            .map((uri) => new S2Implementation_1.default(this, uri));
    }
    get rootComponentDefinitions() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition).filter((uri) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL2.definition, uri);
        }).map((uri) => new S2ComponentDefinition_1.default(this, uri));
    }
    get structurallyRootComponentDefinitions() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition).filter((uri) => {
            const instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, uri)
                .map(rdfoo_1.triple.subjectUri);
            for (var i = 0; i < instantiations.length; ++i) {
                const instantiationUri = instantiations[i];
                if (instantiationUri !== undefined) {
                    if (this.hasType(instantiationUri, bioterms_1.Types.SBOL2.Component)) {
                        return false;
                    }
                }
            }
            return true;
        }).map((uri) => new S2ComponentDefinition_1.default(this, uri));
    }
    get rootModuleDefinitions() {
        return this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition).filter((uri) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL2.definition, uri);
        }).map((uri) => new S2ModuleDefinition_1.default(this, uri));
    }
    get provPlans() {
        return this.instancesOfType(bioterms_1.Types.Prov.Plan)
            .map((uri) => new rdfoo_prov_1.Plan(new rdfoo_prov_1.ProvView(this.graph), uri));
    }
    get measures() {
        return this.instancesOfType(bioterms_1.Types.Measure.Measure)
            .map((uri) => new S2Measure_1.default(this, uri));
    }
    static loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let graph = new SBOL2GraphView(new rdfoo_1.Graph());
            yield graph.loadString(data, defaultURIPrefix, mimeType);
            return graph;
        });
    }
    loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let filetype = rdfoo_3.identifyFiletype(data, mimeType || null);
            if (filetype === rdfoo_3.Filetype.RDFXML || filetype === rdfoo_3.Filetype.NTriples) {
                yield rdfoo_2.parseRDF(this.graph, data, filetype);
                toSBOL2_2.default(this.graph);
                toSBOL2_1.default(this.graph);
                return;
            }
            defaultURIPrefix = defaultURIPrefix || 'http://converted/';
            if (filetype === rdfoo_3.Filetype.FASTA) {
                fastaToSBOL2_1.default(this, defaultURIPrefix, data);
                return;
            }
            if (filetype === rdfoo_3.Filetype.GenBank) {
                genbankToSBOL2_1.default(this, defaultURIPrefix, data);
                return;
            }
            throw new Error('Unknown format');
        });
    }
    serializeXML() {
        let defaultPrefixes = [
            ['rdf', bioterms_1.Prefixes.rdf],
            ['dcterms', bioterms_1.Prefixes.dcterms],
            ['prov', bioterms_1.Prefixes.prov],
            ['sbol', bioterms_1.Prefixes.sbol2],
            ['sbol1', bioterms_1.Prefixes.sbol1],
            ['sbol3', bioterms_1.Prefixes.sbol3],
            ['backport', 'http://sboltools.org/backport#'],
            ['om', bioterms_1.Prefixes.measure],
        ];
        return rdfoo_1.serialize(this.graph, new Map(defaultPrefixes), t => isOwnershipRelation_1.default(this.graph, t), bioterms_1.Prefixes.sbol2);
    }
    // TODO
    //
    get topLevels() {
        const topLevels = [];
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.ComponentDefinition));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.ModuleDefinition));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Sequence));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Collection));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL2.Implementation));
        return topLevels.map((topLevel) => this.uriToFacade(topLevel));
    }
    get uriPrefixes() {
        if (this._cachedUriPrefixes !== null)
            return this._cachedUriPrefixes;
        const topLevels = this.topLevels;
        var prefixes = {};
        topLevels.forEach((topLevel) => {
            const prefix = topLevel.uriPrefix;
            if (prefixes[prefix] === undefined)
                prefixes[prefix] = true;
        });
        this._cachedUriPrefixes = Object.keys(prefixes);
        return this._cachedUriPrefixes;
    }
    getTopLevelsWithPrefix(prefix) {
        const topLevels = this.topLevels;
        return this.topLevels.filter((topLevel) => {
            return topLevel.uri.indexOf(prefix) === 0;
        });
    }
    uriToIdentified(uri) {
        let f = this.uriToFacade(uri);
        if (f instanceof S2Identified_1.default)
            return f;
        else
            return undefined;
    }
    findClosestTopLevel(_subject) {
        var subject = _subject;
        const origSubject = subject;
        var subjectTypes = this.getTypes(subject);
        while (!isTopLevel()) {
            let identified = this.uriToIdentified(subject);
            if (identified === undefined)
                throw new Error('???');
            identified = identified.containingObject;
            if (identified === undefined) {
                return undefined;
            }
            subject = identified.uri;
            subjectTypes = this.getTypes(subject);
        }
        return subject;
        function isTopLevel() {
            // TODO
            return subjectTypes.indexOf(bioterms_1.Types.SBOL2.ComponentDefinition) !== -1
                || subjectTypes.indexOf(bioterms_1.Types.SBOL2.ModuleDefinition) !== -1;
        }
    }
    nameToDisplayId(name) {
        return name.replace(/\s/, '_');
    }
    changeURIPrefix(newPrefix) {
        let topLevels = new Set([
            bioterms_1.Types.SBOL2.Collection,
            bioterms_1.Types.SBOL2.ComponentDefinition,
            bioterms_1.Types.SBOL2.ModuleDefinition,
            bioterms_1.Types.SBOL2.Sequence,
            bioterms_1.Types.SBOL2.Model,
            bioterms_1.Types.Prov.Plan,
            bioterms_1.Types.Prov.Agent,
            bioterms_1.Types.Prov.Activity
        ]);
        rdfoo_1.changeURIPrefix(this.graph, topLevels, newPrefix);
    }
    printTree() {
        for (let cd of this.componentDefinitions) {
            console.log('component:' + cd.uri);
            for (let c of cd.components) {
                console.log(indent(1) + 'c-> ' + c.definition.uri);
            }
        }
        for (let md of this.moduleDefinitions) {
            console.log('module:' + md.uri);
            for (let c of md.functionalComponents) {
                console.log(indent(1) + 'c-> ' + c.definition.uri);
            }
            for (let m of md.modules) {
                console.log(indent(1) + 'm-> ' + m.definition.uri);
            }
        }
        function indent(n) {
            return '        '.slice(8 - n);
        }
    }
    enforceURICompliance(uriPrefix) {
        enforceURICompliance_1.default(this, uriPrefix);
    }
}
exports.default = SBOL2GraphView;
class SBOL2 extends rdfoo_1.GraphViewBasic {
    constructor(view) {
        super(view.graph);
        this.view = view;
    }
    uriToFacade(uri) {
        if (!uri)
            return undefined;
        const types = this.getTypes(uri);
        for (var i = 0; i < types.length; ++i) {
            let type = types[i];
            if (type === bioterms_1.Types.SBOL2.ComponentDefinition)
                return new S2ComponentDefinition_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Component)
                return new S2ComponentInstance_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.FunctionalComponent)
                return new S2FunctionalComponent_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Implementation)
                return new S2Implementation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Experiment)
                return new S2Experiment_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.ExperimentalData)
                return new S2ExperimentalData_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Attachment)
                return new _1.S2Attachment(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Interaction)
                return new S2Interaction_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.MapsTo)
                return new S2MapsTo_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.ModuleDefinition)
                return new S2ModuleDefinition_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Module)
                return new S2ModuleInstance_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Participation)
                return new S2Participation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Range)
                return new S2Range_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Cut)
                return new S2Cut_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.GenericLocation)
                return new S2GenericLocation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.SequenceAnnotation)
                return new S2SequenceAnnotation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.SequenceConstraint)
                return new S2SequenceConstraint_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Sequence)
                return new S2Sequence_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Collection)
                return new S2Collection_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Model)
                return new S2Model_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL2.Attachment)
                return new _1.S2Attachment(this.view, uri);
            if (type === bioterms_1.Types.Measure.Measure)
                return new S2Measure_1.default(this.view, uri);
        }
        return super.uriToFacade(uri);
    }
}
function sbol2(graph) {
    return new SBOL2GraphView(graph);
}
exports.sbol2 = sbol2;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOL2Repository.js":
/*!********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOL2Repository.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = exports.SearchQuery = void 0;
class SearchQuery {
    constructor() {
        this.criteria = [];
    }
    add(key, value) {
        this.criteria.push({ key: key, value: value });
    }
    addObjectType(name) {
        this.add('objectType', name);
    }
    addRole(uri) {
        this.add('role', '<' + uri + '>');
    }
}
exports.SearchQuery = SearchQuery;
class SearchResult {
}
exports.SearchResult = SearchResult;
class Repository {
    constructor(url) {
        this.url = url;
    }
}
exports.default = Repository;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOL3GraphView.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOL3GraphView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sbol3 = void 0;
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Identified_1 = __webpack_require__(/*! ./sbol3/S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3Sequence_1 = __webpack_require__(/*! ./sbol3/S3Sequence */ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js");
const S3Component_1 = __webpack_require__(/*! ./sbol3/S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
const S3SubComponent_1 = __webpack_require__(/*! ./sbol3/S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
const S3OrientedLocation_1 = __webpack_require__(/*! ./sbol3/S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const S3SequenceFeature_1 = __webpack_require__(/*! ./sbol3/S3SequenceFeature */ "./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js");
const S3Range_1 = __webpack_require__(/*! ./sbol3/S3Range */ "./node_modules/sbolgraph/dist/sbol3/S3Range.js");
const S3Participation_1 = __webpack_require__(/*! ./sbol3/S3Participation */ "./node_modules/sbolgraph/dist/sbol3/S3Participation.js");
const S3Interaction_1 = __webpack_require__(/*! ./sbol3/S3Interaction */ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js");
const S3Collection_1 = __webpack_require__(/*! ./sbol3/S3Collection */ "./node_modules/sbolgraph/dist/sbol3/S3Collection.js");
const S3Model_1 = __webpack_require__(/*! ./sbol3/S3Model */ "./node_modules/sbolgraph/dist/sbol3/S3Model.js");
const S3Implementation_1 = __webpack_require__(/*! ./sbol3/S3Implementation */ "./node_modules/sbolgraph/dist/sbol3/S3Implementation.js");
const S3Experiment_1 = __webpack_require__(/*! ./sbol3/S3Experiment */ "./node_modules/sbolgraph/dist/sbol3/S3Experiment.js");
const S3ExperimentalData_1 = __webpack_require__(/*! ./sbol3/S3ExperimentalData */ "./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js");
const S3Measure_1 = __webpack_require__(/*! ./sbol3/S3Measure */ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js");
const S3IdentifiedFactory_1 = __webpack_require__(/*! ./sbol3/S3IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js");
const rdfoo_2 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const toSBOL2_1 = __webpack_require__(/*! ./conversion/fromSBOL1/toSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL1/toSBOL2.js");
const toSBOL3_1 = __webpack_require__(/*! ./conversion/fromSBOL2/toSBOL3 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL3.js");
const SBOL2GraphView_1 = __webpack_require__(/*! ./SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
const isOwnershipRelation_1 = __webpack_require__(/*! ./isOwnershipRelation */ "./node_modules/sbolgraph/dist/isOwnershipRelation.js");
const S3Attachment_1 = __webpack_require__(/*! ./sbol3/S3Attachment */ "./node_modules/sbolgraph/dist/sbol3/S3Attachment.js");
const S3EntireSequence_1 = __webpack_require__(/*! ./sbol3/S3EntireSequence */ "./node_modules/sbolgraph/dist/sbol3/S3EntireSequence.js");
const S3Cut_1 = __webpack_require__(/*! ./sbol3/S3Cut */ "./node_modules/sbolgraph/dist/sbol3/S3Cut.js");
class SBOL3GraphView extends rdfoo_1.GraphViewHybrid {
    constructor(graph) {
        super(graph);
        this.addView(new SBOL3(this));
        this.addView(new rdfoo_prov_1.ProvView(graph));
    }
    createComponent(uriPrefix, id) {
        const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Component, uriPrefix, id, undefined);
        return new S3Component_1.default(this, identified.uri);
    }
    createCollection(uriPrefix, id) {
        const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Collection, uriPrefix, id, undefined);
        return new S3Collection_1.default(this, identified.uri);
    }
    createSequence(uriPrefix, id) {
        const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL3.Sequence, uriPrefix, id, undefined);
        const seq = new S3Sequence_1.default(this, identified.uri);
        seq.encoding = bioterms_1.Specifiers.SBOL3.SequenceEncoding.NucleicAcid;
        seq.elements = '';
        return seq;
    }
    createModel(uriPrefix, id) {
        const identified = S3IdentifiedFactory_1.default.createTopLevel(this, bioterms_1.Types.SBOL2.Model, uriPrefix, id, undefined);
        const model = new S3Model_1.default(this, identified.uri);
        return model;
    }
    get sequences() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Sequence)
            .map((uri) => new S3Sequence_1.default(this, uri));
    }
    get components() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Component)
            .map((uri) => new S3Component_1.default(this, uri));
    }
    get collections() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Collection)
            .map((uri) => new S3Collection_1.default(this, uri));
    }
    get rootComponents() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Component).filter((uri) => {
            return !this.graph.hasMatch(null, bioterms_1.Predicates.SBOL3.instanceOf, uri);
        }).map((uri) => new S3Component_1.default(this, uri));
    }
    getInstancesOfComponent(component) {
        return this.graph.match(null, bioterms_1.Predicates.SBOL3.instanceOf, component.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3SubComponent_1.default(this, uri));
    }
    getExperiment(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL3.Experiment)
            return null;
        return new S3Experiment_1.default(this, uri);
    }
    get experiments() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Experiment)
            .map((uri) => new S3Experiment_1.default(this, uri));
    }
    getExperimentalData(uri) {
        if (this.getType(uri) !== bioterms_1.Types.SBOL3.ExperimentalData)
            return null;
        return new S3ExperimentalData_1.default(this, uri);
    }
    get experimentalData() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.ExperimentalData)
            .map((uri) => new S3ExperimentalData_1.default(this, uri));
    }
    get implementations() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Implementation)
            .map((uri) => new S3Implementation_1.default(this, uri));
    }
    get attachments() {
        return this.instancesOfType(bioterms_1.Types.SBOL3.Attachment)
            .map((uri) => new S3Attachment_1.default(this, uri));
    }
    get measures() {
        return this.instancesOfType(bioterms_1.Types.Measure.Measure)
            .map((uri) => new S3Measure_1.default(this, uri));
    }
    static loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let graph = new SBOL3GraphView(new rdfoo_1.Graph());
            yield graph.loadString(data, defaultURIPrefix, mimeType);
            return graph;
        });
    }
    loadString(data, defaultURIPrefix, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            let filetype = rdfoo_2.identifyFiletype(data, mimeType || null);
            if (filetype === rdfoo_2.Filetype.RDFXML || filetype === rdfoo_2.Filetype.NTriples) {
                yield rdfoo_1.parseRDF(this.graph, data, filetype);
                toSBOL2_1.default(this.graph);
                toSBOL3_1.default(this.graph);
                return;
            }
            defaultURIPrefix = defaultURIPrefix || 'http://converted/';
            if (filetype === rdfoo_2.Filetype.FASTA || filetype == rdfoo_2.Filetype.GenBank) {
                let g2 = yield SBOL2GraphView_1.default.loadString(data, defaultURIPrefix, mimeType);
                this.graph.addAll(g2.graph);
                toSBOL3_1.default(this.graph);
                return;
            }
            throw new Error('Unknown format');
        });
    }
    serializeXML() {
        let defaultPrefixes = [
            ['rdf', bioterms_1.Prefixes.rdf],
            ['dcterms', bioterms_1.Prefixes.dcterms],
            ['prov', bioterms_1.Prefixes.prov],
            ['sbol', bioterms_1.Prefixes.sbol2],
            ['sbol1', bioterms_1.Prefixes.sbol1],
            ['sbol3', bioterms_1.Prefixes.sbol3],
            ['backport', 'http://sboltools.org/backport#'],
            ['om', bioterms_1.Prefixes.measure],
        ];
        return rdfoo_1.serialize(this.graph, new Map(defaultPrefixes), t => isOwnershipRelation_1.default(this.graph, t), bioterms_1.Prefixes.sbol3);
    }
    // TODO
    //
    get topLevels() {
        const topLevels = [];
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Component));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Sequence));
        Array.prototype.push.apply(topLevels, this.instancesOfType(bioterms_1.Types.SBOL3.Collection));
        return topLevels.map((topLevel) => this.uriToFacade(topLevel));
    }
    get uriPrefixes() {
        let topLevels = this.topLevels;
        let prefixes = {};
        topLevels.forEach((topLevel) => {
            let prefix = topLevel.uriPrefix;
            if (prefixes[prefix] === undefined)
                prefixes[prefix] = 1;
            else
                ++prefixes[prefix];
        });
        return Object.keys(prefixes).sort((a, b) => {
            return prefixes[b] - prefixes[a];
        });
    }
    get mostPopularUriPrefix() {
        return this.uriPrefixes[0];
    }
    getTopLevelsWithPrefix(prefix) {
        const topLevels = this.topLevels;
        return this.topLevels.filter((topLevel) => {
            return topLevel.uri.indexOf(prefix) === 0;
        });
    }
    uriToIdentified(uri) {
        let f = this.uriToFacade(uri);
        if (f instanceof S3Identified_1.default)
            return f;
        else
            return undefined;
    }
    findClosestTopLevel(_subject) {
        var subject = _subject;
        const origSubject = subject;
        var subjectTypes = this.getTypes(subject);
        while (!isTopLevel()) {
            let identified = this.uriToIdentified(subject);
            if (identified === undefined)
                throw new Error('???');
            identified = identified.owningObject;
            if (identified === undefined) {
                return undefined;
            }
            subject = identified.uri;
            subjectTypes = this.getTypes(subject);
        }
        return subject;
        function isTopLevel() {
            // TODO
            return subjectTypes.indexOf(bioterms_1.Types.SBOL3.Component) !== -1
                || subjectTypes.indexOf(bioterms_1.Types.SBOL3.Sequence) !== -1;
        }
    }
    changeURIPrefix(newPrefix) {
        let topLevels = new Set([
            bioterms_1.Types.SBOL3.Collection,
            bioterms_1.Types.SBOL3.Component,
            bioterms_1.Types.SBOL3.Sequence,
            bioterms_1.Types.SBOL3.Model,
            bioterms_1.Types.Prov.Plan,
            bioterms_1.Types.Prov.Agent,
            bioterms_1.Types.Prov.Activity
        ]);
        return rdfoo_1.changeURIPrefix(this.graph, topLevels, newPrefix);
    }
    nameToDisplayId(name) {
        return name.replace(/\s/, '_');
    }
    printTree() {
        for (let cd of this.components) {
            console.log('component:' + cd.uri + ' (' + cd.displayId + ')');
            for (let c of cd.subComponents) {
                console.log(indent(1) + 'sc-> ' + c.instanceOf.uri);
            }
        }
        function indent(n) {
            return '        '.slice(8 - n);
        }
    }
}
exports.default = SBOL3GraphView;
class SBOL3 extends rdfoo_1.GraphViewBasic {
    constructor(view) {
        super(view.graph);
        this.view = view;
    }
    uriToFacade(uri) {
        if (!uri)
            return undefined;
        const types = this.getTypes(uri);
        for (var i = 0; i < types.length; ++i) {
            let type = types[i];
            if (type === bioterms_1.Types.SBOL3.Component)
                return new S3Component_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.SubComponent)
                return new S3SubComponent_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Interaction)
                return new S3Interaction_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Participation)
                return new S3Participation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Range)
                return new S3Range_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Cut)
                return new S3Cut_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.EntireSequence)
                return new S3EntireSequence_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.OrientedLocation)
                return new S3OrientedLocation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.SequenceFeature)
                return new S3SequenceFeature_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Sequence)
                return new S3Sequence_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Collection)
                return new S3Collection_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Model)
                return new S3Model_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Implementation)
                return new S3Implementation_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Experiment)
                return new S3Experiment_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.ExperimentalData)
                return new S3ExperimentalData_1.default(this.view, uri);
            if (type === bioterms_1.Types.SBOL3.Attachment)
                return new S3Attachment_1.default(this.view, uri);
            throw new Error('unknown type: ' + uri + ' a ' + type);
        }
    }
}
function sbol3(graph) {
    return new SBOL3GraphView(graph);
}
exports.sbol3 = sbol3;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOLConverter.js":
/*!******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOLConverter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const toSBOL2_1 = __webpack_require__(/*! ./conversion/fromSBOL1/toSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL1/toSBOL2.js");
const toSBOL3_1 = __webpack_require__(/*! ./conversion/fromSBOL2/toSBOL3 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL3.js");
const toSBOL2_2 = __webpack_require__(/*! ./conversion/fromSBOL3/toSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL3/toSBOL2.js");
const toSBOL1_1 = __webpack_require__(/*! ./conversion/fromSBOL2/toSBOL1 */ "./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL1.js");
class SBOLConverter {
    static convert1to2(g) {
        return __awaiter(this, void 0, void 0, function* () {
            yield toSBOL2_1.default(g);
        });
    }
    static convert2to3(g) {
        return __awaiter(this, void 0, void 0, function* () {
            yield toSBOL3_1.default(g);
        });
    }
    static convert3to2(g) {
        return __awaiter(this, void 0, void 0, function* () {
            yield toSBOL2_2.default(g);
        });
    }
    static convert2to1(g) {
        return __awaiter(this, void 0, void 0, function* () {
            yield toSBOL1_1.default(g);
        });
    }
}
exports.default = SBOLConverter;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/SBOLFacade.js":
/*!***************************************************!*\
  !*** ./node_modules/sbolgraph/dist/SBOLFacade.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const isOwnershipRelation_1 = __webpack_require__(/*! ./isOwnershipRelation */ "./node_modules/sbolgraph/dist/isOwnershipRelation.js");
class SBOLFacade extends rdfoo_1.Facade {
    constructor(graph, view, uri) {
        super(graph, uri);
        this.view = view;
    }
    hasProperty(predicate) {
        return this.graph.hasMatch(this.uri, predicate, null);
    }
    get owningObject() {
        let ownageTriples = this.graph.match(null, null, this.uri)
            .filter(t => isOwnershipRelation_1.default(this.graph, t));
        if (ownageTriples.length === 1) {
            return this.view.uriToFacade(rdfoo_1.triple.subjectUri(ownageTriples[0]));
        }
    }
    get ownedObjects() {
        let ownageTriples = this.graph.match(this.uri, null, null)
            .filter(t => isOwnershipRelation_1.default(this.graph, t));
        return ownageTriples.map(rdfoo_1.triple.objectUri)
            .map(uri => this.view.uriToFacade(uri))
            .filter(o => o !== undefined);
    }
    isSiblingOf(other) {
        let ourContainer = this.owningObject;
        let theirContainer = other.owningObject;
        if (!ourContainer) {
            if (!theirContainer) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (theirContainer && theirContainer.uri === ourContainer.uri) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    getSiblings() {
        let ourContainer = this.owningObject;
        if (!ourContainer) {
            return [];
        }
        let containedObjects = ourContainer.ownedObjects;
        // remove us from the list
        //
        for (let i = 0; i < containedObjects.length; ++i) {
            if (containedObjects[i].uri === this.uri) {
                containedObjects.splice(i, 1);
                break;
            }
        }
        return containedObjects;
    }
    destroy() {
        let toPurge = [];
        add(this);
        for (let obj of toPurge) {
            this.graph.purgeSubject(obj.uri);
        }
        function add(o) {
            toPurge.push(o);
            let owned = o.ownedObjects;
            for (let obj of owned) {
                add(obj);
            }
        }
    }
}
exports.default = SBOLFacade;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/URIUtils.js":
/*!*************************************************!*\
  !*** ./node_modules/sbolgraph/dist/URIUtils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class URIUtils {
    static addSuffix(uri, suffix) {
        // ends with something that looks like a version?
        if (uri.match(/\/[0-9]+$/)) {
            // insert suffix before version
            let lastSlash = uri.lastIndexOf('/');
            return uri.slice(0, lastSlash) + suffix + uri.slice(lastSlash);
        }
        else {
            // ends with a fragment?
            let last = uri.lastIndexOf('#');
            if (last !== -1) {
                // insert suffix before fragment
                return uri.slice(0, last) + suffix + uri.slice(last);
            }
            else {
                // insert suffix at end
                return uri + suffix;
            }
        }
    }
    static getPrefix(uri) {
        // ends with something that looks like a version?
        if (uri.match(/\/[0-9]+$/)) {
            return popLastToken(popLastToken(uri));
        }
        else {
            return popLastToken(uri);
        }
    }
    static getSuffix(uri) {
        return uri.slice(0, this.getPrefix(uri).length);
    }
}
exports.default = URIUtils;
function popLastToken(uri) {
    let last = uri.lastIndexOf('#', uri.length - 2);
    if (last === -1)
        last = uri.lastIndexOf('/', uri.length - 2);
    if (last === -1)
        return uri;
    return uri.slice(0, last + 1);
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/enforceURICompliance.js":
/*!************************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/enforceURICompliance.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const URIUtils_1 = __webpack_require__(/*! ../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
const SBOL2GraphView_1 = __webpack_require__(/*! ../SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
function enforceURICompliance(g, uriPrefix) {
    var p_id, p_version, p_persistentIdentity;
    if (g instanceof SBOL2GraphView_1.default) {
        p_id = bioterms_1.Predicates.SBOL2.displayId;
        p_version = bioterms_1.Predicates.SBOL2.version;
        p_persistentIdentity = bioterms_1.Predicates.SBOL2.persistentIdentity;
    }
    else {
        // p_id = Predicates.SBOL3.displayId
        // p_version = Predicates.SBOL3.version
        // p_persistentIdentity = Predicates.SBOL3.persistentIdentity
        throw new Error('sbol3 not supported');
    }
    for (let topLevel of g.topLevels) {
        let version = topLevel.version;
        if (version === undefined) {
            topLevel.version = version = '1';
        }
        addMissingProperties(topLevel, version);
    }
    // Now everything has IDs and versions
    // Second pass: change URIs
    for (let topLevel of g.topLevels) {
        replaceURIs(topLevel, uriPrefix);
    }
    function replaceURIs(object, prefix) {
        let persistentIdentity = prefix + object.getStringProperty(p_id);
        let newURI = persistentIdentity + '/' + object.getStringProperty(p_version);
        object.persistentIdentity = persistentIdentity;
        let contained = object.containedObjects;
        g.graph.replaceURI(object.uri, newURI);
        for (let child of contained) {
            replaceURIs(child, persistentIdentity + '/');
        }
    }
    function addMissingProperties(object, version) {
        object.version = version;
        let id = object.getStringProperty(p_id);
        if (id === undefined) {
            object.setStringProperty(p_id, makeUpID(object));
        }
        for (let child of object.containedObjects) {
            addMissingProperties(child, version);
        }
    }
    function makeUpID(object) {
        let name = object.name;
        if (name) {
            name = sanitize(name);
            if (name && name !== '') {
                return name;
            }
        }
        name = sanitize(URIUtils_1.default.getSuffix(object.uri));
        if (name && name !== '') {
            return name;
        }
        return (object.facadeType.split('#').pop() || 'anon').toLowerCase();
        function sanitize(s) {
            return s.replace(/[^A-Za-z0-9]/g, '');
        }
    }
}
exports.default = enforceURICompliance;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/fastaToSBOL2.js":
/*!****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/fastaToSBOL2.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
function fastaToSBOL2(graph, uriPrefix, fasta) {
    let lines = fasta.split('\n');
    let sequence = null;
    let elements = [];
    for (let line of lines) {
        line = line.trim();
        if (line[0] === ';') {
            continue;
        }
        if (line[0] === '>') {
            if (sequence) {
                setSequenceElementsAndGuessEncoding(sequence, elements.join(''));
                sequence = null;
            }
            let { id, properties } = parseHeader(line);
            sequence = graph.createSequence(uriPrefix, id, '1');
            sequence.insertProperties(properties);
            continue;
        }
        elements.push(line);
    }
    if (sequence) {
        setSequenceElementsAndGuessEncoding(sequence, elements.join(''));
    }
}
exports.default = fastaToSBOL2;
function parseHeader(header) {
    if (header.startsWith('>sp|') || header.startsWith('>tr|')) {
        // looks like uniprot
        let matches = (/([^|]*?)\|([^|]*?)([^\s]+=)/g).exec(header);
        if (matches && matches.length === 4) {
            let accession = matches[1].trim();
            let entryName = matches[2].trim();
            let recommendedName = matches[3].trim();
            // TODO parse organism name etc.
            return {
                id: entryName,
                properties: {
                    [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(recommendedName),
                    ['http://edamontology.org/data_3021']: rdfoo_1.node.createStringNode(accession)
                }
            };
        }
    }
    // TODO pretty lame effort to match some of the NCBI ones
    // should probably expand this
    //
    if (header.startsWith('gb|')
        || header.startsWith('emb|')
        || header.startsWith('dbj|')
        || header.startsWith('sp|')
        || header.startsWith('ref|')) {
        let tokens = header.split('|');
        let accession = tokens[1];
        return {
            id: accession,
            properties: {}
        };
    }
    return {
        // Couldn't do anything clever; just use the whole header as the name
        // and its first token as the ID
        id: header.slice(1).split(' ')[0] || 'imported_fasta',
        properties: {
            [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(header.slice(1)),
        }
    };
}
function setSequenceElementsAndGuessEncoding(sequence, elements) {
    // I know that guessing the encoding isn't necessarily a good idea
    // because it's perfectly possible to have a chunk of protein composed entirely of
    // the nucleic acid alphabet.
    // However, we need to pick one for the encoding property of the sequence.
    // The options are basically:
    //    - Just set it to to DNA or protein and let the user change it later
    //    - Invent a new "I don't know" URI to use as the encoding property
    //             (should probably be in the SBOL spec, actually...)
    //    - Make a best guess
    // Considering it's not very likely at all that an amino acid sequence would look
    // like DNA (actually 0% likely for complete proteins) I've gone for the option of
    // guessing.
    // 
    let encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    let na = new Set(['A', 'a', 'T', 't', 'C', 'c', 'G', 'g', 'U', 'u', '*']);
    for (let i = 0; i < elements.length; ++i) {
        if (!na.has(elements[i])) {
            encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
            break;
        }
    }
    sequence.encoding = encoding;
    sequence.elements = elements;
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/fromSBOL1/toSBOL2.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/fromSBOL1/toSBOL2.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const SBOL1GraphView_1 = __webpack_require__(/*! ../../SBOL1GraphView */ "./node_modules/sbolgraph/dist/SBOL1GraphView.js");
const SBOL2GraphView_1 = __webpack_require__(/*! ../../SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2SequenceConstraint_1 = __webpack_require__(/*! ../../sbol2/S2SequenceConstraint */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js");
const S2Sequence_1 = __webpack_require__(/*! ../../sbol2/S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ../../sbol2/S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S2ComponentInstance_1 = __webpack_require__(/*! ../../sbol2/S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ../../sbol2/S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2Range_1 = __webpack_require__(/*! ../../sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const S2GenericLocation_1 = __webpack_require__(/*! ../../sbol2/S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
const S2Collection_1 = __webpack_require__(/*! ../../sbol2/S2Collection */ "./node_modules/sbolgraph/dist/sbol2/S2Collection.js");
const URIUtils_1 = __webpack_require__(/*! ../../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
const assert_1 = __webpack_require__(/*! assert */ "assert");
function convert1to2(graph) {
    var _a;
    const map = new Map();
    let graph1 = new SBOL1GraphView_1.default(graph);
    let newGraph = new rdfoo_1.Graph();
    let graph2 = new SBOL2GraphView_1.default(newGraph);
    for (let sequence of graph1.dnaSequences) {
        let sequence2 = new S2Sequence_1.default(graph2, sequence.uri);
        sequence2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Sequence);
        copyNonSBOLProperties(sequence, sequence2);
        sequence2.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
        sequence2.elements = sequence.nucleotides;
    }
    for (let dnaComponent of graph1.dnaComponents) {
        let component2 = new S2ComponentDefinition_1.default(graph2, dnaComponent.uri);
        component2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ComponentDefinition);
        copyNonSBOLProperties(dnaComponent, component2);
        component2.addType(bioterms_1.Specifiers.SBOL2.Type.DNA);
        component2.name = dnaComponent.name;
        component2.description = dnaComponent.description;
        copyDisplayId(dnaComponent, component2);
        if (dnaComponent.dnaSequence) {
            component2.insertProperty(bioterms_1.Predicates.SBOL2.sequence, rdfoo_1.node.createUriNode(dnaComponent.dnaSequence.uri));
        }
        for (let type of dnaComponent.getUriProperties(bioterms_1.Predicates.a)) {
            if (type.indexOf(bioterms_1.Prefixes.sbol1) === 0) {
                continue;
            }
            // if(type.indexOf('so:') === 0) {
            //     component2.addRole(Prefixes.sequenceOntologyIdentifiersOrg + 'SO:' + type.slice(3))
            // } else {
            component2.addRole(type);
            // }
        }
        let precedesN = 0;
        for (let anno of dnaComponent.annotations) {
            let anno2 = new S2SequenceAnnotation_1.default(graph2, anno.uri);
            anno2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            /// HAS to have locations
            component2.insertUriProperty(bioterms_1.Predicates.SBOL2.sequenceAnnotation, anno2.uri);
            copyNonSBOLProperties(anno, anno2);
            let subComponent = anno.subComponent;
            if (subComponent
                // any precedes relation requires a subcomponent in SBOL2
                //
                || graph.hasMatch(null, bioterms_1.Predicates.SBOL1.precedes, anno.uri)
                || graph.hasMatch(anno.uri, bioterms_1.Predicates.SBOL1.precedes, null)) {
                let subComponent2 = new S2ComponentInstance_1.default(graph2, URIUtils_1.default.addSuffix(anno.uri, '/component'));
                subComponent2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Component);
                if (subComponent !== undefined) {
                    // an actual SBOL1 composition
                    subComponent2.setUriProperty(bioterms_1.Predicates.SBOL2.definition, subComponent.uri);
                }
                else {
                    // forced subcomponent creation for precedes
                    subComponent2.setUriProperty(bioterms_1.Predicates.SBOL2.definition, 'http://sboltools.org/terms/stub');
                }
                anno2.insertUriProperty(bioterms_1.Predicates.SBOL2.component, subComponent2.uri);
                component2.insertUriProperty(bioterms_1.Predicates.SBOL2.component, subComponent2.uri);
            }
        }
        for (let anno of dnaComponent.annotations) {
            let anno2 = new S2SequenceAnnotation_1.default(graph2, anno.uri);
            anno2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            copyNonSBOLProperties(anno, anno2);
            let start = anno.bioStart;
            let end = anno.bioEnd;
            let strand = anno.strand;
            if (strand === '+')
                strand = bioterms_1.Specifiers.SBOL2.Orientation.Inline;
            else if (strand === '-')
                strand = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
            else
                strand = undefined;
            if (start !== undefined || end !== undefined) {
                let range = new S2Range_1.default(graph2, URIUtils_1.default.addSuffix(anno.uri, '/location'));
                range.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Range);
                range.start = start;
                range.end = end;
                range.orientation = strand;
                anno2.insertUriProperty(bioterms_1.Predicates.SBOL2.location, range.uri);
            }
            else {
                let genericLocation = new S2GenericLocation_1.default(graph2, URIUtils_1.default.addSuffix(anno.uri, '/location'));
                genericLocation.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.GenericLocation);
                if (strand !== undefined)
                    genericLocation.orientation = strand;
                anno2.insertUriProperty(bioterms_1.Predicates.SBOL2.location, genericLocation.uri);
            }
            for (let precedes of anno.precedes) {
                let constraint = new S2SequenceConstraint_1.default(graph2, URIUtils_1.default.addSuffix(dnaComponent.uri, '/precedes' + (++precedesN)));
                constraint.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceConstraint);
                component2.insertUriProperty(bioterms_1.Predicates.SBOL2.sequenceConstraint, constraint.uri);
                let obj = new S2SequenceAnnotation_1.default(graph2, anno.uri);
                let c2 = obj.component;
                assert_1.strict(c2);
                let precedes2 = new S2SequenceAnnotation_1.default(graph2, precedes.uri);
                assert_1.strict(precedes2.component); // no
                constraint.setProperty(bioterms_1.Predicates.SBOL2.subject, rdfoo_1.node.createUriNode(c2.uri));
                constraint.setProperty(bioterms_1.Predicates.SBOL2.restriction, rdfoo_1.node.createUriNode(bioterms_1.Specifiers.SBOL2.SequenceConstraint.Precedes));
                constraint.setProperty(bioterms_1.Predicates.SBOL2.object, rdfoo_1.node.createUriNode((_a = precedes2.component) === null || _a === void 0 ? void 0 : _a.uri));
            }
        }
    }
    for (let collection of graph1.collections) {
        let collection2 = new S2Collection_1.default(graph2, collection.uri);
        collection2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Collection);
        collection2.name = collection.name;
        collection2.description = collection.description;
        copyDisplayId(collection, collection2);
        for (let component of collection.components) {
            collection2.addMember(new S2ComponentDefinition_1.default(graph2, component.uri));
        }
    }
    // Delete anything with an SBOL1 type from the graph
    for (let typeTriple of graph.match(null, bioterms_1.Predicates.a, null)) {
        if (typeTriple.object.toString().indexOf(bioterms_1.Prefixes.sbol1) === 0) {
            graph.removeMatches(typeTriple.subject, null, null);
        }
    }
    graph.addAll(newGraph);
    function copyDisplayId(a, b) {
        let oldDisplayId = a.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
        if (oldDisplayId === undefined) {
            return;
        }
        let newDisplayId = oldDisplayId === null || oldDisplayId === void 0 ? void 0 : oldDisplayId.replace(/[^A-z_]/g, '_');
        b.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, newDisplayId);
        if (oldDisplayId === newDisplayId) {
            return;
        }
        b.setStringProperty('http://sboltools.org/backport#sbol1displayId', oldDisplayId);
    }
    function copyNonSBOLProperties(a, b) {
        for (let t of graph.match(a.uri, null, null)) {
            if (t.subject.indexOf(bioterms_1.Prefixes.sbol1) == 0) {
                continue;
            }
            b.insertProperty(t.predicate, t.object);
        }
    }
}
exports.default = convert1to2;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/sbolgraph/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
function convert2to1(graph) {
    var _a, _b;
    let sbol2View = new __1.SBOL2GraphView(graph);
    let newGraph = new rdfoo_1.Graph();
    let sbol1View = new __1.SBOL1GraphView(newGraph);
    for (let cd of sbol2View.componentDefinitions) {
        if (cd.type !== bioterms_1.Specifiers.SBOL2.Type.DNA) {
            continue;
        }
        newGraph.insertProperties(cd.uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaComponent)
        });
        copyIdentifiedProperties(cd);
        for (let role of cd.roles) {
            newGraph.insertProperties(cd.uri, {
                [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(role)
            });
        }
        if (cd.hasProperty(bioterms_1.Predicates.SBOL2.sequence)) {
            newGraph.insertProperties(cd.uri, {
                [bioterms_1.Predicates.SBOL1.dnaSequence]: rdfoo_1.node.createUriNode((_a = cd.sequences[0]) === null || _a === void 0 ? void 0 : _a.uri)
            });
        }
        for (let sa of cd.sequenceAnnotations) {
            newGraph.insertProperties(sa.uri, {
                [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation)
            });
            newGraph.insertProperties(cd.uri, {
                [bioterms_1.Predicates.SBOL1.annotation]: rdfoo_1.node.createUriNode(sa.uri)
            });
            copyIdentifiedProperties(sa);
            for (let location of sa.locations) {
                if (location instanceof __1.S2Range) {
                    if (location.hasProperty(bioterms_1.Predicates.SBOL2.start)) {
                        newGraph.insertProperties(sa.uri, {
                            [bioterms_1.Predicates.SBOL1.bioStart]: rdfoo_1.node.createIntNode(location.start)
                        });
                    }
                    if (location.hasProperty(bioterms_1.Predicates.SBOL2.end)) {
                        newGraph.insertProperties(sa.uri, {
                            [bioterms_1.Predicates.SBOL1.bioEnd]: rdfoo_1.node.createIntNode(location.end)
                        });
                    }
                    break;
                }
            }
            for (let location of sa.locations) {
                if (location instanceof __1.S2OrientedLocation) {
                    if (location.hasProperty(bioterms_1.Predicates.SBOL2.orientation)) {
                        newGraph.insertProperties(sa.uri, {
                            [bioterms_1.Predicates.SBOL1.strand]: rdfoo_1.node.createStringNode(location.orientation === bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement ? '-' : '+')
                        });
                    }
                }
            }
            if (sa.hasProperty(bioterms_1.Predicates.SBOL2.component)) {
                newGraph.insertProperties(sa.uri, {
                    [bioterms_1.Predicates.SBOL1.subComponent]: rdfoo_1.node.createUriNode((_b = sa.component) === null || _b === void 0 ? void 0 : _b.definition.uri)
                });
            }
        }
        for (let c of cd.components) {
            // if already referenced by an SA, don't duplicate
            //
            if (c.sequenceAnnotations.length > 0) {
                continue;
            }
            newGraph.insertProperties(c.uri, {
                [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation)
            });
            cd.insertProperty(bioterms_1.Predicates.SBOL1.annotation, rdfoo_1.node.createUriNode(c.uri));
            copyIdentifiedProperties(c);
            newGraph.insertProperties(c.uri, {
                [bioterms_1.Predicates.SBOL1.subComponent]: rdfoo_1.node.createUriNode(c.definition.uri)
            });
        }
        for (let sc of cd.sequenceConstraints) {
            if (sc.restriction === bioterms_1.Specifiers.SBOL2.SequenceConstraint.Precedes) {
                let subjSA = sc.subject.sequenceAnnotations.length > 0 ? sc.subject.sequenceAnnotations[0] : sc.subject;
                let objSA = sc.object.sequenceAnnotations.length > 0 ? sc.object.sequenceAnnotations[0] : sc.object;
                newGraph.insertProperties(subjSA.uri, {
                    [bioterms_1.Predicates.SBOL1.precedes]: rdfoo_1.node.createUriNode(objSA.uri)
                });
            }
        }
    }
    for (let coll of sbol2View.collections) {
        newGraph.insertProperties(coll.uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.Collection)
        });
        copyIdentifiedProperties(coll);
        for (let member of coll.members) {
            newGraph.insertProperties(coll.uri, {
                [bioterms_1.Predicates.SBOL1.component]: rdfoo_1.node.createUriNode(member.uri)
            });
        }
    }
    for (let seq of sbol2View.sequences) {
        if (seq.encoding !== bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid)
            continue;
        newGraph.insertProperties(seq.uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaSequence)
        });
        copyIdentifiedProperties(seq);
        if (seq.hasProperty(bioterms_1.Predicates.SBOL2.elements)) {
            newGraph.insertProperties(seq.uri, {
                [bioterms_1.Predicates.SBOL1.nucleotides]: rdfoo_1.node.createStringNode(seq.elements)
            });
        }
    }
    // Delete anything with an SBOL2 type from the graph
    for (let typeTriple of graph.match(null, bioterms_1.Predicates.a, null)) {
        if (typeTriple.object.toString().indexOf(bioterms_1.Prefixes.sbol2) === 0) {
            graph.removeMatches(typeTriple.subject, null, null);
        }
    }
    graph.addAll(newGraph);
    function copyIdentifiedProperties(identified) {
        if (identified.hasProperty('http://sboltools.org/backport#sbol1displayId')) {
            newGraph.insertProperties(identified.uri, {
                [bioterms_1.Predicates.SBOL1.displayId]: rdfoo_1.node.createStringNode(identified.getStringProperty('http://sboltools.org/backport#sbol1displayId'))
            });
        }
        else {
            if (identified.hasProperty(bioterms_1.Predicates.SBOL2.displayId)) {
                newGraph.insertProperties(identified.uri, {
                    [bioterms_1.Predicates.SBOL1.displayId]: rdfoo_1.node.createStringNode(identified.displayId)
                });
            }
        }
        if (identified.hasProperty(bioterms_1.Predicates.Dcterms.title)) {
            newGraph.insertProperties(identified.uri, {
                [bioterms_1.Predicates.SBOL1.name]: rdfoo_1.node.createStringNode(identified.name)
            });
        }
        if (identified.hasProperty(bioterms_1.Predicates.Dcterms.description)) {
            newGraph.insertProperties(identified.uri, {
                [bioterms_1.Predicates.SBOL1.description]: rdfoo_1.node.createStringNode(identified.description)
            });
        }
    }
}
exports.default = convert2to1;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL3.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/fromSBOL2/toSBOL3.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Component_1 = __webpack_require__(/*! ../../sbol3/S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
const S3SequenceFeature_1 = __webpack_require__(/*! ../../sbol3/S3SequenceFeature */ "./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js");
const S2Range_1 = __webpack_require__(/*! ../../sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const S2GenericLocation_1 = __webpack_require__(/*! ../../sbol2/S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
const S3SubComponent_1 = __webpack_require__(/*! ../../sbol3/S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
const S3Collection_1 = __webpack_require__(/*! ../../sbol3/S3Collection */ "./node_modules/sbolgraph/dist/sbol3/S3Collection.js");
const S3Sequence_1 = __webpack_require__(/*! ../../sbol3/S3Sequence */ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js");
const S3Interaction_1 = __webpack_require__(/*! ../../sbol3/S3Interaction */ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js");
const S3Participation_1 = __webpack_require__(/*! ../../sbol3/S3Participation */ "./node_modules/sbolgraph/dist/sbol3/S3Participation.js");
const S2ModuleInstance_1 = __webpack_require__(/*! ../../sbol2/S2ModuleInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js");
const S3Model_1 = __webpack_require__(/*! ../../sbol3/S3Model */ "./node_modules/sbolgraph/dist/sbol3/S3Model.js");
const S3MapsTo_1 = __webpack_require__(/*! ../../sbol3/S3MapsTo */ "./node_modules/sbolgraph/dist/sbol3/S3MapsTo.js");
const S3Experiment_1 = __webpack_require__(/*! ../../sbol3/S3Experiment */ "./node_modules/sbolgraph/dist/sbol3/S3Experiment.js");
const S3ExperimentalData_1 = __webpack_require__(/*! ../../sbol3/S3ExperimentalData */ "./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const SBOL3GraphView_1 = __webpack_require__(/*! ../../SBOL3GraphView */ "./node_modules/sbolgraph/dist/SBOL3GraphView.js");
const SBOL2GraphView_1 = __webpack_require__(/*! ../../SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/sbolgraph/dist/index.js");
const S3Attachment_1 = __webpack_require__(/*! ../../sbol3/S3Attachment */ "./node_modules/sbolgraph/dist/sbol3/S3Attachment.js");
const S3Implementation_1 = __webpack_require__(/*! ../../sbol3/S3Implementation */ "./node_modules/sbolgraph/dist/sbol3/S3Implementation.js");
function convert2to3(graph) {
    const map = new Map();
    let sbol2View = new SBOL2GraphView_1.default(graph);
    let newGraph = new rdfoo_1.Graph();
    let sbol3View = new SBOL3GraphView_1.default(newGraph);
    for (let cd of sbol2View.componentDefinitions) {
        cdTo3Component(cd);
    }
    for (let md of sbol2View.moduleDefinitions) {
        mdTo3Component(md);
    }
    for (let model of sbol2View.models) {
        modelToModel(model);
    }
    for (let seq of sbol2View.sequences) {
        convertSeq(seq);
    }
    for (let ed of sbol2View.experimentalData) {
        convertED(ed);
    }
    for (let ex of sbol2View.experiments) {
        convertExp(ex);
    }
    for (let att of sbol2View.attachments) {
        convertAttachment(att);
    }
    for (let sm of sbol2View.instancesOfType(bioterms_1.Types.SBOL2.Module).map((uri) => sbol2View.uriToFacade(uri))) {
        if (!(sm instanceof S2ModuleInstance_1.default)) {
            throw new Error('???');
        }
        let _subModule = map.get(sm.uri);
        if (!(_subModule instanceof S3SubComponent_1.default)) {
            console.warn(sm.uri + ' did not map to a subcomponent');
            if (_subModule)
                console.warn('it mapped to ' + _subModule.constructor.name);
        }
        const subModule = _subModule;
        for (let mapsTo of sm.mappings) {
            if (!mapsTo.local || !mapsTo.remote) {
                throw new Error('???');
            }
            let a = map.get(mapsTo.local.uri);
            if (!a) {
                console.warn('Local side of MapsTo ' + mapsTo.local.uri + ' in submodule ' + sm.uri + ' was not found');
                a = new S3SubComponent_1.default(sbol3View, mapsTo.local.uri);
            }
            let b = map.get(mapsTo.remote.uri);
            if (!b) {
                console.warn('Remote side of MapsTo ' + mapsTo.remote.uri + ' in submodule ' + sm.uri + ' was not found');
                b = new S3SubComponent_1.default(sbol3View, mapsTo.remote.uri);
            }
            let newMapsTo = new S3MapsTo_1.default(sbol3View, mapsTo.uri);
            newMapsTo.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.MapsTo);
            newMapsTo.local = a;
            newMapsTo.remote = b;
            newMapsTo.refinement = mapsTo.refinement;
            subModule.addMapping(newMapsTo);
            //subModule.createMapping(a as S3SubComponent, b as S3SubComponent)
        }
    }
    for (let collection of sbol2View.collections) {
        const col3 = new S3Collection_1.default(sbol3View, collection.uri);
        col3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Collection);
        copyIdentifiedProperties(collection, col3);
        for (let member of collection.members) {
            const converted = map.get(member.uri);
            if (converted !== undefined) {
                col3.addMember(converted);
            }
        }
    }
    for (let impl of sbol2View.implementations) {
        const impl3 = new S3Implementation_1.default(sbol3View, impl.uri);
        impl3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Implementation);
        copyIdentifiedProperties(impl, impl3);
        impl3.setUriProperty(bioterms_1.Predicates.SBOL3.built, impl.getUriProperty(bioterms_1.Predicates.SBOL2.built));
    }
    function convertSeq(seq) {
        const existing = map.get(seq.uri);
        if (existing)
            return existing;
        const xseq = new S3Sequence_1.default(sbol3View, seq.uri);
        xseq.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Sequence);
        copyIdentifiedProperties(seq, xseq);
        map.set(seq.uri, xseq);
        xseq.encoding = seq.encoding;
        xseq.elements = seq.elements;
        return xseq;
    }
    function modelToModel(model) {
        const existing = map.get(model.uri);
        if (existing)
            return existing;
        const xmodel = new S3Model_1.default(sbol3View, model.uri);
        xmodel.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Model);
        copyIdentifiedProperties(model, xmodel);
        xmodel.framework = model.framework;
        xmodel.source = model.source;
        xmodel.language = model.language;
        map.set(model.uri, xmodel);
        return xmodel;
    }
    function convertED(obj) {
        const existing = map.get(obj.uri);
        if (existing)
            return existing;
        const objx = new S3ExperimentalData_1.default(sbol3View, obj.uri);
        objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.ExperimentalData);
        copyIdentifiedProperties(obj, objx);
        map.set(obj.uri, objx);
        return objx;
    }
    function convertExp(obj) {
        const existing = map.get(obj.uri);
        if (existing)
            return existing;
        const objx = new S3Experiment_1.default(sbol3View, obj.uri);
        objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Experiment);
        copyIdentifiedProperties(obj, objx);
        for (let ed of obj.experimentalData) {
            objx.insertUriProperty(bioterms_1.Predicates.SBOL3.experimentalData, ed.uri);
        }
        map.set(obj.uri, objx);
        return objx;
    }
    function convertAttachment(obj) {
        const existing = map.get(obj.uri);
        if (existing)
            return existing;
        const objx = new S3Attachment_1.default(sbol3View, obj.uri);
        objx.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Attachment);
        copyIdentifiedProperties(obj, objx);
        objx.source = obj.source;
        objx.format = obj.format;
        objx.hash = obj.hash;
        objx.size = obj.size;
        map.set(obj.uri, objx);
        return objx;
    }
    function cdTo3Component(cd) {
        const existing = map.get(cd.uri);
        if (existing)
            return existing;
        const component3 = new S3Component_1.default(sbol3View, cd.uri);
        component3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Component);
        copyIdentifiedProperties(cd, component3);
        component3.setUriProperty('http://sboltools.org/backport#sbol2type', bioterms_1.Types.SBOL2.ComponentDefinition);
        map.set(cd.uri, component3);
        for (let role of cd.roles) {
            component3.addRole(role);
        }
        for (let type of cd.types) {
            component3.addType(type);
        }
        for (let sc of cd.components) {
            const def = cdTo3Component(sc.definition);
            const subComponent3 = new S3SubComponent_1.default(sbol3View, sc.uri);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sc, subComponent3);
            subComponent3.setUriProperty('http://sboltools.org/backport#sbol2type', bioterms_1.Types.SBOL2.Component);
            subComponent3.name = sc.name;
            subComponent3.instanceOf = def;
            if (sc.sourceLocation) {
                subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.sourceLocation, sc.sourceLocation.uri);
            }
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.uri);
            map.set(sc.uri, subComponent3);
            // TODO check sc roles match the def roles
        }
        for (let sa of cd.sequenceAnnotations) {
            if (!sa.component) {
                // no component, make a feature
                const feature = new S3SequenceFeature_1.default(sbol3View, sa.uri);
                feature.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SequenceFeature);
                copyIdentifiedProperties(sa, feature);
                component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, feature.uri);
                feature.name = sa.name;
                for (let role of sa.roles) {
                    feature.addRole(role);
                }
                copyLocations(sa, feature);
            }
            else {
                // has component, add locations to existing submodule
                const found = map.get(sa.component.uri);
                if (!found)
                    throw new Error('???');
                const sc = found;
                copyLocations(sa, sc);
                // don't because the object already exists; would end up with
                // 2 displayIds etc.
                // copyIdentifiedProperties(sa, sc)
                copyNonSBOLProperties(sa, sc);
                // TODO what if more than one? is that even possible
                sc.setStringProperty('http://sboltools.org/backport#sequenceAnnotationDisplayId', sa.displayId);
            }
        }
        for (let seq of cd.sequences) {
            component3.addSequence(convertSeq(seq));
        }
        return component3;
    }
    function mdTo3Component(md) {
        const existing = map.get(md.uri);
        if (existing)
            return existing;
        const component3 = new S3Component_1.default(sbol3View, md.uri);
        component3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Component);
        copyIdentifiedProperties(md, component3);
        component3.setUriProperty('http://sboltools.org/backport#sbol2type', bioterms_1.Types.SBOL2.ModuleDefinition);
        map.set(md.uri, component3);
        for (let sm of md.modules) {
            let subComponent3 = new S3SubComponent_1.default(sbol3View, sm.uri);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sm, subComponent3);
            subComponent3.setUriProperty('http://sboltools.org/backport#sbol2type', bioterms_1.Types.SBOL2.Module);
            let def = map.get(sm.definition.uri);
            if (def && def instanceof S3Component_1.default) {
                subComponent3.instanceOf = def;
            }
            else {
                // missing definition, can't convert it
                subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.instanceOf, sm.definition.uri);
            }
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.uri);
            if (sm.measure) {
                subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, sm.measure.uri);
            }
            map.set(sm.uri, subComponent3);
            // TODO check sc roles match the def roles
        }
        for (let sc of md.functionalComponents) {
            let subComponent3 = new S3SubComponent_1.default(sbol3View, sc.uri);
            subComponent3.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent);
            copyIdentifiedProperties(sc, subComponent3);
            subComponent3.setUriProperty('http://sboltools.org/backport#sbol2type', bioterms_1.Types.SBOL2.FunctionalComponent);
            let def = map.get(sc.definition.uri);
            if (def && def instanceof S3Component_1.default) {
                subComponent3.instanceOf = def;
            }
            else {
                // missing definition, can't convert it
                subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.instanceOf, sc.definition.uri);
            }
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, subComponent3.uri);
            if (sc.measure) {
                subComponent3.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, sc.measure.uri);
            }
            map.set(sc.uri, subComponent3);
            // TODO check sc roles match the def roles
        }
        for (let int of md.interactions) {
            let newInt = new S3Interaction_1.default(sbol3View, int.uri);
            newInt.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Interaction);
            copyIdentifiedProperties(int, newInt);
            component3.insertUriProperty(bioterms_1.Predicates.SBOL3.hasInteraction, newInt.uri);
            for (let type of int.types) {
                newInt.insertUriProperty(bioterms_1.Predicates.SBOL3.type, type);
            }
            if (int.measure) {
                newInt.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, int.measure.uri);
            }
            for (let type of int.types)
                newInt.addType(type);
            for (let participation of int.participations) {
                let newParticipation = new S3Participation_1.default(sbol3View, participation.uri);
                newParticipation.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Participation);
                copyIdentifiedProperties(participation, newParticipation);
                if (participation.measure) {
                    newParticipation.setUriProperty(bioterms_1.Predicates.SBOL3.hasFeature, participation.measure.uri);
                }
                newInt.insertUriProperty(bioterms_1.Predicates.SBOL3.hasParticipation, newParticipation.uri);
                if (participation.participant) {
                    let participant = map.get(participation.participant.uri);
                    if (!participant || !(participant instanceof S3SubComponent_1.default)) {
                        console.warn('participant not instanceof S3SubComponent');
                        if (participant)
                            console.warn(participant.constructor.name);
                        throw new Error('???');
                    }
                    newParticipation.setParticipant(participant);
                }
                for (let role of participation.roles) {
                    newParticipation.addRole(role);
                }
            }
        }
        for (let model of md.models) {
            component3.addModel(modelToModel(model));
        }
        return component3;
    }
    // Delete anything with an SBOL2 type from the graph
    for (let typeTriple of graph.match(null, bioterms_1.Predicates.a, null)) {
        if (typeTriple.object.toString().indexOf(bioterms_1.Prefixes.sbol2) === 0) {
            graph.removeMatches(typeTriple.subject, null, null);
        }
    }
    // For "generic top levels"
    graph.replaceURI(bioterms_1.Predicates.SBOL2.displayId, bioterms_1.Predicates.SBOL3.displayId);
    graph.replaceURI(bioterms_1.Predicates.SBOL2.version, 'http://sboltools.org/backport#sbol2version');
    // For roundtripping 3-2-3:
    /// - when converting 3-2, you have to create a CD and a MD for each C
    /// - when converting back 2-3, therefore, you can end up with double as many Cs as you expect
    /// this hack using a backport predicate indicates that the CD and MD should be merged into one C
    /// we do the merging after 2-3 conversion for simplicity
    for (let m of newGraph.match(null, 'http://sboltools.org/backport#sbol3identity', null)) {
        let currentUri = rdfoo_1.triple.subjectUri(m);
        let actualUri = rdfoo_1.triple.objectUri(m);
        if (currentUri !== actualUri) {
            // only keep displayId from the object that mapped directly
            newGraph.removeMatches(currentUri, bioterms_1.Predicates.SBOL3.displayId, null);
        }
        newGraph.replaceURI(currentUri, actualUri);
    }
    for (let m of newGraph.match(null, 'http://sboltools.org/backport#type', 'http://sboltools.org/backport#SplitComponentComposition')) {
        newGraph.purgeSubject(rdfoo_1.triple.subjectUri(m));
    }
    newGraph.removeMatches(null, 'http://sboltools.org/backport#sbol3identity', null);
    newGraph.removeMatches(null, 'http://sboltools.org/backport#type', null);
    graph.addAll(newGraph);
    function copyIdentifiedProperties(a, b) {
        let measure = a.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
        if (measure !== undefined) {
            b.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure);
        }
        let aTriples = graph.match(a.uri, null, null);
        for (let triple of aTriples) {
            let p = triple.predicate.nominalValue;
            if (p === bioterms_1.Predicates.a) {
                continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.title) {
                newGraph.insert(b.uri, bioterms_1.Predicates.SBOL3.name, triple.object);
                continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.description) {
                newGraph.insert(b.uri, bioterms_1.Predicates.SBOL3.description, triple.object);
                continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol2) !== 0) {
                newGraph.insert(b.uri, triple.predicate.nominalValue, triple.object);
            }
            if (p == bioterms_1.Predicates.SBOL2.displayId) {
                newGraph.insert(b.uri, bioterms_1.Predicates.SBOL3.displayId, triple.object);
            }
            else if (p == bioterms_1.Predicates.SBOL2.version) {
                newGraph.insert(b.uri, 'http://sboltools.org/backport#sbol2version', triple.object);
            }
            else if (p === 'http://sboltools.org/backport#sbol3namespace') {
                b.namespace = triple.object.nominalValue;
            }
        }
    }
    function copyNonSBOLProperties(a, b) {
        let aTriples = graph.match(a.uri, null, null);
        for (let triple of aTriples) {
            let p = triple.predicate.nominalValue;
            if (p === bioterms_1.Predicates.a) {
                continue;
            }
            if (p === bioterms_1.Predicates.Dcterms.title ||
                p === bioterms_1.Predicates.Dcterms.description) {
                continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol2) !== 0) {
                newGraph.insert(b.uri, triple.predicate.nominalValue, triple.object);
            }
        }
    }
    function copyLocations(a, b) {
        for (let location of a.locations) {
            if (location.getUriProperty('http://sboltools.org/backport#type') === 'http://sboltools.org/backport#FeatureOrientation') {
                b.orientation = location.orientation;
                continue;
            }
            if (location instanceof S2Range_1.default) {
                const range = location;
                let loc = new __1.S3OrientedLocation(sbol3View, range.uri);
                loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Range);
                copyIdentifiedProperties(location, loc);
                copyNonSBOLProperties(location, loc);
                b.insertUriProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.uri);
                if (location.sequence) {
                    loc.setUriProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.uri);
                }
                const start = range.start;
                const end = range.end;
                if (start !== undefined) {
                    loc.setIntProperty(bioterms_1.Predicates.SBOL3.start, start);
                }
                if (end !== undefined) {
                    loc.setIntProperty(bioterms_1.Predicates.SBOL3.end, end);
                }
                copyOrientation(range, loc);
            }
            else if (location instanceof __1.S2Cut) {
                const cut = location;
                let loc = new __1.S3OrientedLocation(sbol3View, cut.uri);
                loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Cut);
                copyIdentifiedProperties(location, loc);
                b.insertUriProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.uri);
                if (location.sequence) {
                    loc.setUriProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.uri);
                }
                const at = cut.at;
                if (at !== undefined) {
                    loc.setIntProperty(bioterms_1.Predicates.SBOL3.at, at);
                }
                copyOrientation(cut, loc);
            }
            else if (location instanceof S2GenericLocation_1.default) {
                let loc = new __1.S3OrientedLocation(sbol3View, location.uri);
                loc.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.OrientedLocation);
                copyIdentifiedProperties(location, loc);
                b.insertUriProperty(bioterms_1.Predicates.SBOL3.hasLocation, loc.uri);
                if (location.sequence) {
                    loc.setUriProperty(bioterms_1.Predicates.SBOL3.hasSequence, location.sequence.uri);
                }
                copyOrientation(location, loc);
            }
            else {
                console.warn('not implemented location type: ' + location.uri);
            }
        }
        function copyOrientation(a, b) {
            let o = a.getUriProperty(bioterms_1.Predicates.SBOL2.orientation);
            if (o !== undefined) {
                let o2 = o;
                if (o2 === bioterms_1.Specifiers.SBOL2.Orientation.Inline)
                    o2 = bioterms_1.Specifiers.SBOL3.Orientation.Inline;
                else if (o2 === bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement)
                    o2 = bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement;
                b.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, o2);
            }
        }
    }
}
exports.default = convert2to3;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/fromSBOL3/toSBOL2.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/fromSBOL3/toSBOL2.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SBOL2GraphView_1 = __webpack_require__(/*! ../../SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
const SBOL3GraphView_1 = __webpack_require__(/*! ../../SBOL3GraphView */ "./node_modules/sbolgraph/dist/SBOL3GraphView.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ../../sbol2/S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S3Range_1 = __webpack_require__(/*! ../../sbol3/S3Range */ "./node_modules/sbolgraph/dist/sbol3/S3Range.js");
const S3OrientedLocation_1 = __webpack_require__(/*! ../../sbol3/S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const S2ModuleDefinition_1 = __webpack_require__(/*! ../../sbol2/S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
const S2FunctionalComponent_1 = __webpack_require__(/*! ../../sbol2/S2FunctionalComponent */ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ../../sbol2/S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2GenericLocation_1 = __webpack_require__(/*! ../../sbol2/S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
const S2Experiment_1 = __webpack_require__(/*! ../../sbol2/S2Experiment */ "./node_modules/sbolgraph/dist/sbol2/S2Experiment.js");
const S2ExperimentalData_1 = __webpack_require__(/*! ../../sbol2/S2ExperimentalData */ "./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js");
const S2Range_1 = __webpack_require__(/*! ../../sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ../../sbol2/S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const URIUtils_1 = __webpack_require__(/*! ../../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
const S2Sequence_1 = __webpack_require__(/*! ../../sbol2/S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/sbolgraph/dist/index.js");
const S3Cut_1 = __webpack_require__(/*! ../../sbol3/S3Cut */ "./node_modules/sbolgraph/dist/sbol3/S3Cut.js");
function convert3to2(graph) {
    let newGraph = new rdfoo_1.Graph();
    let sbol3View = new SBOL3GraphView_1.default(graph);
    let sbol2View = new SBOL2GraphView_1.default(newGraph);
    let dontPrune = new Set();
    for (let ed of sbol3View.experimentalData) {
        let ed2 = new S2ExperimentalData_1.default(sbol2View, ed.uri);
        ed2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ExperimentalData);
        copyIdentifiedProperties(ed, ed2);
    }
    for (let ex of sbol3View.experiments) {
        let ex2 = new S2Experiment_1.default(sbol2View, ex.uri);
        ex2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Experiment);
        copyIdentifiedProperties(ex, ex2);
        for (let ed of ex.experimentalData) {
            ex2.insertUriProperty(bioterms_1.Predicates.SBOL3.experimentalData, ed.uri);
        }
    }
    for (let seq of sbol3View.sequences) {
        let seq2 = new S2Sequence_1.default(sbol2View, seq.uri);
        seq2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Sequence);
        copyIdentifiedProperties(seq, seq2);
        seq2.elements = seq.elements;
        seq2.encoding = seq.encoding;
    }
    for (let att of sbol3View.attachments) {
        let att2 = new __1.S2Attachment(sbol2View, att.uri);
        att2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Attachment);
        copyIdentifiedProperties(att, att2);
        att2.source = att.source;
        att2.format = att.format;
        att2.hash = att.hash;
        att2.size = att.size;
    }
    let componentToCDandMD = new Map();
    let subcomponentToFC = new Map();
    function getCDandMD(componentURI) {
        let mapping = componentToCDandMD.get(componentURI);
        if (!mapping) {
            console.warn(componentURI + ' has no cd/md mapping?');
        }
        return mapping;
    }
    // Create CDs and MDs for every component, where the MD contains the CD as an FC
    //
    for (let component of sbol3View.components) {
        let cdUri = component.uri;
        let mdUri = component.uri;
        // whichever SBOL2 object (CD or MD) gets the URI of the SBOL3 component, it will have a predicate telling us it was the original
        // so that if we roundtrip back to SBOL3 the URIs will match up
        // newGraph.insertProperties(component.uri, {
        // 	['http://sboltools.org/backport#sbol3type']: node.createUriNode(Types.SBOL3.Component)
        // })
        let cdSuffix = '_component';
        let mdSuffix = '_module';
        // both URIs need to be different, but want to try to keep the old SBOL2 URI for the correct object if we can
        //
        let backportType = component.getUriProperty('http://sboltools.org/backport#sbol2type');
        if (backportType) {
            switch (backportType) {
                case bioterms_1.Types.SBOL2.ModuleDefinition:
                    mdSuffix = '';
                    break;
                case bioterms_1.Types.SBOL2.ComponentDefinition:
                default:
                    cdSuffix = '';
                    break;
            }
        }
        if (mdSuffix && cdSuffix) {
            // there was no backport property to give us a clue
            // so we'll assume anything with interactions is module-like and
            // should have the identity URI, otherwise the CD gets it
            if (component.interactions.length > 0) {
                mdSuffix = '';
            }
            else {
                cdSuffix = '';
            }
        }
        if (cdSuffix !== '')
            cdUri = URIUtils_1.default.addSuffix(cdUri, cdSuffix);
        if (mdSuffix !== '')
            mdUri = URIUtils_1.default.addSuffix(mdUri, mdSuffix);
        switch (component.getUriProperty('http://sboltools.org/backport#sbol2type')) {
            case bioterms_1.Types.SBOL2.ModuleDefinition:
                dontPrune.add(mdUri);
                break;
            case bioterms_1.Types.SBOL2.ComponentDefinition:
                dontPrune.add(cdUri);
                break;
        }
        let cd = new S2ComponentDefinition_1.default(sbol2View, cdUri);
        cd.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ComponentDefinition);
        copyIdentifiedProperties(component, cd);
        cd.displayId = displayId(component) + cdSuffix;
        let md = new S2ModuleDefinition_1.default(sbol2View, mdUri);
        md.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ModuleDefinition);
        copyIdentifiedProperties(component, md);
        md.displayId = displayId(component) + mdSuffix;
        md.setUriProperty('http://sboltools.org/backport#sbol3identity', component.uri);
        cd.setUriProperty('http://sboltools.org/backport#sbol3identity', component.uri);
        if (md.persistentIdentity && mdSuffix)
            md.persistentIdentity = URIUtils_1.default.addSuffix(md.persistentIdentity, mdSuffix);
        if (cd.persistentIdentity && cdSuffix)
            cd.persistentIdentity = URIUtils_1.default.addSuffix(cd.persistentIdentity, cdSuffix);
        let fcUri = (md.persistentIdentity || md.uri) + '/' + displayId(component);
        let fc = new S2FunctionalComponent_1.default(sbol2View, fcUri);
        fc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.FunctionalComponent);
        fc.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, displayId(component));
        fc.setUriProperty(bioterms_1.Predicates.SBOL2.definition, cd.uri);
        fc.insertUriProperty('http://sboltools.org/backport#type', 'http://sboltools.org/backport#SplitComponentComposition');
        md.addFunctionalComponent(fc);
        for (let role of component.roles) {
            cd.addRole(role);
        }
        for (let type of component.types) {
            cd.addType(type);
        }
        for (let seq of component.sequences) {
            cd.insertUriProperty(bioterms_1.Predicates.SBOL2.sequence, seq.uri);
        }
        for (let feature of component.sequenceFeatures) {
            let sa = new S2SequenceAnnotation_1.default(sbol2View, feature.uri);
            sa.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation);
            copyIdentifiedProperties(feature, sa);
            cd.insertUriProperty(bioterms_1.Predicates.SBOL2.sequenceAnnotation, sa.uri);
            for (let role of feature.roles) {
                sa.addRole(role);
            }
            copyLocations(sbol2View, feature, sa);
        }
        componentToCDandMD.set(component.uri, { cd, md, fc, mdSuffix, cdSuffix });
    }
    // Make subcomponents into ALL of:
    // - SBOL2 subcomponents
    // - SBOL2 functionalcomponents
    // - SBOL2 submodules
    for (let component of sbol3View.components) {
        let mapping = getCDandMD(component.uri);
        if (!mapping) {
            throw new Error('???');
        }
        let { cd, md, fc } = mapping;
        for (let subcomponent of component.subComponents) {
            let defUri = subcomponent.getRequiredUriProperty(bioterms_1.Predicates.SBOL3.instanceOf);
            let newDefOfSubcomponent = getCDandMD(defUri);
            if (newDefOfSubcomponent === undefined) {
                throw new Error('???');
            }
            var cdSubcomponentURI, mdSubcomponentURI, mdSubmoduleURI;
            switch (subcomponent.getUriProperty('http://sboltools.org/backport#sbol2type')) {
                case bioterms_1.Types.SBOL2.Module:
                    mdSubmoduleURI = subcomponent.uri;
                    cdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_c');
                    mdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_fc');
                    break;
                case bioterms_1.Types.SBOL2.FunctionalComponent:
                    mdSubcomponentURI = subcomponent.uri;
                    cdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_c');
                    mdSubmoduleURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_m');
                    break;
                case bioterms_1.Types.SBOL2.Component:
                default:
                    cdSubcomponentURI = subcomponent.uri;
                    mdSubcomponentURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_fc');
                    mdSubmoduleURI = URIUtils_1.default.addSuffix(subcomponent.uri, '_m');
                    break;
            }
            let cdSubcomponent = new __1.S2ComponentInstance(sbol2View, cdSubcomponentURI);
            cdSubcomponent.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Component);
            cdSubcomponent.definition = newDefOfSubcomponent.cd;
            cdSubcomponent.setUriProperty('http://sboltools.org/backport#sbol3identity', subcomponent.uri);
            cd.insertUriProperty(bioterms_1.Predicates.SBOL2.component, cdSubcomponent.uri);
            let mdSubcomponent = new S2FunctionalComponent_1.default(sbol2View, mdSubcomponentURI);
            mdSubcomponent.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.FunctionalComponent);
            mdSubcomponent.definition = newDefOfSubcomponent.cd;
            mdSubcomponent.setUriProperty('http://sboltools.org/backport#sbol3identity', subcomponent.uri);
            md.insertUriProperty(bioterms_1.Predicates.SBOL2.functionalComponent, mdSubcomponent.uri);
            let mdSubmodule = new __1.S2ModuleInstance(sbol2View, mdSubmoduleURI);
            mdSubmodule.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Module);
            mdSubmodule.definition = newDefOfSubcomponent.md;
            mdSubmodule.setUriProperty('http://sboltools.org/backport#sbol3identity', subcomponent.uri);
            md.insertUriProperty(bioterms_1.Predicates.SBOL2.module, mdSubmodule.uri);
            switch (subcomponent.getUriProperty('http://sboltools.org/backport#sbol2type')) {
                case bioterms_1.Types.SBOL2.Module:
                    copyIdentifiedProperties(subcomponent, mdSubmodule);
                    break;
                case bioterms_1.Types.SBOL2.FunctionalComponent:
                    copyIdentifiedProperties(subcomponent, mdSubcomponent);
                    break;
                case bioterms_1.Types.SBOL2.Component:
                    copyIdentifiedProperties(subcomponent, cdSubcomponent);
                    break;
                default:
                    copyIdentifiedProperties(subcomponent, mdSubcomponent);
                    copyIdentifiedProperties(subcomponent, cdSubcomponent);
                    break;
            }
            subcomponentToFC.set(subcomponent.uri, mdSubcomponent);
            if (subcomponent.measure)
                mdSubcomponent.setUriProperty(bioterms_1.Predicates.SBOL2.measure, subcomponent.measure.uri);
            if (subcomponent.sourceLocation) {
                cdSubcomponent.setUriProperty(bioterms_1.Predicates.SBOL3.sourceLocation, subcomponent.sourceLocation.uri);
            }
            if (subcomponent.locations.length > 0 || subcomponent.orientation) {
                // if it has locations or an orientation it needs a SA
                let saDisplayId = subcomponent.getStringProperty('http://sboltools.org/backport#sequenceAnnotationDisplayId');
                if (!saDisplayId) {
                    saDisplayId = displayId(subcomponent) + '_anno';
                }
                let saIdent = S2IdentifiedFactory_1.default.createChild(sbol2View, bioterms_1.Types.SBOL2.SequenceAnnotation, cd, bioterms_1.Predicates.SBOL2.sequenceAnnotation, saDisplayId, subcomponent.getStringProperty(bioterms_1.Predicates.SBOL2.version));
                let sa = new S2SequenceAnnotation_1.default(sbol2View, saIdent.uri);
                sa.setUriProperty(bioterms_1.Predicates.SBOL2.component, subcomponent.uri);
                let orientLoc = sa.addLocationGeneric(subcomponent.orientation);
                orientLoc.setUriProperty('http://sboltools.org/backport#type', 'http://sboltools.org/backport#FeatureOrientation');
                copyLocations(sbol2View, subcomponent, sa);
            }
        }
    }
    // Port interactions
    for (let component of sbol3View.components) {
        let mapping = getCDandMD(component.uri);
        if (!mapping) {
            throw new Error('???');
        }
        let { cd, md, fc, cdSuffix, mdSuffix } = mapping;
        for (let interaction of component.interactions) {
            let newInteraction = md.createInteraction(displayId(interaction), interaction.getStringProperty(bioterms_1.Predicates.SBOL2.version));
            copyIdentifiedProperties(interaction, newInteraction);
            if (interaction.measure) {
                newInteraction.setUriProperty(bioterms_1.Predicates.SBOL2.measure, interaction.measure.uri);
            }
            for (let type of interaction.types) {
                newInteraction.insertUriProperty(bioterms_1.Predicates.SBOL2.type, type);
            }
            for (let participation of interaction.participations) {
                let newParticipation = newInteraction.createParticipation(displayId(participation), participation.getStringProperty(bioterms_1.Predicates.SBOL2.version));
                copyIdentifiedProperties(participation, newParticipation);
                if (participation.measure) {
                    newParticipation.setUriProperty(bioterms_1.Predicates.SBOL2.measure, participation.measure.uri);
                }
                for (let role of participation.roles) {
                    newParticipation.addRole(role);
                }
                let participant = participation.participant;
                if (participant) {
                    let newParticipant = subcomponentToFC.get(participant.uri);
                    newParticipation.participant = newParticipant;
                }
            }
        }
    }
    for (let impl of sbol3View.implementations) {
        const impl2 = new __1.S2Implementation(sbol2View, impl.uri);
        impl2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Implementation);
        copyIdentifiedProperties(impl, impl2);
        impl2.setUriProperty(bioterms_1.Predicates.SBOL2.built, impl.getUriProperty(bioterms_1.Predicates.SBOL3.built));
    }
    for (let coll of sbol3View.collections) {
        let coll2 = new __1.S2Collection(sbol2View, coll.uri);
        coll2.setUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Collection);
        copyIdentifiedProperties(coll, coll2);
        for (let member of coll.members) {
            coll2.insertUriProperty(bioterms_1.Predicates.SBOL2.member, member.uri);
            // if it's a component that has been mapped to an SBOL2 CD and MD,
            // add both to the SBOL2 collection.
            //
            let cdAndMdMapping = componentToCDandMD.get(member.uri);
            if (cdAndMdMapping) {
                coll2.insertUriProperty(bioterms_1.Predicates.SBOL2.member, cdAndMdMapping.cd.uri);
                coll2.insertUriProperty(bioterms_1.Predicates.SBOL2.member, cdAndMdMapping.md.uri);
            }
        }
    }
    // We can do some pruning now.
    //
    //  1) ModuleDefinitions with no interactions and no models are "pointless modules".
    //     They can be deleted along with their submodules and FCs.
    // 
    //  2) Similarly, ComponentDefinitions with no sequences, sequence annotations, or subcomponents
    //     are "pointless components"
    //
    // Important not to delete both though! Or we would completely lose the object when in SBOL2
    // land, including its non SBOL properties if any.
    //
    // It's easier to do this on the generated SBOL2 because it means we don't
    // have to make assumptions about how the SBOL3 will map to SBOL2.
    //
    for (let mapping of componentToCDandMD) {
        let componentUri = mapping[0];
        let { md, cd, fc, cdSuffix, mdSuffix } = mapping[1];
        let mdPruned = false, cdPruned = false;
        if (!dontPrune.has(md.uri)) {
            if (md.interactions.length === 0 && md.models.length === 0 && md.measures.length === 0) {
                md.destroy();
                mdPruned = true;
            }
        }
        if (!mdPruned && !dontPrune.has(cd.uri)) {
            if (cd.containedObjects.length === 0) {
                cd.destroy();
                cdPruned = true;
            }
        }
        if (mdPruned && !cdPruned) {
            // remove suffix from component
            if (cdSuffix.length > 0) {
                console.assert(cd.uri.endsWith(cdSuffix));
                console.assert(cd.displayId.endsWith(cdSuffix));
                let newDisplayid = cd.displayId.substr(0, cd.displayId.length - cdSuffix.length);
                cd.displayId = newDisplayid;
                let newUri = cd.uri.substr(0, cd.uri.length - cdSuffix.length);
                newGraph.replaceURI(cd.uri, newUri);
            }
        }
        else if (cdPruned && !mdPruned) {
            // remove suffix from module
            if (mdSuffix.length > 0) {
                console.assert(md.uri.endsWith(mdSuffix));
                console.assert(md.displayId.endsWith(mdSuffix));
                let newDisplayid = md.displayId.substr(0, md.displayId.length - mdSuffix.length);
                md.displayId = newDisplayid;
                let newUri = md.uri.substr(0, md.uri.length - mdSuffix.length);
                newGraph.replaceURI(md.uri, newUri);
            }
        }
    }
    // Delete anything with an SBOL3 type from the graph
    for (let typeTriple of graph.match(null, bioterms_1.Predicates.a, null)) {
        if (typeTriple.object.toString().indexOf(bioterms_1.Prefixes.sbol3) === 0) {
            graph.removeMatches(typeTriple.subject, null, null);
        }
    }
    // For "generic top levels"
    graph.replaceURI(bioterms_1.Predicates.SBOL3.persistentIdentity, bioterms_1.Predicates.SBOL2.persistentIdentity);
    graph.replaceURI(bioterms_1.Predicates.SBOL3.displayId, bioterms_1.Predicates.SBOL2.displayId);
    graph.replaceURI('http://sboltools.org/backport#sbol2version', bioterms_1.Predicates.SBOL2.version);
    graph.addAll(newGraph);
    function copyIdentifiedProperties(a, b) {
        a.setUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity, a.uri);
        if (a.namespace)
            b.setUriProperty('http://sboltools.org/backport#sbol3namespace', a.namespace);
        let aTriples = graph.match(a.uri, null, null);
        for (let triple of aTriples) {
            let p = triple.predicate.nominalValue;
            if (p === bioterms_1.Predicates.a) {
                continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.displayId) {
                b.graph.insert(b.uri, bioterms_1.Predicates.SBOL2.displayId, triple.object);
                continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.name) {
                b.graph.insert(b.uri, bioterms_1.Predicates.Dcterms.title, triple.object);
                continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.description) {
                b.graph.insert(b.uri, bioterms_1.Predicates.Dcterms.description, triple.object);
                continue;
            }
            if (p === bioterms_1.Predicates.SBOL3.hasMeasure) {
                b.graph.insert(b.uri, bioterms_1.Predicates.SBOL2.measure, triple.object);
                continue;
            }
            if (p === 'http://sboltools.org/backport#sbol2version') {
                b.graph.insert(b.uri, bioterms_1.Predicates.SBOL2.version, triple.object);
                continue;
            }
            if (p.indexOf('http://sboltools.org/backport') !== -1) {
                continue;
            }
            if (p.indexOf(bioterms_1.Prefixes.sbol3) !== 0) {
                b.graph.insert(b.uri, triple.predicate.nominalValue, triple.object);
            }
        }
    }
    function copyLocations(sbol2View, oldThing, newThing) {
        for (let location of oldThing.locations) {
            if (location instanceof S3Range_1.default) {
                let newLoc = new S2Range_1.default(sbol2View, location.uri);
                newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Range);
                copyIdentifiedProperties(location, newLoc);
                newThing.insertUriProperty(bioterms_1.Predicates.SBOL2.location, newLoc.uri);
                if (location.sequence) {
                    newLoc.setUriProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.uri);
                }
                newLoc.start = location.start;
                newLoc.end = location.end;
                copyOrientation(location, newLoc);
            }
            else if (location instanceof S3Cut_1.default) {
                let newLoc = new __1.S2Cut(sbol2View, location.uri);
                newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.Cut);
                copyIdentifiedProperties(location, newLoc);
                newThing.insertUriProperty(bioterms_1.Predicates.SBOL2.location, newLoc.uri);
                if (location.sequence) {
                    newLoc.setUriProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.uri);
                }
                newLoc.at = location.at;
                newLoc.orientation = location.orientation === bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement ?
                    bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement : bioterms_1.Specifiers.SBOL2.Orientation.Inline;
                copyOrientation(location, newLoc);
            }
            else if (location instanceof S3OrientedLocation_1.default) {
                let newLoc = new S2GenericLocation_1.default(sbol2View, location.uri);
                newLoc.insertUriProperty(bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.GenericLocation);
                copyIdentifiedProperties(location, newLoc);
                newThing.insertUriProperty(bioterms_1.Predicates.SBOL2.location, newLoc.uri);
                if (location.sequence) {
                    newLoc.setUriProperty(bioterms_1.Predicates.SBOL2.sequence, location.sequence.uri);
                }
                copyOrientation(location, newLoc);
            }
            else {
                throw new Error('not implemented location type');
            }
            function copyOrientation(a, b) {
                let o = a.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
                if (o !== undefined) {
                    let o2 = o;
                    if (o2 === bioterms_1.Specifiers.SBOL3.Orientation.Inline)
                        o2 = bioterms_1.Specifiers.SBOL2.Orientation.Inline;
                    else if (o2 === bioterms_1.Specifiers.SBOL3.Orientation.ReverseComplement)
                        o2 = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
                    b.setUriProperty(bioterms_1.Predicates.SBOL2.orientation, o2);
                }
            }
        }
    }
}
exports.default = convert3to2;
function displayId(obj) {
    let displayId = obj.displayId;
    if (displayId)
        return displayId;
    let slash = obj.uri.split('/').pop() || '';
    let hash = obj.uri.split('#').pop() || '';
    return slash.length > hash.length ? slash : hash;
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/conversion/genbankToSBOL2.js":
/*!******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/conversion/genbankToSBOL2.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const genbank = __webpack_require__(/*! genbankjs */ "./node_modules/genbankjs/genbank.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
function genbankToSBOL2(graph, uriPrefix, gb) {
    let gbf = genbank.parseGBF(gb);
    let sequence = graph.createSequence(uriPrefix, gbf.locusName + '_sequence', '1');
    if (gbf.moleculeType === 'DNA') {
        sequence.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else {
        sequence.encoding = bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    }
    if (gbf.definition)
        sequence.description = gbf.definition;
    if (gbf.sequence)
        sequence.elements = gbf.sequence;
    if (!gbf.locusName) {
        console.dir(gbf);
        throw new Error('missing locusName?');
    }
    let componentDefinition = graph.createComponentDefinition(uriPrefix, gbf.locusName, '1');
    if (gbf.moleculeType === 'DNA') {
        componentDefinition.type = bioterms_1.Specifiers.SBOL2.Type.DNA;
    }
    else {
        componentDefinition.type = bioterms_1.Specifiers.SBOL2.Type.Protein;
    }
    componentDefinition.description = gbf.definition;
    for (let feature of gbf.features) {
        let name = feature.key;
        if (feature['/gene'] && feature['/gene'][0]) {
            name = feature['/gene'][0];
        }
        else if (feature['/product'] && feature['/product'][0]) {
            name = feature['/product'][0];
        }
        let sequenceAnnotation = componentDefinition.annotateRange(feature.location.start, feature.location.end, name);
        if (feature.location.strand === 'complementary') {
            sequenceAnnotation.locations[0].orientation = bioterms_1.Specifiers.SBOL2.Orientation.ReverseComplement;
        }
        let soTerm = genbankToSO[feature.key];
        if (soTerm) {
            sequenceAnnotation.addRole(soTerm);
        }
    }
}
exports.default = genbankToSBOL2;
var soToGenbank = {
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000001"]: "misc_feature",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000002"]: "misc_structure",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000005"]: "satellite",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000013"]: "scRNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000019"]: "stem_loop",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000112"]: "primer",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000139"]: "RBS",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000552"]: "RBS",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000140"]: "attenuator",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000141"]: "terminator",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000147"]: "exon",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000149"]: "source",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000165"]: "enhancer",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000167"]: "promoter",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000172"]: "CAAT_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000173"]: "GC_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000174"]: "TATA_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000175"]: "-10_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000176"]: "-35_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000185"]: "precursor_RNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000185"]: "prim_transcript",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000188"]: "intron",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000204"]: "5'UTR",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000205"]: "3'UTR",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000233"]: "misc_RNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000234"]: "mRNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000252"]: "rRNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000253"]: "tRNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000274"]: "snRNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000286"]: "LTR",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000296"]: "rep_origin",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000297"]: "D-loop",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000298"]: "misc_recomb",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000305"]: "modified_base",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000313"]: "stem_loop",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000316"]: "CDS",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000331"]: "STS",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000409"]: "misc_binding",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000410"]: "protein_bind",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000413"]: "misc_difference",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000418"]: "sig_peptide",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000419"]: "mat_peptide",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000458"]: "D_segment",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000470"]: "J_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000551"]: "polyA_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000553"]: "polyA_site",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000555"]: "5'clip",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000557"]: "3'clip",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000657"]: "repeat_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000704"]: "gene",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000723"]: "iDNA",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000725"]: "transit_peptide",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0000726"]: "repeat_unit",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001023"]: "allele",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001054"]: "transposon",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001060"]: "variation",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001411"]: "misc_signal",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001645"]: "misc_marker",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001833"]: "V_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001834"]: "C_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001835"]: "N_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0001836"]: "S_region",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0005836"]: "regulatory",
    [bioterms_1.Prefixes.sequenceOntologyIdentifiersOrg + "SO:0005850"]: "primer_bind"
};
var genbankToSO = Object.create(null);
Object.keys(soToGenbank).forEach((uri) => {
    let gb = soToGenbank[uri];
    if (genbankToSO[gb] === undefined) {
        genbankToSO[gb] = uri;
    }
});


/***/ }),

/***/ "./node_modules/sbolgraph/dist/extractTerm.js":
/*!****************************************************!*\
  !*** ./node_modules/sbolgraph/dist/extractTerm.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function extractTerm(uri) {
    let purl1 = 'http://purl.org/obo/owl/SO#';
    let purl2 = 'http://purl.obolibrary.org/obo/';
    let idorg = 'http://identifiers.org/so/';
    if (uri.indexOf(purl1) === 0) {
        return uri.slice(purl1.length).replace(/_/g, ':');
    }
    else if (uri.indexOf(purl2) === 0) {
        return uri.slice(purl2.length).replace(/_/g, ':');
    }
    else if (uri.indexOf(idorg) === 0) {
        return uri.slice(idorg.length);
    }
}
exports.default = extractTerm;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sbolgraph/dist/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.genbankToSBOL2 = exports.fastaToSBOL2 = exports.SBOLConverter = exports.Facade = exports.serialize = exports.SearchResult = exports.SearchQuery = exports.Repository = exports.triple = exports.node = exports.Graph = exports.S3ExperimentalData = exports.S3Experiment = exports.S3Model = exports.S3MapsTo = exports.S3Collection = exports.S3Participation = exports.S3Interaction = exports.S3SequenceFeature = exports.S3Constraint = exports.S3Range = exports.S3OrientedLocation = exports.S3ThingWithLocation = exports.S3Location = exports.S3Sequence = exports.S3Component = exports.S3SubComponent = exports.S3Identified = exports.sbol3 = exports.SBOL3GraphView = exports.S2Attachment = exports.S2MapsTo = exports.S2Interaction = exports.S2Collection = exports.S2GenericLocation = exports.S2Cut = exports.S2Range = exports.S2Location = exports.S2OrientedLocation = exports.S2Sequence = exports.S2ExperimentalData = exports.S2Experiment = exports.S2Implementation = exports.S2FunctionalComponent = exports.S2SequenceAnnotation = exports.S2ModuleDefinition = exports.S2ComponentDefinition = exports.S2ModuleInstance = exports.S2ComponentInstance = exports.S2Identified = exports.sbol2 = exports.SBOL2GraphView = exports.S1SequenceAnnotation = exports.S1DnaSequence = exports.S1DnaComponent = exports.S1Collection = exports.S1Facade = exports.sbol1 = exports.SBOL1GraphView = void 0;
const SBOL1GraphView_1 = __webpack_require__(/*! ./SBOL1GraphView */ "./node_modules/sbolgraph/dist/SBOL1GraphView.js");
exports.SBOL1GraphView = SBOL1GraphView_1.default;
const SBOL2GraphView_1 = __webpack_require__(/*! ./SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
exports.SBOL2GraphView = SBOL2GraphView_1.default;
const SBOL3GraphView_1 = __webpack_require__(/*! ./SBOL3GraphView */ "./node_modules/sbolgraph/dist/SBOL3GraphView.js");
exports.SBOL3GraphView = SBOL3GraphView_1.default;
const SBOL1GraphView_2 = __webpack_require__(/*! ./SBOL1GraphView */ "./node_modules/sbolgraph/dist/SBOL1GraphView.js");
Object.defineProperty(exports, "sbol1", { enumerable: true, get: function () { return SBOL1GraphView_2.sbol1; } });
const SBOL2GraphView_2 = __webpack_require__(/*! ./SBOL2GraphView */ "./node_modules/sbolgraph/dist/SBOL2GraphView.js");
Object.defineProperty(exports, "sbol2", { enumerable: true, get: function () { return SBOL2GraphView_2.sbol2; } });
const SBOL3GraphView_2 = __webpack_require__(/*! ./SBOL3GraphView */ "./node_modules/sbolgraph/dist/SBOL3GraphView.js");
Object.defineProperty(exports, "sbol3", { enumerable: true, get: function () { return SBOL3GraphView_2.sbol3; } });
const S1Facade_1 = __webpack_require__(/*! ./sbol1/S1Facade */ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js");
exports.S1Facade = S1Facade_1.default;
const S1Collection_1 = __webpack_require__(/*! ./sbol1/S1Collection */ "./node_modules/sbolgraph/dist/sbol1/S1Collection.js");
exports.S1Collection = S1Collection_1.default;
const S1DnaComponent_1 = __webpack_require__(/*! ./sbol1/S1DnaComponent */ "./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js");
exports.S1DnaComponent = S1DnaComponent_1.default;
const S1DnaSequence_1 = __webpack_require__(/*! ./sbol1/S1DnaSequence */ "./node_modules/sbolgraph/dist/sbol1/S1DnaSequence.js");
exports.S1DnaSequence = S1DnaSequence_1.default;
const S1SequenceAnnotation_1 = __webpack_require__(/*! ./sbol1/S1SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol1/S1SequenceAnnotation.js");
exports.S1SequenceAnnotation = S1SequenceAnnotation_1.default;
const S2Identified_1 = __webpack_require__(/*! ./sbol2/S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
exports.S2Identified = S2Identified_1.default;
const S2ComponentInstance_1 = __webpack_require__(/*! ./sbol2/S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
exports.S2ComponentInstance = S2ComponentInstance_1.default;
const S2ModuleInstance_1 = __webpack_require__(/*! ./sbol2/S2ModuleInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js");
exports.S2ModuleInstance = S2ModuleInstance_1.default;
const S2ComponentDefinition_1 = __webpack_require__(/*! ./sbol2/S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
exports.S2ComponentDefinition = S2ComponentDefinition_1.default;
const S2ModuleDefinition_1 = __webpack_require__(/*! ./sbol2/S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
exports.S2ModuleDefinition = S2ModuleDefinition_1.default;
const S2SequenceAnnotation_1 = __webpack_require__(/*! ./sbol2/S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
exports.S2SequenceAnnotation = S2SequenceAnnotation_1.default;
const S2FunctionalComponent_1 = __webpack_require__(/*! ./sbol2/S2FunctionalComponent */ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js");
exports.S2FunctionalComponent = S2FunctionalComponent_1.default;
const S2Implementation_1 = __webpack_require__(/*! ./sbol2/S2Implementation */ "./node_modules/sbolgraph/dist/sbol2/S2Implementation.js");
exports.S2Implementation = S2Implementation_1.default;
const S2Experiment_1 = __webpack_require__(/*! ./sbol2/S2Experiment */ "./node_modules/sbolgraph/dist/sbol2/S2Experiment.js");
exports.S2Experiment = S2Experiment_1.default;
const S2ExperimentalData_1 = __webpack_require__(/*! ./sbol2/S2ExperimentalData */ "./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js");
exports.S2ExperimentalData = S2ExperimentalData_1.default;
const S2Sequence_1 = __webpack_require__(/*! ./sbol2/S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
exports.S2Sequence = S2Sequence_1.default;
const S2Location_1 = __webpack_require__(/*! ./sbol2/S2Location */ "./node_modules/sbolgraph/dist/sbol2/S2Location.js");
exports.S2Location = S2Location_1.default;
const S2OrientedLocation_1 = __webpack_require__(/*! ./sbol2/S2OrientedLocation */ "./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js");
exports.S2OrientedLocation = S2OrientedLocation_1.default;
const S2Range_1 = __webpack_require__(/*! ./sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
exports.S2Range = S2Range_1.default;
const S2Cut_1 = __webpack_require__(/*! ./sbol2/S2Cut */ "./node_modules/sbolgraph/dist/sbol2/S2Cut.js");
exports.S2Cut = S2Cut_1.default;
const S2GenericLocation_1 = __webpack_require__(/*! ./sbol2/S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
exports.S2GenericLocation = S2GenericLocation_1.default;
const S2Collection_1 = __webpack_require__(/*! ./sbol2/S2Collection */ "./node_modules/sbolgraph/dist/sbol2/S2Collection.js");
exports.S2Collection = S2Collection_1.default;
const S2Interaction_1 = __webpack_require__(/*! ./sbol2/S2Interaction */ "./node_modules/sbolgraph/dist/sbol2/S2Interaction.js");
exports.S2Interaction = S2Interaction_1.default;
const S2MapsTo_1 = __webpack_require__(/*! ./sbol2/S2MapsTo */ "./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js");
exports.S2MapsTo = S2MapsTo_1.default;
const S2Attachment_1 = __webpack_require__(/*! ./sbol2/S2Attachment */ "./node_modules/sbolgraph/dist/sbol2/S2Attachment.js");
exports.S2Attachment = S2Attachment_1.default;
const S3Identified_1 = __webpack_require__(/*! ./sbol3/S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
exports.S3Identified = S3Identified_1.default;
const S3SubComponent_1 = __webpack_require__(/*! ./sbol3/S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
exports.S3SubComponent = S3SubComponent_1.default;
const S3Component_1 = __webpack_require__(/*! ./sbol3/S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
exports.S3Component = S3Component_1.default;
const S3Sequence_1 = __webpack_require__(/*! ./sbol3/S3Sequence */ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js");
exports.S3Sequence = S3Sequence_1.default;
const S3Constraint_1 = __webpack_require__(/*! ./sbol3/S3Constraint */ "./node_modules/sbolgraph/dist/sbol3/S3Constraint.js");
exports.S3Constraint = S3Constraint_1.default;
const S3Location_1 = __webpack_require__(/*! ./sbol3/S3Location */ "./node_modules/sbolgraph/dist/sbol3/S3Location.js");
exports.S3Location = S3Location_1.default;
const S3OrientedLocation_1 = __webpack_require__(/*! ./sbol3/S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
exports.S3OrientedLocation = S3OrientedLocation_1.default;
const S3Range_1 = __webpack_require__(/*! ./sbol3/S3Range */ "./node_modules/sbolgraph/dist/sbol3/S3Range.js");
exports.S3Range = S3Range_1.default;
const S3SequenceFeature_1 = __webpack_require__(/*! ./sbol3/S3SequenceFeature */ "./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js");
exports.S3SequenceFeature = S3SequenceFeature_1.default;
const S3Interaction_1 = __webpack_require__(/*! ./sbol3/S3Interaction */ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js");
exports.S3Interaction = S3Interaction_1.default;
const S3Participation_1 = __webpack_require__(/*! ./sbol3/S3Participation */ "./node_modules/sbolgraph/dist/sbol3/S3Participation.js");
exports.S3Participation = S3Participation_1.default;
const S3Collection_1 = __webpack_require__(/*! ./sbol3/S3Collection */ "./node_modules/sbolgraph/dist/sbol3/S3Collection.js");
exports.S3Collection = S3Collection_1.default;
const S3Feature_1 = __webpack_require__(/*! ./sbol3/S3Feature */ "./node_modules/sbolgraph/dist/sbol3/S3Feature.js");
exports.S3ThingWithLocation = S3Feature_1.default;
const S3MapsTo_1 = __webpack_require__(/*! ./sbol3/S3MapsTo */ "./node_modules/sbolgraph/dist/sbol3/S3MapsTo.js");
exports.S3MapsTo = S3MapsTo_1.default;
const S3Model_1 = __webpack_require__(/*! ./sbol3/S3Model */ "./node_modules/sbolgraph/dist/sbol3/S3Model.js");
exports.S3Model = S3Model_1.default;
const S3Experiment_1 = __webpack_require__(/*! ./sbol3/S3Experiment */ "./node_modules/sbolgraph/dist/sbol3/S3Experiment.js");
exports.S3Experiment = S3Experiment_1.default;
const S3ExperimentalData_1 = __webpack_require__(/*! ./sbol3/S3ExperimentalData */ "./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js");
exports.S3ExperimentalData = S3ExperimentalData_1.default;
const SBOL2Repository_1 = __webpack_require__(/*! ./SBOL2Repository */ "./node_modules/sbolgraph/dist/SBOL2Repository.js");
exports.Repository = SBOL2Repository_1.default;
const SBOL2Repository_2 = __webpack_require__(/*! ./SBOL2Repository */ "./node_modules/sbolgraph/dist/SBOL2Repository.js");
Object.defineProperty(exports, "SearchQuery", { enumerable: true, get: function () { return SBOL2Repository_2.SearchQuery; } });
Object.defineProperty(exports, "SearchResult", { enumerable: true, get: function () { return SBOL2Repository_2.SearchResult; } });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
Object.defineProperty(exports, "Graph", { enumerable: true, get: function () { return rdfoo_1.Graph; } });
Object.defineProperty(exports, "node", { enumerable: true, get: function () { return rdfoo_1.node; } });
Object.defineProperty(exports, "triple", { enumerable: true, get: function () { return rdfoo_1.triple; } });
Object.defineProperty(exports, "serialize", { enumerable: true, get: function () { return rdfoo_1.serialize; } });
Object.defineProperty(exports, "Facade", { enumerable: true, get: function () { return rdfoo_1.Facade; } });
const SBOLConverter_1 = __webpack_require__(/*! ./SBOLConverter */ "./node_modules/sbolgraph/dist/SBOLConverter.js");
exports.SBOLConverter = SBOLConverter_1.default;
const fastaToSBOL2_1 = __webpack_require__(/*! ./conversion/fastaToSBOL2 */ "./node_modules/sbolgraph/dist/conversion/fastaToSBOL2.js");
exports.fastaToSBOL2 = fastaToSBOL2_1.default;
const genbankToSBOL2_1 = __webpack_require__(/*! ./conversion/genbankToSBOL2 */ "./node_modules/sbolgraph/dist/conversion/genbankToSBOL2.js");
exports.genbankToSBOL2 = genbankToSBOL2_1.default;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/isOwnershipRelation.js":
/*!************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/isOwnershipRelation.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
let ownershipPredicates = [
    bioterms_1.Predicates.SBOL1.annotation,
    bioterms_1.Predicates.SBOL1.dnaSequence,
    bioterms_1.Predicates.SBOL2.sequenceConstraint,
    bioterms_1.Predicates.SBOL2.sequenceAnnotation,
    bioterms_1.Predicates.SBOL2.attachment,
    bioterms_1.Predicates.SBOL2.module,
    bioterms_1.Predicates.SBOL2.functionalComponent,
    bioterms_1.Predicates.SBOL2.participation,
    bioterms_1.Predicates.SBOL2.location,
    bioterms_1.Predicates.SBOL2.sourceLocation,
    bioterms_1.Predicates.SBOL2.interaction,
    bioterms_1.Predicates.Prov.qualifiedAssociation,
    bioterms_1.Predicates.Prov.qualifiedUsage,
    bioterms_1.Predicates.SBOL2.measure,
    bioterms_1.Predicates.SBOL3.hasConstraint,
    bioterms_1.Predicates.SBOL3.hasFeature,
    bioterms_1.Predicates.SBOL3.hasParticipation,
    bioterms_1.Predicates.SBOL3.hasLocation,
    bioterms_1.Predicates.SBOL3.sourceLocation,
    bioterms_1.Predicates.SBOL3.hasInteraction,
    bioterms_1.Predicates.SBOL3.hasMeasure
];
function isOwnershipRelation(g, triple) {
    let p = nodeToURI(triple.predicate);
    if (ownershipPredicates.indexOf(p) !== -1) {
        return true;
    }
    // component is an ownership predicate unless used by SequenceAnnotation...
    //
    if (p === bioterms_1.Predicates.SBOL2.component) {
        let s = nodeToURI(triple.subject);
        if (g.hasMatch(s, bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.SequenceAnnotation))
            return false;
        return true;
    }
    if (p === bioterms_1.Predicates.SBOL1.subComponent) {
        let s = nodeToURI(triple.subject);
        if (g.hasMatch(s, bioterms_1.Predicates.a, bioterms_1.Types.SBOL1.SequenceAnnotation))
            return false;
        return true;
    }
    return false;
}
exports.default = isOwnershipRelation;
function nodeToURI(node) {
    if (node.interfaceName !== 'NamedNode')
        throw new Error('expected NamedNode but found ' + JSON.stringify(node));
    if (typeof node.nominalValue !== 'string')
        throw new Error('nominalValue not a string?');
    return node.nominalValue;
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol1/S1Collection.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol1/S1Collection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S1Facade_1 = __webpack_require__(/*! ./S1Facade */ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js");
const S1DnaComponent_1 = __webpack_require__(/*! ./S1DnaComponent */ "./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js");
class S1Collection extends S1Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL1.Collection;
    }
    get displayId() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
    }
    get name() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
    }
    get description() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.description);
    }
    get components() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL1.component)
            .map((uri) => new S1DnaComponent_1.default(this.view, uri));
    }
}
exports.default = S1Collection;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js":
/*!*************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S1Facade_1 = __webpack_require__(/*! ./S1Facade */ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js");
const S1SequenceAnnotation_1 = __webpack_require__(/*! ./S1SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol1/S1SequenceAnnotation.js");
const S1DnaSequence_1 = __webpack_require__(/*! ./S1DnaSequence */ "./node_modules/sbolgraph/dist/sbol1/S1DnaSequence.js");
class S1DnaComponent extends S1Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL1.DnaComponent;
    }
    get annotations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL1.annotation)
            .map((uri) => new S1SequenceAnnotation_1.default(this.view, uri));
    }
    get displayId() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.displayId);
    }
    get name() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
    }
    get description() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.description);
    }
    get dnaSequence() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL1.dnaSequence);
        if (uri) {
            return new S1DnaSequence_1.default(this.view, uri);
        }
    }
    get subComponents() {
        let scs = [];
        for (let anno of this.annotations) {
            let sc = anno.subComponent;
            if (sc && scs.indexOf(sc.uri) === -1) {
                scs.push(sc.uri);
            }
        }
        return scs.map(uri => new S1DnaComponent(this.view, uri));
    }
}
exports.default = S1DnaComponent;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol1/S1DnaSequence.js":
/*!************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol1/S1DnaSequence.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S1Facade_1 = __webpack_require__(/*! ./S1Facade */ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js");
class S1DnaSequence extends S1Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL1.DnaSequence;
    }
    get nucleotides() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.nucleotides);
    }
    get name() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.name);
    }
}
exports.default = S1DnaSequence;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol1/S1Facade.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SBOLFacade_1 = __webpack_require__(/*! ../SBOLFacade */ "./node_modules/sbolgraph/dist/SBOLFacade.js");
class S1Facade extends SBOLFacade_1.default {
    constructor(view, uri) {
        super(view.graph, view, uri);
        this.view = view;
    }
}
exports.default = S1Facade;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol1/S1SequenceAnnotation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol1/S1SequenceAnnotation.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S1Facade_1 = __webpack_require__(/*! ./S1Facade */ "./node_modules/sbolgraph/dist/sbol1/S1Facade.js");
const S1DnaComponent_1 = __webpack_require__(/*! ./S1DnaComponent */ "./node_modules/sbolgraph/dist/sbol1/S1DnaComponent.js");
class S1SequenceAnnotation extends S1Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL1.SequenceAnnotation;
    }
    get bioStart() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL1.bioStart);
    }
    get bioEnd() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL1.bioEnd);
    }
    get strand() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL1.strand);
    }
    get subComponent() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL1.subComponent);
        if (uri === undefined)
            return undefined;
        return new S1DnaComponent_1.default(this.view, uri);
    }
    get precedes() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL1.precedes)
            .map((uri) => new S1SequenceAnnotation(this.view, uri));
    }
}
exports.default = S1SequenceAnnotation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Attachment.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Attachment.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Attachment extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Attachment;
    }
    get source() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.source);
    }
    set source(source) {
        if (source)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.source, source);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.source);
    }
    get format() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.format);
    }
    set format(format) {
        if (format)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.format, format);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.format);
    }
    get size() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL2.size);
    }
    set size(size) {
        if (size)
            this.setIntProperty(bioterms_1.Predicates.SBOL2.size, size);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.size);
    }
    get hash() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL2.hash);
    }
    set hash(hash) {
        if (hash)
            this.setStringProperty(bioterms_1.Predicates.SBOL2.hash, hash);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.hash);
    }
}
exports.default = S2Attachment;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Collection.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Collection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Collection extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Collection;
    }
    get members() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.member)
            .map((uri) => this.view.uriToFacade(uri))
            .filter((r) => r !== undefined);
    }
    addMember(member) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.member, rdfoo_1.node.createUriNode(member.uri));
    }
    get containingObject() {
        return undefined;
    }
}
exports.default = S2Collection;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js":
/*!********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ComponentInstance_1 = __webpack_require__(/*! ./S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
const S2Sequence_1 = __webpack_require__(/*! ./S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ./S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2SequenceConstraint_1 = __webpack_require__(/*! ./S2SequenceConstraint */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js");
const S2Range_1 = __webpack_require__(/*! ./S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
class S2ComponentDefinition extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.ComponentDefinition;
    }
    get type() {
        const typeUri = this.getUriProperty(bioterms_1.Predicates.SBOL2.type);
        if (!typeUri)
            throw new Error(this.uri + ' has no type?');
        return typeUri;
    }
    get types() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.type);
    }
    set type(uri) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.type, uri);
    }
    addType(uri) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL2.type]: rdfoo_1.node.createUriNode(uri)
        });
    }
    get displayType() {
        for (let role of this.roles) {
            let name = bioterms_1.uriToName(role);
            if (name) {
                return name;
            }
        }
        return "Design";
    }
    get components() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.component)
            .map((uri) => new S2ComponentInstance_1.default(this.view, uri));
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
    }
    hasRole(role) {
        return this.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL2.role, role);
    }
    addRole(role) {
        this.graph.insert(this.uri, bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
    }
    removeRole(role) {
        this.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL2.role, role);
    }
    get sequences() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.sequence)
            .map((uri) => new S2Sequence_1.default(this.view, uri));
    }
    get sequenceAnnotations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.sequenceAnnotation)
            .map((uri) => new S2SequenceAnnotation_1.default(this.view, uri));
    }
    get sequenceConstraints() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.sequenceConstraint)
            .map((uri) => new S2SequenceConstraint_1.default(this.view, uri));
    }
    isPlasmidBackbone() {
        return this.hasRole(bioterms_1.Specifiers.SO.PlasmidBackbone);
    }
    static fromIdentified(identified) {
        const type = identified.objectType;
        if (type === bioterms_1.Types.SBOL2.ComponentDefinition) {
            return new S2ComponentDefinition(identified.view, identified.uri);
        }
        if (type === bioterms_1.Types.SBOL2.Component) {
            const def = identified.getUriProperty(bioterms_1.Predicates.SBOL2.definition);
            if (def === undefined)
                throw new Error('component instance with no def?');
            return new S2ComponentDefinition(identified.view, def);
        }
        throw new Error('cannot get component definition from ' + identified.uri);
    }
    get containingObject() {
        return undefined;
    }
    get containedObjects() {
        return [
            ...this.components,
            ...this.sequenceAnnotations,
            ...this.sequenceConstraints,
            ...this.sequences
        ];
    }
    addComponent(component) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.component, rdfoo_1.node.createUriNode(component.uri));
    }
    addComponentByDefinition(componentDefinition, id, name, version) {
        let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Component, this, bioterms_1.Predicates.SBOL2.component, id || componentDefinition.displayId || 'subcomponent', name, version || this.version);
        let component = new S2ComponentInstance_1.default(this.view, identified.uri);
        component.definition = componentDefinition;
        return component;
    }
    addSequenceAnnotationForComponent(componentInstance) {
        let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.SequenceAnnotation, this, bioterms_1.Predicates.SBOL2.sequenceAnnotation, componentInstance.displayId + '_sequenceAnnotation', undefined, this.version);
        let sequenceAnnotation = new S2SequenceAnnotation_1.default(this.view, identified.uri);
        sequenceAnnotation.component = componentInstance;
        return sequenceAnnotation;
    }
    createSequence() {
        const seq = this.view.createSequence(this.uriPrefix, this.displayName + '_sequence', this.version);
        this.addSequence(seq);
        return seq;
    }
    addSequence(sequence) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.sequence, rdfoo_1.node.createUriNode(sequence.uri));
    }
    annotateRange(start, end, name) {
        this.view.graph.startIgnoringWatchers();
        let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.SequenceAnnotation, this, bioterms_1.Predicates.SBOL2.sequenceAnnotation, 'anno_' + name, this.version);
        let sequenceAnnotation = new S2SequenceAnnotation_1.default(this.view, identified.uri);
        let rangeIdentified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Range, sequenceAnnotation, bioterms_1.Predicates.SBOL2.location, 'range', this.version);
        let range = new S2Range_1.default(this.view, rangeIdentified.uri);
        range.start = start;
        range.end = end;
        this.view.graph.stopIgnoringWatchers();
        return sequenceAnnotation;
    }
    destroy() {
        let instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map(uri => new S2ComponentInstance_1.default(this.view, uri));
        super.destroy();
        for (let instantiation of instantiations) {
            instantiation.destroy();
        }
    }
}
exports.default = S2ComponentDefinition;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js":
/*!******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ./S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ./S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2SequenceConstraint_1 = __webpack_require__(/*! ./S2SequenceConstraint */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2Location_1 = __webpack_require__(/*! ./S2Location */ "./node_modules/sbolgraph/dist/sbol2/S2Location.js");
class S2ComponentInstance extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
        this.access = bioterms_1.Specifiers.SBOL2.Access.PublicAccess;
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Component;
    }
    get displayName() {
        const name = this.name;
        if (name)
            return name;
        const def = this.definition;
        const defName = def.name;
        if (defName)
            return defName;
        return this.displayId || '';
    }
    get definition() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.definition);
        if (!uri) {
            throw new Error('Component ' + this.uri + ' has no definition');
        }
        return new S2ComponentDefinition_1.default(this.view, uri);
    }
    set definition(def) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.definition, def.uri);
    }
    get access() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.access);
    }
    set access(access) {
        if (access === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.access);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.access, access);
        }
    }
    get sequenceAnnotations() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.component, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .filter((uri) => this.view.getType(uri) === bioterms_1.Types.SBOL2.SequenceAnnotation)
            .map((uri) => new S2SequenceAnnotation_1.default(this.view, uri));
    }
    get sequenceConstraints() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.subject, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .filter((uri) => this.view.getType(uri) === bioterms_1.Types.SBOL2.SequenceConstraint)
            .map((uri) => new S2SequenceConstraint_1.default(this.view, uri));
    }
    hasRole(role) {
        return this.definition ? this.definition.hasRole(role) : false;
    }
    get containingComponentDefinition() {
        const uri = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.component, this.uri).map(rdfoo_1.triple.subjectUri).filter((s) => {
            return this.view.hasType(s, bioterms_1.Types.SBOL2.ComponentDefinition);
        })[0];
        if (uri === undefined) {
            throw new Error('component not contained by definition?');
        }
        return new S2ComponentDefinition_1.default(this.view, uri);
    }
    get containingObject() {
        return this.containingComponentDefinition;
    }
    isSequenceBound() {
        return this.sequenceAnnotations.length > 0 || this.sequenceConstraints.length > 0;
    }
    get displayDescription() {
        var desc = this.description;
        if (desc !== undefined)
            return desc;
        const def = this.definition;
        if (def !== undefined)
            return def.displayDescription;
        return undefined;
    }
    get sourceLocation() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.sourceLocation);
        if (uri === undefined)
            return undefined;
        let obj = this.view.uriToFacade(uri);
        if (!(obj instanceof S2Location_1.default)) {
            throw new Error('sourceLocation was not a location');
        }
        return obj;
    }
    set sourceLocation(location) {
        if (location !== undefined)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.sourceLocation, location.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sourceLocation);
    }
}
exports.default = S2ComponentInstance;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Cut.js":
/*!****************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Cut.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2OrientedLocation_1 = __webpack_require__(/*! ./S2OrientedLocation */ "./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Cut extends S2OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.GenericLocation;
    }
    get at() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL2.at);
    }
    set at(at) {
        if (at) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.at, at);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.at);
        }
    }
}
exports.default = S2Cut;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Experiment.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Experiment.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const S2ExperimentalData_1 = __webpack_require__(/*! ./S2ExperimentalData */ "./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2Implementation_1 = __webpack_require__(/*! ./S2Implementation */ "./node_modules/sbolgraph/dist/sbol2/S2Implementation.js");
class S2Experiment extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Experiment;
    }
    get experimentalData() {
        let result = [];
        let expDataURIs = this.getUriProperties(bioterms_1.Predicates.SBOL2.experimentalData);
        for (let uri of expDataURIs) {
            result.push(new S2ExperimentalData_1.default(this.view, uri));
        }
        return result;
        // return this.getUriProperties('https://github.com/SynBioDex/SEPs/blob/sep21/sep_021.md#experimentalData')
        //            .map((uri:string) => this.view.uriToFacade(uri))
        //            .filter((r:SEP21ExperimentalData) => r !== undefined) as Array<SEP21ExperimentalData>
    }
    addExperimentalData(member) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.experimentalData, rdfoo_1.node.createUriNode(member.uri));
    }
    get activity() {
        let activity = this.getUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        if (!activity) {
            return undefined;
        }
        return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
    }
    set activity(activity) {
        if (activity === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.uri);
        }
    }
    get construct() {
        let construct_uri = this.getUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        if (!construct_uri) {
            return undefined;
        }
        return new S2Implementation_1.default(this.view, construct_uri);
    }
    // set construct(construct:S2Implementation|undefined) {
    //     if(construct === undefined) {
    //         this.deleteProperty(Predicates.Prov.wasDerivedFrom)
    //     } else {
    //         this.setUriProperty(Predicates.Prov.wasDerivedFrom, construct.uri)
    //     }
    // }
    addConstruct(construct) {
        this.insertProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, rdfoo_1.node.createUriNode(construct.uri));
    }
    get displayType() {
        return "Experiment";
    }
}
exports.default = S2Experiment;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2ExperimentalData.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2ExperimentalData extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.ExperimentalData;
    }
}
exports.default = S2ExperimentalData;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Facade.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Facade.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SBOLFacade_1 = __webpack_require__(/*! ../SBOLFacade */ "./node_modules/sbolgraph/dist/SBOLFacade.js");
class S2Facade extends SBOLFacade_1.default {
    constructor(view, uri) {
        super(view.graph, view, uri);
        this.view = view;
    }
}
exports.default = S2Facade;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js":
/*!********************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ./S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S2ModuleDefinition_1 = __webpack_require__(/*! ./S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
const S2MapsTo_1 = __webpack_require__(/*! ./S2MapsTo */ "./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js");
const S2Participation_1 = __webpack_require__(/*! ./S2Participation */ "./node_modules/sbolgraph/dist/sbol2/S2Participation.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2Measure_1 = __webpack_require__(/*! ./S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");
class S2FunctionalComponent extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
        this.direction = bioterms_1.Specifiers.SBOL2.Direction.InputAndOutput;
        this.access = bioterms_1.Specifiers.SBOL2.Access.PublicAccess;
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.FunctionalComponent;
    }
    get access() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.access);
    }
    set access(access) {
        if (access === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.access);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.access, access);
        }
    }
    get direction() {
        return this.getUriProperty(bioterms_1.Prefixes.sbol2 + 'direction');
    }
    set direction(direction) {
        if (direction === undefined) {
            this.deleteProperty(bioterms_1.Prefixes.sbol2 + 'direction');
        }
        else {
            this.setUriProperty(bioterms_1.Prefixes.sbol2 + 'direction', direction);
        }
    }
    get displayName() {
        const name = this.name;
        if (name)
            return name;
        const def = this.definition;
        const defName = def.name;
        if (defName)
            return defName;
        return this.displayId || '';
    }
    get definition() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.definition);
        if (!uri) {
            throw new Error('fc ' + this.uri + ' has no def?');
        }
        return new S2ComponentDefinition_1.default(this.view, uri);
    }
    set definition(definition) {
        this.setUriProperty(bioterms_1.Prefixes.sbol2 + 'definition', definition.uri);
    }
    get mappings() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.local, this.uri).map(rdfoo_1.triple.subjectUri)
            .concat(this.view.graph.match(null, bioterms_1.Predicates.SBOL2.remote, this.uri).map(rdfoo_1.triple.subjectUri))
            .filter((el) => !!el)
            .map((mapsToUri) => new S2MapsTo_1.default(this.view, mapsToUri));
    }
    createMapping(local, remote, refinement) {
        let id = local.displayId + '_mapsto_' + remote.displayId;
        let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.MapsTo, this, id, id, this.version);
        let mapsTo = new S2MapsTo_1.default(this.view, identified.uri);
        mapsTo.local = local;
        mapsTo.remote = remote;
        mapsTo.refinement = refinement;
        return mapsTo;
    }
    get containingModuleDefinition() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.functionalComponent, this.uri));
        if (!uri) {
            throw new Error('FC ' + this.uri + ' not contained by a MD?');
        }
        return new S2ModuleDefinition_1.default(this.view, uri);
    }
    get participations() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.participant, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => uri ? new S2Participation_1.default(this.view, uri) : undefined)
            .filter((el) => !!el);
    }
    get interactions() {
        return this.participations.map((participation) => participation.interaction).filter((el) => !!el);
    }
    get containingObject() {
        return this.containingModuleDefinition;
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
        if (measure === undefined)
            return;
        return new S2Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure.uri);
    }
}
exports.default = S2FunctionalComponent;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js":
/*!****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2OrientedLocation_1 = __webpack_require__(/*! ./S2OrientedLocation */ "./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2GenericLocation extends S2OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.GenericLocation;
    }
}
exports.default = S2GenericLocation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Identified.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const URIUtils_1 = __webpack_require__(/*! ../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
const S2Facade_1 = __webpack_require__(/*! ./S2Facade */ "./node_modules/sbolgraph/dist/sbol2/S2Facade.js");
class S2Identified extends S2Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        throw new Error('base called');
    }
    get name() {
        return this.getStringProperty(bioterms_1.Predicates.Dcterms.title);
    }
    get displayName() {
        return this.name || this.displayId;
    }
    get displayType() {
        return this.objectType || 'unknown';
    }
    set name(name) {
        this.setStringProperty(bioterms_1.Predicates.Dcterms.title, name);
    }
    get description() {
        return this.getStringProperty(bioterms_1.Predicates.Dcterms.description);
    }
    set description(desc) {
        this.setStringProperty(bioterms_1.Predicates.Dcterms.description, desc);
    }
    get displayDescription() {
        return this.description;
    }
    get displayId() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL2.displayId);
    }
    set displayId(displayId) {
        this.setStringProperty(bioterms_1.Predicates.SBOL2.displayId, displayId);
    }
    set displayType(type) {
        this.setUriProperty(bioterms_1.Predicates.a, type);
    }
    get version() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL2.version);
    }
    set version(version) {
        this.setStringProperty(bioterms_1.Predicates.SBOL2.version, version);
    }
    get persistentIdentity() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity);
    }
    set persistentIdentity(uri) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.persistentIdentity, uri);
    }
    get uriPrefix() {
        return URIUtils_1.default.getPrefix(this.uri);
    }
    get attachments() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.attachment)
            .map((attachment) => new S2Attachment_1.default(this.view, attachment));
    }
    get measures() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.measure)
            .map((measure) => new S2Measure_1.default(this.view, measure));
    }
    get containingObject() {
        return undefined;
    }
    get containedObjects() {
        return [];
    }
    get containingCollections() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.member, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S2Collection_1.default(this.view, uri));
    }
    get uriChain() {
        const containingObject = this.containingObject;
        if (containingObject !== undefined) {
            return containingObject.uriChain + ';' + this.uri;
        }
        else {
            return this.uri;
        }
    }
    isSiblingOf(other) {
        let ourContainer = this.containingObject;
        let theirContainer = other.containingObject;
        if (!ourContainer) {
            if (!theirContainer) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (theirContainer && theirContainer.uri === ourContainer.uri) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    getSiblings() {
        let ourContainer = this.containingObject;
        if (!ourContainer) {
            return [];
        }
        let containedObjects = ourContainer.containedObjects;
        // remove us from the list
        //
        for (let i = 0; i < containedObjects.length; ++i) {
            if (containedObjects[i].uri === this.uri) {
                containedObjects.splice(i, 1);
                break;
            }
        }
        return containedObjects;
    }
}
exports.default = S2Identified;
const S2Attachment_1 = __webpack_require__(/*! ./S2Attachment */ "./node_modules/sbolgraph/dist/sbol2/S2Attachment.js");
const S2Collection_1 = __webpack_require__(/*! ./S2Collection */ "./node_modules/sbolgraph/dist/sbol2/S2Collection.js");
const S2Measure_1 = __webpack_require__(/*! ./S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
class S3IdentifiedFactory {
    static createTopLevel(view, type, uriPrefix, id, name, version) {
        id = id ? nameToID(id) : 'anon';
        let versionSuffix = version !== undefined ? '/' + version : '';
        const uri = view.graph.generateURI(uriPrefix + id + '$n?$' + versionSuffix);
        view.graph.insertProperties(uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(id),
            [bioterms_1.Predicates.SBOL2.persistentIdentity]: rdfoo_1.node.createUriNode(extractPersistentIdentity(uri, version)),
        });
        if (version !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(version)
            });
        }
        if (name !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
        }
        return new S2Identified_1.default(view, uri);
    }
    static createChild(view, type, parent, ownershipPredicate, id, name, version) {
        id = id ? nameToID(id) : 'anon';
        let versionSuffix = version !== undefined ? '/' + version : '';
        const uri = view.graph.generateURI(parent.persistentIdentity + '/' + id + '$n?$' + versionSuffix);
        view.graph.insertProperties(uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(id),
            [bioterms_1.Predicates.SBOL2.persistentIdentity]: rdfoo_1.node.createUriNode(extractPersistentIdentity(uri, version))
        });
        if (version !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(version)
            });
        }
        if (name !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
        }
        view.graph.insertProperties(parent.uri, {
            [ownershipPredicate]: rdfoo_1.node.createUriNode(uri)
        });
        return new S2Identified_1.default(view, uri);
    }
}
exports.default = S3IdentifiedFactory;
function nameToID(name) {
    // TODO
    return name.replace(/\s/, '_');
}
function extractPersistentIdentity(uri, version) {
    if (version !== undefined) {
        return uri.substr(0, uri.length - version.length - 1);
    }
    else {
        return uri;
    }
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Implementation.js":
/*!***************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Implementation.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/sbolgraph/dist/index.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
class S2Implementation extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Implementation;
    }
    get built() {
        let built = this.getUriProperty(bioterms_1.Predicates.SBOL2.built);
        if (!built) {
            return undefined;
        }
        let builtObj = this.view.uriToFacade(built);
        if (builtObj instanceof __1.S2ComponentDefinition)
            return builtObj;
        if (builtObj instanceof __1.S2ModuleDefinition)
            return builtObj;
        throw new Error('built has wrong type');
    }
    set built(built) {
        if (built === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.built);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.built, built.uri);
        }
    }
    get activity() {
        let activity = this.getUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        if (!activity) {
            return undefined;
        }
        return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
    }
    set activity(activity) {
        if (activity === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.uri);
        }
    }
    get design() {
        let design_uri = this.getUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        if (!design_uri) {
            return undefined;
        }
        return new S2Identified_1.default(this.view, design_uri);
        // console.log(this.view.getTopLevelsWithPrefix(design_uri))
        // let design = this.view.uriToFacade(design_uri)
        // console.log(design)
        // if(design instanceof S2ComponentDefinition)
        //     return design as S2ComponentDefinition
        // if (design instanceof S2ModuleDefinition)
        //     return design as S2ModuleDefinition
        // throw new Error('design has wrong type')
    }
    set design(design) {
        if (design === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, design.uri);
        }
    }
    get displayType() {
        return "Construct";
    }
}
exports.default = S2Implementation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Interaction.js":
/*!************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Interaction.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2Participation_1 = __webpack_require__(/*! ./S2Participation */ "./node_modules/sbolgraph/dist/sbol2/S2Participation.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2Measure_1 = __webpack_require__(/*! ./S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");
const S2ModuleDefinition_1 = __webpack_require__(/*! ./S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
class S2Interaction extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Interaction;
    }
    get type() {
        const typeUri = this.getUriProperty(bioterms_1.Predicates.SBOL2.type);
        if (!typeUri)
            throw new Error(this.uri + ' has no type?');
        return typeUri;
    }
    get types() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.type);
    }
    set type(uri) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.type, uri);
    }
    hasType(type) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL2.type, type);
    }
    get participations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.participation)
            .map((uri) => new S2Participation_1.default(this.view, uri));
    }
    get participants() {
        const participants = this.participations.map((participation) => participation.participant);
        return participants.filter((el) => !!el);
    }
    get containingModuleDefinition() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.interaction, this.uri));
        if (!uri) {
            throw new Error('Interaction ' + this.uri + ' not contained by a MD?');
        }
        return new S2ModuleDefinition_1.default(this.view, uri);
    }
    get containingObject() {
        return this.containingModuleDefinition;
    }
    addParticipation(participation) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL2.participation]: rdfoo_1.node.createUriNode(participation.uri)
        });
    }
    createParticipation(id, version) {
        const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Participation, this, bioterms_1.Predicates.SBOL2.participation, id, undefined, version);
        const participation = new S2Participation_1.default(this.view, identified.uri);
        return participation;
    }
    createParticipationWithParticipantAndRole(id, participant, role, version) {
        let participation = this.createParticipation(id, version);
        participation.addRole(role);
        participation.setParticipant(participant);
        return participation;
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
        if (measure === undefined)
            return;
        return new S2Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure.uri);
    }
}
exports.default = S2Interaction;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Location.js":
/*!*********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Location.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2SequenceAnnotation_1 = __webpack_require__(/*! ./S2SequenceAnnotation */ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js");
const S2Sequence_1 = __webpack_require__(/*! ./S2Sequence */ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js");
class S2Location extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.location, this.uri));
        if (!uri) {
            throw new Error('Location has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get containingSequenceAnnotation() {
        const containingObject = this.containingObject;
        if (!(containingObject instanceof S2SequenceAnnotation_1.default)) {
            throw new Error('???');
        }
        return containingObject;
    }
    get containingComponentInstance() {
        return this.containingSequenceAnnotation.component;
    }
    get containingComponentDefinition() {
        return this.containingSequenceAnnotation.containingComponentDefinition;
    }
    isFixed() {
        return this.facadeType === bioterms_1.Types.SBOL2.Range; // TODO || this.facadeType === Types.SBOL2.Cut
    }
    get sequence() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.sequence);
        if (uri === undefined)
            return undefined;
        let obj = this.view.uriToFacade(uri);
        if (!(obj instanceof S2Sequence_1.default)) {
            throw new Error('sequence was not a sequence');
        }
        return obj;
    }
    set sequence(sequence) {
        if (sequence !== undefined)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.sequence, sequence.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sequence);
    }
}
exports.default = S2Location;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
class S2MapsTo extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.MapsTo;
    }
    get local() {
        const localUri = this.getUriProperty(bioterms_1.Predicates.SBOL2.local);
        if (localUri === undefined)
            return undefined;
        return this.view.uriToIdentified(localUri);
    }
    set local(local) {
        if (local)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.local, local.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.local);
    }
    get remote() {
        const remoteUri = this.getUriProperty(bioterms_1.Predicates.SBOL2.remote);
        if (remoteUri === undefined)
            return undefined;
        return this.view.uriToIdentified(remoteUri);
    }
    set remote(remote) {
        if (remote)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.remote, remote.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.remote);
    }
    set refinement(refinement) {
        if (refinement)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.refinement, refinement);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.refinement);
    }
    get refinement() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.refinement);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.mapsTo, this.uri));
        if (!uri) {
            throw new Error('MapsTo has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
}
exports.default = S2MapsTo;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js":
/*!********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Measure.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Measure extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Measure.Measure;
    }
    get value() {
        return this.getFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
    }
    set value(v) {
        if (v === undefined)
            this.deleteProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
        else
            this.setFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue, v);
    }
    get unit() {
        return this.getUriProperty(bioterms_1.Predicates.Measure.hasUnit);
    }
    set unit(unit) {
        this.setUriProperty(bioterms_1.Predicates.Measure.hasUnit, unit);
    }
}
exports.default = S2Measure;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Model.js":
/*!******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Model.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Model extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Model;
    }
    get framework() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.framework);
    }
    set framework(framework) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.framework, framework);
    }
    get language() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.language);
    }
    set language(language) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.language, language);
    }
    get source() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.source);
    }
    set source(source) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.source, source);
    }
}
exports.default = S2Model;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ModuleInstance_1 = __webpack_require__(/*! ./S2ModuleInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js");
const S2FunctionalComponent_1 = __webpack_require__(/*! ./S2FunctionalComponent */ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js");
const S2Interaction_1 = __webpack_require__(/*! ./S2Interaction */ "./node_modules/sbolgraph/dist/sbol2/S2Interaction.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ../sbol2/S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2Model_1 = __webpack_require__(/*! ./S2Model */ "./node_modules/sbolgraph/dist/sbol2/S2Model.js");
class S2ModuleDefinition extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.ModuleDefinition;
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
    }
    hasRole(role) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL2.role, role);
    }
    addRole(role) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
    }
    removeRole(role) {
        this.view.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL2.role, role);
    }
    get containedObjects() {
        return this.modules
            .concat(this.functionalComponents)
            .concat(this.interactions)
            .concat(this.models);
    }
    get modules() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.module)
            .map((uri) => new S2ModuleInstance_1.default(this.view, uri));
    }
    get functionalComponents() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.functionalComponent)
            .map((uri) => new S2FunctionalComponent_1.default(this.view, uri));
    }
    get interactions() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.interaction)
            .map((uri) => new S2Interaction_1.default(this.view, uri));
    }
    get models() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.model)
            .map((uri) => new S2Model_1.default(this.view, uri));
    }
    get containingObject() {
        return undefined;
    }
    addInteraction(interaction) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL2.interaction]: rdfoo_1.node.createUriNode(interaction.uri)
        });
    }
    addFunctionalComponent(fc) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL2.functionalComponent]: rdfoo_1.node.createUriNode(fc.uri)
        });
    }
    createInteraction(id, version) {
        const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Interaction, this, bioterms_1.Predicates.SBOL2.interaction, id, undefined, version);
        const interaction = new S2Interaction_1.default(this.view, identified.uri);
        return interaction;
    }
    createFunctionalComponent(definition, id, name, version) {
        let actualId = id || definition.displayId || undefined;
        const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.FunctionalComponent, this, bioterms_1.Predicates.SBOL2.functionalComponent, actualId, name, version || this.version);
        const fc = new S2FunctionalComponent_1.default(this.view, identified.uri);
        fc.definition = definition;
        return fc;
    }
    createSubModule(definition, id, name, version) {
        let actualId = id || definition.displayId || undefined;
        const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.Module, this, bioterms_1.Predicates.SBOL2.module, actualId, name, version || this.version);
        const m = new S2ModuleInstance_1.default(this.view, identified.uri);
        m.definition = definition;
        return m;
    }
    get displayType() {
        for (let role of this.roles) {
            let name = bioterms_1.uriToName(role);
            if (name) {
                return name;
            }
        }
        return "Design";
    }
    destroy() {
        let instantiations = this.graph.match(null, bioterms_1.Predicates.SBOL2.definition, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map(uri => new S2ModuleInstance_1.default(this.view, uri));
        super.destroy();
        for (let instantiation of instantiations) {
            instantiation.destroy();
        }
    }
}
exports.default = S2ModuleDefinition;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js":
/*!***************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2ModuleInstance.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ModuleDefinition_1 = __webpack_require__(/*! ./S2ModuleDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ModuleDefinition.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2MapsTo_1 = __webpack_require__(/*! ./S2MapsTo */ "./node_modules/sbolgraph/dist/sbol2/S2MapsTo.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2Measure_1 = __webpack_require__(/*! ./S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");
class S2ModuleInstance extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Module;
    }
    get definition() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.definition);
        if (uri === undefined) {
            throw new Error('module has no definition?');
        }
        return new S2ModuleDefinition_1.default(this.view, uri);
    }
    set definition(def) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.definition, def.uri);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.module, this.uri));
        if (!uri) {
            throw new Error('ModuleInstance has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get mappings() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.mapsTo).map((mapsTo) => new S2MapsTo_1.default(this.view, mapsTo));
    }
    createMapping(local, remote) {
        const identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.MapsTo, this, bioterms_1.Predicates.SBOL2.mapsTo, 'mapping_' + local.displayId + '_' + remote.displayId, undefined, this.version);
        const mapping = new S2MapsTo_1.default(this.view, identified.uri);
        mapping.local = local;
        mapping.remote = remote;
        return mapping;
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
        if (measure === undefined)
            return;
        return new S2Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure.uri);
    }
}
exports.default = S2ModuleInstance;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2Location_1 = __webpack_require__(/*! ./S2Location */ "./node_modules/sbolgraph/dist/sbol2/S2Location.js");
class S2OrientedLocation extends S2Location_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get orientation() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.orientation);
    }
    set orientation(orientation) {
        if (orientation)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.orientation, orientation);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.orientation);
    }
}
exports.default = S2OrientedLocation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Participation.js":
/*!**************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Participation.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2FunctionalComponent_1 = __webpack_require__(/*! ./S2FunctionalComponent */ "./node_modules/sbolgraph/dist/sbol2/S2FunctionalComponent.js");
const S2Interaction_1 = __webpack_require__(/*! ./S2Interaction */ "./node_modules/sbolgraph/dist/sbol2/S2Interaction.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2Measure_1 = __webpack_require__(/*! ./S2Measure */ "./node_modules/sbolgraph/dist/sbol2/S2Measure.js");
class S2Participation extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Participation;
    }
    get participant() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.participant);
        if (uri) {
            return new S2FunctionalComponent_1.default(this.view, uri);
        }
    }
    set participant(participant) {
        if (participant !== undefined) {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.participant, participant.uri);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.participant);
        }
    }
    get interaction() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.participation, this.uri));
        if (uri) {
            return new S2Interaction_1.default(this.view, uri);
        }
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.participation, this.uri));
        if (!uri) {
            throw new Error('Participation has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    hasRole(uri) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL2.role, uri);
    }
    addRole(role) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
    }
    setParticipant(participant) {
        this.setUriProperty(bioterms_1.Predicates.SBOL2.participant, participant.uri);
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL2.measure);
        if (measure === undefined)
            return;
        return new S2Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL2.measure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL2.measure, measure.uri);
    }
}
exports.default = S2Participation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Range.js":
/*!******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Range.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2OrientedLocation_1 = __webpack_require__(/*! ./S2OrientedLocation */ "./node_modules/sbolgraph/dist/sbol2/S2OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2Range extends S2OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Range;
    }
    get start() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL2.start);
    }
    set start(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.start, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.start);
        }
    }
    get end() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL2.end);
    }
    set end(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL2.end, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.end);
        }
    }
}
exports.default = S2Range;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2Sequence.js":
/*!*********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2Sequence.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ../sbol2/S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
const S2Range_1 = __webpack_require__(/*! ../sbol2/S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
class S2Sequence extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Sequence;
    }
    get displayType() {
        switch (this.encoding) {
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid:
                return 'Amino Acid Sequence';
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid:
            case bioterms_1.Specifiers.SBOL2.SequenceEncoding.RNA:
                return 'Nucleic Acid Sequence';
            default:
                return 'Sequence';
        }
    }
    get elements() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL2.elements);
    }
    set elements(elements) {
        if (elements === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.elements);
        }
        else {
            this.setStringProperty(bioterms_1.Predicates.SBOL2.elements, elements);
        }
    }
    // Updates any SAs that use this sequence
    //
    insertFragment(pos, fragment) {
        const elements = this.elements;
        if (elements === undefined)
            throw new Error('???');
        if (pos < 0 || pos >= elements.length)
            return;
        const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.sequence, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S2ComponentDefinition_1.default(this.view, uri));
        containingCDs.forEach((cd) => {
            cd.sequenceAnnotations.forEach((sa) => {
                sa.locations.forEach((location) => {
                    if (location instanceof S2Range_1.default) {
                        const range = location;
                        const start = range.start;
                        const end = range.end;
                        if (start === undefined || end === undefined)
                            throw new Error('???');
                        if (pos >= start && pos <= end) {
                            range.end = end + fragment.length;
                        }
                        else if (pos < start) {
                            range.start = start + fragment.length;
                            range.end = end + fragment.length;
                        }
                    }
                });
            });
        });
        const slices = [
            elements.substring(0, pos),
            fragment,
            elements.substring(pos)
        ];
        this.elements = slices.join('');
    }
    // Updates any SAs that use this sequence
    //
    deleteFragment(pos, n) {
        const elements = this.elements;
        if (elements === undefined)
            throw new Error('???');
        if (pos < 0 || pos >= elements.length)
            return;
        const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL2.sequence, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S2ComponentDefinition_1.default(this.view, uri));
        containingCDs.forEach((cd) => {
            cd.sequenceAnnotations.forEach((sa) => {
                sa.locations.forEach((location) => {
                    if (location instanceof S2Range_1.default) {
                        const range = location;
                        const start = range.start;
                        const end = range.end;
                        if (start === undefined || end === undefined)
                            throw new Error('???');
                        if (pos >= start && pos <= end) {
                            range.end = end - n;
                        }
                        else if (pos < start) {
                            range.start = start - n;
                            range.end = end - n;
                        }
                    }
                });
            });
        });
        const slices = [
            elements.substring(0, pos),
            elements.substring(pos + n)
        ];
        this.elements = slices.join('');
    }
    get encoding() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL2.encoding);
    }
    set encoding(encoding) {
        if (encoding === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.encoding);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.encoding, encoding);
        }
    }
    get containingObject() {
        return undefined;
    }
}
exports.default = S2Sequence;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2SequenceAnnotation.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ComponentInstance_1 = __webpack_require__(/*! ./S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
const S2Range_1 = __webpack_require__(/*! ./S2Range */ "./node_modules/sbolgraph/dist/sbol2/S2Range.js");
const S2GenericLocation_1 = __webpack_require__(/*! ./S2GenericLocation */ "./node_modules/sbolgraph/dist/sbol2/S2GenericLocation.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S2IdentifiedFactory_1 = __webpack_require__(/*! ./S2IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol2/S2IdentifiedFactory.js");
const S2ComponentDefinition_1 = __webpack_require__(/*! ./S2ComponentDefinition */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentDefinition.js");
class S2SequenceAnnotation extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.SequenceAnnotation;
    }
    get locations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.location)
            .map((uri) => this.view.uriToFacade(uri));
    }
    get rangeLocations() {
        return this.locations.filter((location) => {
            return location.objectType === bioterms_1.Types.SBOL2.Range;
        }).map((identified) => {
            return new S2Range_1.default(this.view, identified.uri);
        });
    }
    get rangeMin() {
        var n = Number.MAX_VALUE;
        this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== undefined && start < n)
                n = start;
            if (end !== undefined && end < n)
                n = end;
        });
        return n === Number.MAX_VALUE ? null : n;
    }
    get rangeMax() {
        var n = Number.MIN_VALUE;
        this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== undefined && start > n)
                n = start;
            if (end !== undefined && end > n)
                n = end;
        });
        return n === Number.MIN_VALUE ? null : n;
    }
    hasFixedLocation() {
        const locations = this.locations;
        for (var i = 0; i < locations.length; ++i) {
            if (locations[i].isFixed())
                return true;
        }
        return false;
    }
    get containingComponentDefinition() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceAnnotation, this.uri));
        if (uri === undefined) {
            throw new Error('SA not contained by a CD??');
        }
        return new S2ComponentDefinition_1.default(this.view, uri);
    }
    get component() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL2.component);
        if (uri)
            return new S2ComponentInstance_1.default(this.view, uri);
    }
    set component(component) {
        if (component !== undefined) {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.component, component.uri);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.component);
        }
    }
    get displayName() {
        const component = this.component;
        if (component) {
            const componentDisplayName = component.displayName;
            if (componentDisplayName)
                return componentDisplayName;
        }
        return this.name || this.displayId || '';
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.role);
    }
    hasRole(role) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL2.role, role);
    }
    addRole(role) {
        this.insertProperty(bioterms_1.Predicates.SBOL2.role, rdfoo_1.node.createUriNode(role));
    }
    static fromIdentified(identified) {
        const type = identified.objectType;
        if (type === bioterms_1.Types.SBOL2.SequenceAnnotation)
            return new S2SequenceAnnotation(identified.view, identified.uri);
        if (type === bioterms_1.Types.SBOL2.Component) {
            const sa = (new S2ComponentInstance_1.default(identified.view, identified.uri)).sequenceAnnotations[0];
            if (sa === undefined) {
                throw new Error('cannot get sequence annotation from ' + identified.uri);
            }
            return sa;
        }
        throw new Error('cannot get sequence annotation from ' + identified.uri);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceAnnotation, this.uri));
        if (!uri) {
            throw new Error('SA has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    clearLocations() {
        this.locations.forEach((location) => {
            this.view.graph.purgeSubject(location.uri);
        });
    }
    addLocationGeneric(orientation) {
        let identified = S2IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.GenericLocation, this, bioterms_1.Predicates.SBOL2.location, 'location', this.version);
        let location = new S2GenericLocation_1.default(this.view, identified.uri);
        location.orientation = orientation;
        return location;
    }
    setLocationGeneric(orientation) {
        this.clearLocations();
        this.addLocationGeneric(orientation);
    }
    get allRoles() {
        const rolesHere = this.roles;
        const component = this.component;
        if (component && component.definition) {
            return rolesHere.concat(component.definition.roles);
        }
        else {
            return rolesHere;
        }
    }
    get displayDescription() {
        var desc = this.description;
        if (desc !== undefined)
            return desc;
        const c = this.component;
        if (c !== undefined)
            return c.displayDescription;
        return undefined;
    }
    get containedObjects() {
        return this.locations;
    }
}
exports.default = S2SequenceAnnotation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol2/S2SequenceConstraint.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S2Identified_1 = __webpack_require__(/*! ./S2Identified */ "./node_modules/sbolgraph/dist/sbol2/S2Identified.js");
const S2ComponentInstance_1 = __webpack_require__(/*! ./S2ComponentInstance */ "./node_modules/sbolgraph/dist/sbol2/S2ComponentInstance.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S2SequenceConstraint extends S2Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.SequenceConstraint;
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL2.sequenceConstraint, this.uri));
        if (!uri) {
            throw new Error('SeqCons has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get restriction() {
        const restriction = this.getUriProperty(bioterms_1.Predicates.SBOL2.restriction);
        if (restriction === undefined) {
            throw new Error('SeqCons has no restriction?');
        }
        return restriction;
    }
    get subject() {
        const subject = this.getUriProperty(bioterms_1.Predicates.SBOL2.subject);
        if (subject === undefined) {
            throw new Error('SeqCons has no subject?');
        }
        return new S2ComponentInstance_1.default(this.view, subject);
    }
    get object() {
        const object = this.getUriProperty(bioterms_1.Predicates.SBOL2.object);
        if (object === undefined) {
            throw new Error('SeqCons has no object?');
        }
        return new S2ComponentInstance_1.default(this.view, object);
    }
}
exports.default = S2SequenceConstraint;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Attachment.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Attachment.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Attachment extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Attachment;
    }
    get source() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.source);
    }
    set source(source) {
        if (source)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.source, source);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.source);
    }
    get format() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.format);
    }
    set format(format) {
        if (format)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.format, format);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.format);
    }
    get size() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL3.size);
    }
    set size(size) {
        if (size)
            this.setIntProperty(bioterms_1.Predicates.SBOL3.size, size);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.size);
    }
    get hash() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL3.hash);
    }
    set hash(hash) {
        if (hash)
            this.setStringProperty(bioterms_1.Predicates.SBOL3.hash, hash);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hash);
    }
}
exports.default = S3Attachment;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Collection.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Collection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Collection extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Collection;
    }
    get members() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.member)
            .map((uri) => this.view.uriToFacade(uri))
            .filter((r) => r !== undefined);
    }
    addMember(member) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL3.member]: rdfoo_1.node.createUriNode(member.uri)
        });
    }
}
exports.default = S3Collection;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Component.js":
/*!**********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Component.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3SubComponent_1 = __webpack_require__(/*! ./S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
const S3Interaction_1 = __webpack_require__(/*! ./S3Interaction */ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Sequence_1 = __webpack_require__(/*! ./S3Sequence */ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js");
const S3Constraint_1 = __webpack_require__(/*! ./S3Constraint */ "./node_modules/sbolgraph/dist/sbol3/S3Constraint.js");
const S3SequenceFeature_1 = __webpack_require__(/*! ./S3SequenceFeature */ "./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js");
const S3IdentifiedFactory_1 = __webpack_require__(/*! ./S3IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js");
const extractTerm_1 = __webpack_require__(/*! ../extractTerm */ "./node_modules/sbolgraph/dist/extractTerm.js");
class S3Component extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Component;
    }
    get types() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
    }
    hasType(type) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL3.type, type);
    }
    addType(type) {
        this.view.graph.insert(this.uri, bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
    }
    removeType(type) {
        this.view.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL3.type, type);
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
    }
    hasRole(role) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL3.role, role);
    }
    addRole(role) {
        this.view.graph.insert(this.uri, bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
    }
    removeRole(role) {
        this.view.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL3.role, role);
    }
    get soTerms() {
        let terms = [];
        for (let role of this.roles) {
            let term = extractTerm_1.default(role);
            if (term)
                terms.push(term);
        }
        return terms;
    }
    get sequences() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasSequence)
            .map((uri) => new S3Sequence_1.default(this.view, uri));
    }
    get subComponents() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasFeature)
            .filter((uri) => this.graph.hasMatch(uri, bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SubComponent))
            .map((uri) => new S3SubComponent_1.default(this.view, uri));
    }
    get interactions() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasInteraction)
            .map((uri) => new S3Interaction_1.default(this.view, uri));
    }
    get containingObject() {
        return undefined;
    }
    get sequenceConstraints() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasConstraint)
            .map((uri) => new S3Constraint_1.default(this.view, uri));
    }
    get sequenceFeatures() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasFeature)
            .filter((uri) => this.graph.hasMatch(uri, bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.SequenceFeature))
            .map((uri) => new S3SequenceFeature_1.default(this.view, uri));
    }
    get containedObjects() {
        return this.subComponents
            .concat(this.interactions)
            .concat(this.sequenceConstraints)
            .concat(this.sequenceFeatures);
    }
    get annotatedLocations() {
        const all = [];
        this.subComponents.forEach((sc) => {
            Array.prototype.push.apply(all, sc.locations);
        });
        this.sequenceFeatures.forEach((f) => {
            Array.prototype.push.apply(all, f.locations);
        });
        return all;
    }
    get thingsWithLocations() {
        return this.subComponents
            .concat(this.sequenceFeatures);
    }
    isPlasmidBackbone() {
        return this.hasRole(bioterms_1.Specifiers.SO.PlasmidBackbone);
    }
    createSubComponent(definition) {
        const id = definition.displayId;
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.SubComponent, this, bioterms_1.Predicates.SBOL3.hasFeature, id, undefined);
        const module = new S3SubComponent_1.default(this.view, identified.uri);
        module.instanceOf = definition;
        return module;
    }
    createFeature(name) {
        const id = 'feature_' + name;
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.SequenceFeature, this, bioterms_1.Predicates.SBOL3.hasFeature, id, undefined);
        return new S3SequenceFeature_1.default(this.view, identified.uri);
    }
    createFeatureWithRange(start, end, name) {
        const feature = this.createFeature(name);
        feature.addRange(start, end);
        return feature;
    }
    wrap(wrapperId) {
        const wrapper = this.view.createComponent(this.uriPrefix, wrapperId || (this.displayName + '_wrapper'));
        for (let type of this.types) {
            wrapper.addType(type);
        }
        wrapper.createSubComponent(this);
        return wrapper;
    }
    createConstraint(subject, restriction, object) {
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Constraint, this, bioterms_1.Predicates.SBOL3.hasConstraint, 'constraint_' + subject.displayId + '_' + object.displayId, undefined);
        const constraint = new S3Constraint_1.default(this.view, identified.uri);
        constraint.subject = subject;
        constraint.restriction = restriction;
        constraint.object = object;
        return constraint;
    }
    createSequence() {
        const seq = this.view.createSequence(this.uriPrefix, this.displayName + '_sequence');
        this.addSequence(seq);
        return seq;
    }
    addSequence(seq) {
        this.view.graph.insertProperties(this.uri, {
            [bioterms_1.Predicates.SBOL3.hasSequence]: rdfoo_1.node.createUriNode(seq.uri)
        });
    }
    createInteraction(id, version) {
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Interaction, this, bioterms_1.Predicates.SBOL3.hasInteraction, id, undefined);
        const interaction = new S3Interaction_1.default(this.view, identified.uri);
        return interaction;
    }
    addModel(model) {
        this.insertProperty(bioterms_1.Predicates.SBOL3.hasModel, rdfoo_1.node.createUriNode(model.uri));
    }
}
exports.default = S3Component;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Constraint.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Constraint.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3SubComponent_1 = __webpack_require__(/*! ./S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Constraint extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Constraint;
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasConstraint, this.uri));
        if (!uri) {
            throw new Error('SeqCons has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get containingComponent() {
        return this.containingObject;
    }
    get restriction() {
        const restriction = this.getUriProperty(bioterms_1.Predicates.SBOL3.restriction);
        if (restriction === undefined) {
            throw new Error('SeqCons has no restriction?');
        }
        return restriction;
    }
    set restriction(uri) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.restriction, uri);
    }
    get subject() {
        const subject = this.getUriProperty(bioterms_1.Predicates.SBOL3.subject);
        if (subject === undefined) {
            throw new Error('SeqCons has no subject?');
        }
        return new S3SubComponent_1.default(this.view, subject);
    }
    set subject(sc) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.subject, sc.uri);
    }
    get object() {
        const object = this.getUriProperty(bioterms_1.Predicates.SBOL3.object);
        if (object === undefined) {
            throw new Error('SeqCons has no object?');
        }
        return new S3SubComponent_1.default(this.view, object);
    }
    set object(sc) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.object, sc.uri);
    }
}
exports.default = S3Constraint;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Cut.js":
/*!****************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Cut.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3OrientedLocation_1 = __webpack_require__(/*! ./S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Cut extends S3OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Cut;
    }
    get at() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL3.at);
    }
    set at(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.at, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.at);
        }
    }
    isFixed() {
        return true;
    }
}
exports.default = S3Cut;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3EntireSequence.js":
/*!***************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3EntireSequence.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3OrientedLocation_1 = __webpack_require__(/*! ./S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3EntireSequence extends S3OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.EntireSequence;
    }
    get at() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL3.at);
    }
    set at(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.at, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.at);
        }
    }
    isFixed() {
        return true;
    }
}
exports.default = S3EntireSequence;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Experiment.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Experiment.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const S3ExperimentalData_1 = __webpack_require__(/*! ./S3ExperimentalData */ "./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Implementation_1 = __webpack_require__(/*! ./S3Implementation */ "./node_modules/sbolgraph/dist/sbol3/S3Implementation.js");
class S3Experiment extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Experiment;
    }
    get experimentalData() {
        let result = [];
        let expDataURIs = this.getUriProperties(bioterms_1.Predicates.SBOL3.experimentalData);
        for (let uri of expDataURIs) {
            result.push(new S3ExperimentalData_1.default(this.view, uri));
        }
        return result;
        // return this.getUriProperties('https://github.com/SynBioDex/SEPs/blob/sep21/sep_021.md#experimentalData')
        //            .map((uri:string) => this.view.uriToFacade(uri))
        //            .filter((r:SEP21ExperimentalData) => r !== undefined) as Array<SEP21ExperimentalData>
    }
    addExperimentalData(member) {
        this.insertProperty(bioterms_1.Predicates.SBOL3.experimentalData, rdfoo_1.node.createUriNode(member.uri));
    }
    get activity() {
        let activity = this.getUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        if (!activity) {
            return undefined;
        }
        return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
    }
    set activity(activity) {
        if (activity === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.uri);
        }
    }
    get construct() {
        let construct_uri = this.getUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        if (!construct_uri) {
            return undefined;
        }
        return new S3Implementation_1.default(this.view, construct_uri);
    }
    // set construct(construct:S3Implementation|undefined) {
    //     if(construct === undefined) {
    //         this.deleteProperty(Predicates.Prov.wasDerivedFrom)
    //     } else {
    //         this.setUriProperty(Predicates.Prov.wasDerivedFrom, construct.uri)
    //     }
    // }
    addConstruct(construct) {
        this.insertProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, rdfoo_1.node.createUriNode(construct.uri));
    }
    get displayType() {
        return "Experiment";
    }
}
exports.default = S3Experiment;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3ExperimentalData.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3ExperimentalData extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.ExperimentalData;
    }
}
exports.default = S3ExperimentalData;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Facade.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Facade.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SBOLFacade_1 = __webpack_require__(/*! ../SBOLFacade */ "./node_modules/sbolgraph/dist/SBOLFacade.js");
class S3Facade extends SBOLFacade_1.default {
    constructor(view, uri) {
        super(view.graph, view, uri);
        this.view = view;
    }
}
exports.default = S3Facade;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Feature.js":
/*!********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Feature.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3Range_1 = __webpack_require__(/*! ./S3Range */ "./node_modules/sbolgraph/dist/sbol3/S3Range.js");
const S3IdentifiedFactory_1 = __webpack_require__(/*! ./S3IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3OrientedLocation_1 = __webpack_require__(/*! ./S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const extractTerm_1 = __webpack_require__(/*! ../extractTerm */ "./node_modules/sbolgraph/dist/extractTerm.js");
class S3Feature extends S3Identified_1.default {
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
    }
    hasRole(role) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL3.role, role);
    }
    addRole(role) {
        this.insertProperty(bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
    }
    removeRole(role) {
        this.view.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL3.role, role);
    }
    get soTerms() {
        let terms = [];
        for (let role of this.roles) {
            let term = extractTerm_1.default(role);
            if (term)
                terms.push(term);
        }
        return terms;
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.uri));
        if (!uri) {
            throw new Error('has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get containingComponent() {
        return this.containingObject;
    }
    get locations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasLocation)
            .map((uri) => this.view.uriToFacade(uri));
    }
    get rangeLocations() {
        return this.locations.filter((location) => {
            return location.objectType === bioterms_1.Types.SBOL3.Range;
        }).map((identified) => {
            return new S3Range_1.default(this.view, identified.uri);
        });
    }
    get rangeMin() {
        var n = Number.MAX_VALUE;
        this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== undefined && start < n)
                n = start;
            if (end !== undefined && end < n)
                n = end;
        });
        return n === Number.MAX_VALUE ? null : n;
    }
    get rangeMax() {
        var n = Number.MIN_VALUE;
        this.rangeLocations.forEach((range) => {
            const start = range.start;
            const end = range.end;
            if (start !== undefined && start > n)
                n = start;
            if (end !== undefined && end > n)
                n = end;
        });
        return n === Number.MIN_VALUE ? null : n;
    }
    hasFixedLocation() {
        const locations = this.locations;
        for (var i = 0; i < locations.length; ++i) {
            if (locations[i].isFixed())
                return true;
        }
        return false;
    }
    addRange(start, end) {
        const id = 'range';
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Range, this, bioterms_1.Predicates.SBOL3.hasLocation, id, undefined);
        const range = new S3Range_1.default(this.view, identified.uri);
        range.start = start;
        range.end = end;
        return range;
    }
    addOrientedLocation() {
        const loc = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.OrientedLocation, this, bioterms_1.Predicates.SBOL3.hasLocation, 'location', undefined);
        return new S3OrientedLocation_1.default(loc.view, loc.uri);
    }
    //     setOrientation(orientation:string) {
    //         let hadOrientedLocation = false
    //         if(this.locations.length > 0) {
    //             for(let location of this.locations) {
    //                 if(location instanceof S3OrientedLocation) {
    //                     location.orientation = orientation
    //                     hadOrientedLocation = true
    //                 }
    //             }
    //         }
    //         if(hadOrientedLocation)
    //             return
    //         let loc = this.addOrientedLocation()
    //         loc.orientation = orientation
    //     }
    //     getOrientation():string|undefined {
    //         for (let location of this.locations) {
    //             if (location instanceof S3OrientedLocation) {
    //                 return location.orientation
    //             }
    //         }
    //         return undefined
    //     }
    get orientation() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
    }
    set orientation(orientation) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, orientation);
    }
}
exports.default = S3Feature;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js":
/*!***********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Identified.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Facade_1 = __webpack_require__(/*! ./S3Facade */ "./node_modules/sbolgraph/dist/sbol3/S3Facade.js");
const URIUtils_1 = __webpack_require__(/*! ../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
class S3Identified extends S3Facade_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        throw new Error('base called');
    }
    get name() {
        return this.getStringProperty(bioterms_1.Predicates.Dcterms.title);
    }
    // Should never throw; make sure not dependent on any getRequiredProperties
    get displayName() {
        return this.name || this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId) || this.uri;
    }
    set name(name) {
        this.setStringProperty(bioterms_1.Predicates.Dcterms.title, name);
    }
    get description() {
        return this.getStringProperty(bioterms_1.Predicates.Dcterms.description);
    }
    set description(desc) {
        this.setStringProperty(bioterms_1.Predicates.Dcterms.description, desc);
    }
    get displayDescription() {
        return this.description;
    }
    get displayId() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId);
    }
    set displayId(displayId) {
        this.setStringProperty(bioterms_1.Predicates.SBOL3.displayId, displayId);
    }
    get uriPrefix() {
        return URIUtils_1.default.getPrefix(this.uri);
    }
    get namespace() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.hasNamespace);
    }
    set namespace(namespace) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.hasNamespace, namespace);
    }
    get measures() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL2.measure)
            .map((measure) => new S3Measure_1.default(this.view, measure));
    }
}
exports.default = S3Identified;
const S3Measure_1 = __webpack_require__(/*! ./S3Measure */ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js");


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const URIUtils_1 = __webpack_require__(/*! ../URIUtils */ "./node_modules/sbolgraph/dist/URIUtils.js");
class S3IdentifiedFactory {
    static createTopLevel(view, type, uriPrefix, displayId, name) {
        displayId = displayId ? nameToID(displayId) : 'anon';
        const uri = view.graph.generateURI(uriPrefix + displayId + '$n?$');
        view.graph.insertProperties(uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(displayId)
        });
        if (name !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
        }
        return new S3Identified_1.default(view, uri);
    }
    static createChild(view, type, parent, ownershipPredicate, displayId, name) {
        displayId = displayId ? nameToID(displayId) : 'anon';
        const uri = view.graph.generateURI(URIUtils_1.default.getPrefix(parent.uri) + displayId + '$n?$');
        view.graph.insertProperties(uri, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(type),
            [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(displayId)
        });
        if (name !== undefined) {
            view.graph.insertProperties(uri, {
                [bioterms_1.Predicates.Dcterms.title]: rdfoo_1.node.createStringNode(name)
            });
        }
        view.graph.insertProperties(parent.uri, {
            [ownershipPredicate]: rdfoo_1.node.createUriNode(uri)
        });
        return new S3Identified_1.default(view, uri);
    }
}
exports.default = S3IdentifiedFactory;
function nameToID(name) {
    // TODO
    return name.replace(/\s/, '_');
}
function extractPersistentIdentity(uri, version) {
    if (version !== undefined) {
        return uri.substr(0, uri.length - version.length - 1);
    }
    else {
        return uri;
    }
}
function extractID(uri, version) {
    let tokens = uri.split('/');
    if (version !== undefined) {
        return tokens[tokens.length - 2];
    }
    else {
        return tokens[tokens.length - 1];
    }
}


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Implementation.js":
/*!***************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Implementation.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Component_1 = __webpack_require__(/*! ./S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
class S3Implementation extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL2.Implementation;
    }
    get built() {
        let built = this.getUriProperty(bioterms_1.Predicates.SBOL2.built);
        if (!built) {
            return undefined;
        }
        let builtObj = this.view.uriToFacade(built);
        if (builtObj instanceof S3Component_1.default)
            return builtObj;
        throw new Error('built has wrong type');
    }
    set built(built) {
        if (built === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL2.built);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL2.built, built.uri);
        }
    }
    get activity() {
        let activity = this.getUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        if (!activity) {
            return undefined;
        }
        return new rdfoo_prov_1.Activity(new rdfoo_prov_1.ProvView(this.graph), activity);
    }
    set activity(activity) {
        if (activity === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasGeneratedBy);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasGeneratedBy, activity.uri);
        }
    }
    get design() {
        let design_uri = this.getUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        if (!design_uri) {
            return undefined;
        }
        return new S3Identified_1.default(this.view, design_uri);
        // console.log(this.view.getTopLevelsWithPrefix(design_uri))
        // let design = this.view.uriToFacade(design_uri)
        // console.log(design)
        // if(design instanceof S3ComponentDefinition)
        //     return design as S3ComponentDefinition
        // if (design instanceof S3ModuleDefinition)
        //     return design as S3ModuleDefinition
        // throw new Error('design has wrong type')
    }
    set design(design) {
        if (design === undefined) {
            this.deleteProperty(bioterms_1.Predicates.Prov.wasDerivedFrom);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.Prov.wasDerivedFrom, design.uri);
        }
    }
    get displayType() {
        return "Construct";
    }
}
exports.default = S3Implementation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js":
/*!************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Interaction.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3Participation_1 = __webpack_require__(/*! ./S3Participation */ "./node_modules/sbolgraph/dist/sbol3/S3Participation.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3IdentifiedFactory_1 = __webpack_require__(/*! ./S3IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js");
const S3Measure_1 = __webpack_require__(/*! ./S3Measure */ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js");
const S3Component_1 = __webpack_require__(/*! ./S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
class S3Interaction extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Interaction;
    }
    get type() {
        const typeUri = this.getUriProperty(bioterms_1.Predicates.SBOL3.type);
        if (!typeUri)
            throw new Error(this.uri + ' has no type?');
        return typeUri;
    }
    get types() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.type);
    }
    set type(uri) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.type, uri);
    }
    addType(type) {
        this.insertProperty(bioterms_1.Predicates.SBOL3.type, rdfoo_1.node.createUriNode(type));
    }
    hasType(type) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL3.type, type);
    }
    get participations() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.hasParticipation)
            .map((uri) => new S3Participation_1.default(this.view, uri));
    }
    get participants() {
        const participants = this.participations.map((participation) => participation.participant);
        return participants.filter((el) => !!el);
    }
    hasParticipant(participant) {
        return this.participants.map((p) => p.uri).indexOf(participant.uri) !== -1;
    }
    get containingModule() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasInteraction, this.uri));
        if (!uri) {
            throw new Error('Interaction ' + this.uri + ' not contained by a Module?');
        }
        return new S3Component_1.default(this.view, uri);
    }
    get containingObject() {
        return this.containingModule;
    }
    createParticipation(id, version) {
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL3.Participation, this, bioterms_1.Predicates.SBOL3.hasParticipation, id, undefined);
        const participation = new S3Participation_1.default(this.view, identified.uri);
        return participation;
    }
    createParticipationWithParticipantAndRole(id, participant, role, version) {
        let participation = this.createParticipation(id, version);
        participation.addRole(role);
        participation.setParticipant(participant);
        return participation;
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        if (measure === undefined)
            return;
        return new S3Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.uri);
    }
}
exports.default = S3Interaction;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Location.js":
/*!*********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Location.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Sequence_1 = __webpack_require__(/*! ./S3Sequence */ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js");
class S3Location extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasLocation, this.uri));
        if (!uri) {
            throw new Error('Location has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    isFixed() {
        return this.facadeType === bioterms_1.Types.SBOL3.Range; // TODO || this.facadeType === Types.SBOL3.Cut
    }
    get displayName() {
        const name = this.name;
        if (name !== undefined)
            return name;
        const containingObject = this.containingObject;
        if (containingObject === undefined) {
            throw new Error('???');
        }
        return containingObject.displayName;
    }
    get sequence() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL3.hasSequence);
        if (uri === undefined)
            return undefined;
        let obj = this.view.uriToFacade(uri);
        if (!(obj instanceof S3Sequence_1.default)) {
            throw new Error('sequence was not a sequence');
        }
        return obj;
    }
    set sequence(sequence) {
        if (sequence !== undefined)
            this.setUriProperty(bioterms_1.Predicates.SBOL2.sequence, sequence.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL2.sequence);
    }
}
exports.default = S3Location;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3MapsTo.js":
/*!*******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3MapsTo.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
class S3MapsTo extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.MapsTo;
    }
    get local() {
        const localUri = this.getUriProperty(bioterms_1.Predicates.SBOL3.local);
        if (localUri === undefined)
            return undefined;
        return this.view.uriToIdentified(localUri);
    }
    set local(local) {
        if (local)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.local, local.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.local);
    }
    get remote() {
        const remoteUri = this.getUriProperty(bioterms_1.Predicates.SBOL3.remote);
        if (remoteUri === undefined)
            return undefined;
        return this.view.uriToIdentified(remoteUri);
    }
    set remote(remote) {
        if (remote)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.remote, remote.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.remote);
    }
    set refinement(refinement) {
        if (refinement)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.refinement, refinement);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.refinement);
    }
    get refinement() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.refinement);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.mapsTo, this.uri));
        if (!uri) {
            throw new Error('MapsTo has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
}
exports.default = S3MapsTo;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js":
/*!********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Measure.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Measure extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.Measure.Measure;
    }
    get value() {
        return this.getFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
    }
    set value(v) {
        if (v === undefined)
            this.deleteProperty(bioterms_1.Predicates.Measure.hasNumericalValue);
        else
            this.setFloatProperty(bioterms_1.Predicates.Measure.hasNumericalValue, v);
    }
    get unit() {
        return this.getUriProperty(bioterms_1.Predicates.Measure.hasUnit);
    }
    set unit(unit) {
        this.setUriProperty(bioterms_1.Predicates.Measure.hasUnit, unit);
    }
}
exports.default = S3Measure;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Model.js":
/*!******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Model.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Model extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Model;
    }
    get framework() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.framework);
    }
    set framework(framework) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.framework, framework);
    }
    get language() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.language);
    }
    set language(language) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.language, language);
    }
    get source() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.source);
    }
    set source(source) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.source, source);
    }
}
exports.default = S3Model;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Location_1 = __webpack_require__(/*! ./S3Location */ "./node_modules/sbolgraph/dist/sbol3/S3Location.js");
class S3OrientedLocation extends S3Location_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get orientation() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.orientation);
    }
    set orientation(orientation) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.orientation, orientation);
    }
    isFixed() {
        return false;
    }
}
exports.default = S3OrientedLocation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Participation.js":
/*!**************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Participation.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const S3SubComponent_1 = __webpack_require__(/*! ./S3SubComponent */ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js");
const S3Interaction_1 = __webpack_require__(/*! ./S3Interaction */ "./node_modules/sbolgraph/dist/sbol3/S3Interaction.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3Measure_1 = __webpack_require__(/*! ./S3Measure */ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js");
class S3Participation extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Participation;
    }
    get participant() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL3.participant);
        if (uri) {
            return new S3SubComponent_1.default(this.view, uri);
        }
    }
    set participant(c) {
        if (c) {
            this.setUriProperty(bioterms_1.Predicates.SBOL3.participant, c.uri);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.participant);
        }
    }
    get interaction() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasParticipation, this.uri));
        if (uri) {
            return new S3Interaction_1.default(this.view, uri);
        }
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasParticipation, this.uri));
        if (!uri) {
            throw new Error('Participation has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    hasRole(uri) {
        return this.view.graph.hasMatch(this.uri, bioterms_1.Predicates.SBOL3.role, uri);
    }
    addRole(role) {
        this.insertProperty(bioterms_1.Predicates.SBOL3.role, rdfoo_1.node.createUriNode(role));
    }
    removeRole(role) {
        this.view.graph.removeMatches(this.uri, bioterms_1.Predicates.SBOL3.role, role);
    }
    get roles() {
        return this.getUriProperties(bioterms_1.Predicates.SBOL3.role);
    }
    setParticipant(participant) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.participant, participant.uri);
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        if (measure === undefined)
            return;
        return new S3Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.uri);
    }
}
exports.default = S3Participation;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Range.js":
/*!******************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Range.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3OrientedLocation_1 = __webpack_require__(/*! ./S3OrientedLocation */ "./node_modules/sbolgraph/dist/sbol3/S3OrientedLocation.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
class S3Range extends S3OrientedLocation_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Range;
    }
    get start() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL3.start);
    }
    set start(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.start, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.start);
        }
    }
    get end() {
        return this.getIntProperty(bioterms_1.Predicates.SBOL3.end);
    }
    set end(n) {
        if (n !== undefined) {
            this.setIntProperty(bioterms_1.Predicates.SBOL3.end, n);
        }
        else {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.end);
        }
    }
    isFixed() {
        return true;
    }
}
exports.default = S3Range;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3Sequence.js":
/*!*********************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3Sequence.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Identified_1 = __webpack_require__(/*! ./S3Identified */ "./node_modules/sbolgraph/dist/sbol3/S3Identified.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const S3Component_1 = __webpack_require__(/*! ./S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
const S3Range_1 = __webpack_require__(/*! ./S3Range */ "./node_modules/sbolgraph/dist/sbol3/S3Range.js");
class S3Sequence extends S3Identified_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.Sequence;
    }
    get elements() {
        return this.getStringProperty(bioterms_1.Predicates.SBOL3.elements);
    }
    set elements(elements) {
        if (elements === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.elements);
        }
        else {
            this.setStringProperty(bioterms_1.Predicates.SBOL3.elements, elements);
        }
    }
    prependFragment(fragment) {
        this.elements = fragment + this.elements;
    }
    appendFragment(fragment) {
        this.elements = this.elements + fragment;
    }
    // Updates any SequenceFeatures and SubModules that use this sequence
    //
    insertFragment(pos, fragment) {
        const elements = this.elements;
        if (elements === undefined)
            throw new Error('???');
        if (pos === elements.length) {
            this.appendFragment(fragment);
        }
        if (pos < 0 || pos >= elements.length)
            return;
        const containingModules = this.view.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3Component_1.default(this.view, uri));
        containingModules.forEach((module) => {
            module.sequenceFeatures.forEach((sa) => {
                sa.locations.forEach((location) => {
                    updateLocation(location);
                });
            });
            module.subComponents.forEach((sm) => {
                sm.locations.forEach((location) => {
                    updateLocation(location);
                });
            });
            function updateLocation(location) {
                if (location instanceof S3Range_1.default) {
                    const range = location;
                    const start = range.start;
                    const end = range.end;
                    if (start === undefined || end === undefined)
                        throw new Error('???');
                    if (pos >= start && pos <= end) {
                        range.end = end + fragment.length;
                    }
                    else if (pos < start) {
                        range.start = start + fragment.length;
                        range.end = end + fragment.length;
                    }
                }
            }
        });
        const slices = [
            elements.substring(0, pos),
            fragment,
            elements.substring(pos)
        ];
        this.elements = slices.join('');
    }
    // Updates any SAs that use this sequence
    //
    deleteFragment(pos, n) {
        const elements = this.elements;
        if (elements === undefined)
            throw new Error('???');
        if (pos < 0 || pos >= elements.length)
            return;
        const containingCDs = this.view.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3Component_1.default(this.view, uri));
        containingCDs.forEach((cd) => {
            cd.sequenceFeatures.forEach((sa) => {
                sa.locations.forEach((location) => {
                    updateLocation(location);
                });
            });
            cd.subComponents.forEach((sm) => {
                sm.locations.forEach((location) => {
                    updateLocation(location);
                });
            });
            function updateLocation(location) {
                if (location instanceof S3Range_1.default) {
                    const range = location;
                    const start = range.start;
                    const end = range.end;
                    if (start === undefined || end === undefined)
                        throw new Error('???');
                    if (pos >= start && pos <= end) {
                        range.end = end - n;
                    }
                    else if (pos < start) {
                        range.start = start - n;
                        range.end = end - n;
                    }
                }
            }
        });
        const slices = [
            elements.substring(0, pos),
            elements.substring(pos + n)
        ];
        this.elements = slices.join('');
    }
    get encoding() {
        return this.getUriProperty(bioterms_1.Predicates.SBOL3.encoding);
    }
    set encoding(encoding) {
        if (encoding === undefined) {
            this.deleteProperty(bioterms_1.Predicates.SBOL3.encoding);
        }
        else {
            this.setUriProperty(bioterms_1.Predicates.SBOL3.encoding, encoding);
        }
    }
    get containingObject() {
        return undefined;
    }
    get referencingComponents() {
        return this.graph.match(null, bioterms_1.Predicates.SBOL3.hasSequence, this.uri).map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3Component_1.default(this.view, uri));
    }
}
exports.default = S3Sequence;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js":
/*!****************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3SequenceFeature.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Feature_1 = __webpack_require__(/*! ./S3Feature */ "./node_modules/sbolgraph/dist/sbol3/S3Feature.js");
class S3SequenceFeature extends S3Feature_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
}
exports.default = S3SequenceFeature;


/***/ }),

/***/ "./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js":
/*!*************************************************************!*\
  !*** ./node_modules/sbolgraph/dist/sbol3/S3SubComponent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const S3Feature_1 = __webpack_require__(/*! ./S3Feature */ "./node_modules/sbolgraph/dist/sbol3/S3Feature.js");
const S3Component_1 = __webpack_require__(/*! ./S3Component */ "./node_modules/sbolgraph/dist/sbol3/S3Component.js");
const S3Constraint_1 = __webpack_require__(/*! ./S3Constraint */ "./node_modules/sbolgraph/dist/sbol3/S3Constraint.js");
const S3IdentifiedFactory_1 = __webpack_require__(/*! ./S3IdentifiedFactory */ "./node_modules/sbolgraph/dist/sbol3/S3IdentifiedFactory.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const S3MapsTo_1 = __webpack_require__(/*! ./S3MapsTo */ "./node_modules/sbolgraph/dist/sbol3/S3MapsTo.js");
const S3Location_1 = __webpack_require__(/*! ./S3Location */ "./node_modules/sbolgraph/dist/sbol3/S3Location.js");
const S3Measure_1 = __webpack_require__(/*! ./S3Measure */ "./node_modules/sbolgraph/dist/sbol3/S3Measure.js");
class S3SubComponent extends S3Feature_1.default {
    constructor(view, uri) {
        super(view, uri);
    }
    get facadeType() {
        return bioterms_1.Types.SBOL3.SubComponent;
    }
    get displayName() {
        let name = this.name;
        if (name)
            return name;
        try {
            let instanceOf = this.instanceOf;
            let instanceOfName = instanceOf.name;
            if (instanceOfName) {
                return instanceOfName;
            }
        }
        catch (e) {
        }
        return this.getStringProperty(bioterms_1.Predicates.SBOL3.displayId) || this.uri;
    }
    get instanceOf() {
        const uri = this.getUriProperty(bioterms_1.Predicates.SBOL3.instanceOf);
        if (uri === undefined) {
            throw new Error('subcomponent has no instanceOf?');
        }
        return new S3Component_1.default(this.view, uri);
    }
    set instanceOf(def) {
        this.setUriProperty(bioterms_1.Predicates.SBOL3.instanceOf, def.uri);
    }
    get containingObject() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.uri));
        if (!uri) {
            throw new Error('subcomponent has no containing object?');
        }
        return this.view.uriToIdentified(uri);
    }
    get containingComponent() {
        const uri = rdfoo_1.triple.subjectUri(this.view.graph.matchOne(null, bioterms_1.Predicates.SBOL3.hasFeature, this.uri));
        if (!uri) {
            throw new Error('subcomponent has no containing object?');
        }
        return this.view.uriToFacade(uri);
    }
    get sequenceConstraints() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.subject, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            //.filter((uri:string) => this.view.getType(uri) === Types.SBOL3.SequenceConstraint)
            .map((uri) => new S3Constraint_1.default(this.view, uri));
    }
    createAfter(component) {
        const container = this.containingComponent;
        const sc = container.createSubComponent(component);
        let existingConstraints = this.getConstraintsWithThisSubject();
        container.createConstraint(this, bioterms_1.Specifiers.SBOL3.Constraint.Precedes, sc);
        for (let c of existingConstraints) {
            if (c.restriction === bioterms_1.Specifiers.SBOL3.Constraint.Precedes) {
                c.subject = sc;
            }
        }
        return sc;
    }
    createBefore(component) {
        const container = this.containingComponent;
        const sc = container.createSubComponent(component);
        let existingConstraints = this.getConstraintsWithThisObject();
        container.createConstraint(sc, bioterms_1.Specifiers.SBOL3.Constraint.Precedes, this);
        for (let c of existingConstraints) {
            if (c.restriction === bioterms_1.Specifiers.SBOL3.Constraint.Precedes) {
                c.object = sc;
            }
        }
        return sc;
    }
    getConstraintsWithThisSubject() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.subject, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3Constraint_1.default(this.view, uri));
    }
    getConstraintsWithThisObject() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL3.object, this.uri)
            .map(rdfoo_1.triple.subjectUri)
            .map((uri) => new S3Constraint_1.default(this.view, uri));
    }
    getConstraints() {
        return this.getConstraintsWithThisSubject().concat(this.getConstraintsWithThisObject());
    }
    get mappings() {
        return this.view.graph.match(null, bioterms_1.Predicates.SBOL2.local, this.uri).map(rdfoo_1.triple.subjectUri)
            .concat(this.view.graph.match(null, bioterms_1.Predicates.SBOL2.remote, this.uri).map(rdfoo_1.triple.subjectUri))
            .filter((el) => !!el)
            .map((mapsToUri) => new S3MapsTo_1.default(this.view, mapsToUri));
    }
    addMapping(mapping) {
        this.insertProperties({
            [bioterms_1.Predicates.SBOL2.mapsTo]: rdfoo_1.node.createUriNode(mapping.uri)
        });
    }
    createMapping(local, remote) {
        const identified = S3IdentifiedFactory_1.default.createChild(this.view, bioterms_1.Types.SBOL2.MapsTo, this, bioterms_1.Predicates.SBOL2.mapsTo, 'mapping_' + local.displayId + '_' + remote.displayId, undefined);
        const mapping = new S3MapsTo_1.default(this.view, identified.uri);
        mapping.local = local;
        mapping.remote = remote;
        return mapping;
    }
    swapWith(otherSubComponent) {
        let a = this.getConstraintsWithThisObject();
        let b = this.getConstraintsWithThisSubject();
        let c = otherSubComponent.getConstraintsWithThisObject();
        let d = otherSubComponent.getConstraintsWithThisSubject();
        for (let sc of a) {
            sc.object = otherSubComponent;
        }
        for (let sc of b) {
            sc.subject = otherSubComponent;
        }
        for (let sc of c) {
            sc.object = this;
        }
        for (let sc of d) {
            sc.subject = this;
        }
        // TODO locations
    }
    createInteractionWith(other, id, interactionType, ourRole, theirRole) {
        if (!other.isSiblingOf(this)) {
            throw new Error('???');
        }
        let container = this.containingComponent;
        if (!container) {
            throw new Error('???');
        }
        let interaction = container.createInteraction(id);
        interaction.type = interactionType;
        interaction.createParticipationWithParticipantAndRole('ourParticipation', this, ourRole);
        interaction.createParticipationWithParticipantAndRole('theirParticipation', other, theirRole);
        return interaction;
    }
    createProduct(id) {
        let product = this.view.createComponent(this.uriPrefix, id);
        let container = this.containingComponent;
        let productSC = container.createSubComponent(product);
        let interaction = this.createInteractionWith(productSC, 'production', bioterms_1.Prefixes.sbo + 'SBO:0000589', bioterms_1.Prefixes.sbo + 'SBO:0000645', bioterms_1.Prefixes.sbo + 'SBO:0000011');
        return productSC;
    }
    getInteractions() {
        let container = this.containingComponent;
        return container.interactions.filter((interaction) => {
            return interaction.hasParticipant(this);
        });
    }
    getProducts() {
        let interactions = this.getInteractions();
        let productionInteractions = interactions.filter((interaction) => {
            return interaction.hasType(bioterms_1.Prefixes.sbo + 'SBO:0000589');
        });
        let products = [];
        for (let i of productionInteractions) {
            for (let p of i.participations) {
                if (p.hasRole(bioterms_1.Prefixes.sbo + 'SBO:0000011')) {
                    let participant = p.participant;
                    if (participant === undefined) {
                        throw new Error('???');
                    }
                    products.push(participant);
                }
            }
        }
        return products;
    }
    dissolve() {
        let containingComponent = this.containingComponent;
        let def = this.instanceOf;
        for (let subcomponent of def.subComponents) {
            let newSC = containingComponent.createSubComponent(subcomponent.instanceOf);
            // TODO locations etc
        }
        this.destroy();
    }
    get sourceLocation() {
        let uri = this.getUriProperty(bioterms_1.Predicates.SBOL3.sourceLocation);
        if (uri === undefined)
            return undefined;
        let obj = this.view.uriToFacade(uri);
        if (!(obj instanceof S3Location_1.default)) {
            throw new Error('sourceLocation was not a location');
        }
        return obj;
    }
    set sourceLocation(location) {
        if (location !== undefined)
            this.setUriProperty(bioterms_1.Predicates.SBOL3.sourceLocation, location.uri);
        else
            this.deleteProperty(bioterms_1.Predicates.SBOL3.sourceLocation);
    }
    get measure() {
        let measure = this.getUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        if (measure === undefined)
            return;
        return new S3Measure_1.default(this.view, measure);
    }
    set measure(measure) {
        if (measure === undefined)
            this.deleteProperty(bioterms_1.Predicates.SBOL3.hasMeasure);
        else
            this.setUriProperty(bioterms_1.Predicates.SBOL3.hasMeasure, measure.uri);
    }
}
exports.default = S3SubComponent;


/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte.js");
var format = __webpack_require__(/*! nanoid/format */ "./node_modules/nanoid/format.js");

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
var isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte.js":
/*!********************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! nanoid/random */ "./node_modules/nanoid/random.js");


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id.js":
/*!************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cluster = __webpack_require__(/*! cluster */ "cluster");

var clusterId = 0;
if (!cluster.isMaster && cluster.worker) {
    clusterId = cluster.worker.id;
}
module.exports = parseInt(process.env.NODE_UNIQUE_ID || clusterId, 10);


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/stringifier/index.js":
/*!*******************************************!*\
  !*** ./node_modules/stringifier/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * stringifier
 * 
 * https://github.com/twada/stringifier
 *
 * Copyright (c) 2014-2018 Takuto Wada
 * Licensed under the MIT license.
 *   https://twada.mit-license.org/2014-2018
 */


var traverse = __webpack_require__(/*! traverse */ "./node_modules/traverse/index.js");
var typeName = __webpack_require__(/*! type-name */ "./node_modules/type-name/index.js");
var assign = __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js");
var endsWith = __webpack_require__(/*! core-js/library/fn/string/ends-with */ "./node_modules/core-js/library/fn/string/ends-with.js");
var s = __webpack_require__(/*! ./strategies */ "./node_modules/stringifier/strategies.js");

function defaultHandlers () {
    return {
        'null': s.always('null'),
        'undefined': s.always('undefined'),
        'function': s.prune(),
        'string': s.json(),
        'boolean': s.json(),
        'number': s.number(),
        'symbol': s.toStr(),
        'RegExp': s.toStr(),
        'String': s.newLike(),
        'Boolean': s.newLike(),
        'Number': s.newLike(),
        'Date': s.newLike(),
        'Array': s.array(),
        'Object': s.object(),
        'Error': s.object(null, ['message', 'code']),
        '@default': s.object()
    };
}

function defaultOptions () {
    return {
        maxDepth: null,
        indent: null,
        anonymous: '@Anonymous',
        circular: '#@Circular#',
        snip: '..(snip)',
        lineSeparator: '\n',
        typeFun: typeName
    };
}

function createStringifier (customOptions) {
    var options = assign({}, defaultOptions(), customOptions);
    var handlers = assign({}, defaultHandlers(), options.handlers);
    return function stringifyAny (push, x) {
        var context = this;
        var handler = handlerFor(context.node, options, handlers);
        var currentPath = '/' + context.path.join('/');
        var customization = handlers[currentPath];
        var acc = {
            context: context,
            options: options,
            handlers: handlers,
            push: push
        };
        if (typeName(customization) === 'function') {
            handler = customization;
        } else if (typeName(customization) === 'number') {
            handler = s.flow.compose(s.filters.truncate(customization),handler);
        } else if (context.parent && typeName(context.parent.node) === 'Array' && !(context.key in context.parent.node)) {
            // sparse arrays
            handler = s.always('');
        }
        handler(acc, x);
        return push;
    };
}

function handlerFor (val, options, handlers) {
    var tname = options.typeFun(val);
    if (typeName(handlers[tname]) === 'function') {
        return handlers[tname];
    }
    if (endsWith(tname, 'Error')) {
        return handlers['Error'];
    }
    return handlers['@default'];
}

function walk (val, reducer) {
    var buffer = [];
    var push = function (str) {
        buffer.push(str);
    };
    traverse(val).reduce(reducer, push);
    return buffer.join('');
}

function stringify (val, options) {
    return walk(val, createStringifier(options));
}

function stringifier (options) {
    return function (val) {
        return walk(val, createStringifier(options));
    };
}

stringifier.stringify = stringify;
stringifier.strategies = s;
stringifier.defaultOptions = defaultOptions;
stringifier.defaultHandlers = defaultHandlers;
module.exports = stringifier;


/***/ }),

/***/ "./node_modules/stringifier/strategies.js":
/*!************************************************!*\
  !*** ./node_modules/stringifier/strategies.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var typeName = __webpack_require__(/*! type-name */ "./node_modules/type-name/index.js");
var forEach = __webpack_require__(/*! core-js/library/fn/array/for-each */ "./node_modules/core-js/library/fn/array/for-each.js");
var arrayFilter = __webpack_require__(/*! core-js/library/fn/array/filter */ "./node_modules/core-js/library/fn/array/filter.js");
var reduceRight = __webpack_require__(/*! core-js/library/fn/array/reduce-right */ "./node_modules/core-js/library/fn/array/reduce-right.js");
var indexOf = __webpack_require__(/*! core-js/library/fn/array/index-of */ "./node_modules/core-js/library/fn/array/index-of.js");
var slice = Array.prototype.slice;
var END = {};
var ITERATE = {};

// arguments should end with end or iterate
function compose () {
    var filters = slice.apply(arguments);
    return reduceRight(filters, function(right, left) {
        return left(right);
    });
}

// skip children
function end () {
    return function (acc, x) {
        acc.context.keys = [];
        return END;
    };
}

// iterate children
function iterate () {
    return function (acc, x) {
        return ITERATE;
    };
}

function filter (predicate) {
    return function (next) {
        return function (acc, x) {
            var toBeIterated;
            var isIteratingArray = (typeName(x) === 'Array');
            if (typeName(predicate) === 'function') {
                toBeIterated = [];
                forEach(acc.context.keys, function (key) {
                    var indexOrKey = isIteratingArray ? parseInt(key, 10) : key;
                    var kvp = {
                        key: indexOrKey,
                        value: x[key]
                    };
                    var decision = predicate(kvp);
                    if (decision) {
                        toBeIterated.push(key);
                    }
                    if (typeName(decision) === 'number') {
                        truncateByKey(decision, key, acc);
                    }
                    if (typeName(decision) === 'function') {
                        customizeStrategyForKey(decision, key, acc);
                    }
                });
                acc.context.keys = toBeIterated;
            }
            return next(acc, x);
        };
    };
}

function customizeStrategyForKey (strategy, key, acc) {
    acc.handlers[currentPath(key, acc)] = strategy;
}

function truncateByKey (size, key, acc) {
    acc.handlers[currentPath(key, acc)] = size;
}

function currentPath (key, acc) {
    var pathToCurrentNode = [''].concat(acc.context.path);
    if (typeName(key) !== 'undefined') {
        pathToCurrentNode.push(key);
    }
    return pathToCurrentNode.join('/');
}

function allowedKeys (orderedWhiteList) {
    return function (next) {
        return function (acc, x) {
            var isIteratingArray = (typeName(x) === 'Array');
            if (!isIteratingArray && typeName(orderedWhiteList) === 'Array') {
                acc.context.keys = arrayFilter(orderedWhiteList, function (propKey) {
                    return x.hasOwnProperty(propKey);
                });
            }
            return next(acc, x);
        };
    };
}

function safeKeys () {
    return function (next) {
        return function (acc, x) {
            if (typeName(x) !== 'Array') {
                acc.context.keys = arrayFilter(acc.context.keys, function (propKey) {
                    // Error handling for unsafe property access.
                    // For example, on PhantomJS,
                    // accessing HTMLInputElement.selectionEnd causes TypeError
                    try {
                        var val = x[propKey];
                        return true;
                    } catch (e) {
                        // skip unsafe key
                        return false;
                    }
                });
            }
            return next(acc, x);
        };
    };
}

function arrayIndicesToKeys () {
    return function (next) {
        return function (acc, x) {
            if (typeName(x) === 'Array' && 0 < x.length) {
                var indices = Array(x.length);
                for(var i = 0; i < x.length; i += 1) {
                    indices[i] = String(i); // traverse uses strings as keys
                }
                acc.context.keys = indices;
            }
            return next(acc, x);
        };
    };
}

function when (guard, then) {
    return function (next) {
        return function (acc, x) {
            var kvp = {
                key: acc.context.key,
                value: x
            };
            if (guard(kvp, acc)) {
                return then(acc, x);
            }
            return next(acc, x);
        };
    };
}

function truncate (size) {
    return function (next) {
        return function (acc, x) {
            var orig = acc.push;
            var ret;
            acc.push = function (str) {
                var savings = str.length - size;
                var truncated;
                if (savings <= size) {
                    orig.call(acc, str);
                } else {
                    truncated = str.substring(0, size);
                    orig.call(acc, truncated + acc.options.snip);
                }
            };
            ret = next(acc, x);
            acc.push = orig;
            return ret;
        };
    };
}

function constructorName () {
    return function (next) {
        return function (acc, x) {
            var name = acc.options.typeFun(x);
            if (name === '') {
                name = acc.options.anonymous;
            }
            acc.push(name);
            return next(acc, x);
        };
    };
}

function always (str) {
    return function (next) {
        return function (acc, x) {
            acc.push(str);
            return next(acc, x);
        };
    };
}

function optionValue (key) {
    return function (next) {
        return function (acc, x) {
            acc.push(acc.options[key]);
            return next(acc, x);
        };
    };
}

function json (replacer) {
    return function (next) {
        return function (acc, x) {
            acc.push(JSON.stringify(x, replacer));
            return next(acc, x);
        };
    };
}

function toStr () {
    return function (next) {
        return function (acc, x) {
            acc.push(x.toString());
            return next(acc, x);
        };
    };
}

function decorateArray () {
    return function (next) {
        return function (acc, x) {
            acc.context.before(function (node) {
                acc.push('[');
            });
            acc.context.after(function (node) {
                afterAllChildren(this, acc.push, acc.options);
                acc.push(']');
            });
            acc.context.pre(function (val, key) {
                beforeEachChild(this, acc.push, acc.options);
            });
            acc.context.post(function (childContext) {
                afterEachChild(childContext, acc.push);
            });
            return next(acc, x);
        };
    };
}

function decorateObject () {
    return function (next) {
        return function (acc, x) {
            acc.context.before(function (node) {
                acc.push('{');
            });
            acc.context.after(function (node) {
                afterAllChildren(this, acc.push, acc.options);
                acc.push('}');
            });
            acc.context.pre(function (val, key) {
                beforeEachChild(this, acc.push, acc.options);
                acc.push(sanitizeKey(key) + (acc.options.indent ? ': ' : ':'));
            });
            acc.context.post(function (childContext) {
                afterEachChild(childContext, acc.push);
            });
            return next(acc, x);
        };
    };
}

function sanitizeKey (key) {
    return /^[A-Za-z_]+$/.test(key) ? key : JSON.stringify(key);
}

function afterAllChildren (context, push, options) {
    if (options.indent && 0 < context.keys.length) {
        push(options.lineSeparator);
        for(var i = 0; i < context.level; i += 1) { // indent level - 1
            push(options.indent);
        }
    }
}

function beforeEachChild (context, push, options) {
    if (options.indent) {
        push(options.lineSeparator);
        for(var i = 0; i <= context.level; i += 1) {
            push(options.indent);
        }
    }
}

function afterEachChild (childContext, push) {
    if (!childContext.isLast) {
        push(',');
    }
}

function nan (kvp, acc) {
    return kvp.value !== kvp.value;
}

function positiveInfinity (kvp, acc) {
    return !isFinite(kvp.value) && kvp.value === Infinity;
}

function negativeInfinity (kvp, acc) {
    return !isFinite(kvp.value) && kvp.value !== Infinity;
}

function circular (kvp, acc) {
    return acc.context.circular;
}

function maxDepth (kvp, acc) {
    return (acc.options.maxDepth && acc.options.maxDepth <= acc.context.level);
}

var prune = compose(
    always('#'),
    constructorName(),
    always('#'),
    end()
);
var omitNaN = when(nan, compose(
    always('NaN'),
    end()
));
var omitPositiveInfinity = when(positiveInfinity, compose(
    always('Infinity'),
    end()
));
var omitNegativeInfinity = when(negativeInfinity, compose(
    always('-Infinity'),
    end()
));
var omitCircular = when(circular, compose(
    optionValue('circular'),
    end()
));
var omitMaxDepth = when(maxDepth, prune);

module.exports = {
    filters: {
        always: always,
        optionValue: optionValue,
        constructorName: constructorName,
        json: json,
        toStr: toStr,
        prune: prune,
        truncate: truncate,
        decorateArray: decorateArray,
        decorateObject: decorateObject
    },
    flow: {
        compose: compose,
        when: when,
        allowedKeys: allowedKeys,
        safeKeys: safeKeys,
        arrayIndicesToKeys: arrayIndicesToKeys,
        filter: filter,
        iterate: iterate,
        end: end
    },
    symbols: {
        END: END,
        ITERATE: ITERATE
    },
    always: function (str) {
        return compose(always(str), end());
    },
    json: function () {
        return compose(json(), end());
    },
    toStr: function () {
        return compose(toStr(), end());
    },
    prune: function () {
        return prune;
    },
    number: function () {
        return compose(
            omitNaN,
            omitPositiveInfinity,
            omitNegativeInfinity,
            json(),
            end()
        );
    },
    newLike: function () {
        return compose(
            always('new '),
            constructorName(),
            always('('),
            json(),
            always(')'),
            end()
        );
    },
    array: function (predicate) {
        return compose(
            omitCircular,
            omitMaxDepth,
            decorateArray(),
            arrayIndicesToKeys(),
            filter(predicate),
            iterate()
        );
    },
    object: function (predicate, orderedWhiteList) {
        return compose(
            omitCircular,
            omitMaxDepth,
            constructorName(),
            decorateObject(),
            allowedKeys(orderedWhiteList),
            safeKeys(),
            filter(predicate),
            iterate()
        );
    }
};


/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./node_modules/traverse/index.js":
/*!****************************************!*\
  !*** ./node_modules/traverse/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};


/***/ }),

/***/ "./node_modules/type-name/index.js":
/*!*****************************************!*\
  !*** ./node_modules/type-name/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * type-name - Just a reasonable typeof
 *
 * https://github.com/twada/type-name
 *
 * Copyright (c) 2014-2016 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/twada/type-name/blob/master/LICENSE
 */


var toStr = Object.prototype.toString;

function funcName (f) {
    if (f.name) {
        return f.name;
    }
    var match = /^\s*function\s*([^\(]*)/im.exec(f.toString());
    return match ? match[1] : '';
}

function ctorName (obj) {
    var strName = toStr.call(obj).slice(8, -1);
    if ((strName === 'Object' || strName === 'Error') && obj.constructor) {
        return funcName(obj.constructor);
    }
    return strName;
}

function typeName (val) {
    var type;
    if (val === null) {
        return 'null';
    }
    type = typeof val;
    if (type === 'object') {
        return ctorName(val);
    }
    return type;
}

module.exports = typeName;


/***/ }),

/***/ "./node_modules/typedarray/index.js":
/*!******************************************!*\
  !*** ./node_modules/typedarray/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var undefined = (void 0); // Paranoia

// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
// create, and consume so much memory, that the browser appears frozen.
var MAX_ARRAY_LENGTH = 1e5;

// Approximations of internal ECMAScript conversion functions
var ECMAScript = (function() {
  // Stash a copy in case other scripts modify these
  var opts = Object.prototype.toString,
      ophop = Object.prototype.hasOwnProperty;

  return {
    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
    HasProperty: function(o, p) { return p in o; },
    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
    IsCallable: function(o) { return typeof o === 'function'; },
    ToInt32: function(v) { return v >> 0; },
    ToUint32: function(v) { return v >>> 0; }
  };
}());

// Snapshot intrinsics
var LN2 = Math.LN2,
    abs = Math.abs,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    pow = Math.pow,
    round = Math.round;

// ES5: lock down object properties
function configureProperties(obj) {
  if (getOwnPropNames && defineProp) {
    var props = getOwnPropNames(obj), i;
    for (i = 0; i < props.length; i += 1) {
      defineProp(obj, props[i], {
        value: obj[props[i]],
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
  }
}

// emulate ES5 getter/setter API using legacy APIs
// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
var defineProp
if (Object.defineProperty && (function() {
      try {
        Object.defineProperty({}, 'x', {});
        return true;
      } catch (e) {
        return false;
      }
    })()) {
  defineProp = Object.defineProperty;
} else {
  defineProp = function(o, p, desc) {
    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
    return o;
  };
}

var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
  var props = [], p;
  for (p in o) {
    if (ECMAScript.HasOwnProperty(o, p)) {
      props.push(p);
    }
  }
  return props;
};

// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
// for index in 0 ... obj.length
function makeArrayAccessors(obj) {
  if (!defineProp) { return; }

  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

  function makeArrayAccessor(index) {
    defineProp(obj, index, {
      'get': function() { return obj._getter(index); },
      'set': function(v) { obj._setter(index, v); },
      enumerable: true,
      configurable: false
    });
  }

  var i;
  for (i = 0; i < obj.length; i += 1) {
    makeArrayAccessor(i);
  }
}

// Internal conversion functions:
//    pack<Type>()   - take a number (interpreted as Type), output a byte array
//    unpack<Type>() - take a byte array, output a Type-like number

function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

function packI8(n) { return [n & 0xff]; }
function unpackI8(bytes) { return as_signed(bytes[0], 8); }

function packU8(n) { return [n & 0xff]; }
function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

function packIEEE754(v, ebits, fbits) {

  var bias = (1 << (ebits - 1)) - 1,
      s, e, f, ln,
      i, bits, str, bytes;

  function roundToEven(n) {
    var w = floor(n), f = n - w;
    if (f < 0.5)
      return w;
    if (f > 0.5)
      return w + 1;
    return w % 2 ? w + 1 : w;
  }

  // Compute sign, exponent, fraction
  if (v !== v) {
    // NaN
    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
  } else if (v === Infinity || v === -Infinity) {
    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
  } else if (v === 0) {
    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
  } else {
    s = v < 0;
    v = abs(v);

    if (v >= pow(2, 1 - bias)) {
      e = min(floor(log(v) / LN2), 1023);
      f = roundToEven(v / pow(2, e) * pow(2, fbits));
      if (f / pow(2, fbits) >= 2) {
        e = e + 1;
        f = 1;
      }
      if (e > bias) {
        // Overflow
        e = (1 << ebits) - 1;
        f = 0;
      } else {
        // Normalized
        e = e + bias;
        f = f - pow(2, fbits);
      }
    } else {
      // Denormalized
      e = 0;
      f = roundToEven(v / pow(2, 1 - bias - fbits));
    }
  }

  // Pack sign, exponent, fraction
  bits = [];
  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
  bits.push(s ? 1 : 0);
  bits.reverse();
  str = bits.join('');

  // Bits to bytes
  bytes = [];
  while (str.length) {
    bytes.push(parseInt(str.substring(0, 8), 2));
    str = str.substring(8);
  }
  return bytes;
}

function unpackIEEE754(bytes, ebits, fbits) {

  // Bytes to bits
  var bits = [], i, j, b, str,
      bias, s, e, f;

  for (i = bytes.length; i; i -= 1) {
    b = bytes[i - 1];
    for (j = 8; j; j -= 1) {
      bits.push(b % 2 ? 1 : 0); b = b >> 1;
    }
  }
  bits.reverse();
  str = bits.join('');

  // Unpack sign, exponent, fraction
  bias = (1 << (ebits - 1)) - 1;
  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
  e = parseInt(str.substring(1, 1 + ebits), 2);
  f = parseInt(str.substring(1 + ebits), 2);

  // Produce number
  if (e === (1 << ebits) - 1) {
    return f !== 0 ? NaN : s * Infinity;
  } else if (e > 0) {
    // Normalized
    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
  } else if (f !== 0) {
    // Denormalized
    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
  } else {
    return s < 0 ? -0 : 0;
  }
}

function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
function packF64(v) { return packIEEE754(v, 11, 52); }
function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
function packF32(v) { return packIEEE754(v, 8, 23); }


//
// 3 The ArrayBuffer Type
//

(function() {

  /** @constructor */
  var ArrayBuffer = function ArrayBuffer(length) {
    length = ECMAScript.ToInt32(length);
    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

    this.byteLength = length;
    this._bytes = [];
    this._bytes.length = length;

    var i;
    for (i = 0; i < this.byteLength; i += 1) {
      this._bytes[i] = 0;
    }

    configureProperties(this);
  };

  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

  //
  // 4 The ArrayBufferView Type
  //

  // NOTE: this constructor is not exported
  /** @constructor */
  var ArrayBufferView = function ArrayBufferView() {
    //this.buffer = null;
    //this.byteOffset = 0;
    //this.byteLength = 0;
  };

  //
  // 5 The Typed Array View Types
  //

  function makeConstructor(bytesPerElement, pack, unpack) {
    // Each TypedArray type requires a distinct constructor instance with
    // identical logic, which this produces.

    var ctor;
    ctor = function(buffer, byteOffset, length) {
      var array, sequence, i, s;

      if (!arguments.length || typeof arguments[0] === 'number') {
        // Constructor(unsigned long length)
        this.length = ECMAScript.ToInt32(arguments[0]);
        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;
      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
        // Constructor(TypedArray array)
        array = arguments[0];

        this.length = array.length;
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          this._setter(i, array._getter(i));
        }
      } else if (typeof arguments[0] === 'object' &&
                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(sequence<type> array)
        sequence = arguments[0];

        this.length = ECMAScript.ToUint32(sequence.length);
        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        this.buffer = new ArrayBuffer(this.byteLength);
        this.byteOffset = 0;

        for (i = 0; i < this.length; i += 1) {
          s = sequence[i];
          this._setter(i, Number(s));
        }
      } else if (typeof arguments[0] === 'object' &&
                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
        // Constructor(ArrayBuffer buffer,
        //             optional unsigned long byteOffset, optional unsigned long length)
        this.buffer = buffer;

        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }

        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
          // The given byteOffset must be a multiple of the element
          // size of the specific type, otherwise an exception is raised.
          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
        }

        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;

          if (this.byteLength % this.BYTES_PER_ELEMENT) {
            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
          }
          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
        } else {
          this.length = ECMAScript.ToUint32(length);
          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
        }

        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }

      this.constructor = ctor;

      configureProperties(this);
      makeArrayAccessors(this);
    };

    ctor.prototype = new ArrayBufferView();
    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
    ctor.prototype._pack = pack;
    ctor.prototype._unpack = unpack;
    ctor.BYTES_PER_ELEMENT = bytesPerElement;

    // getter type (unsigned long index);
    ctor.prototype._getter = function(index) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = [], i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        bytes.push(this.buffer._bytes[o]);
      }
      return this._unpack(bytes);
    };

    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
    ctor.prototype.get = ctor.prototype._getter;

    // setter void (unsigned long index, type value);
    ctor.prototype._setter = function(index, value) {
      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

      index = ECMAScript.ToUint32(index);
      if (index >= this.length) {
        return undefined;
      }

      var bytes = this._pack(value), i, o;
      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
           i < this.BYTES_PER_ELEMENT;
           i += 1, o += 1) {
        this.buffer._bytes[o] = bytes[i];
      }
    };

    // void set(TypedArray array, optional unsigned long offset);
    // void set(sequence<type> array, optional unsigned long offset);
    ctor.prototype.set = function(index, value) {
      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
      var array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
        // void set(TypedArray array, optional unsigned long offset);
        array = arguments[0];
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + array.length > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
        byteLength = array.length * this.BYTES_PER_ELEMENT;

        if (array.buffer === this.buffer) {
          tmp = [];
          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
            tmp[i] = array.buffer._bytes[s];
          }
          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
            this.buffer._bytes[d] = tmp[i];
          }
        } else {
          for (i = 0, s = array.byteOffset, d = byteOffset;
               i < byteLength; i += 1, s += 1, d += 1) {
            this.buffer._bytes[d] = array.buffer._bytes[s];
          }
        }
      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
        // void set(sequence<type> array, optional unsigned long offset);
        sequence = arguments[0];
        len = ECMAScript.ToUint32(sequence.length);
        offset = ECMAScript.ToUint32(arguments[1]);

        if (offset + len > this.length) {
          throw new RangeError("Offset plus length of array is out of range");
        }

        for (i = 0; i < len; i += 1) {
          s = sequence[i];
          this._setter(offset + i, Number(s));
        }
      } else {
        throw new TypeError("Unexpected argument type(s)");
      }
    };

    // TypedArray subarray(long begin, optional long end);
    ctor.prototype.subarray = function(start, end) {
      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

      start = ECMAScript.ToInt32(start);
      end = ECMAScript.ToInt32(end);

      if (arguments.length < 1) { start = 0; }
      if (arguments.length < 2) { end = this.length; }

      if (start < 0) { start = this.length + start; }
      if (end < 0) { end = this.length + end; }

      start = clamp(start, 0, this.length);
      end = clamp(end, 0, this.length);

      var len = end - start;
      if (len < 0) {
        len = 0;
      }

      return new this.constructor(
        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
    };

    return ctor;
  }

  var Int8Array = makeConstructor(1, packI8, unpackI8);
  var Uint8Array = makeConstructor(1, packU8, unpackU8);
  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
  var Int16Array = makeConstructor(2, packI16, unpackI16);
  var Uint16Array = makeConstructor(2, packU16, unpackU16);
  var Int32Array = makeConstructor(4, packI32, unpackI32);
  var Uint32Array = makeConstructor(4, packU32, unpackU32);
  var Float32Array = makeConstructor(4, packF32, unpackF32);
  var Float64Array = makeConstructor(8, packF64, unpackF64);

  exports.Int8Array = exports.Int8Array || Int8Array;
  exports.Uint8Array = exports.Uint8Array || Uint8Array;
  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
  exports.Int16Array = exports.Int16Array || Int16Array;
  exports.Uint16Array = exports.Uint16Array || Uint16Array;
  exports.Int32Array = exports.Int32Array || Int32Array;
  exports.Uint32Array = exports.Uint32Array || Uint32Array;
  exports.Float32Array = exports.Float32Array || Float32Array;
  exports.Float64Array = exports.Float64Array || Float64Array;
}());

//
// 6 The DataView View Type
//

(function() {
  function r(array, index) {
    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
  }

  var IS_BIG_ENDIAN = (function() {
    var u16array = new(exports.Uint16Array)([0x1234]),
        u8array = new(exports.Uint8Array)(u16array.buffer);
    return r(u8array, 0) === 0x12;
  }());

  // Constructor(ArrayBuffer buffer,
  //             optional unsigned long byteOffset,
  //             optional unsigned long byteLength)
  /** @constructor */
  var DataView = function DataView(buffer, byteOffset, byteLength) {
    if (arguments.length === 0) {
      buffer = new exports.ArrayBuffer(0);
    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
      throw new TypeError("TypeError");
    }

    this.buffer = buffer || new exports.ArrayBuffer(0);

    this.byteOffset = ECMAScript.ToUint32(byteOffset);
    if (this.byteOffset > this.buffer.byteLength) {
      throw new RangeError("byteOffset out of range");
    }

    if (arguments.length < 3) {
      this.byteLength = this.buffer.byteLength - this.byteOffset;
    } else {
      this.byteLength = ECMAScript.ToUint32(byteLength);
    }

    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
    }

    configureProperties(this);
  };

  function makeGetter(arrayType) {
    return function(byteOffset, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);

      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }
      byteOffset += this.byteOffset;

      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
          bytes = [], i;
      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(uint8Array, i));
      }

      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
    };
  }

  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

  function makeSetter(arrayType) {
    return function(byteOffset, value, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);
      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
        throw new RangeError("Array index out of range");
      }

      // Get bytes
      var typeArray = new arrayType([value]),
          byteArray = new exports.Uint8Array(typeArray.buffer),
          bytes = [], i, byteView;

      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
        bytes.push(r(byteArray, i));
      }

      // Flip if necessary
      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      // Write them
      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
      byteView.set(bytes);
    };
  }

  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

  exports.DataView = exports.DataView || DataView;

}());


/***/ }),

/***/ "./node_modules/universal-deep-strict-equal/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/universal-deep-strict-equal/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// port of https://github.com/nodejs/node/blob/v6.3.0/lib/assert.js#L145-L248

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



var Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer;
var compare = Buffer.compare;
var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var filter = __webpack_require__(/*! array-filter */ "./node_modules/array-filter/index.js");
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__ || (
    obj.constructor
      ? obj.constructor.prototype
      : Object.prototype
  );
};
function isEnumerable(obj, key) {
  return Object.prototype.propertyIsEnumerable.call(obj, key);
};
function pToString(obj) {
  return Object.prototype.toString.call(obj);
};
function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
function isDate(d) {
  return isObject(d) && pToString(d) === '[object Date]';
}
function isRegExp(re) {
  return isObject(re) && pToString(re) === '[object RegExp]';
}
var isArguments = (function () {
  function isArg(obj) {
    return isObject(obj) && pToString(obj) == '[object Arguments]';
  }
  // dealing with old IEs (There's no Arguments type)
  if (!isArg(arguments)) {
    return function(obj) {
      return isObject(obj) &&
        typeof obj.length === 'number' &&
        obj.length >= 0 &&
        pToString(obj) !== '[object Array]' &&
        pToString(obj.callee) === '[object Function]';
    };
  } else {
    return isArg;
  }
})();
function fromBufferSupport() {
  try {
    return typeof Buffer.from === 'function' && !!Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  } catch (e) {
    // Buffer.from under Node 4.x causes `TypeError: this is not a typed array.`
    return false;
  }
}
var toBuffer = (function () {
  // check whether Buffer constructor accepts ArrayBuffer or not
  function isBufferConstructorAcceptsArrayBuffer() {
    try {
      return typeof Uint8Array === 'function' && (new Buffer(new Uint8Array([1]).buffer)[0] === 1);
    } catch (e) {
      return false;
    }
  }
  if (isBufferConstructorAcceptsArrayBuffer()) {
    // Node 4.x
    return function (ab) {
      return new Buffer(ab);
    };
  } else {
    // Node 0.10.x and 0.12.x
    return function (ab) {
      var buffer = new Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
      return buffer;
    };
  }
})();
var bufferFrom = fromBufferSupport() ? Buffer.from : toBuffer;
var objectKeys = (function () {
  var OLD_V8_ARRAY_BUFFER_ENUM = ['BYTES_PER_ELEMENT','get','set','slice','subarray','buffer','length','byteOffset','byteLength'];
  var keys = Object.keys || __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
  return function objectKeys(obj) {
    // avoid iterating enumerable properties of ArrayBuffer under old V8
    if (isEnumerable(obj, 'buffer') &&
        isEnumerable(obj, 'byteOffset') &&
        isEnumerable(obj, 'byteLength')) {
      return filter(keys(obj), function (k) {
        return indexOf(OLD_V8_ARRAY_BUFFER_ENUM, k) === -1;
      });
    } else {
      return keys(obj);
    }
  };
})();

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (actual instanceof Buffer && expected instanceof Buffer) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (typeof ArrayBuffer === 'function' && typeof ArrayBuffer.isView === 'function' &&
             ArrayBuffer.isView(actual) && ArrayBuffer.isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(bufferFrom(actual.buffer),
                   bufferFrom(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = indexOf(memos.actual, actual);
    if (actualIndex !== -1) {
      if (actualIndex === indexOf(memos.expected, expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && getPrototypeOf(a) !== getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

module.exports = _deepEqual;


/***/ }),

/***/ "./node_modules/util-deprecate/node.js":
/*!*********************************************!*\
  !*** ./node_modules/util-deprecate/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(/*! util */ "util").deprecate;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/xmldom/dom-parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xmldom/dom-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(/*! ./sax */ "./node_modules/xmldom/sax.js").XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").DOMImplementation;
	exports.XMLSerializer = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),

/***/ "./node_modules/xmldom/dom.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/dom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/xmldom/sax.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/sax.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),

/***/ "./node_modules/xtend/mutable.js":
/*!***************************************!*\
  !*** ./node_modules/xtend/mutable.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./src/Context.ts":
/*!************************!*\
  !*** ./src/Context.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ./util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
class Context {
    constructor() {
        this.graphs = new Map();
        this.currentGraph = new rdfoo_1.Graph();
        this.graphs.set('default', this.currentGraph);
        this.currentNamespace = '';
        this.sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.Empty;
    }
    getCurrentGraph() {
        return this.currentGraph;
    }
    setCurrentGraph(name) {
        let g = this.graphs.get(name.toLowerCase());
        if (!g) {
            g = new rdfoo_1.Graph();
            this.graphs.set(name.toLowerCase(), g);
        }
        this.currentGraph = g;
    }
    getGraph(name) {
        let g = this.graphs.get(name.toLowerCase());
        return g;
    }
}
exports.default = Context;


/***/ }),

/***/ "./src/actions/ActionDef.ts":
/*!**********************************!*\
  !*** ./src/actions/ActionDef.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.def2usage = void 0;
function def2usage(def) {
    let out = '';
    let indent = 0;
    addLine(def.name);
    let doneOpts = new Set();
    // I like the --preposition-* opts like "for" and "within" to be before anything else in the help
    for (let forOpt of def.namedOpts.filter(opt => opt.name.indexOf('for') === 0 || opt.name.indexOf('within') === 0)) {
        doneOpts.add(forOpt);
        addLine(descNamedOpt(forOpt));
    }
    // then mandatory ones
    for (let opt of def.namedOpts.filter(opt => !opt.optional)) {
        if (!doneOpts.has(opt)) {
            doneOpts.add(opt);
            addLine(descNamedOpt(opt));
        }
    }
    // then everything else
    for (let opt of def.namedOpts) {
        if (!doneOpts.has(opt)) {
            doneOpts.add(opt);
            addLine(descNamedOpt(opt));
        }
    }
    // finally, positional args
    for (let opt of def.positionalOpts) {
        addLine(descPositionalOpt(opt));
    }
    return out;
    function addLine(line) {
        out += ' '.repeat(indent) + line + '\n';
        indent += 4;
    }
    function descNamedOpt(opt) {
        return [
            opt.optional === true ? '[' : '',
            opt.name.length > 0 ? '--' + opt.name : opt.name,
            ' ' + argType(opt),
            opt.optional === true ? ']' : '',
        ].join('');
    }
    function descPositionalOpt(opt) {
        return [
            opt.optional === true ? '[' : '<',
            opt.name,
            opt.optional === true ? ']' : '>',
        ].join('');
    }
    function argType(opt) {
        switch (opt.type.name) {
            case 'OptIdentity':
                return '<identity>';
            case 'OptSBOLVersion':
                return '<sbol-version>';
            case 'OptString':
                return '<string>';
            case 'OptURL':
                return '<url>';
            case 'OptVcParameters':
                return '<vc-params>';
            default:
                return '<arg>';
        }
    }
}
exports.def2usage = def2usage;


/***/ }),

/***/ "./src/actions/ActionResult.ts":
/*!*************************************!*\
  !*** ./src/actions/ActionResult.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.actionResultShowHelp = exports.actionResultAbort = exports.actionResult = exports.Outcome = void 0;
var Outcome;
(function (Outcome) {
    Outcome[Outcome["Abort"] = 0] = "Abort";
    Outcome[Outcome["ShowHelp"] = 1] = "ShowHelp";
    Outcome[Outcome["Continue"] = 2] = "Continue";
})(Outcome = exports.Outcome || (exports.Outcome = {}));
class ActionResult {
    constructor(output, outcome) {
        this.output = output;
        this.outcome = outcome;
        if (outcome === undefined) {
            this.outcome = Outcome.Continue;
        }
    }
}
exports.default = ActionResult;
function actionResult(output) {
    return new ActionResult(output, Outcome.Continue);
}
exports.actionResult = actionResult;
function actionResultAbort(output) {
    return new ActionResult(output, Outcome.Abort);
}
exports.actionResultAbort = actionResultAbort;
function actionResultShowHelp(output) {
    return new ActionResult(output, Outcome.ShowHelp);
}
exports.actionResultShowHelp = actionResultShowHelp;


/***/ }),

/***/ "./src/actions/add-subcomponent.ts":
/*!*****************************************!*\
  !*** ./src/actions/add-subcomponent.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
let addSubcomponentAction = {
    name: 'create-component',
    description: 'Creates a component',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'within-component',
            type: OptIdentity_1.default,
            optional: true
        }
    ],
    positionalOpts: [],
    run: addSubcomponent
};
exports.default = addSubcomponentAction;
function addSubcomponent(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        // let [ optIdentity, optWithinComponentIdentity ] = namedOpts
        // assert(optIdentity instanceof OptIdentity)
        // assert(optWithinComponentIdentity instanceof OptIdentity)
        // let identity = optIdentity.getIdentity(g, Existence.MustNotExist)
        // assert(identity !== undefined)
        // if(identity.parentURI) {
        //     throw new ActionResult(text('Components cannot have parents, as they are designated top-level. To specify a component-subcomponent relationship, use the --within-component option.'), Outcome.Abort)
        // }
        // if(identity.sbolVersion === SBOLVersion.SBOL1) {
        //     let gv = new SBOL1GraphView(g)
        //     g.insertProperties(identity.uri, {
        //         [Predicates.a]: node.createUriNode(Types.SBOL1.DnaComponent),
        //         [Predicates.SBOL1.displayId]: node.createStringNode(identity.displayId)
        //     })
        //     let withinComponentIdentity = optWithinComponentIdentity.getIdentity(g)
        //     if(withinComponentIdentity !== undefined) {
        //         if(!g.hasMatch(withinComponentIdentity.uri, Predicates.a, Types.SBOL1.DnaComponent)) {
        //             throw new ActionResult(text(`DnaComponent with URI ${withinComponentIdentity.uri} not found for --within-component`), Outcome.Abort)
        //         }
        //         let annoURI = g.generateURI(withinComponentIdentity.uri + '_anno$n$')
        //         g.insertProperties(withinComponentIdentity.uri, {
        //             [Predicates.SBOL1.annotation]: node.createUriNode(annoURI),
        //         })
        //         g.insertProperties(annoURI, {
        //             [Predicates.a]: node.createUriNode(Types.SBOL1.SequenceAnnotation),
        //             [Predicates.SBOL1.subComponent]: node.createUriNode(identity.uri)
        //         })
        //     }
        return ActionResult_1.actionResult(output_1.text(''));
    });
}


/***/ }),

/***/ "./src/actions/annotate-range.ts":
/*!***************************************!*\
  !*** ./src/actions/annotate-range.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const OptURL_1 = __webpack_require__(/*! ./opt/OptURL */ "./src/actions/opt/OptURL.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const Opt1BasedInt_1 = __webpack_require__(/*! ./opt/Opt1BasedInt */ "./src/actions/opt/Opt1BasedInt.ts");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
let annotateRangeAction = {
    name: 'annotate-range',
    description: 'Annotates a range in a sequence',
    category: 'seq-anno',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'in-component',
            type: OptIdentity_1.default
        },
        {
            name: 'start',
            type: Opt1BasedInt_1.default
        },
        {
            name: 'end',
            type: Opt1BasedInt_1.default
        },
        {
            name: 'role',
            type: Opt1BasedInt_1.default
        }
    ],
    positionalOpts: [],
    run: annotateRange,
    help: `
`
};
exports.default = annotateRangeAction;
function annotateRange(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let [optIdentity, optInComponentIdentity, optSource, optEncoding] = namedOpts;
        let g = ctx.getCurrentGraph();
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optInComponentIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optSource instanceof OptURL_1.default);
        assert_1.strict(optEncoding instanceof OptString_1.default);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustExist);
        assert_1.strict(identity !== undefined);
        if (identity.sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
            throw new ActionResult_1.default(output_1.text('SBOL1 does not support sequence annotations without subcomponents.  Instead, create and assign a subcomponent using the create-component and add-subcomponent actions.'), ActionResult_1.Outcome.Abort);
        }
        return new ActionResult_1.default();
    });
}


/***/ }),

/***/ "./src/actions/compare.ts":
/*!********************************!*\
  !*** ./src/actions/compare.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptGraph_1 = __webpack_require__(/*! ./opt/OptGraph */ "./src/actions/opt/OptGraph.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const OptTriplePattern_1 = __webpack_require__(/*! ./opt/OptTriplePattern */ "./src/actions/opt/OptTriplePattern.ts");
let action = {
    name: 'compare',
    category: 'graphops',
    namedOpts: [
        {
            name: 'to',
            type: OptGraph_1.default,
            optional: false
        },
        {
            name: 'ignore',
            type: OptTriplePattern_1.default,
            optional: true
        }
    ],
    positionalOpts: [],
    run: graphCompare
};
exports.default = action;
function graphCompare(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let [to, ignore] = namedOpts;
        assert_1.strict(to instanceof OptGraph_1.default);
        assert_1.strict(!ignore || ignore instanceof OptTriplePattern_1.default);
        let ignorePattern = ignore ? ignore.getPattern() : null;
        let fromGraph = ctx.getCurrentGraph();
        let toGraph = to.getGraph(ctx);
        assert_1.strict(toGraph);
        let equal = true;
        let inFromOnly = [];
        let inToOnly = [];
        let subjects = new Set();
        for (let triple of fromGraph.toArray()) {
            if (ignorePattern) {
                if (ignorePattern.s.test(triple.subject.nominalValue) &&
                    ignorePattern.p.test(triple.predicate.nominalValue) &&
                    ignorePattern.o.test(triple.object.nominalValue)) {
                    continue;
                }
            }
            if (!toGraph.hasMatch(triple.subject, triple.predicate, triple.object)) {
                equal = false;
                inFromOnly.push([
                    triple.subject.nominalValue,
                    triple.predicate.nominalValue === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
                        ? 'a' : triple.predicate.nominalValue,
                    triple.object.nominalValue
                ]);
                subjects.add(triple.subject.nominalValue);
                subjects.add(triple.object.nominalValue);
            }
        }
        for (let triple of toGraph.toArray()) {
            if (ignorePattern) {
                if (ignorePattern.s.test(triple.subject.nominalValue) &&
                    ignorePattern.p.test(triple.predicate.nominalValue) &&
                    ignorePattern.o.test(triple.object.nominalValue)) {
                    continue;
                }
            }
            if (!fromGraph.hasMatch(triple.subject, triple.predicate, triple.object)) {
                equal = false;
                inToOnly.push([
                    triple.subject.nominalValue,
                    triple.predicate.nominalValue === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
                        ? 'a' : triple.predicate.nominalValue,
                    triple.object.nominalValue
                ]);
                subjects.add(triple.subject.nominalValue);
                subjects.add(triple.object.nominalValue);
            }
        }
        let typesInFrom = [];
        let typesInTo = [];
        for (let subject of subjects) {
            let type = rdfoo_1.triple.objectUri(fromGraph.match(subject, bioterms_1.Predicates.a, null)[0]);
            if (type)
                typesInFrom.push([subject, 'a', type]);
        }
        for (let subject of subjects) {
            let type = rdfoo_1.triple.objectUri(toGraph.match(subject, bioterms_1.Predicates.a, null)[0]);
            if (type)
                typesInTo.push([subject, 'a', type]);
        }
        let out = [];
        if (equal) {
            out.push(output_1.text('compare: Graphs were equal'));
            return ActionResult_1.actionResult(output_1.group(out));
        }
        else {
            out.push(output_1.text('compare: Graphs were not equal'));
            out.push(output_1.spacer());
            if (inFromOnly.length > 0) {
                out.push(output_1.spacer());
                out.push(output_1.text('In current graph but not comparison graph:'));
                out.push(output_1.indent([
                    output_1.tabulated(inFromOnly)
                ]));
            }
            if (inToOnly.length > 0) {
                out.push(output_1.spacer());
                out.push(output_1.text('In comparison graph but not current graph:'));
                out.push(output_1.indent([
                    output_1.tabulated(inToOnly)
                ]));
            }
            /*
            if(typesInFrom.length > 0) {
                out.push(spacer())
                out.push(text('Types in current graph:'))
                out.push(indent([
                    tabulated(typesInFrom)
                ]))
            }
    
            if(typesInTo.length > 0) {
                out.push(spacer())
                out.push(text('Types in comparison graph:'))
                out.push(indent([
                    tabulated(typesInTo)
                ]))
            }*/
            return ActionResult_1.actionResultAbort(output_1.group(out));
        }
    });
}


/***/ }),

/***/ "./src/actions/components.ts":
/*!***********************************!*\
  !*** ./src/actions/components.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const dnaComponentTree_1 = __webpack_require__(/*! ../sbol1/dnaComponentTree */ "./src/sbol1/dnaComponentTree.ts");
const componentTree_1 = __webpack_require__(/*! ../sbol3/componentTree */ "./src/sbol3/componentTree.ts");
const cdTree_1 = __webpack_require__(/*! ../sbol2/cdTree */ "./src/sbol2/cdTree.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
let componentsAction = {
    name: 'components',
    category: 'other',
    namedOpts: [],
    positionalOpts: [],
    run: components
};
exports.default = componentsAction;
function components(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        let output = [];
        let g1 = new sbolgraph_1.SBOL1GraphView(g);
        if (g1.dnaComponents.length > 0) {
            output.push(output_1.group([
                output_1.header('SBOL1 DnaComponents'),
                output_1.spacer(),
                dnaComponentTree_1.dnaComponentTree(g1),
                output_1.spacer()
            ]));
        }
        let g2 = new sbolgraph_1.SBOL2GraphView(g);
        if (g2.componentDefinitions.length > 0) {
            output.push(output_1.group([
                output_1.header('SBOL2 ComponentDefinitions'),
                output_1.spacer(),
                cdTree_1.cdTree(g2),
                output_1.spacer()
            ]));
        }
        if (g2.moduleDefinitions.length > 0) {
            output.push(output_1.group([
                output_1.header('SBOL2 ModuleDefinitions'),
                output_1.spacer(),
                cdTree_1.cdTree(g2),
                output_1.spacer()
            ]));
        }
        let g3 = new sbolgraph_1.SBOL3GraphView(g);
        if (g3.components.length > 0) {
            output.push(output_1.group([
                output_1.header('SBOL3 Components'),
                output_1.spacer(),
                componentTree_1.componentTree(new sbolgraph_1.SBOL3GraphView(g)),
                output_1.spacer()
            ]));
        }
        return new ActionResult_1.default(output_1.group(output));
    });
}


/***/ }),

/***/ "./src/actions/convert.ts":
/*!********************************!*\
  !*** ./src/actions/convert.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptSBOLVersion_1 = __webpack_require__(/*! ./opt/OptSBOLVersion */ "./src/actions/opt/OptSBOLVersion.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const OptFlag_1 = __webpack_require__(/*! ./opt/OptFlag */ "./src/actions/opt/OptFlag.ts");
const node_fetch_1 = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/lib/index.mjs");
const get_sbol_version_from_graph_2 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
let convertAction = {
    name: 'convert',
    category: 'local-conversion',
    namedOpts: [
        {
            name: 'target',
            type: OptSBOLVersion_1.default,
            refinements: {
                infer: false
            }
        },
        {
            name: 'online',
            type: OptFlag_1.default,
            optional: true
        }
    ],
    positionalOpts: [],
    run: convert
};
exports.default = convertAction;
function convert(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        let [target, online] = namedOpts;
        assert_1.strict(target instanceof OptSBOLVersion_1.default);
        assert_1.strict(online instanceof OptFlag_1.default);
        let sbolVersion = target.getSBOLVersion(g);
        if (online.isSet()) {
            return convertVC(g, sbolVersion);
        }
        else {
            return convertOffline(g, sbolVersion);
        }
    });
}
function convertOffline(g, sbolVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
            print_1.trace(output_1.text('Offline converting 3->2 and 2->1'));
            yield sbolgraph_1.SBOLConverter.convert3to2(g);
            yield sbolgraph_1.SBOLConverter.convert2to1(g);
        }
        else if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL2) {
            print_1.trace(output_1.text('Offline converting 1->2 and 3->2'));
            yield sbolgraph_1.SBOLConverter.convert1to2(g);
            yield sbolgraph_1.SBOLConverter.convert3to2(g);
        }
        else if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL3) {
            print_1.trace(output_1.text('Offline converting 1->2 and 2->3'));
            yield sbolgraph_1.SBOLConverter.convert1to2(g);
            yield sbolgraph_1.SBOLConverter.convert2to3(g);
        }
        else {
            return new ActionResult_1.default(output_1.text('convert: target must be one of sbol1, sbol2, sbol3'), ActionResult_1.Outcome.Abort);
        }
        return ActionResult_1.actionResult();
    });
}
function convertVC(g, sbolVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        // let target = opts.getString('target', 'sbol2').toUpperCase()
        // let check_uri_compliance = opts.getBoolean('check-uri-compliance', true)
        // let check_completeness = opts.getBoolean('check-completeness', true)
        // let check_best_practices = opts.getBoolean('check-best-practices', false)
        // let fail_on_first_error = opts.getBoolean('fail-on-first-error', false)
        // let provide_detailed_stack_trace = opts.getBoolean('provide-detailed-stack-trace', false)
        // let subset_uri = opts.getString('subset-uri', '')
        // let uri_prefix = opts.getString('uri-prefix', '')
        // let version = opts.getString('version', '')
        // let insert_type = opts.getBoolean('insert-type', false)
        let sourceVersion = get_sbol_version_from_graph_2.getSBOLVersionFromGraph(g);
        let xml = '';
        if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
            xml = new sbolgraph_1.SBOL1GraphView(g).serializeXML();
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL2) {
            xml = new sbolgraph_1.SBOL2GraphView(g).serializeXML();
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL3) {
            throw new ActionResult_1.default(output_1.text('convert: cannot convert from SBOL3 using the online validator/converter'), ActionResult_1.Outcome.Abort);
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.Mixed) {
            throw new ActionResult_1.default(output_1.text('convert: graph has mixed SBOL versions so cannot use online validator/converter'), ActionResult_1.Outcome.Abort);
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.Empty) {
            xml = new sbolgraph_1.SBOL2GraphView(g).serializeXML();
        }
        else {
            throw new ActionResult_1.default(output_1.text('convert: unknown source SBOLVersion ' + sourceVersion));
        }
        let target = '';
        if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
            target = 'sbol1';
        }
        else if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL2) {
            target = 'sbol2';
        }
        else if (sbolVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL3) {
            throw new ActionResult_1.default(output_1.text('convert: cannot convert to SBOL3 using the online validator/converter'), ActionResult_1.Outcome.Abort);
        }
        else {
            throw new ActionResult_1.default(output_1.text('convert: unknown SBOLVersion ' + sbolVersion));
        }
        print_1.trace(output_1.text(`convert: target language sent to validator/converter is ${target.toUpperCase()}`));
        let body = {
            options: {
                language: target.toUpperCase(),
                test_equality: false,
                check_uri_compliance: false,
                check_completeness: false,
                check_best_practices: false,
                fail_on_first_error: false,
                provide_detailed_stack_trace: false,
                subset_uri: '',
                uri_prefix: '',
                version: '',
                insert_type: false,
                main_file_name: 'main file',
                diff_file_name: 'comparison file'
            },
            main_file: xml,
            return_file: true
        };
        let r = yield node_fetch_1.default('https://validator.sbolstandard.org/validate/', {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        try {
            var response = yield r.json();
        }
        catch (e) {
            return ActionResult_1.actionResult(output_1.text('The online validator/converter failed: ' + e));
        }
        let { valid, check_equality, equality, errors, output_file, result } = response;
        let output = [];
        if (!valid) {
            throw ActionResult_1.actionResult(output_1.group([
                output_1.spacer(),
                output_1.text('The online validator/converter said the SBOL sent by sboltools was invalid'),
                output_1.text('This should not happen, and is likely indicative of a bug in sboltools'),
                output_1.spacer()
            ]));
        }
        errors = errors.filter(e => e.trim() != '');
        if (!valid) {
            if (errors.length > 0) {
                output.push(output_1.spacer());
                output.push(output_1.group(errors.map(e => output_1.text('Online validator error: ' + e))));
                output.push(output_1.spacer());
            }
        }
        if (result) {
            // console.log('before delete')
            // console.log(new SBOL3GraphView(g).serializeXML())
            if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
                for (let topLevel of new sbolgraph_1.SBOL1GraphView(g).topLevels) {
                    topLevel.destroy();
                }
            }
            else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL2) {
                for (let topLevel of new sbolgraph_1.SBOL2GraphView(g).topLevels) {
                    topLevel.destroy();
                }
            }
            // console.log('after delete')
            // console.log(new SBOL3GraphView(g).serializeXML())
            g.addAll(yield rdfoo_1.Graph.loadString(result, 'http://dummyprefix/', 'application/rdf+xml'));
        }
        return ActionResult_1.actionResult(output_1.group(output));
    });
}


/***/ }),

/***/ "./src/actions/create-component.ts":
/*!*****************************************!*\
  !*** ./src/actions/create-component.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const Identity_1 = __webpack_require__(/*! ../identity/Identity */ "./src/identity/Identity.ts");
const sbol2_compliant_concat_1 = __webpack_require__(/*! ../util/sbol2-compliant-concat */ "./src/util/sbol2-compliant-concat.ts");
const join_uri_fragments_1 = __webpack_require__(/*! ../util/join-uri-fragments */ "./src/util/join-uri-fragments.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
let createComponentAction = {
    name: 'component',
    description: 'Creates a component',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'type',
            type: OptTerm_1.default
        },
        {
            name: 'role',
            type: OptTerm_1.default
        }
    ],
    positionalOpts: [],
    run: createComponent
};
exports.default = createComponentAction;
function createComponent(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createComponent'));
        let [optIdentity, optType, optRole] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optType instanceof OptTerm_1.default);
        assert_1.strict(optRole instanceof OptTerm_1.default);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist);
        assert_1.strict(identity !== undefined);
        let parentURI = '';
        /*
            In order to enable the shorthand for creating subcomponents with their
            components at the same time
            the component creation action operates in two ways:
            - If no parent is specified, we create a component with the identity
            - If a parent is specified, we create two things:
                (1) A Component top-level using only the namespace and displayId of the identity
                (2) A SubComponent with the specified identity
                     which is an instanceOf the Component
        */
        if (identity.parentURI) {
            parentURI = identity.parentURI;
            identity = Identity_1.default.toplevel_from_namespace_displayId(IdentityFactory_1.Existence.MustNotExist, identity.sbolVersion, g, identity.namespace, identity.displayId, identity.version);
        }
        print_1.trace(output_1.text('Create component: identity: ' + identity.uri + ', parent identity: ' + parentURI));
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL1:
                return createComponentSBOL1(g, identity, optType, optRole, parentURI);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createComponentSBOL2(g, identity, optType, optRole, parentURI);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                return createComponentSBOL3(g, identity, optType, optRole, parentURI);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-component'));
        }
        return new ActionResult_1.default();
    });
}
function createComponentSBOL1(g, identity, optType, optRole, parentURI) {
    let gv = new sbolgraph_1.SBOL1GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaComponent),
        [bioterms_1.Predicates.SBOL1.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
    });
    if (parentURI) {
        if (!g.hasMatch(parentURI, bioterms_1.Predicates.a, bioterms_1.Types.SBOL1.DnaComponent)) {
            throw new ActionResult_1.default(output_1.text(`Parent DnaComponent with URI ${identity.parentURI} not found`), ActionResult_1.Outcome.Abort);
        }
        let annoURI = g.generateURI(parentURI + '_anno$n$');
        g.insertProperties(parentURI, {
            [bioterms_1.Predicates.SBOL1.annotation]: rdfoo_1.node.createUriNode(annoURI),
        });
        g.insertProperties(annoURI, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.SequenceAnnotation),
            [bioterms_1.Predicates.SBOL1.subComponent]: rdfoo_1.node.createUriNode(identity.uri)
        });
    }
    return new ActionResult_1.default();
}
function createComponentSBOL2(g, identity, optType, optRole, parentURI) {
    let type = optType.getTerm(OptTerm_1.TermType.Role);
    if (!type) {
        throw new ActionResult_1.default(output_1.text(`--type parameter is required for component create action`), ActionResult_1.Outcome.Abort);
    }
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.ComponentDefinition),
        [bioterms_1.Predicates.SBOL2.type]: rdfoo_1.node.createUriNode(type),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
    });
    if (identity.version !== undefined) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    if (parentURI) {
        if (!g.hasMatch(parentURI, bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ComponentDefinition)) {
            throw new ActionResult_1.default(output_1.text(`Parent ComponentDefinition with URI ${identity.parentURI} not found`), ActionResult_1.Outcome.Abort);
        }
        let scURI = g.generateURI(sbol2_compliant_concat_1.default(g, parentURI, identity.displayId));
        g.insertProperties(parentURI, {
            [bioterms_1.Predicates.SBOL2.component]: rdfoo_1.node.createUriNode(scURI),
        });
        g.insertProperties(scURI, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Component),
            [bioterms_1.Predicates.SBOL2.definition]: rdfoo_1.node.createUriNode(identity.uri),
            [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
        });
    }
    return new ActionResult_1.default();
}
function createComponentSBOL3(g, identity, optType, optRole, parentURI) {
    let type = optType.getTerm(OptTerm_1.TermType.Role);
    if (!type) {
        throw new ActionResult_1.default(output_1.text(`--type parameter is required for component create action`), ActionResult_1.Outcome.Abort);
    }
    let gv = new sbolgraph_1.SBOL3GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.Component),
        [bioterms_1.Predicates.SBOL3.type]: rdfoo_1.node.createUriNode(type),
        [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
    });
    if (parentURI) {
        if (!g.hasMatch(parentURI, bioterms_1.Predicates.a, bioterms_1.Types.SBOL3.Component)) {
            throw new ActionResult_1.default(output_1.text(`Parent Component with URI ${identity.parentURI} not found`), ActionResult_1.Outcome.Abort);
        }
        let scURI = g.generateURI(join_uri_fragments_1.default([parentURI, 'subcomponent$n$']));
        let scDisplayId = scURI.split('/').pop() || identity.displayId;
        g.insertProperties(parentURI, {
            [bioterms_1.Predicates.SBOL3.hasFeature]: rdfoo_1.node.createUriNode(scURI),
        });
        g.insertProperties(scURI, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.SubComponent),
            [bioterms_1.Predicates.SBOL3.instanceOf]: rdfoo_1.node.createUriNode(identity.uri),
            [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(scDisplayId)
        });
    }
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-constraint.ts":
/*!******************************************!*\
  !*** ./src/actions/create-constraint.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
let createConstraintAction = {
    name: 'constraint',
    description: 'Creates a constraint',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'subject',
            type: OptIdentity_1.default,
            optional: false
        },
        {
            name: 'restriction',
            type: OptTerm_1.default,
            optional: false
        },
        {
            name: 'object',
            type: OptIdentity_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: createConstraint
};
exports.default = createConstraintAction;
function createConstraint(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createConstraint'));
        let [optIdentity, optSubject, optRestriction, optObject] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optSubject instanceof OptIdentity_1.default);
        assert_1.strict(optRestriction instanceof OptTerm_1.default);
        assert_1.strict(optObject instanceof OptIdentity_1.default);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist);
        assert_1.strict(identity !== undefined);
        if (!identity.parentURI) {
            throw new ActionResult_1.default(output_1.text('Constraint must be contained in a component'));
        }
        let subjectIdentity = optSubject.getIdentity(ctx, IdentityFactory_1.Existence.MustExist);
        if (!subjectIdentity) {
            throw new ActionResult_1.default(output_1.text('Constraint subject does not exist'));
        }
        if (subjectIdentity.parentURI !== identity.parentURI) {
            throw new ActionResult_1.default(output_1.text('Constraint subject must have the same parent as the constraint'));
        }
        let objectIdentity = optSubject.getIdentity(ctx, IdentityFactory_1.Existence.MustExist);
        if (!objectIdentity) {
            throw new ActionResult_1.default(output_1.text('Constraint object does not exist'));
        }
        if (objectIdentity.parentURI !== identity.parentURI) {
            throw new ActionResult_1.default(output_1.text('Constraint object must have the same parent as the constraint'));
        }
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createConstraintSBOL2(g, identity, subjectIdentity, optRestriction, objectIdentity);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                return createConstraintSBOL3(g, identity, subjectIdentity, optRestriction, objectIdentity);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-component'));
        }
        return new ActionResult_1.default();
    });
}
function createConstraintSBOL2(g, identity, subject, optRestriction, object) {
    let restriction = optRestriction.getTerm(OptTerm_1.TermType.RestrictionSBOL2);
    assert_1.strict(restriction);
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.SequenceConstraint),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Predicates.SBOL2.restriction]: rdfoo_1.node.createUriNode(restriction)
    });
    if (identity.version !== undefined) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    assert_1.strict(identity.parentURI);
    g.insertProperties(identity.parentURI, {
        [bioterms_1.Predicates.SBOL2.sequenceConstraint]: rdfoo_1.node.createUriNode(identity.uri),
    });
    return new ActionResult_1.default();
}
function createConstraintSBOL3(g, identity, subject, optRestriction, object) {
    let restriction = optRestriction.getTerm(OptTerm_1.TermType.RestrictionSBOL3);
    assert_1.strict(restriction);
    let gv = new sbolgraph_1.SBOL3GraphView(g);
    let namespace = identity.namespace;
    assert_1.strict(namespace);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.Constraint),
        [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Prefixes.sbol3 + 'namespace']: rdfoo_1.node.createUriNode(identity.namespace),
    });
    assert_1.strict(identity.parentURI);
    g.insertProperties(identity.parentURI, {
        [bioterms_1.Predicates.SBOL3.hasConstraint]: rdfoo_1.node.createUriNode(identity.uri),
    });
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-interaction.ts":
/*!*******************************************!*\
  !*** ./src/actions/create-interaction.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const Identity_1 = __webpack_require__(/*! ../identity/Identity */ "./src/identity/Identity.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
let createInteractionAction = {
    name: 'interaction',
    description: 'Creates an interaction',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'within-component',
            type: OptIdentity_1.default,
            optional: true
        },
        {
            name: 'type',
            type: OptTerm_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: createInteraction
};
exports.default = createInteractionAction;
function createInteraction(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createInteraction'));
        let [optIdentity, optWithinComponentIdentity, optRole] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optWithinComponentIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optRole instanceof OptTerm_1.default);
        let withinComponentIdentity = optWithinComponentIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MayExist);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist, withinComponentIdentity);
        assert_1.strict(identity !== undefined);
        if (!withinComponentIdentity) {
            if (identity.parentURI) {
                withinComponentIdentity = Identity_1.default.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, identity.sbolVersion, g, identity.namespace, identity.parentURI, identity.version);
            }
        }
        assert_1.strict(withinComponentIdentity !== undefined);
        if (!withinComponentIdentity) {
            throw new ActionResult_1.default(output_1.text('Components cannot have parents, as they are designated top-level. To specify a component-subcomponent relationship, use the --within-component option.'), ActionResult_1.Outcome.Abort);
        }
        let role = optRole.getTerm(OptTerm_1.TermType.InteractionType);
        assert_1.strict(role);
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createInteractionSBOL2(g, identity, withinComponentIdentity, role);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                return createInteractionSBOL3(g, identity, withinComponentIdentity, role);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-component'));
        }
        return new ActionResult_1.default();
    });
}
function createInteractionSBOL2(g, identity, withinComponentIdentity, type) {
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Interaction),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Predicates.SBOL2.type]: rdfoo_1.node.createUriNode(type)
    });
    if (identity.version !== undefined) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    g.insertProperties(withinComponentIdentity.uri, {
        [bioterms_1.Predicates.SBOL2.interaction]: rdfoo_1.node.createUriNode(identity.uri),
    });
    return new ActionResult_1.default();
}
function createInteractionSBOL3(g, identity, withinComponentIdentity, type) {
    let gv = new sbolgraph_1.SBOL3GraphView(g);
    let namespace = identity.namespace;
    assert_1.strict(namespace);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.Interaction),
        [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
    });
    g.insertProperties(withinComponentIdentity.uri, {
        [bioterms_1.Predicates.SBOL3.hasInteraction]: rdfoo_1.node.createUriNode(identity.uri),
    });
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-module.ts":
/*!**************************************!*\
  !*** ./src/actions/create-module.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const sbol2_compliant_concat_1 = __webpack_require__(/*! ../util/sbol2-compliant-concat */ "./src/util/sbol2-compliant-concat.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
let createModuleAction = {
    name: 'module',
    description: 'Creates a module (SBOL2 only)',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'within-module',
            type: OptIdentity_1.default,
            optional: true
        }
    ],
    positionalOpts: [],
    run: createModule
};
exports.default = createModuleAction;
function createModule(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createModule'));
        let [optIdentity, optWithinModuleIdentity] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optWithinModuleIdentity instanceof OptIdentity_1.default);
        print_1.trace(output_1.text(`Getting withinModuleIdentity`));
        let withinModuleIdentity = optWithinModuleIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustExist);
        print_1.trace(output_1.text(`Got withinModuleIdentity: ${withinModuleIdentity}`));
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist, withinModuleIdentity);
        assert_1.strict(identity !== undefined);
        if (identity.parentURI) {
            throw new ActionResult_1.default(output_1.text('Modules cannot have parents, as they are designated top-level. To specify a module-submodule relationship, use the --within-module option.'), ActionResult_1.Outcome.Abort);
        }
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createModuleSBOL2(g, identity, withinModuleIdentity);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-module'));
        }
        return new ActionResult_1.default();
    });
}
function createModuleSBOL2(g, identity, withinModuleIdentity) {
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.ModuleDefinition),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId)
    });
    if (identity.version !== undefined) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    if (withinModuleIdentity !== undefined) {
        if (!g.hasMatch(withinModuleIdentity.uri, bioterms_1.Predicates.a, bioterms_1.Types.SBOL2.ModuleDefinition)) {
            throw new ActionResult_1.default(output_1.text(`ModuleDefinition with URI ${withinModuleIdentity.uri} not found for --within-Module`), ActionResult_1.Outcome.Abort);
        }
        let scURI = g.generateURI(sbol2_compliant_concat_1.default(g, withinModuleIdentity.uri, 'subModule$n$'));
        g.insertProperties(withinModuleIdentity.uri, {
            [bioterms_1.Predicates.SBOL2.module]: rdfoo_1.node.createUriNode(scURI),
        });
        g.insertProperties(scURI, {
            [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Module),
            [bioterms_1.Predicates.SBOL2.definition]: rdfoo_1.node.createUriNode(identity.uri),
        });
    }
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-participant.ts":
/*!*******************************************!*\
  !*** ./src/actions/create-participant.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const Identity_1 = __webpack_require__(/*! ../identity/Identity */ "./src/identity/Identity.ts");
const join_uri_fragments_1 = __webpack_require__(/*! ../util/join-uri-fragments */ "./src/util/join-uri-fragments.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
let createParticipantAction = {
    name: 'participant',
    description: 'Shorthand for creating a participation with a participant',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'within-interaction',
            type: OptIdentity_1.default,
            optional: true
        },
        {
            name: 'role',
            type: OptTerm_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: createParticipant
};
exports.default = createParticipantAction;
function createParticipant(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createParticipant'));
        let [optIdentity, optWithinInteractionIdentity, optRole] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optWithinInteractionIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optRole instanceof OptTerm_1.default);
        let withinInteractionIdentity = optWithinInteractionIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MayExist);
        // identity of the subcomponent to use as a participant
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustExist, withinInteractionIdentity);
        assert_1.strict(identity !== undefined);
        if (!withinInteractionIdentity) {
            if (identity.parentURI) {
                withinInteractionIdentity = Identity_1.default.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, identity.sbolVersion, g, identity.namespace, identity.parentURI, identity.version);
            }
        }
        assert_1.strict(withinInteractionIdentity !== undefined);
        if (!withinInteractionIdentity) {
            throw new ActionResult_1.default(output_1.text('Participation must be contained by an interaction'));
        }
        let role = optRole.getTerm(OptTerm_1.TermType.ParticipationRole);
        assert_1.strict(role);
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createParticipantSBOL2(g, identity, withinInteractionIdentity, role);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                return createParticipantSBOL3(g, identity, withinInteractionIdentity, role);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for participant action'));
        }
        return new ActionResult_1.default();
    });
}
function createParticipantSBOL2(g, participantIdentity, withinInteractionIdentity, role) {
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    let participationURI = g.generateURI(join_uri_fragments_1.default([withinInteractionIdentity.uri, 'participation$n$']));
    let participationDisplayId = participationURI.split('/').pop();
    g.insertProperties(participationURI, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Participation),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(participationDisplayId),
        [bioterms_1.Predicates.SBOL2.role]: rdfoo_1.node.createUriNode(role),
        [bioterms_1.Predicates.SBOL2.participant]: rdfoo_1.node.createUriNode(participantIdentity.uri)
    });
    g.insertProperties(withinInteractionIdentity.uri, {
        [bioterms_1.Predicates.SBOL2.participation]: rdfoo_1.node.createUriNode(participationURI),
    });
    return new ActionResult_1.default();
}
function createParticipantSBOL3(g, participantIdentity, withinInteractionIdentity, role) {
    let gv = new sbolgraph_1.SBOL3GraphView(g);
    let participationURI = g.generateURI(join_uri_fragments_1.default([withinInteractionIdentity.uri, 'participation$n$']));
    let participationDisplayId = participationURI.split('/').pop();
    g.insertProperties(participationURI, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.Participation),
        [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(participationDisplayId),
        [bioterms_1.Predicates.SBOL3.role]: rdfoo_1.node.createUriNode(role),
        [bioterms_1.Predicates.SBOL3.participant]: rdfoo_1.node.createUriNode(participantIdentity.uri)
    });
    g.insertProperties(withinInteractionIdentity.uri, {
        [bioterms_1.Predicates.SBOL3.hasParticipation]: rdfoo_1.node.createUriNode(participationURI),
    });
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-participation.ts":
/*!*********************************************!*\
  !*** ./src/actions/create-participation.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const Identity_1 = __webpack_require__(/*! ../identity/Identity */ "./src/identity/Identity.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
let createParticipationAction = {
    name: 'participation',
    description: 'Creates a participation',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'within-interaction',
            type: OptIdentity_1.default,
            optional: true
        },
        {
            name: 'participant',
            type: OptIdentity_1.default,
            optional: true
        },
        {
            name: 'role',
            type: OptTerm_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: createParticipation
};
exports.default = createParticipationAction;
function createParticipation(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        print_1.trace(output_1.text('createParticipation'));
        let [optIdentity, optWithinInteractionIdentity, optParticipant, optRole] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optWithinInteractionIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optParticipant instanceof OptIdentity_1.default);
        assert_1.strict(optRole instanceof OptTerm_1.default);
        print_1.trace(output_1.text(`createParticipation participant ${JSON.stringify(optParticipant.optDef)}`));
        let withinInteractionIdentity = optWithinInteractionIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MayExist);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist, withinInteractionIdentity);
        assert_1.strict(identity !== undefined);
        if (!withinInteractionIdentity) {
            if (identity.parentURI) {
                withinInteractionIdentity = Identity_1.default.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, identity.sbolVersion, g, identity.namespace, identity.parentURI, identity.version);
            }
        }
        assert_1.strict(withinInteractionIdentity !== undefined);
        if (!withinInteractionIdentity) {
            throw new ActionResult_1.default(output_1.text('Participation must be contained by an interaction'));
        }
        let participantIdentity = optParticipant.getIdentity(ctx, IdentityFactory_1.Existence.MustExist, withinInteractionIdentity);
        assert_1.strict(participantIdentity);
        let role = optRole.getTerm(OptTerm_1.TermType.ParticipationRole);
        assert_1.strict(role);
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                return createParticipationSBOL2(g, identity, withinInteractionIdentity, participantIdentity, role);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                return createParticipationSBOL3(g, identity, withinInteractionIdentity, participantIdentity, role);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-component'));
        }
        return new ActionResult_1.default();
    });
}
function createParticipationSBOL2(g, identity, withinInteractionIdentity, participantIdentity, role) {
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Participation),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Predicates.SBOL2.role]: rdfoo_1.node.createUriNode(role)
    });
    if (identity.version !== undefined) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    g.insertProperties(withinInteractionIdentity.uri, {
        [bioterms_1.Predicates.SBOL2.participation]: rdfoo_1.node.createUriNode(identity.uri),
    });
    if (participantIdentity) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.participant]: rdfoo_1.node.createUriNode(participantIdentity.uri)
        });
    }
    return new ActionResult_1.default();
}
function createParticipationSBOL3(g, identity, withinInteractionIdentity, participantIdentity, role) {
    let gv = new sbolgraph_1.SBOL3GraphView(g);
    let namespace = identity.namespace;
    assert_1.strict(namespace);
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL3.Participation),
        [bioterms_1.Predicates.SBOL3.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Predicates.SBOL3.role]: rdfoo_1.node.createUriNode(role)
    });
    g.insertProperties(withinInteractionIdentity.uri, {
        [bioterms_1.Predicates.SBOL3.hasParticipation]: rdfoo_1.node.createUriNode(identity.uri),
    });
    if (participantIdentity) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL3.participant]: rdfoo_1.node.createUriNode(participantIdentity.uri)
        });
    }
    return new ActionResult_1.default();
}


/***/ }),

/***/ "./src/actions/create-sequence.ts":
/*!****************************************!*\
  !*** ./src/actions/create-sequence.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptIdentity_1 = __webpack_require__(/*! ./opt/OptIdentity */ "./src/actions/opt/OptIdentity.ts");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const OptURL_1 = __webpack_require__(/*! ./opt/OptURL */ "./src/actions/opt/OptURL.ts");
const IdentityFactory_1 = __webpack_require__(/*! ../identity/IdentityFactory */ "./src/identity/IdentityFactory.ts");
const OptTerm_1 = __webpack_require__(/*! ./opt/OptTerm */ "./src/actions/opt/OptTerm.ts");
const import_to_graph_1 = __webpack_require__(/*! ./helpers/import-to-graph */ "./src/actions/helpers/import-to-graph.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
let createSequenceAction = {
    name: 'sequence',
    description: 'Creates a sequence',
    category: 'object-cd',
    namedOpts: [
        {
            name: '',
            type: OptIdentity_1.default
        },
        {
            name: 'for-component',
            type: OptIdentity_1.default
        },
        {
            name: 'source',
            type: OptURL_1.default
        },
        {
            name: 'encoding',
            type: OptTerm_1.default
        }
    ],
    positionalOpts: [],
    run: createSequence,
    help: `
If the sequence identity is not specified, a default identity will be created from the component identity with \`_seq\` appended to its displayId.

If the encoding is not specified, it will be inferred from the component in the case that \`--for-component\` is specified (e.g. a DNA component will result in a nucleic acid sequence being created).

If such inference is not possible (e.g. no component is specified, or the specified component is of a type other than DNA, RNA, or Protein), an error will be thrown.
`
};
exports.default = createSequenceAction;
function createSequence(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        let [optIdentity, optForComponentIdentity, optSource, optEncoding] = namedOpts;
        assert_1.strict(optIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optSource instanceof OptURL_1.default);
        assert_1.strict(optForComponentIdentity instanceof OptIdentity_1.default);
        assert_1.strict(optEncoding instanceof OptTerm_1.default);
        let forComponentIdentity = optForComponentIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustExist);
        let identity = optIdentity.getIdentity(ctx, IdentityFactory_1.Existence.MustNotExist);
        assert_1.strict(identity !== undefined);
        let source = yield optSource.downloadToString();
        let sourceG = new rdfoo_1.Graph();
        yield import_to_graph_1.default(sourceG, source, 'sbol3');
        let sourceGV = new sbolgraph_1.SBOL3GraphView(sourceG);
        if (sourceGV.sequences.length !== 1) {
            throw new ActionResult_1.default(output_1.text('Source did not evaluate to exactly one sequence'));
        }
        let elements = sourceGV.sequences[0].elements;
        assert_1.strict(elements);
        switch (identity.sbolVersion) {
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL1:
                return createSequenceSBOL1(g, identity, forComponentIdentity, encoding, elements);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
                var encoding = optEncoding.getTerm(OptTerm_1.TermType.SequenceEncodingSBOL2);
                return createSequenceSBOL2(g, identity, forComponentIdentity, encoding, elements);
            case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
                var encoding = optEncoding.getTerm(OptTerm_1.TermType.SequenceEncodingSBOL3);
                assert_1.strict(encoding);
                return createSequenceSBOL3(g, identity, forComponentIdentity, encoding, elements);
            default:
                throw new ActionResult_1.default(output_1.text('Unsupported SBOL version for create-component'), ActionResult_1.Outcome.Abort);
        }
    });
}
function createSequenceSBOL1(g, identity, forComponentIdentity, encoding, elements) {
    let gv = new sbolgraph_1.SBOL1GraphView(g);
    if (!identity.parentURI) {
        throw new ActionResult_1.default(output_1.text('DnaSequence must have a parent in SBOL1, as unlike Sequence in SBOL2/3, it is not designated as top-level'), ActionResult_1.Outcome.Abort);
    }
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL1.DnaSequence),
        [bioterms_1.Predicates.SBOL1.nucleotides]: rdfoo_1.node.createStringNode(elements)
    });
    g.insertProperties(identity.parentURI, {
        [bioterms_1.Predicates.SBOL1.dnaSequence]: rdfoo_1.node.createUriNode(identity.uri)
    });
    return new ActionResult_1.default();
}
function createSequenceSBOL2(g, identity, forComponentIdentity, encoding, elements) {
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    if (identity.parentURI) {
        throw new ActionResult_1.default(output_1.text('Sequence cannot have a parent in SBOL2/3, as unlike DnaSequence in SBOL1, it is not designated as top-level. Consider using the --for-component option instead to attach the sequence to a component upon creation.'), ActionResult_1.Outcome.Abort);
    }
    if (!encoding) {
        if (forComponentIdentity !== undefined) {
            let component = gv.uriToFacade(forComponentIdentity.uri);
            assert_1.strict(component instanceof sbolgraph_1.S2ComponentDefinition);
            print_1.trace(output_1.text('Attempting to infer seq encoding from component with types ' + component.types.join(', ')));
            print_1.trace(output_1.text(bioterms_1.Specifiers.SBOL2.Type.DNA));
            print_1.trace(output_1.text(bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid));
            encoding = typesToEncoding(component.types);
        }
    }
    if (!encoding) {
        throw new ActionResult_1.default(output_1.text('Cannot infer sequence encoding from component type; please specify an encoding'), ActionResult_1.Outcome.Abort);
    }
    g.insertProperties(identity.uri, {
        [bioterms_1.Predicates.a]: rdfoo_1.node.createUriNode(bioterms_1.Types.SBOL2.Sequence),
        [bioterms_1.Predicates.SBOL2.displayId]: rdfoo_1.node.createStringNode(identity.displayId),
        [bioterms_1.Predicates.SBOL2.encoding]: rdfoo_1.node.createUriNode(encoding),
        [bioterms_1.Predicates.SBOL2.elements]: rdfoo_1.node.createStringNode(elements)
    });
    if (identity.version) {
        g.insertProperties(identity.uri, {
            [bioterms_1.Predicates.SBOL2.version]: rdfoo_1.node.createStringNode(identity.version)
        });
    }
    if (forComponentIdentity !== undefined) {
        g.insertProperties(forComponentIdentity.uri, {
            [bioterms_1.Predicates.SBOL2.sequence]: rdfoo_1.node.createUriNode(identity.uri)
        });
    }
    return new ActionResult_1.default();
}
function createSequenceSBOL3(g, identity, forComponentIdentity, encoding, elements) {
    return new ActionResult_1.default();
}
function typesToEncoding(types) {
    if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#Dna') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#DnaRegion') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#Rna') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#RnaRegion') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#Protein') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    }
    else if (types.indexOf('http://www.biopax.org/release/biopax-level3.owl#Protein') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    }
    else if (types.indexOf('https://identifiers.org/SBO:0000251') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('https://identifiers.org/SBO:0000251') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.NucleicAcid;
    }
    else if (types.indexOf('https://identifiers.org/SBO:0000252') !== -1) {
        return bioterms_1.Specifiers.SBOL2.SequenceEncoding.AminoAcid;
    }
    assert_1.strict(false);
}


/***/ }),

/***/ "./src/actions/dump-graph.ts":
/*!***********************************!*\
  !*** ./src/actions/dump-graph.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
let action = {
    name: 'graph-dump',
    category: 'graphops',
    namedOpts: [
        {
            name: 'title',
            type: OptString_1.default,
            optional: true
        }
    ],
    positionalOpts: [],
    run: dumpGraph
};
exports.default = action;
function dumpGraph(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        let [titleOpt] = namedOpts;
        let title = 'Graph dump';
        if (titleOpt) {
            title += ': ' + titleOpt.getString(g);
        }
        return ActionResult_1.actionResult(output_1.group([
            output_1.spacer(),
            output_1.header(title),
            output_1.spacer(),
            output_1.indent([
                output_1.text(new sbolgraph_1.SBOL3GraphView(g).serializeXML())
            ])
        ]));
    });
}


/***/ }),

/***/ "./src/actions/graph.ts":
/*!******************************!*\
  !*** ./src/actions/graph.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const assert = __webpack_require__(/*! assert */ "assert");
let action = {
    name: 'graph',
    category: 'graphops',
    namedOpts: [],
    positionalOpts: [
        {
            name: 'graph_name',
            type: OptString_1.default,
            optional: true
        }
    ],
    run: graph
};
exports.default = action;
function graph(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (positionalOpts.length !== 1) {
            throw new ActionResult_1.default(output_1.text('graph action needs exactly one parameter: the name of the graph to switch to'));
        }
        let graphNameOpt = positionalOpts[0];
        assert(graphNameOpt instanceof OptString_1.default);
        let graphName = graphNameOpt.getString(ctx.getCurrentGraph());
        ctx.setCurrentGraph(graphName);
        return ActionResult_1.actionResult();
    });
}


/***/ }),

/***/ "./src/actions/helpers/import-to-graph.ts":
/*!************************************************!*\
  !*** ./src/actions/helpers/import-to-graph.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const ActionResult_1 = __webpack_require__(/*! ../ActionResult */ "./src/actions/ActionResult.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
function importToGraph(g, src, format) {
    return __awaiter(this, void 0, void 0, function* () {
        let ft = rdfoo_1.identifyFiletype(src, '');
        if (!format) {
            // Import as-is
            if (ft === rdfoo_1.Filetype.RDFXML || ft === rdfoo_1.Filetype.NTriples) {
                g.loadString(src);
                return new ActionResult_1.default();
            }
            else {
                // GenBank/FASTA/etc
                //
                throw new ActionResult_1.default(output_1.text('Please specify a conversion target --as for GenBank/FASTA files'), ActionResult_1.Outcome.Abort);
            }
        }
        // Convert on import
        let tempg = new rdfoo_1.Graph();
        if (ft === rdfoo_1.Filetype.RDFXML || ft === rdfoo_1.Filetype.NTriples) {
            tempg.loadString(src);
        }
        else {
            // import GenBank/FASTA as SBOL2 first
            new sbolgraph_1.SBOL2GraphView(tempg).loadString(src);
        }
        switch (format) {
            case 'sbol1':
                yield sbolgraph_1.SBOLConverter.convert3to2(tempg);
                yield sbolgraph_1.SBOLConverter.convert2to1(tempg);
                break;
            case 'sbol2':
                yield sbolgraph_1.SBOLConverter.convert3to2(tempg);
                yield sbolgraph_1.SBOLConverter.convert1to2(tempg);
                break;
            case 'sbol3':
            default:
                yield sbolgraph_1.SBOLConverter.convert1to2(tempg);
                yield sbolgraph_1.SBOLConverter.convert2to3(tempg);
                break;
        }
        g.addAll(tempg);
    });
}
exports.default = importToGraph;


/***/ }),

/***/ "./src/actions/import.ts":
/*!*******************************!*\
  !*** ./src/actions/import.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const OptURL_1 = __webpack_require__(/*! ./opt/OptURL */ "./src/actions/opt/OptURL.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const import_to_graph_1 = __webpack_require__(/*! ./helpers/import-to-graph */ "./src/actions/helpers/import-to-graph.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
let createSequenceAction = {
    name: 'import',
    description: 'Import RDF, FASTA, or GenBank into the current graph',
    category: 'graph',
    positionalOpts: [
        {
            name: 'source',
            type: OptURL_1.default,
            optional: true
        }
    ],
    namedOpts: [
        {
            name: 'as',
            type: OptString_1.default
        }
    ],
    run: _import,
    help: `
The source may be either the filename or URL of a serialized RDF resource, such as an SBOL1, 2, or 3 file; or the filename or URL of a FASTA or GenBank file.

The --as parameter specifies the RDF conversion target sbol1/sbol/sbol3.  For example,

    import foo.fasta --as sbol1

would result in a graph containing foo.fasta converted to SBOL1 RDF. Without an --as parameter, the SBOL will be imported as-is.  The --as parameter
for FASTA/GenBank imports defaults to SBOL3.
`
};
exports.default = createSequenceAction;
function _import(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let g = ctx.getCurrentGraph();
        let [source] = positionalOpts;
        let [_as] = namedOpts;
        assert_1.strict(source instanceof OptURL_1.default);
        assert_1.strict(!_as || _as instanceof OptString_1.default);
        print_1.trace(output_1.text('Import: positional opts ' + JSON.stringify(positionalOpts)));
        let format = _as ? _as.getString(g) : undefined;
        let src = yield source.downloadToString();
        yield import_to_graph_1.default(g, src, format);
        return new ActionResult_1.default();
    });
}


/***/ }),

/***/ "./src/actions/index.ts":
/*!******************************!*\
  !*** ./src/actions/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const import_1 = __webpack_require__(/*! ./import */ "./src/actions/import.ts");
const convert_1 = __webpack_require__(/*! ./convert */ "./src/actions/convert.ts");
const create_sequence_1 = __webpack_require__(/*! ./create-sequence */ "./src/actions/create-sequence.ts");
const components_1 = __webpack_require__(/*! ./components */ "./src/actions/components.ts");
const validate_1 = __webpack_require__(/*! ./validate */ "./src/actions/validate.ts");
const create_constraint_1 = __webpack_require__(/*! ./create-constraint */ "./src/actions/create-constraint.ts");
const create_component_1 = __webpack_require__(/*! ./create-component */ "./src/actions/create-component.ts");
const create_module_1 = __webpack_require__(/*! ./create-module */ "./src/actions/create-module.ts");
const create_interaction_1 = __webpack_require__(/*! ./create-interaction */ "./src/actions/create-interaction.ts");
const create_participation_1 = __webpack_require__(/*! ./create-participation */ "./src/actions/create-participation.ts");
const render_1 = __webpack_require__(/*! ./render */ "./src/actions/render.ts");
const annotate_range_1 = __webpack_require__(/*! ./annotate-range */ "./src/actions/annotate-range.ts");
const add_subcomponent_1 = __webpack_require__(/*! ./add-subcomponent */ "./src/actions/add-subcomponent.ts");
const create_participant_1 = __webpack_require__(/*! ./create-participant */ "./src/actions/create-participant.ts");
const dump_graph_1 = __webpack_require__(/*! ./dump-graph */ "./src/actions/dump-graph.ts");
const graph_1 = __webpack_require__(/*! ./graph */ "./src/actions/graph.ts");
const compare_1 = __webpack_require__(/*! ./compare */ "./src/actions/compare.ts");
const merge_1 = __webpack_require__(/*! ./merge */ "./src/actions/merge.ts");
const insert_1 = __webpack_require__(/*! ./insert */ "./src/actions/insert.ts");
const namespace_1 = __webpack_require__(/*! ./namespace */ "./src/actions/namespace.ts");
const sbol_version_1 = __webpack_require__(/*! ./sbol-version */ "./src/actions/sbol-version.ts");
exports.default = [
    import_1.default,
    convert_1.default,
    components_1.default,
    validate_1.default,
    create_component_1.default,
    create_constraint_1.default,
    create_module_1.default,
    create_interaction_1.default,
    create_participation_1.default,
    create_sequence_1.default,
    render_1.default,
    annotate_range_1.default,
    add_subcomponent_1.default,
    create_participant_1.default,
    dump_graph_1.default,
    graph_1.default,
    compare_1.default,
    merge_1.default,
    insert_1.default,
    namespace_1.default,
    sbol_version_1.default
];


/***/ }),

/***/ "./src/actions/insert.ts":
/*!*******************************!*\
  !*** ./src/actions/insert.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
let action = {
    name: 'insert',
    category: 'graphops',
    namedOpts: [
        {
            name: 'subject',
            type: OptString_1.default,
            optional: false
        },
        {
            name: 'predicate',
            type: OptString_1.default,
            optional: false
        },
        {
            name: 'object',
            type: OptString_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: graphInsert
};
exports.default = action;
function graphInsert(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let [subject, predicate, object] = namedOpts;
        let g = ctx.getCurrentGraph();
        // TODO
        g.insertProperties(subject.getString(g), {
            [predicate.getString(g)]: rdfoo_1.node.createStringNode(object.getString(g))
        });
        return ActionResult_1.actionResult();
    });
}


/***/ }),

/***/ "./src/actions/merge.ts":
/*!******************************!*\
  !*** ./src/actions/merge.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptGraph_1 = __webpack_require__(/*! ./opt/OptGraph */ "./src/actions/opt/OptGraph.ts");
const assert_1 = __webpack_require__(/*! assert */ "assert");
let action = {
    name: 'merge',
    category: 'graphops',
    namedOpts: [
        {
            name: 'from',
            type: OptGraph_1.default,
            optional: false
        }
    ],
    positionalOpts: [],
    run: graphMerge
};
exports.default = action;
function graphMerge(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        let [from] = namedOpts;
        assert_1.strict(from instanceof OptGraph_1.default);
        let toGraph = ctx.getCurrentGraph();
        let fromGraph = from.getGraph(ctx);
        assert_1.strict(fromGraph);
        toGraph.addAll(fromGraph);
        return ActionResult_1.actionResult();
    });
}


/***/ }),

/***/ "./src/actions/namespace.ts":
/*!**********************************!*\
  !*** ./src/actions/namespace.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const assert = __webpack_require__(/*! assert */ "assert");
let action = {
    name: 'namespace',
    category: 'graphops',
    namedOpts: [],
    positionalOpts: [
        {
            name: '',
            type: OptString_1.default,
            optional: false
        }
    ],
    run: namespace,
    help: `
Sets the default namespace for actions which accept an identity parameter. This namespace can be overridden per-action with --identity.
`
};
exports.default = action;
function namespace(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (positionalOpts.length !== 1) {
            throw new ActionResult_1.default(output_1.text('namespace action needs exactly one parameter: the URI of a namespace to set as current'));
        }
        let nsOpt = positionalOpts[0];
        assert(nsOpt instanceof OptString_1.default);
        let ns = nsOpt.getString(ctx.getCurrentGraph());
        ctx.currentNamespace = ns;
        return ActionResult_1.actionResult();
    });
}


/***/ }),

/***/ "./src/actions/opt/Opt.ts":
/*!********************************!*\
  !*** ./src/actions/opt/Opt.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Opt {
    constructor(actDef, optDef, argv) {
        this.actDef = actDef;
        this.optDef = optDef;
        this.argv = argv;
    }
}
exports.default = Opt;


/***/ }),

/***/ "./src/actions/opt/Opt1BasedInt.ts":
/*!*****************************************!*\
  !*** ./src/actions/opt/Opt1BasedInt.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
class Opt1BasedInt extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getInt(g) {
        let s = this.argv.getString(this.optDef.name, '');
        let n = parseInt(s);
        if (n < 1) {
            throw new Error('1 based int must be >= 1');
        }
        return n;
    }
}
exports.default = Opt1BasedInt;


/***/ }),

/***/ "./src/actions/opt/OptFlag.ts":
/*!************************************!*\
  !*** ./src/actions/opt/OptFlag.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
class OptFlag extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    isSet() {
        return this.argv.getFlag(this.optDef.name);
    }
}
exports.default = OptFlag;


/***/ }),

/***/ "./src/actions/opt/OptGraph.ts":
/*!*************************************!*\
  !*** ./src/actions/opt/OptGraph.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
class OptGraphName extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getGraph(ctx) {
        let s = this.argv.getString(this.optDef.name, '');
        let g = ctx.getGraph(s);
        return g;
    }
}
exports.default = OptGraphName;


/***/ }),

/***/ "./src/actions/opt/OptIdentity.ts":
/*!****************************************!*\
  !*** ./src/actions/opt/OptIdentity.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
const Identity_1 = __webpack_require__(/*! ../../identity/Identity */ "./src/identity/Identity.ts");
const ActionResult_1 = __webpack_require__(/*! ../ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
const get_consensus_sbol_version_1 = __webpack_require__(/*! ./helper/get-consensus-sbol-version */ "./src/actions/opt/helper/get-consensus-sbol-version.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const print_1 = __webpack_require__(/*! ../../output/print */ "./src/output/print.ts");
class OptIdentity extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getIdentity(ctx, existence, relatedIdentity) {
        var _a;
        let g = ctx.getCurrentGraph();
        let currentNamespace = ctx.currentNamespace;
        let defaultVersion = ctx.sbolVersion;
        print_1.trace(output_1.text('default sbol version: ' + defaultVersion));
        let paramPrefix = this.optDef.name !== '' ? this.optDef.name + '-' : '';
        let namespace = this.argv.getString(paramPrefix + 'namespace', '');
        let displayId = this.argv.getString(paramPrefix + 'displayId', '');
        let version = this.argv.getStringOrUndefined(paramPrefix + 'version');
        let context = this.argv.getString(paramPrefix + 'context', '');
        let identity = this.argv.getString(this.optDef.name, '') || // e.g. --within-component
            this.argv.getString(paramPrefix + 'identity', ''); // e.g. --within-component-identity
        let sbolversion = this.argv.getString(paramPrefix + 'sbol-version', '');
        if (this.optDef.name === '') {
            // anon identity (default identity for an action, like create-component .some.identity)
            let anonIdChain = this.argv.getIdentityChain();
            if (anonIdChain !== undefined) {
                identity = anonIdChain;
            }
        }
        else {
            // param identity (identity for an action param, like create-component --within-component .some.identity)
            let identityOpt = this.argv.getString(this.optDef.name, '');
            if (identityOpt) {
                identity = identityOpt;
            }
        }
        print_1.trace(output_1.text(`get identity: relatedIdentity ${relatedIdentity}`));
        if (relatedIdentity) {
            if (!namespace) {
                print_1.trace(output_1.text(`No namespace was specified, so using namespace of related identity ${relatedIdentity.namespace}`));
                namespace = relatedIdentity.namespace;
            }
        }
        if (!namespace && !displayId && version === undefined && !context && !identity && !sbolversion) {
            if (this.optDef.optional === true) {
                return;
            }
        }
        if (currentNamespace && !namespace) {
            namespace = currentNamespace;
        }
        let sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.Empty;
        let inferSBOLVersion = ((_a = this.optDef.refinements) === null || _a === void 0 ? void 0 : _a.inferSBOLVersion) !== false;
        if (sbolversion === '1') {
            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL1;
        }
        else if (sbolversion === '2') {
            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL2;
        }
        else if (sbolversion === '3') {
            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL3;
        }
        else {
            if (!inferSBOLVersion) {
                if (defaultVersion !== get_sbol_version_from_graph_1.SBOLVersion.Empty) {
                    sbolVersion = defaultVersion;
                }
                else {
                    throw ActionResult_1.actionResultAbort(output_1.text(`Please specify --${paramPrefix}sbol-version 1/2/3`));
                }
            }
            else {
                if (relatedIdentity) {
                    sbolVersion = relatedIdentity.sbolVersion;
                }
                else {
                    if (defaultVersion !== get_sbol_version_from_graph_1.SBOLVersion.Empty) {
                        sbolVersion = defaultVersion;
                    }
                    else {
                        let consensus = get_consensus_sbol_version_1.getConsensusSBOLVersion(g);
                        if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL1)
                            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL1;
                        else if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL2)
                            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL2;
                        else if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL3)
                            sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL3;
                        else {
                            throw ActionResult_1.actionResultAbort(output_1.text(`Could not infer input SBOL version from current graph (is it empty, or does it contain mixed SBOL versions?); please specify --${paramPrefix}sbol-version 1/2/3 or set a global default SBOL version using the sbol-version action`));
                        }
                    }
                }
            }
        }
        let allOptions = { namespace, displayId, context, identity };
        print_1.trace(output_1.text('allOptions: ' + JSON.stringify(allOptions)));
        let anyCombinations = [
            { namespace, identity,
                getIdentity: () => Identity_1.default.from_namespace_and_identity(existence, sbolVersion, g, namespace, identity, version) },
            { identity,
                getIdentity: () => Identity_1.default.from_identity(existence, sbolVersion, g, identity, version)
            }
        ];
        let tlCombinations = [
            { namespace, displayId,
                getIdentity: () => Identity_1.default.toplevel_from_namespace_displayId(existence, sbolVersion, g, namespace, displayId, version)
            },
            { displayId,
                getIdentity: () => Identity_1.default.toplevel_from_displayId(existence, sbolVersion, g, displayId, version)
            }
        ];
        let childCombinations = [
            { namespace, context, displayId,
                getIdentity: () => Identity_1.default.child_from_namespace_context_displayId(existence, sbolVersion, g, namespace, context, displayId, version)
            },
            { context, displayId,
                getIdentity: () => Identity_1.default.child_from_context_displayId(existence, sbolVersion, g, context, displayId, version)
            }
        ];
        let allCombinations = anyCombinations
            .concat(tlCombinations)
            .concat(childCombinations);
        var combo;
        eachCombo: for (combo of allCombinations) {
            // are any of the combination required params empty?
            if (Object.values(combo).filter(v => v === '').length > 0) {
                continue;
            }
            // are any other identity params populated that shouldn't be?
            for (let k of Object.keys(allOptions)) {
                if (Object.keys(combo).indexOf(k) !== -1) {
                    // this option is present in this combination; all good
                    continue;
                }
                // this option is not present in this combination
                if (allOptions[k] !== '') {
                    // and it's populated; this is not our combo
                    continue eachCombo;
                }
            }
            print_1.trace(output_1.text('identity combination: ' + JSON.stringify(combo) + ' ' + combo.getIdentity));
            return combo.getIdentity();
        }
        throw badCombo(this.actDef.name, paramPrefix);
    }
}
exports.default = OptIdentity;
function badCombo(action, paramPrefix) {
    let paramName = paramPrefix.slice(0, -1);
    let opts = [
        [`--${paramPrefix}identity`, `Identifies a top-level, or a child if --${paramPrefix}identity is an identity chain and provides context`],
        [`--${paramPrefix}namespace, --${paramPrefix}displayId`, `Identifies a top-level`],
        [`--${paramPrefix}namespace, --${paramPrefix}identity`, `Identifies a top-level, or a child if --${paramPrefix}identity is an identity chain and provides context`],
        [`--${paramPrefix}displayId`, `Identifies a top-level`],
        [`--${paramPrefix}namespace, --${paramPrefix}context, --${paramPrefix}displayId`, `Identifies a child object`],
        [`--${paramPrefix}context, --${paramPrefix}displayId`, `Identifies a child object`]
    ];
    if (paramName) {
        opts.unshift([`--${paramName}`, `Identifies a top-level, or a child if --${paramName} is an identity chain and provides context`]);
    }
    return ActionResult_1.actionResultAbort(output_1.group([
        output_1.text(`${action}: Please specify a valid combination of identity parameters${paramPrefix ? ' for --' + paramName : ''}.  The following combinations are supported:`),
        output_1.spacer(),
        output_1.tabulated(opts)
    ]));
}
function sameValues(arr1, arr2) {
    return arr1.length === arr2.length &&
        arr1.every(v => arr2.indexOf(v) !== -1);
}


/***/ }),

/***/ "./src/actions/opt/OptSBOLVersion.ts":
/*!*******************************************!*\
  !*** ./src/actions/opt/OptSBOLVersion.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const ActionResult_1 = __webpack_require__(/*! ../ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
const get_consensus_sbol_version_1 = __webpack_require__(/*! ./helper/get-consensus-sbol-version */ "./src/actions/opt/helper/get-consensus-sbol-version.ts");
class OptSBOLVersion extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getSBOLVersion(g) {
        let paramPrefix = this.optDef.name !== '' ? this.optDef.name + '-' : '';
        let sbolversion = this.argv.getString(paramPrefix + 'sbol-version', '');
        let infer = this.optDef.refinements.infer !== false;
        if (sbolversion === '1') {
            return get_sbol_version_from_graph_1.SBOLVersion.SBOL1;
        }
        else if (sbolversion === '2') {
            return get_sbol_version_from_graph_1.SBOLVersion.SBOL2;
        }
        else if (sbolversion === '3') {
            return get_sbol_version_from_graph_1.SBOLVersion.SBOL3;
        }
        else {
            if (!infer) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Please specify --${paramPrefix}sbol-version 1/2/3`));
            }
            let consensus = get_consensus_sbol_version_1.getConsensusSBOLVersion(g);
            if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL1)
                return get_sbol_version_from_graph_1.SBOLVersion.SBOL1;
            else if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL2)
                return get_sbol_version_from_graph_1.SBOLVersion.SBOL2;
            else if (consensus === get_consensus_sbol_version_1.ConsensusVersion.SBOL3)
                return get_sbol_version_from_graph_1.SBOLVersion.SBOL3;
            else {
                throw ActionResult_1.actionResultAbort(output_1.text(`Could not infer input SBOL version from current graph (does it contain mixed SBOL versions?); please specify  --${paramPrefix}sbol-version 1/2/3`));
            }
        }
    }
}
exports.default = OptSBOLVersion;


/***/ }),

/***/ "./src/actions/opt/OptString.ts":
/*!**************************************!*\
  !*** ./src/actions/opt/OptString.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
class OptString extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getString(g) {
        return this.argv.getString(this.optDef.name, '');
    }
}
exports.default = OptString;


/***/ }),

/***/ "./src/actions/opt/OptTerm.ts":
/*!************************************!*\
  !*** ./src/actions/opt/OptTerm.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TermType = void 0;
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
const ActionResult_1 = __webpack_require__(/*! ../ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
var TermType;
(function (TermType) {
    TermType["Role"] = "Role";
    TermType["InteractionType"] = "InteractionType";
    TermType["ParticipationRole"] = "ParticipationRole";
    TermType["RestrictionSBOL2"] = "RestrictionSBOL2";
    TermType["RestrictionSBOL3"] = "RestrictionSBOL3";
    TermType["SequenceEncodingSBOL2"] = "SequenceEncodingSBOL2";
    TermType["SequenceEncodingSBOL3"] = "SequenceEncodingSBOL3";
    TermType["ComponentTypeSBOL2"] = "ComponentTypeSBOL2";
    TermType["ComponentTypeSBOL3"] = "ComponentTypeSBOL3";
})(TermType = exports.TermType || (exports.TermType = {}));
class OptTerm extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getTerm(type) {
        let name = this.argv.getString(this.optDef.name, '');
        if (!name) {
            return undefined;
        }
        if (name.indexOf('://') !== -1) {
            return name;
        }
        if (type === TermType.Role) {
            var uri = roleVocab[name.toLowerCase()];
        }
        else if (type === TermType.InteractionType) {
            var uri = interactionTypeVocab[name.toLowerCase()];
        }
        else if (type == TermType.ParticipationRole) {
            var uri = participationRoleVocab[name.toLowerCase()];
        }
        else if (type == TermType.RestrictionSBOL2) {
            var uri = restrictionVocabSBOL2[name.toLowerCase()];
        }
        else if (type == TermType.RestrictionSBOL3) {
            var uri = restrictionVocabSBOL3[name.toLowerCase()];
        }
        else if (type == TermType.SequenceEncodingSBOL2) {
            var uri = sequenceEncodingVocabSBOL2[name.toLowerCase()];
        }
        else if (type == TermType.SequenceEncodingSBOL3) {
            var uri = sequenceEncodingVocabSBOL3[name.toLowerCase()];
        }
        else if (type == TermType.ComponentTypeSBOL2) {
            var uri = componentTypeVocabSBOL2[name.toLowerCase()];
        }
        else if (type == TermType.ComponentTypeSBOL3) {
            var uri = componentTypeVocabSBOL3[name.toLowerCase()];
        }
        if (uri === undefined) {
            throw new ActionResult_1.default(output_1.text('Unknown term: ' + name + ' for term type ' + type));
        }
        return uri;
    }
}
exports.default = OptTerm;
let roleVocab = {
    'dna': 'https://identifiers.org/SBO:0000251',
    'rna': 'https://identifiers.org/SBO:0000250',
    'protein': 'https://identifiers.org/SBO:0000252',
    'simplechemical': 'https://identifiers.org/SBO:0000247',
    'chemical': 'https://identifiers.org/SBO:0000247',
    'complex': 'https://identifiers.org/SBO:0000253',
    'noncovalentcomplex': 'https://identifiers.org/SBO:0000253',
    'functionalentity': 'https://identifiers.org/SBO:0000241',
    'functional': 'https://identifiers.org/SBO:0000241',
    'linear': 'http://identifiers.org/so/SO:0000987',
    'circular': 'http://identifiers.org/so/SO:0000988',
    'singlestranded': 'http://identifiers.org/so/SO:0000984',
    'doublestranded': 'http://identifiers.org/so/SO:0000985',
    'promoter': 'http://identifiers.org/so/SO:0000167',
    'rbs': 'http://identifiers.org/so/SO:0000139',
    'cds': 'http://identifiers.org/so/SO:0000316',
    'terminator': 'http://identifiers.org/so/SO:0000141',
    'gene': 'http://identifiers.org/so/SO:0000704',
    'operator': 'http://identifiers.org/so/SO:0000057',
    'engineeredgene': 'http://identifiers.org/so/SO:0000280',
    'mrna': 'http://identifiers.org/so/SO:0000234',
    'effector': 'http://identifiers.org/chebi/CHEBI:35224',
    'transcriptionfactor': 'http://identifiers.org/go/GO:0003700'
};
let interactionTypeVocab = {
    'inhibition': 'http://identifiers.org/biomodels.sbo/SBO:0000169',
    'stimulation': 'http://identifiers.org/biomodels.sbo/SBO:0000170',
    'biochemicalreaction': 'http://identifiers.org/biomodels.sbo/SBO:0000176',
    'noncovalentbinding': 'http://identifiers.org/biomodels.sbo/SBO:0000177',
    'degradation': 'http://identifiers.org/biomodels.sbo/SBO:0000179',
    'geneticproduction': 'http://identifiers.org/biomodels.sbo/SBO:0000589',
    'control': 'http://identifiers.org/biomodels.sbo/SBO:0000168',
};
let participationRoleVocab = {
    'inhibitor': 'http://identifiers.org/biomodels.sbo/SBO:0000020',
    'inhibited': 'http://identifiers.org/biomodels.sbo/SBO:0000642',
    'stimulator': 'http://identifiers.org/biomodels.sbo/SBO:0000459',
    'stimulated': 'http://identifiers.org/biomodels.sbo/SBO:0000643',
    'reactant': 'http://identifiers.org/biomodels.sbo/SBO:0000010',
    'product': 'http://identifiers.org/biomodels.sbo/SBO:0000011',
    'promoter': 'http://identifiers.org/biomodels.sbo/SBO:0000598',
    'modifier': 'http://identifiers.org/biomodels.sbo/SBO:0000019',
    'modified': 'http://identifiers.org/biomodels.sbo/SBO:0000644',
    'template': 'http://identifiers.org/biomodels.sbo/SBO:0000645',
};
let restrictionVocabSBOL2 = {
    'precedes': 'http://sbols.org/v2#precedes'
};
let restrictionVocabSBOL3 = {
    'precedes': 'http://sbols.org/v3#precedes',
};
let sequenceEncodingVocabSBOL2 = {
    'nucleicacid': 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html',
    'dna': 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html',
    'rna': 'http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html',
    'protein': 'http://www.chem.qmul.ac.uk/iupac/AminoAcid/',
    'smiles': 'http://www.opensmiles.org/opensmiles.html'
};
let sequenceEncodingVocabSBOL3 = {
    'nucleicacid': 'http://sbols.org/v3#iupacNucleicAcid',
    'dna': 'http://sbols.org/v3#iupacNucleicAcid',
    'rna': 'http://sbols.org/v3#iupacNucleicAcid',
    'aminoacid': 'http://sbols.org/v3#iupacAminoAcid',
    'protein': 'http://sbols.org/v3#iupacAminoAcid',
    'smiles': 'http://www.opensmiles.org/opensmiles.html',
    'chemical': 'http://www.opensmiles.org/opensmiles.html'
};
let componentTypeVocabSBOL2 = {
    'dna': 'http://www.biopax.org/release/biopax-level3.owl#Dna',
    'dnamolecule': 'http://www.biopax.org/release/biopax-level3.owl#Dna',
    'dnaregion': 'http://www.biopax.org/release/biopax-level3.owl#DnaRegion',
    'rna': 'http://www.biopax.org/release/biopax-level3.owl#Rna',
    'rnamolecule': 'http://www.biopax.org/release/biopax-level3.owl#Rna',
    'rnaregion': 'http://www.biopax.org/release/biopax-level3.owl#RnaRegion',
    'protein': 'http://www.biopax.org/release/biopax-level3.owl#Protein',
    'smallmolecule': 'http://www.biopax.org/release/biopax-level3.owl#SmallMolecule',
    'complex': 'http://www.biopax.org/release/biopax-level3.owl#Complex'
};
let componentTypeVocabSBOL3 = {
    'dna': 'https://identifiers.org/SBO:0000251',
    'dnamolecule': 'https://identifiers.org/SBO:0000251',
    'dnaregion': 'https://identifiers.org/SBO:0000251',
    'rna': 'https://identifiers.org/SBO:0000250',
    'protein': 'https://identifiers.org/SBO:0000252',
    'chemical': 'https://identifiers.org/SBO:0000247',
    'simplechemical': 'https://identifiers.org/SBO:0000247',
    'noncovalentcomplex': 'https://identifiers.org/SBO:0000253',
    'complex': 'https://identifiers.org/SBO:0000253',
    'functionalentity': 'https://identifiers.org/SBO:0000241',
    'module': 'https://identifiers.org/SBO:0000241',
};


/***/ }),

/***/ "./src/actions/opt/OptTriplePattern.ts":
/*!*********************************************!*\
  !*** ./src/actions/opt/OptTriplePattern.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
class OptTriplePattern extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getPattern() {
        let pattern = this.argv.getString(this.optDef.name, '');
        let spo = pattern.split(/\s+/);
        return {
            s: new RegExp(spo[0]),
            p: new RegExp(spo[1]),
            o: new RegExp(spo[2])
        };
    }
}
exports.default = OptTriplePattern;


/***/ }),

/***/ "./src/actions/opt/OptURL.ts":
/*!***********************************!*\
  !*** ./src/actions/opt/OptURL.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Opt_1 = __webpack_require__(/*! ./Opt */ "./src/actions/opt/Opt.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
const print_1 = __webpack_require__(/*! ../../output/print */ "./src/output/print.ts");
const node_fetch_1 = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/lib/index.mjs");
const fs = __webpack_require__(/*! fs */ "fs");
class OptURL extends Opt_1.default {
    constructor(actDef, optDef, argv) {
        super(actDef, optDef, argv);
    }
    getURL() {
        return this.argv.getString(this.optDef.name, '');
    }
    downloadToString() {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.getURL();
            if (!url) {
                print_1.trace(output_1.text('downloadToString: no URL, returning empty string'));
                return '';
            }
            print_1.trace(output_1.text('Downloading ' + url + '...'));
            if (url.indexOf('http://') === 0 || url.indexOf('https://') === 0) {
                let res = yield node_fetch_1.default(url);
                return yield res.text();
            }
            else if (url.indexOf('file:///') === 0) {
                let res = yield loadFile(url.split('file:///')[1]);
                return res + '';
            }
            else {
                // treat everything else as a filename
                let res = yield loadFile(url);
                return res + '';
            }
        });
    }
}
exports.default = OptURL;
function loadFile(filename) {
    return new Promise((resolve, reject) => {
        fs.readFile(filename, (err, file) => {
            if (err)
                reject(err);
            else
                resolve(file);
        });
    });
}


/***/ }),

/***/ "./src/actions/opt/helper/get-consensus-sbol-version.ts":
/*!**************************************************************!*\
  !*** ./src/actions/opt/helper/get-consensus-sbol-version.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getConsensusSBOLVersion = exports.ConsensusVersion = void 0;
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
var ConsensusVersion;
(function (ConsensusVersion) {
    ConsensusVersion[ConsensusVersion["SBOL1"] = 0] = "SBOL1";
    ConsensusVersion[ConsensusVersion["SBOL2"] = 1] = "SBOL2";
    ConsensusVersion[ConsensusVersion["SBOL3"] = 2] = "SBOL3";
    ConsensusVersion[ConsensusVersion["Mixed"] = 3] = "Mixed";
    ConsensusVersion[ConsensusVersion["Empty"] = 4] = "Empty";
})(ConsensusVersion = exports.ConsensusVersion || (exports.ConsensusVersion = {}));
function getConsensusSBOLVersion(g) {
    let version = ConsensusVersion.Empty;
    for (let s of g.subjects) {
        for (let t of g.match(s, bioterms_1.Predicates.a, null)) {
            let uri = sbolgraph_1.triple.objectUri(t);
            if (!uri)
                continue;
            if (uri.indexOf(bioterms_1.Prefixes.sbol1) === 0) {
                if (version !== ConsensusVersion.Empty) {
                    if (version !== ConsensusVersion.SBOL1) {
                        return ConsensusVersion.Mixed;
                    }
                }
                else {
                    version = ConsensusVersion.SBOL1;
                }
            }
            else if (uri.indexOf(bioterms_1.Prefixes.sbol2) === 0) {
                if (version !== ConsensusVersion.Empty) {
                    if (version !== ConsensusVersion.SBOL2) {
                        return ConsensusVersion.Mixed;
                    }
                }
                else {
                    version = ConsensusVersion.SBOL2;
                }
            }
            else if (uri.indexOf(bioterms_1.Prefixes.sbol3) === 0) {
                if (version !== ConsensusVersion.Empty) {
                    if (version !== ConsensusVersion.SBOL3) {
                        return ConsensusVersion.Mixed;
                    }
                }
                else {
                    version = ConsensusVersion.SBOL3;
                }
            }
        }
    }
    return version;
}
exports.getConsensusSBOLVersion = getConsensusSBOLVersion;


/***/ }),

/***/ "./src/actions/render.ts":
/*!*******************************!*\
  !*** ./src/actions/render.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
let renderAction = {
    name: 'synbiocad-render',
    category: 'other',
    namedOpts: [],
    positionalOpts: [],
    run: render
};
exports.default = renderAction;
function render(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        // let format = opts.filter(o => o.name === 'format')[0]?.value
        // let filename = opts.filter(o => o.name === 'filename')[0]?.value
        // //let validFormats = ['svg', 'png', 'pptx']
        // let validFormats = ['svg']
        // if(validFormats.indexOf(format as string) === -1) {
        //     return new ActionResult(true, text('render: --format must be one of: ' + validFormats))
        // }
        // if(!filename) {
        //     return new ActionResult(true, text('render: please specify a --filename'))
        // }
        // let r = await fetch(`https://api.biocad.io/render/${format}`, {
        //     method: 'POST',
        //     headers: {
        //         'content-type': 'application/rdf+xml'
        //     },
        //     body: serialize(g, new Map(), () => false)
        // })
        // let body = await r.text()
        // fs.writeFileSync(filename, body)
        // return new ActionResult(false, text(`Rendered ${filename}`))
        return new ActionResult_1.default(output_1.group([]));
    });
}


/***/ }),

/***/ "./src/actions/sbol-version.ts":
/*!*************************************!*\
  !*** ./src/actions/sbol-version.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const OptString_1 = __webpack_require__(/*! ./opt/OptString */ "./src/actions/opt/OptString.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const assert = __webpack_require__(/*! assert */ "assert");
let action = {
    name: 'sbol-version',
    category: 'graphops',
    namedOpts: [],
    positionalOpts: [
        {
            name: '',
            type: OptString_1.default,
            optional: false
        }
    ],
    run: sbolVersion,
    help: `
Sets the default SBOL version 1/2/3 for actions which create SBOL objects. This namespace can be overridden per-action with --sbol-version.
`
};
exports.default = action;
function sbolVersion(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (positionalOpts.length !== 1) {
            throw new ActionResult_1.default(output_1.text('sbol-version action needs exactly one parameter: an SBOL version 1/2/3'));
        }
        let versionOpt = positionalOpts[0];
        assert(versionOpt instanceof OptString_1.default);
        let version = versionOpt.getString(ctx.getCurrentGraph());
        if (version === '1') {
            ctx.sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL1;
        }
        else if (version === '2') {
            ctx.sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL2;
        }
        else if (version === '3') {
            ctx.sbolVersion = get_sbol_version_from_graph_1.SBOLVersion.SBOL3;
        }
        else {
            throw new ActionResult_1.default(output_1.text('unknown SBOL version: ' + version));
        }
        return ActionResult_1.actionResult();
    });
}


/***/ }),

/***/ "./src/actions/validate.ts":
/*!*********************************!*\
  !*** ./src/actions/validate.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const fetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/lib/index.mjs");
const ActionResult_1 = __webpack_require__(/*! ./ActionResult */ "./src/actions/ActionResult.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
let vcValidateAction = {
    name: 'validate',
    category: 'vc',
    namedOpts: [],
    positionalOpts: [],
    run: vcValidate
};
exports.default = vcValidateAction;
function vcValidate(ctx, namedOpts, positionalOpts) {
    return __awaiter(this, void 0, void 0, function* () {
        // let target = opts.getString('target', 'sbol2').toUpperCase()
        // let check_uri_compliance = opts.getBoolean('check-uri-compliance', true)
        // let check_completeness = opts.getBoolean('check-completeness', true)
        // let check_best_practices = opts.getBoolean('check-best-practices', false)
        // let fail_on_first_error = opts.getBoolean('fail-on-first-error', false)
        // let provide_detailed_stack_trace = opts.getBoolean('provide-detailed-stack-trace', false)
        // let subset_uri = opts.getString('subset-uri', '')
        // let uri_prefix = opts.getString('uri-prefix', '')
        // let version = opts.getString('version', '')
        // let insert_type = opts.getBoolean('insert-type', false)
        let g = ctx.getCurrentGraph();
        let sourceVersion = get_sbol_version_from_graph_1.getSBOLVersionFromGraph(g);
        let xml = '';
        if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL1) {
            xml = new sbolgraph_1.SBOL1GraphView(g).serializeXML();
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL2) {
            xml = new sbolgraph_1.SBOL2GraphView(g).serializeXML();
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.SBOL3) {
            throw new ActionResult_1.default(output_1.text('convert: cannot convert from SBOL3 using the online validator/converter'), ActionResult_1.Outcome.Abort);
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.Mixed) {
            throw new ActionResult_1.default(output_1.text('convert: graph has mixed SBOL versions so cannot use online validator/converter'), ActionResult_1.Outcome.Abort);
        }
        else if (sourceVersion === get_sbol_version_from_graph_1.SBOLVersion.Empty) {
            xml = new sbolgraph_1.SBOL2GraphView(g).serializeXML();
        }
        else {
            throw new ActionResult_1.default(output_1.text('convert: unknown source SBOLVersion ' + sourceVersion));
        }
        let body = {
            options: {
                //language: vcTarget.toUpperCase(), // output language
                test_equality: false,
                check_uri_compliance: false,
                check_completeness: false,
                check_best_practices: false,
                fail_on_first_error: false,
                provide_detailed_stack_trace: false,
                subset_uri: '',
                uri_prefix: '',
                version: '',
                insert_type: false,
                main_file_name: 'main file',
                diff_file_name: 'comparison file'
            },
            main_file: xml,
            return_file: true
        };
        let r = yield fetch('https://validator.sbolstandard.org/validate/', {
            method: 'POST',
            headers: {
                'content-type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        try {
            var response = yield r.json();
        }
        catch (e) {
            return ActionResult_1.actionResult(output_1.text('The online validator/converter failed: ' + e));
        }
        //console.log(JSON.stringify(response, null, 2))
        let { valid, check_equality, equality, errors, output_file, result } = response;
        let output = [];
        errors = errors.filter(e => e.trim() != '');
        if (!valid) {
            if (errors.length > 0) {
                output.push(output_1.spacer());
                output.push(output_1.group(errors.map(e => output_1.text('Online validator error: ' + e))));
                output.push(output_1.spacer());
            }
        }
        if (valid) {
            output.push(output_1.text('validate: the validator/converter said: valid!'));
        }
        else {
            output.push(output_1.spacer(), output_1.text('The online validator/converter said the SBOL sent by sboltools was invalid'), output_1.text('This should not happen, and is likely indicative of a bug in sboltools'), output_1.spacer());
            throw new ActionResult_1.default(output_1.group(output), ActionResult_1.Outcome.Abort);
        }
        if (result) {
            output.push(output_1.text('validate: have result'));
        }
        else {
            output.push(output_1.text('validate: do not have result'));
        }
        return ActionResult_1.actionResult(output_1.group(output));
    });
}


/***/ }),

/***/ "./src/applyStyles.ts":
/*!****************************!*\
  !*** ./src/applyStyles.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.applyStyles = void 0;
const chalk = __webpack_require__(/*! chalk */ "./node_modules/chalk/source/index.js");
function applyStyles(str, style) {
    if (style === '')
        return str;
    let fns = style.split(' ');
    let fn = chalk[fns[0]];
    if (!fn) {
        throw new Error('unknown style: ' + fns[0]);
    }
    for (let s of fns.slice(1)) {
        if (s === 'caps') {
            str = str.toUpperCase();
            continue;
        }
        fn = fn[s];
        if (!fn) {
            throw new Error('unknown style: ' + s);
        }
    }
    return fn(str);
}
exports.applyStyles = applyStyles;


/***/ }),

/***/ "./src/help.ts":
/*!*********************!*\
  !*** ./src/help.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = `
✨ *sboltools 0.1.0                                   SBOL 1.1.0   2.3.0   3.0.0*
      -> using sbolgraph 1.0.0
      -> questions/comments please contact James McLaughlin <james@mclgh.net>

**Usage**

    sbol [--output <format>]
            [action1] [action1args]
            [action2] [action2args]
            ...

This tool allows the manipulation of files describing biological systems using
the Synthetic Biology Open Language (SBOL) and other related standards such as
FASTA and GenBank.

Available actions:

%actions%

For help with a specific action, try:

    sbol <action> --help

For comprehensive documentation, check out http://sboltools.github.io
`
    .trim();


/***/ }),

/***/ "./src/identity/Identity.ts":
/*!**********************************!*\
  !*** ./src/identity/Identity.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const ActionResult_1 = __webpack_require__(/*! ../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const IdentityFactorySBOL1_1 = __webpack_require__(/*! ./IdentityFactorySBOL1 */ "./src/identity/IdentityFactorySBOL1.ts");
const IdentityFactorySBOL2_1 = __webpack_require__(/*! ./IdentityFactorySBOL2 */ "./src/identity/IdentityFactorySBOL2.ts");
const IdentityFactorySBOL3_1 = __webpack_require__(/*! ./IdentityFactorySBOL3 */ "./src/identity/IdentityFactorySBOL3.ts");
const validation_1 = __webpack_require__(/*! ./helpers/validation */ "./src/identity/helpers/validation.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
class Identity {
    constructor(sbolVersion, namespace, displayId, version, parentURI, uri) {
        // simple validation common to all SBOL versions
        this.sbolVersion = sbolVersion;
        this.namespace = namespace;
        this.displayId = displayId;
        this.version = version;
        this.parentURI = parentURI;
        this.uri = uri;
        validation_1.validateNamespace(namespace, { sbolVersion, displayId, version, parentURI, uri });
        validation_1.validateNamespaceIsPrefix(namespace, uri);
        validation_1.validateDisplayId(displayId);
    }
    static from_identity(existence, sbolVersion, g, identity, version) {
        print_1.trace(output_1.text(`from_identity: Constructing identity (existence = ${existence}) from identity ${identity}, version ${version}`));
        return factory(sbolVersion).from_identity(existence, g, identity, version);
    }
    static from_namespace_and_identity(existence, sbolVersion, g, namespace, identity, version) {
        print_1.trace(output_1.text(`from_namespace_and_identity: Constructing identity (existence = ${existence}) from namespace ${namespace}, identity ${identity}, version ${version}`));
        return factory(sbolVersion).from_namespace_and_identity(existence, g, namespace, identity, version);
    }
    static child_from_namespace_context_displayId(existence, sbolVersion, g, namespace, context, displayId, version) {
        print_1.trace(output_1.text(`child_from_namespace_context_identity: Constructing identity (existence = ${existence}) from namespace ${namespace}, context ${context}, displayId ${displayId}, version ${version}`));
        return factory(sbolVersion).child_from_namespace_context_displayId(existence, g, namespace, context, displayId, version);
    }
    static toplevel_from_namespace_displayId(existence, sbolVersion, g, namespace, displayId, version) {
        print_1.trace(output_1.text(`toplevel_from_namespace_displayId: Constructing identity (existence = ${existence}) from namespace ${namespace}, displayId ${displayId}`));
        return factory(sbolVersion).toplevel_from_namespace_displayId(existence, g, namespace, displayId, version);
    }
    static child_from_context_displayId(existence, sbolVersion, g, context, displayId, version) {
        print_1.trace(output_1.text(`child_from_namespace_displayId: Constructing identity (existence = ${existence}) from context ${context}, displayId ${displayId}, version ${version}`));
        return factory(sbolVersion).child_from_context_displayId(existence, g, context, displayId, version);
    }
    static toplevel_from_displayId(existence, sbolVersion, g, displayId, version) {
        print_1.trace(output_1.text(`toplevel_from_displayId: Constructing identity (existence = ${existence}) from displayId ${displayId}, version ${version}`));
        return factory(sbolVersion).toplevel_from_displayId(existence, g, displayId, version);
    }
}
exports.default = Identity;
function factory(sbolVersion) {
    switch (sbolVersion) {
        case get_sbol_version_from_graph_1.SBOLVersion.SBOL1:
            return new IdentityFactorySBOL1_1.default();
        case get_sbol_version_from_graph_1.SBOLVersion.SBOL2:
            return new IdentityFactorySBOL2_1.default();
        case get_sbol_version_from_graph_1.SBOLVersion.SBOL3:
            return new IdentityFactorySBOL3_1.default();
        default:
            throw ActionResult_1.actionResultAbort(output_1.text(`Unknown SBOL version`));
    }
}


/***/ }),

/***/ "./src/identity/IdentityFactory.ts":
/*!*****************************************!*\
  !*** ./src/identity/IdentityFactory.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Existence = void 0;
var Existence;
(function (Existence) {
    // UltimatelyMeaningless,
    Existence["MustExist"] = "MustExist";
    Existence["MayExist"] = "MayExist";
    Existence["MustNotExist"] = "MustNotExist";
})(Existence = exports.Existence || (exports.Existence = {}));
class IdentityFactory {
}
exports.default = IdentityFactory;


/***/ }),

/***/ "./src/identity/IdentityFactorySBOL1.ts":
/*!**********************************************!*\
  !*** ./src/identity/IdentityFactorySBOL1.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Identity_1 = __webpack_require__(/*! ./Identity */ "./src/identity/Identity.ts");
const ActionResult_1 = __webpack_require__(/*! ../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const IdentityFactory_1 = __webpack_require__(/*! ./IdentityFactory */ "./src/identity/IdentityFactory.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const join_uri_fragments_1 = __webpack_require__(/*! ../util/join-uri-fragments */ "./src/util/join-uri-fragments.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const errors_1 = __webpack_require__(/*! ./helpers/errors */ "./src/identity/helpers/errors.ts");
const validation_1 = __webpack_require__(/*! ./helpers/validation */ "./src/identity/helpers/validation.ts");
const Chain_1 = __webpack_require__(/*! ./helpers/Chain */ "./src/identity/helpers/Chain.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
class IdentityFactorySBOL1 extends IdentityFactory_1.default {
    from_namespace_and_identity(existence, g, namespace, identity, version) {
        if (version) {
            throw sbol1VersionError();
        }
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            if (Chain_1.default.isEmpty(identity)) {
                throw errors_1.identityErrorEmptyChain();
            }
            if (Chain_1.default.tokens(identity).length === 1) {
                return this.toplevel_from_namespace_displayId(existence, g, namespace, Chain_1.default.displayId(identity), undefined);
            }
            else {
                return this.child_from_namespace_context_displayId(existence, g, namespace, Chain_1.default.context(identity), Chain_1.default.displayId(identity), undefined);
            }
        }
        else {
            // URI: has to be top-level
            validation_1.validateNamespaceIsPrefix(namespace, identity);
            let displayId = identity.slice(namespace.length);
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL1, namespace, displayId, undefined, undefined, identity);
        }
    }
    from_identity(existence, g, identity, version) {
        print_1.trace(output_1.text(`SBOL1 from_identity: identity ${identity}, version ${version}`));
        if (version) {
            throw sbol1VersionError();
        }
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            // No namespace supplied and identity is a chain
            // Infer the namespace from the graph?
            let prefixes = extractPrefixesFromGraphSBOL1(g);
            if (prefixes.length !== 1) {
                throw errors_1.identityErrorUnguessableNamespace(prefixes);
            }
            return this.from_namespace_and_identity(existence, g, prefixes[0], identity, undefined);
        }
        else {
            // URI: has to be top-level
            // No namespace supplied and identity is a URI
            // Invent a namespace from the URI
            let namespace = inventUriPrefixSBOL1(identity);
            return this.from_namespace_and_identity(existence, g, namespace, identity, undefined);
        }
    }
    toplevel_from_displayId(existence, g, displayId, version) {
        print_1.trace(output_1.text(`SBOL1 toplevel_from_displayId: displayId ${displayId}, version ${version}`));
        if (version) {
            throw sbol1VersionError();
        }
        let prefixes = extractPrefixesFromGraphSBOL1(g);
        if (prefixes.length !== 1) {
            throw errors_1.identityErrorUnguessableNamespace(prefixes);
        }
        return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, undefined);
    }
    toplevel_from_namespace_displayId(existence, g, namespace, displayId, version) {
        print_1.trace(output_1.text(`SBOL1 toplevel_from_namespace_displayId: namespace ${namespace}, displayId ${displayId}, version ${version}`));
        if (version) {
            throw sbol1VersionError();
        }
        return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL1, namespace, displayId, undefined, '', join_uri_fragments_1.default([namespace, displayId]));
    }
    child_from_namespace_context_displayId(existence, g, namespace, contextIdentity, displayId, version) {
        if (version !== undefined) {
            throw sbol1VersionError();
        }
        let context = this.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, g, namespace, contextIdentity, undefined);
        assert_1.strict(context.namespace === namespace);
        // base case TL:C = context is a top level
        // recursive case C:C = context is a child
        // who cares context is a shit that has a shitting uri
        let parent = sbolgraph_1.sbol1(g).uriToFacade(context.uri);
        let children = [];
        if (parent instanceof sbolgraph_1.S1DnaComponent) {
            children = children.concat(parent.annotations);
            children = children.concat(parent.subComponents);
        }
        let match = children.filter((child) => child.getStringProperty(bioterms_1.Predicates.SBOL1.displayId) === displayId)[0];
        // TODO: does supplied version match object?
        return this.from_namespace_and_identity(existence, g, namespace, match.uri, version);
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
        if (version !== undefined) {
            throw sbol1VersionError();
        }
        let context = this.from_identity(IdentityFactory_1.Existence.MustExist, g, contextIdentity, undefined);
        let parent = sbolgraph_1.sbol1(g).uriToFacade(context.uri);
        if (!parent) {
            throw ActionResult_1.actionResultAbort(output_1.text(`Context object with identity ${contextIdentity} not found`));
        }
        let children = [];
        if (parent instanceof sbolgraph_1.S1DnaComponent) {
            children = children.concat(parent.annotations);
            children = children.concat(parent.subComponents);
        }
        let match = children.filter((child) => child.getStringProperty(bioterms_1.Predicates.SBOL1.displayId) === displayId)[0];
        return this.from_namespace_and_identity(existence, g, context.namespace, match.uri, version);
    }
}
exports.default = IdentityFactorySBOL1;
function sbol1VersionError() {
    return ActionResult_1.actionResultAbort(output_1.text(`Version is only supported in SBOL2`));
}
function extractPrefixesFromGraphSBOL1(g) {
    let v = new sbolgraph_1.SBOL1GraphView(g);
    let topLevels = v.topLevels;
    let prefixes = new Set();
    for (let t of topLevels) {
        let prefix = inventUriPrefixSBOL1(t.uri);
        if (prefix)
            prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
}
function inventUriPrefixSBOL1(uri) {
    let slash = uri.lastIndexOf('/');
    let hash = uri.lastIndexOf('#');
    if (slash !== -1) {
        return uri.slice(0, slash + 1);
    }
    if (hash !== -1) {
        return uri.slice(0, hash + 1);
    }
    return '';
}


/***/ }),

/***/ "./src/identity/IdentityFactorySBOL2.ts":
/*!**********************************************!*\
  !*** ./src/identity/IdentityFactorySBOL2.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const Identity_1 = __webpack_require__(/*! ./Identity */ "./src/identity/Identity.ts");
const ActionResult_1 = __webpack_require__(/*! ../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const IdentityFactory_1 = __webpack_require__(/*! ./IdentityFactory */ "./src/identity/IdentityFactory.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const errors_1 = __webpack_require__(/*! ./helpers/errors */ "./src/identity/helpers/errors.ts");
const Chain_1 = __webpack_require__(/*! ./helpers/Chain */ "./src/identity/helpers/Chain.ts");
const validation_1 = __webpack_require__(/*! ./helpers/validation */ "./src/identity/helpers/validation.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const join_uri_fragments_1 = __webpack_require__(/*! ../util/join-uri-fragments */ "./src/util/join-uri-fragments.ts");
const console_1 = __webpack_require__(/*! console */ "console");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const sbol2_compliant_concat_1 = __webpack_require__(/*! ../util/sbol2-compliant-concat */ "./src/util/sbol2-compliant-concat.ts");
const is_toplevel_type_1 = __webpack_require__(/*! ../util/is-toplevel-type */ "./src/util/is-toplevel-type.ts");
class IdentityFactorySBOL2 extends IdentityFactory_1.default {
    from_namespace_and_identity(existence, g, namespace, identity, version) {
        print_1.trace(output_1.text(`SBOL2 from_namespace_and_identity: existence ${existence}, namespace ${namespace}, identity ${identity}, version ${version}`));
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            if (Chain_1.default.isEmpty(identity)) {
                throw errors_1.identityErrorEmptyChain();
            }
            if (Chain_1.default.tokens(identity).length === 1) {
                return this.toplevel_from_namespace_displayId(existence, g, namespace, Chain_1.default.displayId(identity), version);
            }
            else {
                return this.child_from_namespace_context_displayId(existence, g, namespace, Chain_1.default.context(identity), Chain_1.default.displayId(identity), version);
            }
        }
        else {
            // URI: has to be top-level
            validation_1.validateNamespaceIsPrefix(namespace, identity);
            var displayId = undefined;
            // If it already exists we can take the displayId from the object
            let existing = sbolgraph_1.sbol2(g).uriToIdentified(identity);
            // TODO: check existing is TL
            if (existing) {
                if (existence === IdentityFactory_1.Existence.MustNotExist) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`An object with identity ${identity} in namespace ${namespace} already exists`));
                }
                if (version !== undefined && existing.version !== version) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`Supplied version ${version} does not match the version ${existing.version} of existing object ${identity}`));
                }
                if (existing.displayId !== undefined) {
                    displayId = existing.displayId;
                }
            }
            else {
                if (existence === IdentityFactory_1.Existence.MustExist) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`An object with identity ${identity} in namespace ${namespace} was not found`));
                }
            }
            if (displayId === undefined) {
                // The namespace has been provided and it is a prefix of our URI
                // However, the object does not exist in our graph, or it does
                // exist but does not have a displayId.
                //
                // Try to extract the displayId, compliant URI style!
                //
                let afterNamespace = identity.slice(namespace.length);
                let tokens = afterNamespace.split(/[\/#]/g);
                if (version !== undefined && tokens[tokens.length - 1] === version) {
                    tokens.pop();
                }
                displayId = tokens[tokens.length - 1];
            }
            if (displayId === undefined) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Could not determine displayId for identity ${identity}`));
            }
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, namespace, displayId, version, undefined, identity);
        }
    }
    from_identity(existence, g, identity, version) {
        print_1.trace(output_1.text(`SBOL2 from_identity: existence ${existence}, identity ${identity}, version ${version}`));
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            // No namespace supplied and identity is a chain
            // Infer the namespace from the graph?
            let prefixes = extractPrefixesFromGraphSBOL2(g);
            if (prefixes.length !== 1) {
                throw errors_1.identityErrorUnguessableNamespace(prefixes);
            }
            return this.from_namespace_and_identity(existence, g, prefixes[0], identity, version);
        }
        else {
            // URI: has to be top-level
            // No namespace supplied and identity is a URI
            var namespace = undefined;
            let existing = sbolgraph_1.sbol2(g).uriToIdentified(identity);
            // TODO: check existing is TL
            if (existing && (version === undefined || existing.version === version)) {
                if (existence === IdentityFactory_1.Existence.MustNotExist) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`An object with identity ${identity} already exists`));
                }
                namespace = existing.uriPrefix;
            }
            else {
                if (existence === IdentityFactory_1.Existence.MustExist) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`An object with identity ${identity} was not found`));
                }
            }
            if (namespace === undefined) {
                // Invent a namespace from the URI
                let persistentIdentity = identity;
                if (version !== undefined) {
                    if (identity.endsWith('/' + version) || identity.endsWith('#' + version)) {
                        persistentIdentity = identity.slice(0, identity.length - version.length - 1);
                    }
                }
                // Chop one more token off, making the assumption that it's the displayId
                let slash = persistentIdentity.lastIndexOf('/');
                let hash = persistentIdentity.lastIndexOf('#');
                if (slash === -1 && hash === -1) {
                    throw ActionResult_1.actionResultAbort(output_1.text(`Could not invent namespace for identity ${identity}`));
                }
                namespace = persistentIdentity.slice(0, Math.min(slash, hash) - 1);
            }
            if (namespace === undefined) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Could not determine namespace for identity ${identity}`));
            }
            return this.from_namespace_and_identity(existence, g, namespace, identity, version);
        }
    }
    toplevel_from_namespace_displayId(existence, g, namespace, displayId, version) {
        print_1.trace(output_1.text(`SBOL2 toplevel_from_namespace_displayId: existence ${existence} namespace ${namespace}, displayId ${displayId}, version ${version}`));
        // It may already exist. Look for objects with that displayId, and check if prefixed with the supplied namespace.
        // TODO: this may not work correctly if there are namespaces prefixed with other namespaces?
        let matches = g.match(null, bioterms_1.Predicates.SBOL2.displayId, displayId)
            .map(rdfoo_1.triple.subjectUri)
            .filter((uri) => uri && uri.indexOf(namespace) === 0);
        if (version !== undefined) {
            matches = matches.filter(uri => g.hasMatch(uri, bioterms_1.Predicates.SBOL2.version, rdfoo_1.node.createStringNode(version)));
        }
        matches = matches.filter(uri => {
            let type = rdfoo_1.triple.objectUri(g.matchOne(uri, bioterms_1.Predicates.a, null));
            return is_toplevel_type_1.default(type);
        });
        if (matches.length > 0) {
            // Already exists
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`An object with displayId ${displayId} in namespace ${namespace} already exists`));
            }
            if (matches.length > 1) {
                throw ActionResult_1.actionResultAbort(output_1.text(`More than one object with displayId ${displayId} in namespace ${namespace} found; reference is ambiguous`));
            }
            let uri = matches[0];
            console_1.assert(typeof uri === 'string');
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, namespace, displayId, version, undefined, uri);
        }
        // Does not already exist; mint a compliant URI
        if (existence === IdentityFactory_1.Existence.MustExist) {
            throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} with version ${version} in namespace ${namespace} found`));
        }
        let uri = join_uri_fragments_1.default(version ? [namespace, displayId, version] : [namespace, displayId]);
        return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, namespace, displayId, version, undefined, uri);
    }
    toplevel_from_displayId(existence, g, displayId, version) {
        print_1.trace(output_1.text(`SBOL2 toplevel_from_displayId: displayId ${displayId}`));
        // It may already exist. Look for objects with that displayId
        let matches = g.match(null, bioterms_1.Predicates.SBOL2.displayId, displayId)
            .map(rdfoo_1.triple.subjectUri);
        if (version !== undefined) {
            matches = matches.filter(uri => g.hasMatch(uri, bioterms_1.Predicates.SBOL2.version, rdfoo_1.node.createStringNode(version)));
        }
        if (matches.length > 0) {
            // Already exists
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`An object with displayId ${displayId} already exists, and no namespace was specified`));
            }
            let uri = matches[0];
            console_1.assert(typeof uri === 'string');
            return this.from_identity(IdentityFactory_1.Existence.MustExist, g, uri, version);
        }
        if (existence === IdentityFactory_1.Existence.MustExist) {
            throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} with version ${version} found`));
        }
        // Does not exist and only have a displayId
        // Infer the namespace from the graph?
        let prefixes = extractPrefixesFromGraphSBOL2(g);
        if (prefixes.length !== 1) {
            throw errors_1.identityErrorUnguessableNamespace(prefixes);
        }
        return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, version);
    }
    child_from_namespace_context_displayId(existence, g, namespace, contextIdentity, displayId, version) {
        print_1.trace(output_1.text(`SBOL2 child_from_namespace_context_displayId: existence ${existence}, namespace ${namespace}, context ${contextIdentity}, displayId ${displayId}`));
        let context = this.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, g, namespace, contextIdentity, undefined);
        console_1.assert(context.namespace === namespace);
        let parent = sbolgraph_1.sbol2(g).uriToFacade(context.uri);
        if (!parent) {
            throw ActionResult_1.actionResultAbort(output_1.text(`Context object with identity ${contextIdentity} not found`));
        }
        console_1.assert(parent instanceof sbolgraph_1.S2Identified);
        let children = [];
        if (parent instanceof sbolgraph_1.S2ComponentDefinition
            || parent instanceof sbolgraph_1.S2ModuleDefinition
            || parent instanceof sbolgraph_1.S2ComponentInstance
            || parent instanceof sbolgraph_1.S2SequenceAnnotation) {
            children = children.concat(parent.containedObjects);
        }
        let matches = children.filter((child) => displayIdMatches(child, displayId));
        if (version !== undefined) {
            matches = matches.filter(match => match.version === version);
        }
        if (matches.length === 0) {
            // does not exist
            if (existence === IdentityFactory_1.Existence.MustExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
            }
            let childUri = sbol2_compliant_concat_1.default(g, parent.uri, displayId);
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, context.namespace, displayId, version, parent.uri, childUri);
        }
        else {
            console_1.assert(matches.length === 1);
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
            }
            let match = matches[0];
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, context.namespace, displayId, version, context.uri, match.uri);
        }
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
        print_1.trace(output_1.text(`SBOL2 child_from_context_displayId: context ${contextIdentity}, displayId ${displayId}`));
        let context = this.from_identity(IdentityFactory_1.Existence.MustExist, g, contextIdentity, undefined);
        let parent = sbolgraph_1.sbol2(g).uriToFacade(context.uri);
        if (!parent) {
            throw ActionResult_1.actionResultAbort(output_1.text(`Context object with identity ${contextIdentity} not found`));
        }
        console_1.assert(parent instanceof sbolgraph_1.S2Identified);
        let children = [];
        if (parent instanceof sbolgraph_1.S2ComponentDefinition
            || parent instanceof sbolgraph_1.S2ModuleDefinition
            || parent instanceof sbolgraph_1.S2ComponentInstance
            || parent instanceof sbolgraph_1.S2SequenceAnnotation) {
            children = children.concat(parent.containedObjects);
        }
        let matches = children.filter((child) => displayIdMatches(child, displayId));
        if (version !== undefined) {
            matches = matches.filter(match => match.version === version);
        }
        if (matches.length === 0) {
            // does not exist
            if (existence === IdentityFactory_1.Existence.MustExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
            }
            let childUri = sbol2_compliant_concat_1.default(g, parent.uri, displayId);
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, context.namespace, displayId, version, parent.uri, childUri);
        }
        else {
            console_1.assert(matches.length === 1);
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
            }
            let match = matches[0];
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL2, context.namespace, displayId, version, context.uri, match.uri);
        }
    }
}
exports.default = IdentityFactorySBOL2;
function extractPrefixesFromGraphSBOL2(g) {
    let v = new sbolgraph_1.SBOL2GraphView(g);
    let prefixes = new Set();
    for (let t of v.topLevels) {
        let prefix = t.uriPrefix;
        if (prefix)
            prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
}
function displayIdMatches(obj, displayId) {
    if (obj.displayId === displayId)
        return true;
    let instanceOf = obj.getUriProperty(bioterms_1.Predicates.SBOL2.definition);
    if (instanceOf) {
        let parentObj = obj.view.uriToFacade(instanceOf);
        if (parentObj && parentObj.getStringProperty(bioterms_1.Predicates.SBOL2.displayId) === displayId) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./src/identity/IdentityFactorySBOL3.ts":
/*!**********************************************!*\
  !*** ./src/identity/IdentityFactorySBOL3.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Identity_1 = __webpack_require__(/*! ./Identity */ "./src/identity/Identity.ts");
const ActionResult_1 = __webpack_require__(/*! ../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
const IdentityFactory_1 = __webpack_require__(/*! ./IdentityFactory */ "./src/identity/IdentityFactory.ts");
const get_sbol_version_from_graph_1 = __webpack_require__(/*! ../util/get-sbol-version-from-graph */ "./src/util/get-sbol-version-from-graph.ts");
const join_uri_fragments_1 = __webpack_require__(/*! ../util/join-uri-fragments */ "./src/util/join-uri-fragments.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
const assert_1 = __webpack_require__(/*! assert */ "assert");
const errors_1 = __webpack_require__(/*! ./helpers/errors */ "./src/identity/helpers/errors.ts");
const validation_1 = __webpack_require__(/*! ./helpers/validation */ "./src/identity/helpers/validation.ts");
const Chain_1 = __webpack_require__(/*! ./helpers/Chain */ "./src/identity/helpers/Chain.ts");
const print_1 = __webpack_require__(/*! ../output/print */ "./src/output/print.ts");
const get_last_uri_fragment_1 = __webpack_require__(/*! ../util/get-last-uri-fragment */ "./src/util/get-last-uri-fragment.ts");
class IdentityFactorySBOL3 extends IdentityFactory_1.default {
    from_namespace_and_identity(existence, g, namespace, identity, version) {
        if (version) {
            throw sbol3VersionError();
        }
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            if (Chain_1.default.isEmpty(identity)) {
                throw errors_1.identityErrorEmptyChain();
            }
            if (Chain_1.default.tokens(identity).length === 1) {
                return this.toplevel_from_namespace_displayId(existence, g, namespace, Chain_1.default.displayId(identity), undefined);
            }
            else {
                return this.child_from_namespace_context_displayId(existence, g, namespace, Chain_1.default.context(identity), Chain_1.default.displayId(identity), undefined);
            }
        }
        else {
            // URI: has to be top-level
            validation_1.validateNamespaceIsPrefix(namespace, identity);
            let displayId = get_last_uri_fragment_1.default(identity);
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, namespace, displayId, undefined, undefined, identity);
        }
    }
    from_identity(existence, g, identity, version) {
        if (version) {
            throw sbol3VersionError();
        }
        print_1.trace(output_1.text(`SBOL3 from_identity: identity ${identity}`));
        if (Chain_1.default.isChain(identity)) {
            // Chain: can be top-level or child
            // No namespace supplied and identity is a chain
            // Infer the namespace from the graph?
            let prefixes = extractPrefixesFromGraphSBOL3(g);
            if (prefixes.length !== 1) {
                throw errors_1.identityErrorUnguessableNamespace(prefixes);
            }
            return this.from_namespace_and_identity(existence, g, prefixes[0], identity, undefined);
        }
        else {
            // URI: has to be top-level
            // No namespace supplied and identity is a URI
            // Invent a namespace from the URI
            let namespace = inventUriPrefixSBOL3(identity);
            return this.from_namespace_and_identity(existence, g, namespace, identity, undefined);
        }
    }
    toplevel_from_displayId(existence, g, displayId, version) {
        if (version) {
            throw sbol3VersionError();
        }
        print_1.trace(output_1.text(`SBOL3 toplevel_from_displayId: displayId ${displayId}`));
        let prefixes = extractPrefixesFromGraphSBOL3(g);
        if (prefixes.length !== 1) {
            throw errors_1.identityErrorUnguessableNamespace(prefixes);
        }
        return this.toplevel_from_namespace_displayId(existence, g, prefixes[0], displayId, undefined);
    }
    toplevel_from_namespace_displayId(existence, g, namespace, displayId, version) {
        if (version) {
            throw sbol3VersionError();
        }
        print_1.trace(output_1.text(`SBOL3 toplevel_from_namespace_displayId: namespace ${namespace}, displayId ${displayId}`));
        return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, namespace, displayId, undefined, '', join_uri_fragments_1.default([namespace, displayId]));
    }
    child_from_namespace_context_displayId(existence, g, namespace, contextIdentity, displayId, version) {
        if (version !== undefined) {
            throw sbol3VersionError();
        }
        let context = this.from_namespace_and_identity(IdentityFactory_1.Existence.MustExist, g, namespace, contextIdentity, undefined);
        assert_1.strict(context.namespace === namespace);
        // base case TL:C = context is a top level
        // recursive case C:C = context is a child
        let parent = sbolgraph_1.sbol3(g).uriToFacade(context.uri);
        assert_1.strict(parent instanceof sbolgraph_1.S3Identified);
        let children = parent.ownedObjects;
        let matches = children.filter((child) => displayIdMatches(child, displayId));
        if (matches.length === 0) {
            // does not exist
            if (existence === IdentityFactory_1.Existence.MustExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} in context ${JSON.stringify(context)}`));
            }
            // TODO ??
            let childUri = parent.uri + '/' + displayId;
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, context.namespace, displayId, version, parent.uri, childUri);
        }
        else {
            assert_1.strict(matches.length === 1);
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Object with displayId ${displayId} already exists in context ${JSON.stringify(context)}`));
            }
            let match = matches[0];
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, context.namespace, displayId, version, context.uri, match.uri);
        }
    }
    child_from_context_displayId(existence, g, contextIdentity, displayId, version) {
        if (version !== undefined) {
            throw sbol3VersionError();
        }
        let context = this.from_identity(IdentityFactory_1.Existence.MustExist, g, contextIdentity, undefined);
        let parent = sbolgraph_1.sbol3(g).uriToFacade(context.uri);
        if (!parent) {
            throw ActionResult_1.actionResultAbort(output_1.text(`Context object with identity ${contextIdentity} not found`));
        }
        assert_1.strict(parent instanceof sbolgraph_1.S3Identified);
        let matches = parent.ownedObjects.filter((child) => displayIdMatches(child, displayId));
        if (matches.length === 0) {
            // does not exist
            if (existence === IdentityFactory_1.Existence.MustExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`No object with displayId ${displayId} and version ${version} found in context ${JSON.stringify(context)}`));
            }
            let childUri = parent.uri + '/' + displayId;
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, context.namespace, displayId, version, parent.uri, childUri);
        }
        else {
            assert_1.strict(matches.length === 1);
            if (existence === IdentityFactory_1.Existence.MustNotExist) {
                throw ActionResult_1.actionResultAbort(output_1.text(`Object with displayId ${displayId} and version ${version} already exists in context ${context}`));
            }
            let match = matches[0];
            return new Identity_1.default(get_sbol_version_from_graph_1.SBOLVersion.SBOL3, context.namespace, displayId, version, context.uri, match.uri);
        }
    }
}
exports.default = IdentityFactorySBOL3;
function sbol3VersionError() {
    return ActionResult_1.actionResultAbort(output_1.text(`Version is only supported in SBOL2`));
}
function extractPrefixesFromGraphSBOL3(g) {
    let v = new sbolgraph_1.SBOL3GraphView(g);
    let prefixes = new Set();
    for (let t of v.topLevels) {
        let prefix = t.uriPrefix;
        if (prefix)
            prefixes.add(prefix);
    }
    let arr = Array.from(prefixes);
    arr.sort((a, b) => a.length - b.length);
    return arr;
}
function inventUriPrefixSBOL3(uri) {
    let slash = uri.lastIndexOf('/');
    let hash = uri.lastIndexOf('#');
    if (slash !== -1) {
        return uri.slice(0, slash + 1);
    }
    if (hash !== -1) {
        return uri.slice(0, hash + 1);
    }
    return '';
}
function displayIdMatches(obj, displayId) {
    if (obj.displayId === displayId)
        return true;
    let instanceOf = obj.getUriProperty(bioterms_1.Predicates.SBOL3.instanceOf);
    if (instanceOf) {
        let parentObj = obj.view.uriToFacade(instanceOf);
        if (parentObj && parentObj.getStringProperty(bioterms_1.Predicates.SBOL3.displayId) === displayId) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./src/identity/helpers/Chain.ts":
/*!***************************************!*\
  !*** ./src/identity/helpers/Chain.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __webpack_require__(/*! assert */ "assert");
class Chain {
    static isChain(chain) {
        return chain[0] === '.';
    }
    static isEmpty(chain) {
        return Chain.tokens(chain).length === 0;
    }
    static context(chain) {
        return '.' + Chain.tokens(chain).slice(0, -1).join('.');
    }
    static displayId(chain) {
        return Chain.tokens(chain).pop();
    }
    static tokens(chain) {
        assert_1.strict(Chain.isChain(chain));
        return chain.slice(1).split('.');
    }
}
exports.default = Chain;


/***/ }),

/***/ "./src/identity/helpers/errors.ts":
/*!****************************************!*\
  !*** ./src/identity/helpers/errors.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.identityErrorEmptyChain = exports.identityErrorChildIdentityMissingContext = exports.identityErrorUnguessableNamespace = exports.identityErrorGeneric = void 0;
const ActionResult_1 = __webpack_require__(/*! ../../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
function identityErrorGeneric() {
    return ActionResult_1.actionResultAbort(output_1.text(`Unable to construct an identity using the supplied parameters`));
}
exports.identityErrorGeneric = identityErrorGeneric;
function identityErrorUnguessableNamespace(namespaces) {
    if (namespaces.length > 0) {
        return ActionResult_1.actionResultAbort(output_1.text(`No namespace was specified, and cannot default to a single existing namespace as there are ${namespaces.length} different namespaces in use in the knowledge graph: ${namespaces.join(', ')}`));
    }
    else {
        return ActionResult_1.actionResultAbort(output_1.text(`No namespace was specified, and cannot default to a single existing namespace as the knowledge graph appears to be empty`));
    }
}
exports.identityErrorUnguessableNamespace = identityErrorUnguessableNamespace;
function identityErrorChildIdentityMissingContext() {
    return ActionResult_1.actionResultAbort(output_1.text(`The combination of identity parameters used indicates a child object, but no context was provided to indicate the parent`));
}
exports.identityErrorChildIdentityMissingContext = identityErrorChildIdentityMissingContext;
function identityErrorEmptyChain() {
    return ActionResult_1.actionResultAbort(output_1.text(`Empty identity chain`));
}
exports.identityErrorEmptyChain = identityErrorEmptyChain;


/***/ }),

/***/ "./src/identity/helpers/validation.ts":
/*!********************************************!*\
  !*** ./src/identity/helpers/validation.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNamespaceIsPrefix = exports.validateNamespace = exports.validateDisplayId = void 0;
const ActionResult_1 = __webpack_require__(/*! ../../actions/ActionResult */ "./src/actions/ActionResult.ts");
const output_1 = __webpack_require__(/*! ../../output/output */ "./src/output/output.ts");
const print_1 = __webpack_require__(/*! ../../output/print */ "./src/output/print.ts");
function validateDisplayId(displayId) {
    if (displayId.length === 0) {
        throw ActionResult_1.actionResultAbort(output_1.text(`Empty displayId`));
    }
    if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(displayId)) {
        throw ActionResult_1.actionResultAbort(output_1.text(`displayId '${displayId}': must start with a letter or underscore and be composed of only alphanumeric and underscore characters`));
    }
}
exports.validateDisplayId = validateDisplayId;
function validateNamespace(namespace, debug) {
    if (namespace.length === 0) {
        print_1.trace(output_1.group([
            output_1.text('Namespace validation debug output:'),
            output_1.spacer(),
            output_1.indent([
                output_1.jsonTree(debug)
            ])
        ]));
        throw ActionResult_1.actionResultAbort(output_1.group([
            output_1.text(`Empty namespace`)
        ]));
    }
    if (namespace[namespace.length - 1] !== '/' && namespace[namespace.length - 1] !== '#') {
        throw ActionResult_1.actionResultAbort(output_1.text(`Namespace ${namespace} does not look valid: should end in / or #`));
    }
}
exports.validateNamespace = validateNamespace;
function validateNamespaceIsPrefix(ns, uri) {
    if (uri.indexOf(ns) !== 0) {
        throw ActionResult_1.actionResultAbort(output_1.text(`Specified namespace ${ns} is not a prefix of identity URI ${uri}`));
    }
}
exports.validateNamespaceIsPrefix = validateNamespaceIsPrefix;


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sboltools_1 = __webpack_require__(/*! ./sboltools */ "./src/sboltools.ts");
main();
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        let out = yield sboltools_1.default(process.argv);
        if (out) {
            process.stdout.write(out);
        }
    });
}


/***/ }),

/***/ "./src/output/OutputNode.ts":
/*!**********************************!*\
  !*** ./src/output/OutputNode.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class OutputNode {
    constructor(children) {
        this.children = children || [];
    }
}
exports.default = OutputNode;


/***/ }),

/***/ "./src/output/OutputNodeGroup.ts":
/*!***************************************!*\
  !*** ./src/output/OutputNodeGroup.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeGroup extends OutputNode_1.default {
    constructor(children) {
        super(children);
    }
}
exports.default = OutputNodeGroup;


/***/ }),

/***/ "./src/output/OutputNodeHeader.ts":
/*!****************************************!*\
  !*** ./src/output/OutputNodeHeader.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeHeader extends OutputNode_1.default {
    constructor(title, style) {
        super();
        this.title = title;
        this.style = style || 'white bold underline';
    }
}
exports.default = OutputNodeHeader;


/***/ }),

/***/ "./src/output/OutputNodeIndent.ts":
/*!****************************************!*\
  !*** ./src/output/OutputNodeIndent.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeIndent extends OutputNode_1.default {
    constructor(children) {
        super(children);
    }
}
exports.default = OutputNodeIndent;


/***/ }),

/***/ "./src/output/OutputNodeJSONTree.ts":
/*!******************************************!*\
  !*** ./src/output/OutputNodeJSONTree.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeJSONTree extends OutputNode_1.default {
    constructor(obj) {
        super();
        this.obj = obj;
    }
}
exports.default = OutputNodeJSONTree;


/***/ }),

/***/ "./src/output/OutputNodeMultiline.ts":
/*!*******************************************!*\
  !*** ./src/output/OutputNodeMultiline.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeMultiline extends OutputNode_1.default {
    constructor(text, style) {
        super();
        this.text = text;
        this.style = style || '';
    }
}
exports.default = OutputNodeMultiline;


/***/ }),

/***/ "./src/output/OutputNodeSpacer.ts":
/*!****************************************!*\
  !*** ./src/output/OutputNodeSpacer.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeSpacer extends OutputNode_1.default {
    constructor() {
        super();
    }
}
exports.default = OutputNodeSpacer;


/***/ }),

/***/ "./src/output/OutputNodeTabulated.ts":
/*!*******************************************!*\
  !*** ./src/output/OutputNodeTabulated.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeTabulated extends OutputNode_1.default {
    constructor(rows) {
        super();
        this.rows = rows;
    }
}
exports.default = OutputNodeTabulated;


/***/ }),

/***/ "./src/output/OutputNodeText.ts":
/*!**************************************!*\
  !*** ./src/output/OutputNodeText.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeText extends OutputNode_1.default {
    constructor(text, style) {
        super();
        this.text = text;
        this.style = style || '';
    }
}
exports.default = OutputNodeText;


/***/ }),

/***/ "./src/output/OutputNodeTree.ts":
/*!**************************************!*\
  !*** ./src/output/OutputNodeTree.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNode_1 = __webpack_require__(/*! ./OutputNode */ "./src/output/OutputNode.ts");
class OutputNodeTree extends OutputNode_1.default {
    constructor(text, attribs, children) {
        super(children);
        this.text = text;
        this.attribs = attribs;
        this.children = children;
    }
}
exports.default = OutputNodeTree;


/***/ }),

/***/ "./src/output/output.ts":
/*!******************************!*\
  !*** ./src/output/output.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonTree = exports.tabulated = exports.conditional = exports.indent = exports.group = exports.treeNode = exports.multiline = exports.text = exports.spacer = exports.header = void 0;
const OutputNodeHeader_1 = __webpack_require__(/*! ./OutputNodeHeader */ "./src/output/OutputNodeHeader.ts");
const OutputNodeSpacer_1 = __webpack_require__(/*! ./OutputNodeSpacer */ "./src/output/OutputNodeSpacer.ts");
const OutputNodeText_1 = __webpack_require__(/*! ./OutputNodeText */ "./src/output/OutputNodeText.ts");
const OutputNodeTree_1 = __webpack_require__(/*! ./OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const OutputNodeGroup_1 = __webpack_require__(/*! ./OutputNodeGroup */ "./src/output/OutputNodeGroup.ts");
const OutputNodeIndent_1 = __webpack_require__(/*! ./OutputNodeIndent */ "./src/output/OutputNodeIndent.ts");
const OutputNodeTabulated_1 = __webpack_require__(/*! ./OutputNodeTabulated */ "./src/output/OutputNodeTabulated.ts");
const OutputNodeJSONTree_1 = __webpack_require__(/*! ./OutputNodeJSONTree */ "./src/output/OutputNodeJSONTree.ts");
const OutputNodeMultiline_1 = __webpack_require__(/*! ./OutputNodeMultiline */ "./src/output/OutputNodeMultiline.ts");
function header(title, style) {
    return new OutputNodeHeader_1.default(title, style);
}
exports.header = header;
function spacer() {
    return new OutputNodeSpacer_1.default();
}
exports.spacer = spacer;
function text(text, style) {
    return new OutputNodeText_1.default(text, style);
}
exports.text = text;
function multiline(text, style) {
    return new OutputNodeMultiline_1.default(text, style);
}
exports.multiline = multiline;
function treeNode(text, attribs, children) {
    return new OutputNodeTree_1.default(text, attribs, children);
}
exports.treeNode = treeNode;
function group(children) {
    return new OutputNodeGroup_1.default(children);
}
exports.group = group;
function indent(children) {
    return new OutputNodeIndent_1.default(children);
}
exports.indent = indent;
function conditional(cond, children) {
    return new OutputNodeGroup_1.default(cond ? children : []);
}
exports.conditional = conditional;
function tabulated(rows) {
    return new OutputNodeTabulated_1.default(rows);
}
exports.tabulated = tabulated;
function jsonTree(obj) {
    return new OutputNodeJSONTree_1.default(obj);
}
exports.jsonTree = jsonTree;


/***/ }),

/***/ "./src/output/print.ts":
/*!*****************************!*\
  !*** ./src/output/print.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.printStderr = exports.endCaptureOutput = exports.beginCaptureOutput = exports.enableTrace = exports.trace = exports.print = void 0;
const tostring_1 = __webpack_require__(/*! ./tostring */ "./src/output/tostring.ts");
const chalk = __webpack_require__(/*! chalk */ "./node_modules/chalk/source/index.js");
let traceOn = false;
let captureOutput = false;
// let captured:string[] = []
let captured = [];
function print(node, prefix) {
    if (captureOutput) {
        captured.push({ type: 'print', node: node });
        return;
    }
    if (prefix) {
        let out = tostring_1.default(0, node);
        out = out.trim().split('\n').map(line => prefix + line).join('\n');
        out = out + '\n';
        printStderr(out + '\n');
    }
    else {
        printStderr(tostring_1.default(0, node));
    }
}
exports.print = print;
function trace(node) {
    if (!traceOn)
        return;
    if (captureOutput) {
        captured.push({ type: 'trace', node: node });
        return;
    }
    let out = tostring_1.default(0, node);
    out = out.trim().split('\n').map(line => '[trace] ' + line).join('\n');
    out = chalk.dim(out) + '\n';
    printStderr(chalk.dim(out));
}
exports.trace = trace;
function enableTrace() {
    traceOn = true;
}
exports.enableTrace = enableTrace;
function beginCaptureOutput() {
    captureOutput = true;
    captured = [];
}
exports.beginCaptureOutput = beginCaptureOutput;
function endCaptureOutput() {
    captureOutput = false;
    return captured;
}
exports.endCaptureOutput = endCaptureOutput;
function printStderr(out) {
    // if (captureOutput) {
    //     captured.push(out)
    // } else {
    process.stderr.write(out);
    // }
}
exports.printStderr = printStderr;


/***/ }),

/***/ "./src/output/tostring.ts":
/*!********************************!*\
  !*** ./src/output/tostring.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const OutputNodeTree_1 = __webpack_require__(/*! ./OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const OutputNodeText_1 = __webpack_require__(/*! ./OutputNodeText */ "./src/output/OutputNodeText.ts");
const OutputNodeSpacer_1 = __webpack_require__(/*! ./OutputNodeSpacer */ "./src/output/OutputNodeSpacer.ts");
const OutputNodeHeader_1 = __webpack_require__(/*! ./OutputNodeHeader */ "./src/output/OutputNodeHeader.ts");
const applyStyles_1 = __webpack_require__(/*! ../applyStyles */ "./src/applyStyles.ts");
const OutputNodeGroup_1 = __webpack_require__(/*! ./OutputNodeGroup */ "./src/output/OutputNodeGroup.ts");
const OutputNodeIndent_1 = __webpack_require__(/*! ./OutputNodeIndent */ "./src/output/OutputNodeIndent.ts");
const OutputNodeTabulated_1 = __webpack_require__(/*! ./OutputNodeTabulated */ "./src/output/OutputNodeTabulated.ts");
const OutputNodeJSONTree_1 = __webpack_require__(/*! ./OutputNodeJSONTree */ "./src/output/OutputNodeJSONTree.ts");
const colorizeJSON = __webpack_require__(/*! json-colorizer */ "./node_modules/json-colorizer/src/lib/index.js");
const OutputNodeMultiline_1 = __webpack_require__(/*! ./OutputNodeMultiline */ "./src/output/OutputNodeMultiline.ts");
let INDENT_SIZE = 4;
function tostring(indent, node) {
    let lastWasSpace = false;
    let out = [];
    printNode(node, indent);
    out.push('');
    return out.join('\n');
    function printNode(node, depth) {
        if (node instanceof OutputNodeGroup_1.default) {
            printGroupNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeTree_1.default) {
            printTreeNode(node, depth, depth);
            return;
        }
        else if (node instanceof OutputNodeText_1.default) {
            printTextNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeMultiline_1.default) {
            printMultilineNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeSpacer_1.default) {
            printSpacerNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeHeader_1.default) {
            printHeaderNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeIndent_1.default) {
            printIndentNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeTabulated_1.default) {
            printTabulatedNode(node, depth);
            return;
        }
        else if (node instanceof OutputNodeJSONTree_1.default) {
            printJSONTreeNode(node, depth);
            return;
        }
        else {
            throw new Error('unknown node type >>' + JSON.stringify(node) + '<<');
        }
    }
    function printGroupNode(node, depth) {
        for (let child of node.children) {
            printNode(child, depth);
        }
    }
    function printTextNode(node, depth) {
        lastWasSpace = false;
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        out.push(indentstr + applyStyles_1.applyStyles(node.text, node.style));
        for (let child of node.children) {
            printNode(child, depth + 1);
        }
    }
    function printMultilineNode(node, depth) {
        lastWasSpace = false;
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        for (let line of node.text.split('\n')) {
            out.push(indentstr + applyStyles_1.applyStyles(line, node.style));
        }
    }
    function printTreeNode(node, rootDepth, depth) {
        lastWasSpace = false;
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        let branch = depth > rootDepth ? '┗ ' : '';
        out.push(indentstr + branch + node.text);
        for (let child of node.children) {
            if (!(child instanceof OutputNodeTree_1.default)) {
                throw new Error('tree child not tree node');
            }
            printTreeNode(child, rootDepth, depth + 1);
        }
    }
    function printSpacerNode(node, depth) {
        if (lastWasSpace)
            return;
        lastWasSpace = true;
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        out.push(indentstr);
    }
    function printHeaderNode(node, depth) {
        lastWasSpace = false;
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        out.push(indentstr + applyStyles_1.applyStyles(node.title, node.style));
        for (let child of node.children) {
            printNode(child, depth + 1);
        }
    }
    function printIndentNode(node, depth) {
        for (let child of node.children) {
            printNode(child, depth + 1);
        }
    }
    function printTabulatedNode(node, depth) {
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        let cols = 0;
        for (let row of node.rows) {
            cols = Math.max(cols, row.length);
        }
        let widths = [];
        for (let i = 0; i < cols; ++i) {
            widths.push(0);
        }
        for (let row of node.rows) {
            for (let i = 0; i < cols; ++i) {
                widths[i] = Math.max(widths[i], row[i].length);
            }
        }
        for (let i = 0; i < cols; ++i) {
            widths[i] = widths[i] + 7;
        }
        for (let row of node.rows) {
            let outRow = '';
            for (let c = 0; c < row.length; ++c) {
                let outCol = row[c];
                while (outCol.length < widths[c]) {
                    outCol += ' ';
                }
                outRow += outCol;
            }
            out.push(indentstr + outRow);
        }
    }
    function printJSONTreeNode(node, depth) {
        let indentstr = ' '.repeat(depth * INDENT_SIZE);
        // ensure undefined properties get serialized (as null)
        let replace = (k, v) => v === undefined ? null : v;
        let json = colorizeJSON(JSON.stringify(node.obj, replace, 2));
        for (let line of json.split('\n')) {
            out.push(indentstr + line);
        }
    }
}
exports.default = tostring;


/***/ }),

/***/ "./src/parse-argv.ts":
/*!***************************!*\
  !*** ./src/parse-argv.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgvOptionSet = exports.ArgvNamedOption = exports.ArgvAction = exports.ArgvArgs = void 0;
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions/index.ts");
class ArgvArgs {
    constructor(globalOpts, actions) {
        this.globalOpts = globalOpts;
        this.actions = actions;
    }
}
exports.ArgvArgs = ArgvArgs;
class ArgvAction {
    constructor(name, namedOpts, positionalOpts) {
        this.name = name;
        this.namedOpts = namedOpts;
        this.positionalOpts = positionalOpts;
    }
}
exports.ArgvAction = ArgvAction;
class ArgvNamedOption {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
}
exports.ArgvNamedOption = ArgvNamedOption;
class ArgvOptionSet {
    constructor(opts, identityChain) {
        this.opts = opts;
        this.identityChain = identityChain;
    }
    getStringOrUndefined(opt) {
        var _a;
        let value = (_a = this.opts.filter(o => o.name === opt)[0]) === null || _a === void 0 ? void 0 : _a.value;
        return value;
    }
    getString(opt, def) {
        var _a;
        let value = (_a = this.opts.filter(o => o.name === opt)[0]) === null || _a === void 0 ? void 0 : _a.value;
        return value === undefined ? def : value;
    }
    getFlag(opt) {
        let value = this.opts.filter(o => o.name === opt)[0];
        return value !== undefined;
    }
    getIdentityChain() {
        return this.identityChain;
    }
}
exports.ArgvOptionSet = ArgvOptionSet;
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Option"] = 0] = "Option";
    TokenType[TokenType["Action"] = 1] = "Action";
    TokenType[TokenType["IdentityChain"] = 2] = "IdentityChain";
    TokenType[TokenType["Other"] = 3] = "Other";
})(TokenType || (TokenType = {}));
function parseArgv(argv) {
    let args = argv.slice(2);
    let globalOpts = [];
    let actions = [];
    // Global opts
    while (args.length > 0) {
        let { type, name } = parseToken(args[0]);
        if (type === TokenType.Option) {
            args.shift();
            let option = { name };
            if (parseToken(args[0]).type === TokenType.Other) {
                option.value = args.shift();
            }
            globalOpts.push(option);
            continue;
        }
        else {
            break;
        }
    }
    // Actions
    while (args.length > 0) {
        actions.push(parseAction());
    }
    return new ArgvArgs(new ArgvOptionSet(globalOpts), actions);
    function parseAction() {
        let name = args.shift();
        let def = actions_1.default.filter(a => a.name === name)[0];
        let namedOpts = [];
        let positionalOpts = [];
        let nPositionalRemaining = def === null || def === void 0 ? void 0 : def.positionalOpts.length;
        let idChain = undefined;
        while (args.length > 0) {
            let { name, type } = parseToken(args[0]);
            if (type === TokenType.IdentityChain) {
                if (idChain !== undefined) {
                    throw new Error('multiple anonymous id chains specified in args: ' + args[0]);
                }
                idChain = args.shift();
                continue;
            }
            if (type !== TokenType.Option) {
                if (nPositionalRemaining > 0) {
                    --nPositionalRemaining;
                    positionalOpts.push(args[0]);
                    args.shift();
                    continue;
                }
                else {
                    break;
                }
            }
            args.shift();
            let option = { name };
            if (parseToken(args[0]).type !== TokenType.Action) {
                option.value = args.shift();
            }
            namedOpts.push(option);
        }
        return new ArgvAction(name, new ArgvOptionSet(namedOpts, idChain), positionalOpts);
    }
}
exports.default = parseArgv;
function isAction(str) {
    return actions_1.default.filter(a => a.name === str).length > 0;
}
function parseToken(str) {
    if (/^-[^-]/g.test(str)) {
        return { type: TokenType.Option, name: str.slice(1) };
    }
    else if (/^--[^-]/g.test(str)) {
        return { type: TokenType.Option, name: str.slice(2) };
    }
    else if (str[0] === '.') {
        return { type: TokenType.IdentityChain };
    }
    else if (isAction(str)) {
        return { type: TokenType.Action };
    }
    else {
        return { type: TokenType.Other };
    }
}


/***/ }),

/***/ "./src/sbol1/dnaComponentTree.ts":
/*!***************************************!*\
  !*** ./src/sbol1/dnaComponentTree.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.dnaComponentTree = void 0;
const OutputNodeTree_1 = __webpack_require__(/*! ../output/OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
function dnaComponentTree(gv) {
    let roots = gv.rootDnaComponents;
    return output_1.group(roots.map(dnaComponentToNode));
    function dnaComponentToNode(c) {
        // console.log(gv.graph.match(c.uri, null, null))
        // console.log(c.getUriProperties(Predicates.SBOL1.subComponent).length)
        return new OutputNodeTree_1.default(c.name || c.displayId || c.uri, { 'foo': 'bar' }, c.subComponents.map(dnaComponentToNode)
            .concat([c.dnaSequence].filter((seq) => seq !== undefined).map(dnaSequenceToNode)));
    }
    function dnaSequenceToNode(c) {
        return new OutputNodeTree_1.default(c.name || c.uri, { 'foo': 'bar' }, []);
    }
}
exports.dnaComponentTree = dnaComponentTree;


/***/ }),

/***/ "./src/sbol2/cdTree.ts":
/*!*****************************!*\
  !*** ./src/sbol2/cdTree.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.cdTree = void 0;
const OutputNodeTree_1 = __webpack_require__(/*! ../output/OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
function cdTree(gv) {
    let roots = gv.structurallyRootComponentDefinitions;
    return output_1.group(roots.map(cdToNode));
    function cdToNode(cd) {
        return new OutputNodeTree_1.default(cd.displayName || '???', { 'foo': 'bar' }, cd.components.map(cToNode));
    }
    function cToNode(m) {
        if (roots.filter(r => r.uri === m.uri).length > 0) {
            // its a root
            return new OutputNodeTree_1.default(' -> ' + m.definition.displayName, {}, []);
        }
        else {
            return cdToNode(m.definition);
        }
    }
}
exports.cdTree = cdTree;


/***/ }),

/***/ "./src/sbol2/mdTree.ts":
/*!*****************************!*\
  !*** ./src/sbol2/mdTree.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.mdTree = void 0;
const OutputNodeTree_1 = __webpack_require__(/*! ../output/OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
function mdTree(gv) {
    let roots = gv.rootModuleDefinitions;
    return output_1.group(roots.map(mdToNode));
    function mdToNode(md) {
        return new OutputNodeTree_1.default('ModuleDefinition ' + md.displayName, { 'foo': 'bar' }, md.modules.map(mToNode)
            .concat(md.functionalComponents.map(fcToNode)));
    }
    function mToNode(m) {
        if (roots.filter(r => r.uri === m.uri).length > 0) {
            // its a root
            return {
                text: 'ModuleDefinition --[definition]--> ' + m.definition.displayName,
                attribs: {},
                children: []
            };
        }
        else {
            return mdToNode(m.definition);
        }
    }
    function fcToNode(fc) {
        let node = new OutputNodeTree_1.default(fc.definition.displayName || '??fc', {}, []);
        return node;
    }
}
exports.mdTree = mdTree;


/***/ }),

/***/ "./src/sbol3/componentTree.ts":
/*!************************************!*\
  !*** ./src/sbol3/componentTree.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.componentTree = void 0;
const OutputNodeTree_1 = __webpack_require__(/*! ../output/OutputNodeTree */ "./src/output/OutputNodeTree.ts");
const output_1 = __webpack_require__(/*! ../output/output */ "./src/output/output.ts");
function componentTree(gv) {
    let roots = gv.components;
    return output_1.group(roots.map(componentToNode));
    function componentToNode(c) {
        return new OutputNodeTree_1.default(c.displayName || 'c?', { 'foo': 'bar' }, c.subComponents.map(subComponentToNode));
    }
    function subComponentToNode(c) {
        return new OutputNodeTree_1.default(c.displayName || 'sc?', { 'foo': 'bar' }, []);
    }
}
exports.componentTree = componentTree;


/***/ }),

/***/ "./src/sboltools.ts":
/*!**************************!*\
  !*** ./src/sboltools.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const print_1 = __webpack_require__(/*! ./output/print */ "./src/output/print.ts");
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions/index.ts");
const parse_argv_1 = __webpack_require__(/*! ./parse-argv */ "./src/parse-argv.ts");
const help_1 = __webpack_require__(/*! ./help */ "./src/help.ts");
const summarize_1 = __webpack_require__(/*! ./summarize */ "./src/summarize.ts");
const ActionResult_1 = __webpack_require__(/*! ./actions/ActionResult */ "./src/actions/ActionResult.ts");
const chalk = __webpack_require__(/*! chalk */ "./node_modules/chalk/source/index.js");
const output_1 = __webpack_require__(/*! ./output/output */ "./src/output/output.ts");
const ActionDef_1 = __webpack_require__(/*! ./actions/ActionDef */ "./src/actions/ActionDef.ts");
const Context_1 = __webpack_require__(/*! ./Context */ "./src/Context.ts");
function sboltools(args) {
    return __awaiter(this, void 0, void 0, function* () {
        // console.dir(args)
        let argv = parse_argv_1.default(args);
        // console.dir(argv)
        if (argv.actions.length === 0 ||
            (argv.globalOpts.getFlag('help') || argv.globalOpts.getFlag('h'))) {
            help();
            return;
        }
        if (argv.globalOpts.getFlag('trace')) {
            print_1.enableTrace();
            print_1.trace(output_1.text('sboltools trace output is enabled'));
        }
        let output = argv.globalOpts.getString('output', 'summary');
        let graphs = new Map();
        let ctx = new Context_1.default();
        let aborted = false;
        for (let action of argv.actions) {
            let actDef = actions_1.default.filter(a => a.name === action.name)[0];
            if (actDef === undefined) {
                print_1.print(output_1.text('Unknown action: ' + action.name));
                aborted = true;
                break;
            }
            if (action.namedOpts.getFlag('help') || action.namedOpts.getFlag('h')) {
                help();
                break;
            }
            let namedOpts = actDef.namedOpts.map(optDef => new optDef.type(actDef, optDef, action.namedOpts));
            // todo hacky af
            let positionalOpts = actDef.positionalOpts.map((optDef, i) => new optDef.type(actDef, optDef, new parse_argv_1.ArgvOptionSet([
                new parse_argv_1.ArgvNamedOption(optDef.name, action.positionalOpts[i])
            ], undefined)));
            // console.dir('po')
            // console.dir(positionalOpts)
            let err = false;
            try {
                print_1.trace(output_1.text(`Begin action: ${actDef.name}`));
                var actionResult = yield actDef.run(ctx, namedOpts, positionalOpts);
            }
            catch (e) {
                if (e instanceof ActionResult_1.default) {
                    actionResult = e;
                    err = true;
                }
                else {
                    throw e;
                }
            }
            if (err) {
                if (actionResult.output !== undefined) {
                    print_1.print(actionResult.output, chalk.red.bold(action.name + ': '));
                }
            }
            else {
                if (actionResult.output !== undefined) {
                    print_1.print(actionResult.output, chalk.bold(action.name + ': '));
                }
            }
            if (actionResult.outcome === ActionResult_1.Outcome.Abort) {
                aborted = true;
                break;
            }
            if (actionResult.outcome === ActionResult_1.Outcome.ShowHelp) {
                help();
                break;
            }
            function help() {
                print_1.print(output_1.group([
                    output_1.text(ActionDef_1.def2usage(actDef).trim()),
                    output_1.spacer(),
                    actDef.description ? output_1.text(actDef.description) : output_1.spacer(),
                    output_1.spacer(),
                    actDef.help ? output_1.text(actDef.help) : output_1.spacer()
                ]));
                aborted = true;
            }
        }
        if (aborted) {
            process.exitCode = 1;
        }
        else {
            switch (output) {
                case 'summary':
                    summarize_1.default(ctx.getCurrentGraph());
                    break;
                case 'sbol1':
                    return new sbolgraph_1.SBOL1GraphView(ctx.getCurrentGraph()).serializeXML();
                case 'sbol2':
                    return new sbolgraph_1.SBOL2GraphView(ctx.getCurrentGraph()).serializeXML();
                case 'sbol3':
                    return new sbolgraph_1.SBOL3GraphView(ctx.getCurrentGraph()).serializeXML();
                case 'fasta':
                    print_1.print(output_1.text(chalk.red('FASTA output not yet supported')));
                    break;
                case 'genbank':
                    print_1.print(output_1.text(chalk.red('GenBank output not yet supported')));
                    break;
                case 'none':
                    break;
                default:
                    print_1.print(output_1.text(chalk.red('Unknown output type: ' + output)));
                    process.exitCode = 2;
                    break;
            }
        }
    });
}
exports.default = sboltools;
function help() {
    print_1.print(output_1.text(help_1.default
        .replace(/\*\*(.*)\*\*/g, (w, str) => chalk.white.underline.bold(str.toUpperCase()))
        .replace(/\*(.*)\*/g, (w, str) => chalk.white.bold(str))
        .replace('%actions%', actions_1.default.map(a => '    ' + a.name).join('\n'))));
}


/***/ }),

/***/ "./src/summarize.ts":
/*!**************************!*\
  !*** ./src/summarize.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const output_1 = __webpack_require__(/*! ./output/output */ "./src/output/output.ts");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const dnaComponentTree_1 = __webpack_require__(/*! ./sbol1/dnaComponentTree */ "./src/sbol1/dnaComponentTree.ts");
const mdTree_1 = __webpack_require__(/*! ./sbol2/mdTree */ "./src/sbol2/mdTree.ts");
const componentTree_1 = __webpack_require__(/*! ./sbol3/componentTree */ "./src/sbol3/componentTree.ts");
const rdfoo_prov_1 = __webpack_require__(/*! rdfoo-prov */ "./node_modules/rdfoo-prov/dist/index.js");
const cdTree_1 = __webpack_require__(/*! ./sbol2/cdTree */ "./src/sbol2/cdTree.ts");
const print_1 = __webpack_require__(/*! ./output/print */ "./src/output/print.ts");
function summarize(g) {
    return __awaiter(this, void 0, void 0, function* () {
        let out = [];
        out.push(output_1.group([
            output_1.spacer(),
            output_1.header('Summary', 'bold underline caps'),
            output_1.spacer(),
            output_1.indent([
                summariseSBOL1(g),
                summariseSBOL2(g),
                summariseSBOL3(g),
                summariseProv(g)
            ]),
            output_1.spacer(),
            output_1.conditional(new sbolgraph_1.SBOL1GraphView(g).topLevels.length > 0, [
                output_1.header('SBOL 1.x Overview', 'bold underline caps'),
                output_1.spacer(),
                output_1.indent([
                    output_1.indent([
                        output_1.header('DnaComponent(s)'),
                        output_1.spacer(),
                        output_1.indent([
                            dnaComponentTree_1.dnaComponentTree(new sbolgraph_1.SBOL1GraphView(g))
                        ])
                    ])
                ])
            ]),
            output_1.conditional(new sbolgraph_1.SBOL2GraphView(g).topLevels.length > 0, [
                output_1.header('SBOL 2.x Overview', 'bold underline caps'),
                output_1.spacer(),
                output_1.indent([
                    output_1.indent([
                        output_1.header('ModuleDefinition(s)'),
                        output_1.spacer(),
                        output_1.indent([
                            mdTree_1.mdTree(new sbolgraph_1.SBOL2GraphView(g))
                        ]),
                        output_1.spacer(),
                        output_1.header('ComponentDefinition(s)'),
                        output_1.spacer(),
                        output_1.indent([
                            cdTree_1.cdTree(new sbolgraph_1.SBOL2GraphView(g))
                        ])
                    ])
                ])
            ]),
            output_1.conditional(new sbolgraph_1.SBOL3GraphView(g).topLevels.length > 0, [
                output_1.header('SBOL 3.x Overview', 'bold underline caps'),
                output_1.spacer(),
                output_1.indent([
                    output_1.indent([
                        output_1.header('Component(s)'),
                        output_1.spacer(),
                        output_1.indent([
                            componentTree_1.componentTree(new sbolgraph_1.SBOL3GraphView(g))
                        ])
                    ])
                ])
            ])
        ]));
        print_1.print(output_1.group(out));
    });
}
exports.default = summarize;
function summariseSBOL1(g) {
    let v = new sbolgraph_1.SBOL1GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
        return output_1.group([
            output_1.text('No SBOL 1.x to output'),
            output_1.spacer()
        ]);
    }
    return output_1.group([
        output_1.header('SBOL 1.x', 'bold underline white'),
        output_1.spacer(),
        output_1.indent([
            arraySummary(v.dnaComponents, 'DnaComponent'),
            arraySummary(v.dnaSequences, 'DnaSequence')
        ]),
        output_1.spacer()
    ]);
}
function summariseSBOL2(g) {
    let v = new sbolgraph_1.SBOL2GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
        return output_1.group([
            output_1.text('No SBOL 2.x to output'),
            output_1.spacer()
        ]);
    }
    return output_1.group([
        output_1.text('SBOL 2.x:'),
        output_1.spacer(),
        output_1.indent([
            arraySummary(v.moduleDefinitions, 'ModuleDefinition'),
            arraySummary(v.componentDefinitions, 'ComponentDefinition')
        ]),
        output_1.spacer()
    ]);
}
function summariseSBOL3(g) {
    let v = new sbolgraph_1.SBOL3GraphView(g);
    let any = v.topLevels.length > 0;
    if (!any) {
        return output_1.group([
            output_1.text('No SBOL 3.x to output'),
            output_1.spacer()
        ]);
    }
    return output_1.group([
        output_1.text('SBOL 3.x:'),
        output_1.spacer(),
        output_1.indent([
            arraySummary(v.components, 'Component')
        ]),
        output_1.spacer()
    ]);
}
function summariseProv(g) {
    let v = new rdfoo_prov_1.ProvView(g);
    return output_1.group([]);
}
function arraySummary(arr, name) {
    let style = arr.length > 0 ? 'white' : 'gray';
    return output_1.text(`${arr.length} ${name}(s)`, style);
}


/***/ }),

/***/ "./src/util/get-last-uri-fragment.ts":
/*!*******************************************!*\
  !*** ./src/util/get-last-uri-fragment.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getLastURIFragment(uri) {
    let slash = uri.lastIndexOf('/');
    let hash = uri.lastIndexOf('#');
    let eq = uri.lastIndexOf('=');
    if (slash !== -1) {
        return uri.slice(slash + 1);
    }
    if (hash !== -1) {
        return uri.slice(hash + 1);
    }
    if (eq !== -1) {
        return uri.slice(eq + 1);
    }
    throw new Error('could not extract last uri fragment');
}
exports.default = getLastURIFragment;


/***/ }),

/***/ "./src/util/get-sbol-version-from-graph.ts":
/*!*************************************************!*\
  !*** ./src/util/get-sbol-version-from-graph.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getSBOLVersionFromGraph = exports.SBOLVersion = void 0;
const rdfoo_1 = __webpack_require__(/*! rdfoo */ "./node_modules/rdfoo/dist/index.js");
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
var SBOLVersion;
(function (SBOLVersion) {
    SBOLVersion["SBOL1"] = "SBOL1";
    SBOLVersion["SBOL2"] = "SBOL2";
    SBOLVersion["SBOL3"] = "SBOL3";
    SBOLVersion["Mixed"] = "Mixed";
    SBOLVersion["Empty"] = "Empty";
})(SBOLVersion = exports.SBOLVersion || (exports.SBOLVersion = {}));
function getSBOLVersionFromGraph(g) {
    let version = SBOLVersion.Empty;
    for (let s of g.subjects) {
        for (let t of g.match(s, bioterms_1.Predicates.a, null)) {
            let uri = rdfoo_1.triple.objectUri(t);
            if (!uri)
                continue;
            if (uri.indexOf(bioterms_1.Prefixes.sbol1) === 0) {
                if (version !== SBOLVersion.Empty) {
                    if (version !== SBOLVersion.SBOL1) {
                        return SBOLVersion.Mixed;
                    }
                }
                else {
                    version = SBOLVersion.SBOL1;
                }
            }
            else if (uri.indexOf(bioterms_1.Prefixes.sbol2) === 0) {
                if (version !== SBOLVersion.Empty) {
                    if (version !== SBOLVersion.SBOL2) {
                        return SBOLVersion.Mixed;
                    }
                }
                else {
                    version = SBOLVersion.SBOL2;
                }
            }
            else if (uri.indexOf(bioterms_1.Prefixes.sbol3) === 0) {
                if (version !== SBOLVersion.Empty) {
                    if (version !== SBOLVersion.SBOL3) {
                        return SBOLVersion.Mixed;
                    }
                }
                else {
                    version = SBOLVersion.SBOL3;
                }
            }
        }
    }
    return version;
}
exports.getSBOLVersionFromGraph = getSBOLVersionFromGraph;


/***/ }),

/***/ "./src/util/is-toplevel-type.ts":
/*!**************************************!*\
  !*** ./src/util/is-toplevel-type.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bioterms_1 = __webpack_require__(/*! bioterms */ "./node_modules/bioterms/dist/index.js");
function isTopLevelType(type) {
    return [
        bioterms_1.Types.SBOL1.DnaComponent,
        bioterms_1.Types.SBOL1.Collection,
        bioterms_1.Types.SBOL2.ComponentDefinition,
        bioterms_1.Types.SBOL2.ModuleDefinition,
        bioterms_1.Types.SBOL2.Sequence,
        bioterms_1.Types.SBOL3.Component,
        bioterms_1.Types.SBOL3.Sequence
    ].indexOf(type) !== -1;
}
exports.default = isTopLevelType;


/***/ }),

/***/ "./src/util/join-uri-fragments.ts":
/*!****************************************!*\
  !*** ./src/util/join-uri-fragments.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function joinURIFragments(t) {
    let s = '';
    for (let token of t) {
        if (token === undefined)
            continue;
        if (s.length > 0 && token[0] !== '/' && s[s.length - 1] !== '/')
            s += '/';
        s += token;
    }
    return s;
}
exports.default = joinURIFragments;


/***/ }),

/***/ "./src/util/sbol2-compliant-concat.ts":
/*!********************************************!*\
  !*** ./src/util/sbol2-compliant-concat.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert = __webpack_require__(/*! assert */ "assert");
const sbolgraph_1 = __webpack_require__(/*! sbolgraph */ "./node_modules/sbolgraph/dist/index.js");
const join_uri_fragments_1 = __webpack_require__(/*! ./join-uri-fragments */ "./src/util/join-uri-fragments.ts");
function sbol2CompliantConcat(g, uri, childDisplayId) {
    assert(uri);
    let gv = new sbolgraph_1.SBOL2GraphView(g);
    let identified = new sbolgraph_1.S2Identified(gv, uri);
    // does it have a persistentIdentity? if so concat to that
    let pId = identified.persistentIdentity;
    let version = identified.version;
    if (pId) {
        return join_uri_fragments_1.default([pId, childDisplayId, version]);
    }
    // no = not compliant (or does not exist yet? TODO is this actually getting
    // used for stuff that doesn't exist?)
    return join_uri_fragments_1.default([uri, childDisplayId]);
}
exports.default = sbol2CompliantConcat;


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "cluster":
/*!**************************!*\
  !*** external "cluster" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("cluster");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("console");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=sbol.js.map
